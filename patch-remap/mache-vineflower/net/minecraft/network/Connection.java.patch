--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -9,6 +9,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
@@ -28,7 +29,6 @@
 import io.netty.handler.timeout.ReadTimeoutHandler;
 import io.netty.handler.timeout.TimeoutException;
 import io.netty.util.AttributeKey;
-import io.netty.util.concurrent.Future;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.Objects;
@@ -41,6 +41,7 @@
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
@@ -49,7 +50,7 @@
 import net.minecraft.network.protocol.login.ClientLoginPacketListener;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.network.protocol.status.ClientStatusPacketListener;
-import net.minecraft.server.RunningOnDifferentThreadException;
+import net.minecraft.server.CancelledPacketHandleException;
 import net.minecraft.util.Mth;
 import net.minecraft.util.SampleLogger;
 import org.apache.commons.lang3.Validate;
@@ -58,27 +59,34 @@
 import org.slf4j.MarkerFactory;
 
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
+
     private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final Marker ROOT_MARKER = MarkerFactory.getMarker("NETWORK");
-    public static final Marker PACKET_MARKER = Util.make(MarkerFactory.getMarker("NETWORK_PACKETS"), marker -> marker.add(ROOT_MARKER));
-    public static final Marker PACKET_RECEIVED_MARKER = Util.make(MarkerFactory.getMarker("PACKET_RECEIVED"), marker -> marker.add(PACKET_MARKER));
-    public static final Marker PACKET_SENT_MARKER = Util.make(MarkerFactory.getMarker("PACKET_SENT"), marker -> marker.add(PACKET_MARKER));
-    public static final AttributeKey<ConnectionProtocol.CodecData<?>> ATTRIBUTE_SERVERBOUND_PROTOCOL = AttributeKey.valueOf("serverbound_protocol");
-    public static final AttributeKey<ConnectionProtocol.CodecData<?>> ATTRIBUTE_CLIENTBOUND_PROTOCOL = AttributeKey.valueOf("clientbound_protocol");
-    public static final Supplier<NioEventLoopGroup> NETWORK_WORKER_GROUP = Suppliers.memoize(
-        () -> new NioEventLoopGroup(0, new ThreadFactoryBuilder().setNameFormat("Netty Client IO #%d").setDaemon(true).build())
-    );
-    public static final Supplier<EpollEventLoopGroup> NETWORK_EPOLL_WORKER_GROUP = Suppliers.memoize(
-        () -> new EpollEventLoopGroup(0, new ThreadFactoryBuilder().setNameFormat("Netty Epoll Client IO #%d").setDaemon(true).build())
-    );
-    public static final Supplier<DefaultEventLoopGroup> LOCAL_WORKER_GROUP = Suppliers.memoize(
-        () -> new DefaultEventLoopGroup(0, new ThreadFactoryBuilder().setNameFormat("Netty Local Client IO #%d").setDaemon(true).build())
-    );
+    public static final Marker PACKET_MARKER = (Marker) Util.make(MarkerFactory.getMarker("NETWORK_PACKETS"), (marker) -> {
+        marker.add(Connection.ROOT_MARKER);
+    });
+    public static final Marker PACKET_RECEIVED_MARKER = (Marker) Util.make(MarkerFactory.getMarker("PACKET_RECEIVED"), (marker) -> {
+        marker.add(Connection.PACKET_MARKER);
+    });
+    public static final Marker PACKET_SENT_MARKER = (Marker) Util.make(MarkerFactory.getMarker("PACKET_SENT"), (marker) -> {
+        marker.add(Connection.PACKET_MARKER);
+    });
+    public static final AttributeKey<ConnectionProtocol.a<?>> ATTRIBUTE_SERVERBOUND_PROTOCOL = AttributeKey.valueOf("serverbound_protocol");
+    public static final AttributeKey<ConnectionProtocol.a<?>> ATTRIBUTE_CLIENTBOUND_PROTOCOL = AttributeKey.valueOf("clientbound_protocol");
+    public static final Supplier<NioEventLoopGroup> NETWORK_WORKER_GROUP = Suppliers.memoize(() -> {
+        return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Client IO #%d").setDaemon(true).build());
+    });
+    public static final Supplier<EpollEventLoopGroup> NETWORK_EPOLL_WORKER_GROUP = Suppliers.memoize(() -> {
+        return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Client IO #%d").setDaemon(true).build());
+    });
+    public static final Supplier<DefaultEventLoopGroup> LOCAL_WORKER_GROUP = Suppliers.memoize(() -> {
+        return new DefaultEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Client IO #%d").setDaemon(true).build());
+    });
     private final PacketFlow receiving;
     private final Queue<Consumer<Connection>> pendingActions = Queues.newConcurrentLinkedQueue();
-    private Channel channel;
-    private SocketAddress address;
+    public Channel channel;
+    public SocketAddress address;
     @Nullable
     private volatile PacketListener disconnectListener;
     @Nullable
@@ -97,92 +105,97 @@
     private volatile Component delayedDisconnect;
     @Nullable
     BandwidthDebugMonitor bandwidthDebugMonitor;
+    public String hostname = ""; // CraftBukkit - add field
 
     public Connection(PacketFlow receiving) {
         this.receiving = receiving;
     }
 
-    @Override
-    public void channelActive(ChannelHandlerContext context) throws Exception {
-        super.channelActive(context);
-        this.channel = context.channel();
+    public void channelActive(ChannelHandlerContext channelhandlercontext) throws Exception {
+        super.channelActive(channelhandlercontext);
+        this.channel = channelhandlercontext.channel();
         this.address = this.channel.remoteAddress();
         if (this.delayedDisconnect != null) {
             this.disconnect(this.delayedDisconnect);
         }
+
     }
 
     public static void setInitialProtocolAttributes(Channel channel) {
-        channel.attr(ATTRIBUTE_SERVERBOUND_PROTOCOL).set(ConnectionProtocol.HANDSHAKING.codec(PacketFlow.SERVERBOUND));
-        channel.attr(ATTRIBUTE_CLIENTBOUND_PROTOCOL).set(ConnectionProtocol.HANDSHAKING.codec(PacketFlow.CLIENTBOUND));
+        channel.attr(Connection.ATTRIBUTE_SERVERBOUND_PROTOCOL).set(ConnectionProtocol.HANDSHAKING.codec(PacketFlow.SERVERBOUND));
+        channel.attr(Connection.ATTRIBUTE_CLIENTBOUND_PROTOCOL).set(ConnectionProtocol.HANDSHAKING.codec(PacketFlow.CLIENTBOUND));
     }
 
-    @Override
-    public void channelInactive(ChannelHandlerContext context) {
+    public void channelInactive(ChannelHandlerContext channelhandlercontext) {
         this.disconnect(Component.translatable("disconnect.endOfStream"));
     }
 
-    @Override
-    public void exceptionCaught(ChannelHandlerContext context, Throwable exception) {
-        if (exception instanceof SkipPacketException) {
-            LOGGER.debug("Skipping packet due to errors", exception.getCause());
+    public void exceptionCaught(ChannelHandlerContext channelhandlercontext, Throwable throwable) {
+        if (throwable instanceof SkipPacketException) {
+            Connection.LOGGER.debug("Skipping packet due to errors", throwable.getCause());
         } else {
             boolean flag = !this.handlingFault;
+
             this.handlingFault = true;
             if (this.channel.isOpen()) {
-                if (exception instanceof TimeoutException) {
-                    LOGGER.debug("Timeout", exception);
+                if (throwable instanceof TimeoutException) {
+                    Connection.LOGGER.debug("Timeout", throwable);
                     this.disconnect(Component.translatable("disconnect.timeout"));
                 } else {
-                    Component component = Component.translatable("disconnect.genericReason", "Internal Exception: " + exception);
+                    MutableComponent ichatmutablecomponent = Component.translatable("disconnect.genericReason", "Internal Exception: " + throwable);
+
                     if (flag) {
-                        LOGGER.debug("Failed to sent packet", exception);
+                        Connection.LOGGER.debug("Failed to sent packet", throwable);
                         if (this.getSending() == PacketFlow.CLIENTBOUND) {
-                            ConnectionProtocol connectionProtocol = this.channel.attr(ATTRIBUTE_CLIENTBOUND_PROTOCOL).get().protocol();
-                            Packet<?> packet = (Packet<?>)(connectionProtocol == ConnectionProtocol.LOGIN
-                                ? new ClientboundLoginDisconnectPacket(component)
-                                : new ClientboundDisconnectPacket(component));
-                            this.send(packet, PacketSendListener.thenRun(() -> this.disconnect(component)));
+                            ConnectionProtocol enumprotocol = ((ConnectionProtocol.a) this.channel.attr(Connection.ATTRIBUTE_CLIENTBOUND_PROTOCOL).get()).protocol();
+                            Packet<?> packet = enumprotocol == ConnectionProtocol.LOGIN ? new ClientboundLoginDisconnectPacket(ichatmutablecomponent) : new ClientboundDisconnectPacket(ichatmutablecomponent);
+
+                            this.send((Packet) packet, PacketSendListener.thenRun(() -> {
+                                this.disconnect(ichatmutablecomponent);
+                            }));
                         } else {
-                            this.disconnect(component);
+                            this.disconnect(ichatmutablecomponent);
                         }
 
                         this.setReadOnly();
                     } else {
-                        LOGGER.debug("Double fault", exception);
-                        this.disconnect(component);
+                        Connection.LOGGER.debug("Double fault", throwable);
+                        this.disconnect(ichatmutablecomponent);
                     }
                 }
+
             }
         }
     }
 
-    @Override
     protected void channelRead0(ChannelHandlerContext context, Packet<?> packet) {
         if (this.channel.isOpen()) {
-            PacketListener packetListener = this.packetListener;
-            if (packetListener == null) {
+            PacketListener packetlistener = this.packetListener;
+
+            if (packetlistener == null) {
                 throw new IllegalStateException("Received a packet before the packet listener was initialized");
             } else {
-                if (packetListener.shouldHandleMessage(packet)) {
+                if (packetlistener.shouldHandleMessage(packet)) {
                     try {
-                        genericsFtw(packet, packetListener);
-                    } catch (RunningOnDifferentThreadException var5) {
-                    } catch (RejectedExecutionException var6) {
+                        genericsFtw(packet, packetlistener);
+                    } catch (CancelledPacketHandleException cancelledpackethandleexception) {
+                        ;
+                    } catch (RejectedExecutionException rejectedexecutionexception) {
                         this.disconnect(Component.translatable("multiplayer.disconnect.server_shutdown"));
-                    } catch (ClassCastException var7) {
-                        LOGGER.error("Received {} that couldn't be processed", packet.getClass(), var7);
+                    } catch (ClassCastException classcastexception) {
+                        Connection.LOGGER.error("Received {} that couldn't be processed", packet.getClass(), classcastexception);
                         this.disconnect(Component.translatable("multiplayer.disconnect.invalid_packet"));
                     }
 
-                    this.receivedPackets++;
+                    ++this.receivedPackets;
                 }
+
             }
         }
     }
 
     private static <T extends PacketListener> void genericsFtw(Packet<T> packet, PacketListener listener) {
-        packet.handle((T)listener);
+        packet.handle((T) listener); // CraftBukkit - decompile error
     }
 
     public void suspendInboundAfterProtocolChange() {
@@ -194,22 +207,17 @@
     }
 
     public void setListener(PacketListener handler) {
-        Validate.notNull(handler, "packetListener");
-        PacketFlow packetFlow = handler.flow();
-        if (packetFlow != this.receiving) {
-            throw new IllegalStateException("Trying to set listener for wrong side: connection is " + this.receiving + ", but listener is " + packetFlow);
+        Validate.notNull(handler, "packetListener", new Object[0]);
+        PacketFlow enumprotocoldirection = handler.flow();
+
+        if (enumprotocoldirection != this.receiving) {
+            throw new IllegalStateException("Trying to set listener for wrong side: connection is " + this.receiving + ", but listener is " + enumprotocoldirection);
         } else {
-            ConnectionProtocol connectionProtocol = handler.protocol();
-            ConnectionProtocol connectionProtocol1 = this.channel.attr(getProtocolKey(packetFlow)).get().protocol();
-            if (connectionProtocol1 != connectionProtocol) {
-                throw new IllegalStateException(
-                    "Trying to set listener for protocol "
-                        + connectionProtocol.id()
-                        + ", but current "
-                        + packetFlow
-                        + " protocol is "
-                        + connectionProtocol1.id()
-                );
+            ConnectionProtocol enumprotocol = handler.protocol();
+            ConnectionProtocol enumprotocol1 = ((ConnectionProtocol.a) this.channel.attr(getProtocolKey(enumprotocoldirection)).get()).protocol();
+
+            if (enumprotocol1 != enumprotocol) {
+                throw new IllegalStateException("Trying to set listener for protocol " + enumprotocol.id() + ", but current " + enumprotocoldirection + " protocol is " + enumprotocol1.id());
             } else {
                 this.packetListener = handler;
                 this.disconnectListener = null;
@@ -217,54 +225,55 @@
         }
     }
 
-    public void setListenerForServerboundHandshake(PacketListener packetListener) {
+    public void setListenerForServerboundHandshake(PacketListener packetlistener) {
         if (this.packetListener != null) {
             throw new IllegalStateException("Listener already set");
-        } else if (this.receiving == PacketFlow.SERVERBOUND
-            && packetListener.flow() == PacketFlow.SERVERBOUND
-            && packetListener.protocol() == ConnectionProtocol.HANDSHAKING) {
-            this.packetListener = packetListener;
+        } else if (this.receiving == PacketFlow.SERVERBOUND && packetlistener.flow() == PacketFlow.SERVERBOUND && packetlistener.protocol() == ConnectionProtocol.HANDSHAKING) {
+            this.packetListener = packetlistener;
         } else {
             throw new IllegalStateException("Invalid initial listener");
         }
     }
 
-    public void initiateServerboundStatusConnection(String string, int i, ClientStatusPacketListener clientStatusPacketListener) {
-        this.initiateServerboundConnection(string, i, clientStatusPacketListener, ClientIntent.STATUS);
+    public void initiateServerboundStatusConnection(String s, int i, ClientStatusPacketListener packetstatusoutlistener) {
+        this.initiateServerboundConnection(s, i, packetstatusoutlistener, ClientIntent.STATUS);
     }
 
-    public void initiateServerboundPlayConnection(String string, int i, ClientLoginPacketListener clientLoginPacketListener) {
-        this.initiateServerboundConnection(string, i, clientLoginPacketListener, ClientIntent.LOGIN);
+    public void initiateServerboundPlayConnection(String s, int i, ClientLoginPacketListener packetloginoutlistener) {
+        this.initiateServerboundConnection(s, i, packetloginoutlistener, ClientIntent.LOGIN);
     }
 
-    private void initiateServerboundConnection(String string, int i, PacketListener packetListener, ClientIntent clientIntent) {
-        this.disconnectListener = packetListener;
-        this.runOnceConnected(connection -> {
-            connection.setClientboundProtocolAfterHandshake(clientIntent);
-            this.setListener(packetListener);
-            connection.sendPacket(new ClientIntentionPacket(SharedConstants.getCurrentVersion().getProtocolVersion(), string, i, clientIntent), null, true);
+    private void initiateServerboundConnection(String s, int i, PacketListener packetlistener, ClientIntent clientintent) {
+        this.disconnectListener = packetlistener;
+        this.runOnceConnected((networkmanager) -> {
+            networkmanager.setClientboundProtocolAfterHandshake(clientintent);
+            this.setListener(packetlistener);
+            networkmanager.sendPacket(new ClientIntentionPacket(SharedConstants.getCurrentVersion().getProtocolVersion(), s, i, clientintent), (PacketSendListener) null, true);
         });
     }
 
-    public void setClientboundProtocolAfterHandshake(ClientIntent clientIntent) {
-        this.channel.attr(ATTRIBUTE_CLIENTBOUND_PROTOCOL).set(clientIntent.protocol().codec(PacketFlow.CLIENTBOUND));
+    public void setClientboundProtocolAfterHandshake(ClientIntent clientintent) {
+        this.channel.attr(Connection.ATTRIBUTE_CLIENTBOUND_PROTOCOL).set(clientintent.protocol().codec(PacketFlow.CLIENTBOUND));
     }
 
     public void send(Packet<?> packet) {
-        this.send(packet, null);
+        this.send(packet, (PacketSendListener) null);
     }
 
     public void send(Packet<?> packet, @Nullable PacketSendListener sendListener) {
         this.send(packet, sendListener, true);
     }
 
-    public void send(Packet<?> packet, @Nullable PacketSendListener packetSendListener, boolean flag) {
+    public void send(Packet<?> packet, @Nullable PacketSendListener packetsendlistener, boolean flag) {
         if (this.isConnected()) {
             this.flushQueue();
-            this.sendPacket(packet, packetSendListener, flag);
+            this.sendPacket(packet, packetsendlistener, flag);
         } else {
-            this.pendingActions.add(connection -> connection.sendPacket(packet, packetSendListener, flag));
+            this.pendingActions.add((networkmanager) -> {
+                networkmanager.sendPacket(packet, packetsendlistener, flag);
+            });
         }
+
     }
 
     public void runOnceConnected(Consumer<Connection> consumer) {
@@ -274,34 +283,42 @@
         } else {
             this.pendingActions.add(consumer);
         }
+
     }
 
-    private void sendPacket(Packet<?> packet, @Nullable PacketSendListener packetSendListener, boolean flag) {
-        this.sentPackets++;
+    private void sendPacket(Packet<?> packet, @Nullable PacketSendListener packetsendlistener, boolean flag) {
+        ++this.sentPackets;
         if (this.channel.eventLoop().inEventLoop()) {
-            this.doSendPacket(packet, packetSendListener, flag);
+            this.doSendPacket(packet, packetsendlistener, flag);
         } else {
-            this.channel.eventLoop().execute(() -> this.doSendPacket(packet, packetSendListener, flag));
+            this.channel.eventLoop().execute(() -> {
+                this.doSendPacket(packet, packetsendlistener, flag);
+            });
         }
+
     }
 
-    private void doSendPacket(Packet<?> packet, @Nullable PacketSendListener packetSendListener, boolean flag) {
-        ChannelFuture channelFuture = flag ? this.channel.writeAndFlush(packet) : this.channel.write(packet);
-        if (packetSendListener != null) {
-            channelFuture.addListener(future -> {
+    private void doSendPacket(Packet<?> packet, @Nullable PacketSendListener packetsendlistener, boolean flag) {
+        ChannelFuture channelfuture = flag ? this.channel.writeAndFlush(packet) : this.channel.write(packet);
+
+        if (packetsendlistener != null) {
+            channelfuture.addListener((future) -> {
                 if (future.isSuccess()) {
-                    packetSendListener.onSuccess();
+                    packetsendlistener.onSuccess();
                 } else {
-                    Packet<?> packet1 = packetSendListener.onFailure();
+                    Packet<?> packet1 = packetsendlistener.onFailure();
+
                     if (packet1 != null) {
-                        ChannelFuture channelFuture1 = this.channel.writeAndFlush(packet1);
-                        channelFuture1.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+                        ChannelFuture channelfuture1 = this.channel.writeAndFlush(packet1);
+
+                        channelfuture1.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
                     }
                 }
+
             });
         }
 
-        channelFuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+        channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
     }
 
     public void flushChannel() {
@@ -310,38 +327,60 @@
         } else {
             this.pendingActions.add(Connection::flush);
         }
+
     }
 
     private void flush() {
         if (this.channel.eventLoop().inEventLoop()) {
             this.channel.flush();
         } else {
-            this.channel.eventLoop().execute(() -> this.channel.flush());
+            this.channel.eventLoop().execute(() -> {
+                this.channel.flush();
+            });
         }
+
     }
 
-    private static AttributeKey<ConnectionProtocol.CodecData<?>> getProtocolKey(PacketFlow packetFlow) {
-        return switch (packetFlow) {
-            case CLIENTBOUND -> ATTRIBUTE_CLIENTBOUND_PROTOCOL;
-            case SERVERBOUND -> ATTRIBUTE_SERVERBOUND_PROTOCOL;
-        };
+    private static AttributeKey<ConnectionProtocol.a<?>> getProtocolKey(PacketFlow enumprotocoldirection) {
+        AttributeKey attributekey;
+
+        switch (enumprotocoldirection) {
+            case CLIENTBOUND:
+                attributekey = Connection.ATTRIBUTE_CLIENTBOUND_PROTOCOL;
+                break;
+            case SERVERBOUND:
+                attributekey = Connection.ATTRIBUTE_SERVERBOUND_PROTOCOL;
+                break;
+            default:
+                throw new IncompatibleClassChangeError();
+        }
+
+        return attributekey;
     }
 
     private void flushQueue() {
         if (this.channel != null && this.channel.isOpen()) {
+            Queue queue = this.pendingActions;
+
             synchronized (this.pendingActions) {
-                Consumer<Connection> consumer;
-                while ((consumer = this.pendingActions.poll()) != null) {
+                Consumer consumer;
+
+                while ((consumer = (Consumer) this.pendingActions.poll()) != null) {
                     consumer.accept(this);
                 }
+
             }
         }
     }
 
     public void tick() {
         this.flushQueue();
-        if (this.packetListener instanceof TickablePacketListener tickablePacketListener) {
-            tickablePacketListener.tick();
+        PacketListener packetlistener = this.packetListener;
+
+        if (packetlistener instanceof TickablePacketListener) {
+            TickablePacketListener tickablepacketlistener = (TickablePacketListener) packetlistener;
+
+            tickablepacketlistener.tick();
         }
 
         if (!this.isConnected() && !this.disconnectionHandled) {
@@ -359,11 +398,12 @@
         if (this.bandwidthDebugMonitor != null) {
             this.bandwidthDebugMonitor.tick();
         }
+
     }
 
     protected void tickSecond() {
-        this.averageSentPackets = Mth.lerp(0.75F, (float)this.sentPackets, this.averageSentPackets);
-        this.averageReceivedPackets = Mth.lerp(0.75F, (float)this.receivedPackets, this.averageReceivedPackets);
+        this.averageSentPackets = Mth.lerp(0.75F, (float) this.sentPackets, this.averageSentPackets);
+        this.averageReceivedPackets = Mth.lerp(0.75F, (float) this.receivedPackets, this.averageReceivedPackets);
         this.sentPackets = 0;
         this.receivedPackets = 0;
     }
@@ -373,11 +413,7 @@
     }
 
     public String getLoggableAddress(boolean flag) {
-        if (this.address == null) {
-            return "local";
-        } else {
-            return flag ? this.address.toString() : "IP hidden";
-        }
+        return this.address == null ? "local" : (flag ? this.address.toString() : "IP hidden");
     }
 
     public void disconnect(Component message) {
@@ -386,9 +422,10 @@
         }
 
         if (this.isConnected()) {
-            this.channel.close().awaitUninterruptibly();
+            this.channel.close(); // We can't wait as this may be called from an event loop.
             this.disconnectedReason = message;
         }
+
     }
 
     public boolean isMemoryConnection() {
@@ -403,84 +440,86 @@
         return this.receiving.getOpposite();
     }
 
-    public static Connection connectToServer(InetSocketAddress inetSocketAddress, boolean flag, @Nullable SampleLogger sampleLogger) {
-        Connection connection = new Connection(PacketFlow.CLIENTBOUND);
-        if (sampleLogger != null) {
-            connection.setBandwidthLogger(sampleLogger);
+    public static Connection connectToServer(InetSocketAddress inetsocketaddress, boolean flag, @Nullable SampleLogger samplelogger) {
+        Connection networkmanager = new Connection(PacketFlow.CLIENTBOUND);
+
+        if (samplelogger != null) {
+            networkmanager.setBandwidthLogger(samplelogger);
         }
 
-        ChannelFuture channelFuture = connect(inetSocketAddress, flag, connection);
-        channelFuture.syncUninterruptibly();
-        return connection;
+        ChannelFuture channelfuture = connect(inetsocketaddress, flag, networkmanager);
+
+        channelfuture.syncUninterruptibly();
+        return networkmanager;
     }
 
     public static ChannelFuture connect(InetSocketAddress address, boolean useEpollIfAvailable, final Connection connection) {
-        Class<? extends SocketChannel> clazz;
-        EventLoopGroup eventLoopGroup;
+        Class oclass;
+        EventLoopGroup eventloopgroup;
+
         if (Epoll.isAvailable() && useEpollIfAvailable) {
-            clazz = EpollSocketChannel.class;
-            eventLoopGroup = NETWORK_EPOLL_WORKER_GROUP.get();
+            oclass = EpollSocketChannel.class;
+            eventloopgroup = (EventLoopGroup) Connection.NETWORK_EPOLL_WORKER_GROUP.get();
         } else {
-            clazz = NioSocketChannel.class;
-            eventLoopGroup = NETWORK_WORKER_GROUP.get();
+            oclass = NioSocketChannel.class;
+            eventloopgroup = (EventLoopGroup) Connection.NETWORK_WORKER_GROUP.get();
         }
 
-        return new Bootstrap().group(eventLoopGroup).handler(new ChannelInitializer<Channel>() {
-            @Override
+        return ((Bootstrap) ((Bootstrap) ((Bootstrap) (new Bootstrap()).group(eventloopgroup)).handler(new ChannelInitializer<Channel>() {
             protected void initChannel(Channel channel) {
                 Connection.setInitialProtocolAttributes(channel);
 
                 try {
                     channel.config().setOption(ChannelOption.TCP_NODELAY, true);
-                } catch (ChannelException var3) {
+                } catch (ChannelException channelexception) {
+                    ;
                 }
 
-                ChannelPipeline channelPipeline = channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30));
-                Connection.configureSerialization(channelPipeline, PacketFlow.CLIENTBOUND, connection.bandwidthDebugMonitor);
-                connection.configurePacketHandler(channelPipeline);
+                ChannelPipeline channelpipeline = channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30));
+
+                Connection.configureSerialization(channelpipeline, PacketFlow.CLIENTBOUND, connection.bandwidthDebugMonitor);
+                connection.configurePacketHandler(channelpipeline);
             }
-        }).channel(clazz).connect(address.getAddress(), address.getPort());
+        })).channel(oclass)).connect(address.getAddress(), address.getPort());
     }
 
-    public static void configureSerialization(ChannelPipeline channelPipeline, PacketFlow packetFlow, @Nullable BandwidthDebugMonitor bandwidthDebugMonitor) {
-        PacketFlow opposite = packetFlow.getOpposite();
-        AttributeKey<ConnectionProtocol.CodecData<?>> protocolKey = getProtocolKey(packetFlow);
-        AttributeKey<ConnectionProtocol.CodecData<?>> protocolKey1 = getProtocolKey(opposite);
-        channelPipeline.addLast("splitter", new Varint21FrameDecoder(bandwidthDebugMonitor))
-            .addLast("decoder", new PacketDecoder(protocolKey))
-            .addLast("prepender", new Varint21LengthFieldPrepender())
-            .addLast("encoder", new PacketEncoder(protocolKey1))
-            .addLast("unbundler", new PacketBundleUnpacker(protocolKey1))
-            .addLast("bundler", new PacketBundlePacker(protocolKey));
+    public static void configureSerialization(ChannelPipeline channelpipeline, PacketFlow enumprotocoldirection, @Nullable BandwidthDebugMonitor bandwidthdebugmonitor) {
+        PacketFlow enumprotocoldirection1 = enumprotocoldirection.getOpposite();
+        AttributeKey<ConnectionProtocol.a<?>> attributekey = getProtocolKey(enumprotocoldirection);
+        AttributeKey<ConnectionProtocol.a<?>> attributekey1 = getProtocolKey(enumprotocoldirection1);
+
+        channelpipeline.addLast("splitter", new Varint21FrameDecoder(bandwidthdebugmonitor)).addLast("decoder", new PacketDecoder(attributekey)).addLast("prepender", new Varint21LengthFieldPrepender()).addLast("encoder", new PacketEncoder(attributekey1)).addLast("unbundler", new PacketBundleUnpacker(attributekey1)).addLast("bundler", new PacketBundlePacker(attributekey));
     }
 
-    public void configurePacketHandler(ChannelPipeline channelPipeline) {
-        channelPipeline.addLast(new FlowControlHandler()).addLast("packet_handler", this);
+    public void configurePacketHandler(ChannelPipeline channelpipeline) {
+        channelpipeline.addLast(new ChannelHandler[]{new FlowControlHandler()}).addLast("packet_handler", this);
     }
 
-    private static void configureInMemoryPacketValidation(ChannelPipeline channelPipeline, PacketFlow packetFlow) {
-        PacketFlow opposite = packetFlow.getOpposite();
-        AttributeKey<ConnectionProtocol.CodecData<?>> protocolKey = getProtocolKey(packetFlow);
-        AttributeKey<ConnectionProtocol.CodecData<?>> protocolKey1 = getProtocolKey(opposite);
-        channelPipeline.addLast("validator", new PacketFlowValidator(protocolKey, protocolKey1));
+    private static void configureInMemoryPacketValidation(ChannelPipeline channelpipeline, PacketFlow enumprotocoldirection) {
+        PacketFlow enumprotocoldirection1 = enumprotocoldirection.getOpposite();
+        AttributeKey<ConnectionProtocol.a<?>> attributekey = getProtocolKey(enumprotocoldirection);
+        AttributeKey<ConnectionProtocol.a<?>> attributekey1 = getProtocolKey(enumprotocoldirection1);
+
+        channelpipeline.addLast("validator", new PacketFlowValidator(attributekey, attributekey1));
     }
 
-    public static void configureInMemoryPipeline(ChannelPipeline channelPipeline, PacketFlow packetFlow) {
-        configureInMemoryPacketValidation(channelPipeline, packetFlow);
+    public static void configureInMemoryPipeline(ChannelPipeline channelpipeline, PacketFlow enumprotocoldirection) {
+        configureInMemoryPacketValidation(channelpipeline, enumprotocoldirection);
     }
 
     public static Connection connectToLocalServer(SocketAddress address) {
-        final Connection connection = new Connection(PacketFlow.CLIENTBOUND);
-        new Bootstrap().group(LOCAL_WORKER_GROUP.get()).handler(new ChannelInitializer<Channel>() {
-            @Override
+        final Connection networkmanager = new Connection(PacketFlow.CLIENTBOUND);
+
+        ((Bootstrap) ((Bootstrap) ((Bootstrap) (new Bootstrap()).group((EventLoopGroup) Connection.LOCAL_WORKER_GROUP.get())).handler(new ChannelInitializer<Channel>() {
             protected void initChannel(Channel channel) {
                 Connection.setInitialProtocolAttributes(channel);
-                ChannelPipeline channelPipeline = channel.pipeline();
-                Connection.configureInMemoryPacketValidation(channelPipeline, PacketFlow.CLIENTBOUND);
-                connection.configurePacketHandler(channelPipeline);
+                ChannelPipeline channelpipeline = channel.pipeline();
+
+                Connection.configureInMemoryPipeline(channelpipeline, PacketFlow.CLIENTBOUND);
+                networkmanager.configurePacketHandler(channelpipeline);
             }
-        }).channel(LocalChannel.class).connect(address).syncUninterruptibly();
-        return connection;
+        })).channel(LocalChannel.class)).connect(address).syncUninterruptibly();
+        return networkmanager;
     }
 
     public void setEncryptionKey(Cipher decryptingCipher, Cipher encryptingCipher) {
@@ -515,18 +554,19 @@
         if (this.channel != null) {
             this.channel.config().setAutoRead(false);
         }
+
     }
 
     public void setupCompression(int threshold, boolean validateDecompressed) {
         if (threshold >= 0) {
             if (this.channel.pipeline().get("decompress") instanceof CompressionDecoder) {
-                ((CompressionDecoder)this.channel.pipeline().get("decompress")).setThreshold(threshold, validateDecompressed);
+                ((CompressionDecoder) this.channel.pipeline().get("decompress")).setThreshold(threshold, validateDecompressed);
             } else {
                 this.channel.pipeline().addBefore("decoder", "decompress", new CompressionDecoder(threshold, validateDecompressed));
             }
 
             if (this.channel.pipeline().get("compress") instanceof CompressionEncoder) {
-                ((CompressionEncoder)this.channel.pipeline().get("compress")).setThreshold(threshold);
+                ((CompressionEncoder) this.channel.pipeline().get("compress")).setThreshold(threshold);
             } else {
                 this.channel.pipeline().addBefore("encoder", "compress", new CompressionEncoder(threshold));
             }
@@ -539,22 +579,26 @@
                 this.channel.pipeline().remove("compress");
             }
         }
+
     }
 
     public void handleDisconnection() {
         if (this.channel != null && !this.channel.isOpen()) {
             if (this.disconnectionHandled) {
-                LOGGER.warn("handleDisconnection() called twice");
+                Connection.LOGGER.warn("handleDisconnection() called twice");
             } else {
                 this.disconnectionHandled = true;
-                PacketListener packetListener = this.getPacketListener();
-                PacketListener packetListener1 = packetListener != null ? packetListener : this.disconnectListener;
-                if (packetListener1 != null) {
-                    Component component = Objects.requireNonNullElseGet(
-                        this.getDisconnectedReason(), () -> Component.translatable("multiplayer.disconnect.generic")
-                    );
-                    packetListener1.onDisconnect(component);
+                PacketListener packetlistener = this.getPacketListener();
+                PacketListener packetlistener1 = packetlistener != null ? packetlistener : this.disconnectListener;
+
+                if (packetlistener1 != null) {
+                    Component ichatbasecomponent = (Component) Objects.requireNonNullElseGet(this.getDisconnectedReason(), () -> {
+                        return Component.translatable("multiplayer.disconnect.generic");
+                    });
+
+                    packetlistener1.onDisconnect(ichatbasecomponent);
                 }
+
             }
         }
     }
@@ -567,7 +611,7 @@
         return this.averageSentPackets;
     }
 
-    public void setBandwidthLogger(SampleLogger sampleLogger) {
-        this.bandwidthDebugMonitor = new BandwidthDebugMonitor(sampleLogger);
+    public void setBandwidthLogger(SampleLogger samplelogger) {
+        this.bandwidthDebugMonitor = new BandwidthDebugMonitor(samplelogger);
     }
 }
