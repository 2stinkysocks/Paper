--- a/net/minecraft/server/commands/SpreadPlayersCommand.java
+++ b/net/minecraft/server/commands/SpreadPlayersCommand.java
@@ -6,16 +6,17 @@
 import com.mojang.brigadier.arguments.BoolArgumentType;
 import com.mojang.brigadier.arguments.FloatArgumentType;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
-import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
 import com.mojang.brigadier.exceptions.Dynamic4CommandExceptionType;
 import java.util.Collection;
+import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
 import net.minecraft.commands.arguments.EntityArgument;
 import net.minecraft.commands.arguments.coordinates.Vec2Argument;
 import net.minecraft.core.BlockPos;
@@ -28,275 +29,236 @@
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.phys.Vec2;
+import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Team;
 
 public class SpreadPlayersCommand {
+
     private static final int MAX_ITERATION_COUNT = 10000;
-    private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_TEAMS = new Dynamic4CommandExceptionType(
-        (teamCount, x, z, suggestedSpread) -> Component.translatableEscape("commands.spreadplayers.failed.teams", teamCount, x, z, suggestedSpread)
-    );
-    private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_ENTITIES = new Dynamic4CommandExceptionType(
-        (entityCount, x, z, suggestedSpread) -> Component.translatableEscape("commands.spreadplayers.failed.entities", entityCount, x, z, suggestedSpread)
-    );
-    private static final Dynamic2CommandExceptionType ERROR_INVALID_MAX_HEIGHT = new Dynamic2CommandExceptionType(
-        (maxHeight, worldMin) -> Component.translatableEscape("commands.spreadplayers.failed.invalid.height", maxHeight, worldMin)
-    );
+    private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_TEAMS = new Dynamic4CommandExceptionType((object, object1, object2, object3) -> {
+        return Component.translatableEscape("commands.spreadplayers.failed.teams", object, object1, object2, object3);
+    });
+    private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_ENTITIES = new Dynamic4CommandExceptionType((object, object1, object2, object3) -> {
+        return Component.translatableEscape("commands.spreadplayers.failed.entities", object, object1, object2, object3);
+    });
+    private static final Dynamic2CommandExceptionType ERROR_INVALID_MAX_HEIGHT = new Dynamic2CommandExceptionType((object, object1) -> {
+        return Component.translatableEscape("commands.spreadplayers.failed.invalid.height", object, object1);
+    });
 
+    public SpreadPlayersCommand() {}
+
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
-        dispatcher.register(
-            Commands.literal("spreadplayers")
-                .requires(source -> source.hasPermission(2))
-                .then(
-                    Commands.argument("center", Vec2Argument.vec2())
-                        .then(
-                            Commands.argument("spreadDistance", FloatArgumentType.floatArg(0.0F))
-                                .then(
-                                    Commands.argument("maxRange", FloatArgumentType.floatArg(1.0F))
-                                        .then(
-                                            Commands.argument("respectTeams", BoolArgumentType.bool())
-                                                .then(
-                                                    Commands.argument("targets", EntityArgument.entities())
-                                                        .executes(
-                                                            context -> spreadPlayers(
-                                                                    context.getSource(),
-                                                                    Vec2Argument.getVec2(context, "center"),
-                                                                    FloatArgumentType.getFloat(context, "spreadDistance"),
-                                                                    FloatArgumentType.getFloat(context, "maxRange"),
-                                                                    context.getSource().getLevel().getMaxBuildHeight(),
-                                                                    BoolArgumentType.getBool(context, "respectTeams"),
-                                                                    EntityArgument.getEntities(context, "targets")
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                        .then(
-                                            Commands.literal("under")
-                                                .then(
-                                                    Commands.argument("maxHeight", IntegerArgumentType.integer())
-                                                        .then(
-                                                            Commands.argument("respectTeams", BoolArgumentType.bool())
-                                                                .then(
-                                                                    Commands.argument("targets", EntityArgument.entities())
-                                                                        .executes(
-                                                                            context -> spreadPlayers(
-                                                                                    context.getSource(),
-                                                                                    Vec2Argument.getVec2(context, "center"),
-                                                                                    FloatArgumentType.getFloat(context, "spreadDistance"),
-                                                                                    FloatArgumentType.getFloat(context, "maxRange"),
-                                                                                    IntegerArgumentType.getInteger(context, "maxHeight"),
-                                                                                    BoolArgumentType.getBool(context, "respectTeams"),
-                                                                                    EntityArgument.getEntities(context, "targets")
-                                                                                )
-                                                                        )
-                                                                )
-                                                        )
-                                                )
-                                        )
-                                )
-                        )
-                )
-        );
+        dispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("spreadplayers").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
+        })).then(net.minecraft.commands.Commands.argument("center", Vec2Argument.vec2()).then(net.minecraft.commands.Commands.argument("spreadDistance", FloatArgumentType.floatArg(0.0F)).then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("maxRange", FloatArgumentType.floatArg(1.0F)).then(net.minecraft.commands.Commands.argument("respectTeams", BoolArgumentType.bool()).then(net.minecraft.commands.Commands.argument("targets", EntityArgument.entities()).executes((commandcontext) -> {
+            return spreadPlayers((CommandSourceStack) commandcontext.getSource(), Vec2Argument.getVec2(commandcontext, "center"), FloatArgumentType.getFloat(commandcontext, "spreadDistance"), FloatArgumentType.getFloat(commandcontext, "maxRange"), ((CommandSourceStack) commandcontext.getSource()).getLevel().getMaxBuildHeight(), BoolArgumentType.getBool(commandcontext, "respectTeams"), EntityArgument.getEntities(commandcontext, "targets"));
+        })))).then(net.minecraft.commands.Commands.literal("under").then(net.minecraft.commands.Commands.argument("maxHeight", IntegerArgumentType.integer()).then(net.minecraft.commands.Commands.argument("respectTeams", BoolArgumentType.bool()).then(net.minecraft.commands.Commands.argument("targets", EntityArgument.entities()).executes((commandcontext) -> {
+            return spreadPlayers((CommandSourceStack) commandcontext.getSource(), Vec2Argument.getVec2(commandcontext, "center"), FloatArgumentType.getFloat(commandcontext, "spreadDistance"), FloatArgumentType.getFloat(commandcontext, "maxRange"), IntegerArgumentType.getInteger(commandcontext, "maxHeight"), BoolArgumentType.getBool(commandcontext, "respectTeams"), EntityArgument.getEntities(commandcontext, "targets"));
+        })))))))));
     }
 
-    private static int spreadPlayers(
-        CommandSourceStack source, Vec2 center, float spreadDistance, float maxRange, int maxHeight, boolean respectTeams, Collection<? extends Entity> targets
-    ) throws CommandSyntaxException {
-        ServerLevel level = source.getLevel();
-        int minBuildHeight = level.getMinBuildHeight();
-        if (maxHeight < minBuildHeight) {
-            throw ERROR_INVALID_MAX_HEIGHT.create(maxHeight, minBuildHeight);
+    private static int spreadPlayers(CommandSourceStack source, Vec2 center, float spreadDistance, float maxRange, int maxHeight, boolean respectTeams, Collection<? extends Entity> targets) throws CommandSyntaxException {
+        ServerLevel worldserver = source.getLevel();
+        int j = worldserver.getMinBuildHeight();
+
+        if (maxHeight < j) {
+            throw SpreadPlayersCommand.ERROR_INVALID_MAX_HEIGHT.create(maxHeight, j);
         } else {
-            RandomSource randomSource = RandomSource.create();
-            double d = (double)(center.x - maxRange);
-            double d1 = (double)(center.y - maxRange);
-            double d2 = (double)(center.x + maxRange);
-            double d3 = (double)(center.y + maxRange);
-            SpreadPlayersCommand.Position[] positions = createInitialPositions(
-                randomSource, respectTeams ? getNumberOfTeams(targets) : targets.size(), d, d1, d2, d3
-            );
-            spreadPositions(center, (double)spreadDistance, level, randomSource, d, d1, d2, d3, maxHeight, positions, respectTeams);
-            double d4 = setPlayerPositions(targets, level, positions, maxHeight, respectTeams);
-            source.sendSuccess(
-                () -> Component.translatable(
-                        "commands.spreadplayers.success." + (respectTeams ? "teams" : "entities"),
-                        positions.length,
-                        center.x,
-                        center.y,
-                        String.format(Locale.ROOT, "%.2f", d4)
-                    ),
-                true
-            );
-            return positions.length;
+            RandomSource randomsource = RandomSource.create();
+            double d0 = (double) (center.x - maxRange);
+            double d1 = (double) (center.y - maxRange);
+            double d2 = (double) (center.x + maxRange);
+            double d3 = (double) (center.y + maxRange);
+            SpreadPlayersCommand.Position[] acommandspreadplayers_a = createInitialPositions(randomsource, respectTeams ? getNumberOfTeams(targets) : targets.size(), d0, d1, d2, d3);
+
+            spreadPositions(center, (double) spreadDistance, worldserver, randomsource, d0, d1, d2, d3, maxHeight, acommandspreadplayers_a, respectTeams);
+            double d4 = setPlayerPositions(targets, worldserver, acommandspreadplayers_a, maxHeight, respectTeams);
+
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.spreadplayers.success." + (respectTeams ? "teams" : "entities"), acommandspreadplayers_a.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d4));
+            }, true);
+            return acommandspreadplayers_a.length;
         }
     }
 
     private static int getNumberOfTeams(Collection<? extends Entity> entities) {
         Set<Team> set = Sets.newHashSet();
+        Iterator iterator = entities.iterator();
 
-        for (Entity entity : entities) {
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
             if (entity instanceof Player) {
                 set.add(entity.getTeam());
             } else {
-                set.add(null);
+                set.add((Team) null); // CraftBukkit - decompile error
             }
         }
 
         return set.size();
     }
 
-    private static void spreadPositions(
-        Vec2 center,
-        double spreadDistance,
-        ServerLevel level,
-        RandomSource random,
-        double minX,
-        double minZ,
-        double maxX,
-        double maxZ,
-        int maxHeight,
-        SpreadPlayersCommand.Position[] positions,
-        boolean respectTeams
-    ) throws CommandSyntaxException {
-        boolean flag = true;
-        double d = Float.MAX_VALUE;
+    private static void spreadPositions(Vec2 center, double spreadDistance, ServerLevel worldserver, RandomSource level, double random, double minX, double d3, double minZ, int i, SpreadPlayersCommand.Position[] maxX, boolean flag) throws CommandSyntaxException {
+        boolean flag1 = true;
+        double d5 = 3.4028234663852886E38D;
 
-        int i;
-        for (i = 0; i < 10000 && flag; i++) {
-            flag = false;
-            d = Float.MAX_VALUE;
+        int j;
 
-            for (int i1 = 0; i1 < positions.length; i1++) {
-                SpreadPlayersCommand.Position position = positions[i1];
-                int i2 = 0;
-                SpreadPlayersCommand.Position position1 = new SpreadPlayersCommand.Position();
+        for (j = 0; j < 10000 && flag1; ++j) {
+            flag1 = false;
+            d5 = 3.4028234663852886E38D;
 
-                for (int i3 = 0; i3 < positions.length; i3++) {
-                    if (i1 != i3) {
-                        SpreadPlayersCommand.Position position2 = positions[i3];
-                        double d1 = position.dist(position2);
-                        d = Math.min(d1, d);
-                        if (d1 < spreadDistance) {
-                            i2++;
-                            position1.x = position1.x + (position2.x - position.x);
-                            position1.z = position1.z + (position2.z - position.z);
+            int k;
+            SpreadPlayersCommand.Position commandspreadplayers_a;
+
+            for (int l = 0; l < maxX.length; ++l) {
+                SpreadPlayersCommand.Position commandspreadplayers_a1 = maxX[l];
+
+                k = 0;
+                commandspreadplayers_a = new SpreadPlayersCommand.Position();
+
+                for (int i1 = 0; i1 < maxX.length; ++i1) {
+                    if (l != i1) {
+                        SpreadPlayersCommand.Position commandspreadplayers_a2 = maxX[i1];
+                        double d6 = commandspreadplayers_a1.dist(commandspreadplayers_a2);
+
+                        d5 = Math.min(d6, d5);
+                        if (d6 < spreadDistance) {
+                            ++k;
+                            commandspreadplayers_a.x += commandspreadplayers_a2.x - commandspreadplayers_a1.x;
+                            commandspreadplayers_a.z += commandspreadplayers_a2.z - commandspreadplayers_a1.z;
                         }
                     }
                 }
 
-                if (i2 > 0) {
-                    position1.x /= (double)i2;
-                    position1.z /= (double)i2;
-                    double length = position1.getLength();
-                    if (length > 0.0) {
-                        position1.normalize();
-                        position.moveAway(position1);
+                if (k > 0) {
+                    commandspreadplayers_a.x /= (double) k;
+                    commandspreadplayers_a.z /= (double) k;
+                    double d7 = commandspreadplayers_a.getLength();
+
+                    if (d7 > 0.0D) {
+                        commandspreadplayers_a.normalize();
+                        commandspreadplayers_a1.moveAway(commandspreadplayers_a);
                     } else {
-                        position.randomize(random, minX, minZ, maxX, maxZ);
+                        commandspreadplayers_a1.randomize(level, random, minX, d3, minZ);
                     }
 
-                    flag = true;
+                    flag1 = true;
                 }
 
-                if (position.clamp(minX, minZ, maxX, maxZ)) {
-                    flag = true;
+                if (commandspreadplayers_a1.clamp(random, minX, d3, minZ)) {
+                    flag1 = true;
                 }
             }
 
-            if (!flag) {
-                for (SpreadPlayersCommand.Position position1 : positions) {
-                    if (!position1.isSafe(level, maxHeight)) {
-                        position1.randomize(random, minX, minZ, maxX, maxZ);
-                        flag = true;
+            if (!flag1) {
+                SpreadPlayersCommand.Position[] acommandspreadplayers_a1 = maxX;
+                int j1 = maxX.length;
+
+                for (k = 0; k < j1; ++k) {
+                    commandspreadplayers_a = acommandspreadplayers_a1[k];
+                    if (!commandspreadplayers_a.isSafe(worldserver, i)) {
+                        commandspreadplayers_a.randomize(level, random, minX, d3, minZ);
+                        flag1 = true;
                     }
                 }
             }
         }
 
-        if (d == Float.MAX_VALUE) {
-            d = 0.0;
+        if (d5 == 3.4028234663852886E38D) {
+            d5 = 0.0D;
         }
 
-        if (i >= 10000) {
-            if (respectTeams) {
-                throw ERROR_FAILED_TO_SPREAD_TEAMS.create(positions.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d));
+        if (j >= 10000) {
+            if (flag) {
+                throw SpreadPlayersCommand.ERROR_FAILED_TO_SPREAD_TEAMS.create(maxX.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d5));
             } else {
-                throw ERROR_FAILED_TO_SPREAD_ENTITIES.create(positions.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d));
+                throw SpreadPlayersCommand.ERROR_FAILED_TO_SPREAD_ENTITIES.create(maxX.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d5));
             }
         }
     }
 
-    private static double setPlayerPositions(
-        Collection<? extends Entity> targets, ServerLevel level, SpreadPlayersCommand.Position[] positions, int maxHeight, boolean respectTeams
-    ) {
-        double d = 0.0;
-        int i = 0;
+    private static double setPlayerPositions(Collection<? extends Entity> targets, ServerLevel level, SpreadPlayersCommand.Position[] positions, int maxHeight, boolean respectTeams) {
+        double d0 = 0.0D;
+        int j = 0;
         Map<Team, SpreadPlayersCommand.Position> map = Maps.newHashMap();
 
-        for (Entity entity : targets) {
-            SpreadPlayersCommand.Position position;
+        double d1;
+
+        for (Iterator iterator = targets.iterator(); iterator.hasNext(); d0 += d1) {
+            Entity entity = (Entity) iterator.next();
+            SpreadPlayersCommand.Position commandspreadplayers_a;
+
             if (respectTeams) {
-                Team team = entity instanceof Player ? entity.getTeam() : null;
-                if (!map.containsKey(team)) {
-                    map.put(team, positions[i++]);
+                PlayerTeam scoreboardteam = entity instanceof Player ? entity.getTeam() : null;
+
+                if (!map.containsKey(scoreboardteam)) {
+                    map.put(scoreboardteam, positions[j++]);
                 }
 
-                position = map.get(team);
+                commandspreadplayers_a = (SpreadPlayersCommand.Position) map.get(scoreboardteam);
             } else {
-                position = positions[i++];
+                commandspreadplayers_a = positions[j++];
             }
 
-            entity.teleportTo(
-                level,
-                (double)Mth.floor(position.x) + 0.5,
-                (double)position.getSpawnY(level, maxHeight),
-                (double)Mth.floor(position.z) + 0.5,
-                Set.of(),
-                entity.getYRot(),
-                entity.getXRot()
-            );
-            double d1 = Double.MAX_VALUE;
+            entity.teleportTo(level, (double) Mth.floor(commandspreadplayers_a.x) + 0.5D, (double) commandspreadplayers_a.getSpawnY(level, maxHeight), (double) Mth.floor(commandspreadplayers_a.z) + 0.5D, Set.of(), entity.getYRot(), entity.getXRot(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND); // CraftBukkit - handle teleport reason
+            d1 = Double.MAX_VALUE;
+            SpreadPlayersCommand.Position[] acommandspreadplayers_a1 = positions;
+            int k = positions.length;
 
-            for (SpreadPlayersCommand.Position position1 : positions) {
-                if (position != position1) {
-                    double d2 = position.dist(position1);
+            for (int l = 0; l < k; ++l) {
+                SpreadPlayersCommand.Position commandspreadplayers_a1 = acommandspreadplayers_a1[l];
+
+                if (commandspreadplayers_a != commandspreadplayers_a1) {
+                    double d2 = commandspreadplayers_a.dist(commandspreadplayers_a1);
+
                     d1 = Math.min(d2, d1);
                 }
             }
-
-            d += d1;
         }
 
-        return targets.size() < 2 ? 0.0 : d / (double)targets.size();
+        if (targets.size() < 2) {
+            return 0.0D;
+        } else {
+            d0 /= (double) targets.size();
+            return d0;
+        }
     }
 
-    private static SpreadPlayersCommand.Position[] createInitialPositions(RandomSource random, int count, double minX, double minZ, double maxX, double maxZ) {
-        SpreadPlayersCommand.Position[] positions = new SpreadPlayersCommand.Position[count];
+    private static SpreadPlayersCommand.Position[] createInitialPositions(RandomSource random, int count, double minX, double d1, double minZ, double d3) {
+        SpreadPlayersCommand.Position[] acommandspreadplayers_a = new SpreadPlayersCommand.Position[count];
 
-        for (int i = 0; i < positions.length; i++) {
-            SpreadPlayersCommand.Position position = new SpreadPlayersCommand.Position();
-            position.randomize(random, minX, minZ, maxX, maxZ);
-            positions[i] = position;
+        for (int j = 0; j < acommandspreadplayers_a.length; ++j) {
+            SpreadPlayersCommand.Position commandspreadplayers_a = new SpreadPlayersCommand.Position();
+
+            commandspreadplayers_a.randomize(random, minX, d1, minZ, d3);
+            acommandspreadplayers_a[j] = commandspreadplayers_a;
         }
 
-        return positions;
+        return acommandspreadplayers_a;
     }
 
-    static class Position {
+    private static class Position {
+
         double x;
         double z;
 
+        Position() {}
+
         double dist(SpreadPlayersCommand.Position other) {
-            double d = this.x - other.x;
+            double d0 = this.x - other.x;
             double d1 = this.z - other.z;
-            return Math.sqrt(d * d + d1 * d1);
+
+            return Math.sqrt(d0 * d0 + d1 * d1);
         }
 
         void normalize() {
-            double length = this.getLength();
-            this.x /= length;
-            this.z /= length;
+            double d0 = this.getLength();
+
+            this.x /= d0;
+            this.z /= d0;
         }
 
         double getLength() {
@@ -304,25 +266,26 @@
         }
 
         public void moveAway(SpreadPlayersCommand.Position other) {
-            this.x = this.x - other.x;
-            this.z = this.z - other.z;
+            this.x -= other.x;
+            this.z -= other.z;
         }
 
-        public boolean clamp(double minX, double minZ, double maxX, double maxZ) {
+        public boolean clamp(double minX, double d1, double minZ, double d3) {
             boolean flag = false;
+
             if (this.x < minX) {
                 this.x = minX;
                 flag = true;
-            } else if (this.x > maxX) {
-                this.x = maxX;
+            } else if (this.x > minZ) {
+                this.x = minZ;
                 flag = true;
             }
 
-            if (this.z < minZ) {
-                this.z = minZ;
+            if (this.z < d1) {
+                this.z = d1;
                 flag = true;
-            } else if (this.z > maxZ) {
-                this.z = maxZ;
+            } else if (this.z > d3) {
+                this.z = d3;
                 flag = true;
             }
 
@@ -330,34 +293,36 @@
         }
 
         public int getSpawnY(BlockGetter level, int y) {
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos(this.x, (double)(y + 1), this.z);
-            boolean isAir = level.getBlockState(mutableBlockPos).isAir();
-            mutableBlockPos.move(Direction.DOWN);
-            boolean isAir1 = level.getBlockState(mutableBlockPos).isAir();
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(this.x, (double) (y + 1), this.z);
+            boolean flag = level.getBlockState(blockposition_mutableblockposition).isAir();
 
-            while (mutableBlockPos.getY() > level.getMinBuildHeight()) {
-                mutableBlockPos.move(Direction.DOWN);
-                boolean isAir2 = level.getBlockState(mutableBlockPos).isAir();
-                if (!isAir2 && isAir1 && isAir) {
-                    return mutableBlockPos.getY() + 1;
+            blockposition_mutableblockposition.move(Direction.DOWN);
+
+            boolean flag1;
+
+            for (boolean flag2 = level.getBlockState(blockposition_mutableblockposition).isAir(); blockposition_mutableblockposition.getY() > level.getMinBuildHeight(); flag2 = flag1) {
+                blockposition_mutableblockposition.move(Direction.DOWN);
+                flag1 = level.getBlockState(blockposition_mutableblockposition).isAir();
+                if (!flag1 && flag2 && flag) {
+                    return blockposition_mutableblockposition.getY() + 1;
                 }
 
-                isAir = isAir1;
-                isAir1 = isAir2;
+                flag = flag2;
             }
 
             return y + 1;
         }
 
         public boolean isSafe(BlockGetter level, int y) {
-            BlockPos blockPos = BlockPos.containing(this.x, (double)(this.getSpawnY(level, y) - 1), this.z);
-            BlockState blockState = level.getBlockState(blockPos);
-            return blockPos.getY() < y && !blockState.liquid() && !blockState.is(BlockTags.FIRE);
+            BlockPos blockposition = BlockPos.containing(this.x, (double) (this.getSpawnY(level, y) - 1), this.z);
+            IBlockData iblockdata = level.getBlockState(blockposition);
+
+            return blockposition.getY() < y && !iblockdata.liquid() && !iblockdata.is(BlockTags.FIRE);
         }
 
-        public void randomize(RandomSource random, double minX, double minZ, double maxX, double maxZ) {
-            this.x = Mth.nextDouble(random, minX, maxX);
-            this.z = Mth.nextDouble(random, minZ, maxZ);
+        public void randomize(RandomSource random, double minX, double d1, double minZ, double d3) {
+            this.x = Mth.nextDouble(random, minX, minZ);
+            this.z = Mth.nextDouble(random, d1, d3);
         }
     }
 }
