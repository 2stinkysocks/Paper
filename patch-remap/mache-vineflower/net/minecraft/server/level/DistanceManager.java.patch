--- a/net/minecraft/server/level/DistanceManager.java
+++ b/net/minecraft/server/level/DistanceManager.java
@@ -12,11 +12,11 @@
 import it.unimi.dsi.fastutil.longs.Long2IntMaps;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
@@ -25,6 +25,7 @@
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 import java.util.Iterator;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -37,11 +38,12 @@
 import org.slf4j.Logger;
 
 public abstract class DistanceManager {
+
     static final Logger LOGGER = LogUtils.getLogger();
     static final int PLAYER_TICKET_LEVEL = ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING);
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap<>();
-    final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>();
+    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
+    public final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker();
     private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8);
     private final TickingTracker tickingTicketsTracker = new TickingTracker();
@@ -56,25 +58,28 @@
     private int simulationDistance = 10;
 
     protected DistanceManager(Executor dispatcher, Executor mainThreadExecutor) {
-        ProcessorHandle<Runnable> processorHandle = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
-        ChunkTaskPriorityQueueSorter chunkTaskPriorityQueueSorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(processorHandle), dispatcher, 4);
-        this.ticketThrottler = chunkTaskPriorityQueueSorter;
-        this.ticketThrottlerInput = chunkTaskPriorityQueueSorter.getProcessor(processorHandle, true);
-        this.ticketThrottlerReleaser = chunkTaskPriorityQueueSorter.getReleaseProcessor(processorHandle);
+        Objects.requireNonNull(mainThreadExecutor);
+        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
+        ChunkTaskPriorityQueueSorter chunktaskqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(mailbox), dispatcher, 4);
+
+        this.ticketThrottler = chunktaskqueuesorter;
+        this.ticketThrottlerInput = chunktaskqueuesorter.getProcessor(mailbox, true);
+        this.ticketThrottlerReleaser = chunktaskqueuesorter.getReleaseProcessor(mailbox);
         this.mainThreadExecutor = mainThreadExecutor;
     }
 
     protected void purgeStaleTickets() {
-        this.ticketTickCounter++;
-        ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectIterator = this.tickets.long2ObjectEntrySet().fastIterator();
+        ++this.ticketTickCounter;
+        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
-        while (objectIterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = objectIterator.next();
-            Iterator<Ticket<?>> iterator = entry.getValue().iterator();
+        while (objectiterator.hasNext()) {
+            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
+            Iterator<Ticket<?>> iterator = ((SortedArraySet) entry.getValue()).iterator();
             boolean flag = false;
 
             while (iterator.hasNext()) {
-                Ticket<?> ticket = iterator.next();
+                Ticket<?> ticket = (Ticket) iterator.next();
+
                 if (ticket.timedOut(this.ticketTickCounter)) {
                     iterator.remove();
                     flag = true;
@@ -83,17 +88,18 @@
             }
 
             if (flag) {
-                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt(entry.getValue()), false);
+                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt((SortedArraySet) entry.getValue()), false);
             }
 
-            if (entry.getValue().isEmpty()) {
-                objectIterator.remove();
+            if (((SortedArraySet) entry.getValue()).isEmpty()) {
+                objectiterator.remove();
             }
         }
+
     }
 
     private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
-        return !tickets.isEmpty() ? tickets.first().getTicketLevel() : ChunkLevel.MAX_LEVEL + 1;
+        return !tickets.isEmpty() ? ((Ticket) tickets.first()).getTicketLevel() : ChunkLevel.MAX_LEVEL + 1;
     }
 
     protected abstract boolean isChunkToRemove(long chunkPos);
@@ -102,7 +108,7 @@
     protected abstract ChunkHolder getChunk(long chunkPos);
 
     @Nullable
-    protected abstract ChunkHolder updateChunkScheduling(long chunkPos, int i, @Nullable ChunkHolder newLevel, int holder);
+    protected abstract ChunkHolder updateChunkScheduling(long chunkPos, int j, @Nullable ChunkHolder newLevel, int holder);
 
     public boolean runAllUpdates(ChunkMap chunkManager) {
         this.naturalSpawnChunkCounter.runAllUpdates();
@@ -110,32 +116,56 @@
         this.playerTicketManager.runAllUpdates();
         int i = Integer.MAX_VALUE - this.ticketTracker.runDistanceUpdates(Integer.MAX_VALUE);
         boolean flag = i != 0;
+
         if (flag) {
+            ;
         }
 
         if (!this.chunksToUpdateFutures.isEmpty()) {
-            this.chunksToUpdateFutures.forEach(chunkHolder -> chunkHolder.updateFutures(chunkManager, this.mainThreadExecutor));
-            this.chunksToUpdateFutures.clear();
+            // CraftBukkit start
+            // Iterate pending chunk updates with protection against concurrent modification exceptions
+            java.util.Iterator<ChunkHolder> iter = this.chunksToUpdateFutures.iterator();
+            int expectedSize = this.chunksToUpdateFutures.size();
+            do {
+                ChunkHolder playerchunk = iter.next();
+                iter.remove();
+                expectedSize--;
+
+                playerchunk.updateFutures(chunkManager, this.mainThreadExecutor);
+
+                // Reset iterator if set was modified using add()
+                if (this.chunksToUpdateFutures.size() != expectedSize) {
+                    expectedSize = this.chunksToUpdateFutures.size();
+                    iter = this.chunksToUpdateFutures.iterator();
+                }
+            } while (iter.hasNext());
+            // CraftBukkit end
+
             return true;
         } else {
             if (!this.ticketsToRelease.isEmpty()) {
-                LongIterator longIterator = this.ticketsToRelease.iterator();
+                LongIterator longiterator = this.ticketsToRelease.iterator();
 
-                while (longIterator.hasNext()) {
-                    long l = longIterator.nextLong();
-                    if (this.getTickets(l).stream().anyMatch(ticket -> ticket.getType() == TicketType.PLAYER)) {
-                        ChunkHolder updatingChunkIfPresent = chunkManager.getUpdatingChunkIfPresent(l);
-                        if (updatingChunkIfPresent == null) {
+                while (longiterator.hasNext()) {
+                    long j = longiterator.nextLong();
+
+                    if (this.getTickets(j).stream().anyMatch((ticket) -> {
+                        return ticket.getType() == TicketType.PLAYER;
+                    })) {
+                        ChunkHolder playerchunk = chunkManager.getUpdatingChunkIfPresent(j);
+
+                        if (playerchunk == null) {
                             throw new IllegalStateException();
                         }
 
-                        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> entityTickingChunkFuture = updatingChunkIfPresent.getEntityTickingChunkFuture(
-                            
-                        );
-                        entityTickingChunkFuture.thenAccept(
-                            either -> this.mainThreadExecutor.execute(() -> this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
-                                    }, l, false)))
-                        );
+                        CompletableFuture<Either<LevelChunk, ChunkHolder.Failure>> completablefuture = playerchunk.getEntityTickingChunkFuture();
+
+                        completablefuture.thenAccept((either) -> {
+                            this.mainThreadExecutor.execute(() -> {
+                                this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
+                                }, j, false));
+                            });
+                        });
                     }
                 }
 
@@ -146,26 +176,33 @@
         }
     }
 
-    void addTicket(long chunkPos, Ticket<?> ticket) {
-        SortedArraySet<Ticket<?>> tickets = this.getTickets(chunkPos);
-        int ticketLevelAt = getTicketLevelAt(tickets);
-        Ticket<?> ticket1 = tickets.addOrGet(ticket);
+    boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
+        int j = getTicketLevelAt(arraysetsorted);
+        Ticket<?> ticket1 = (Ticket) arraysetsorted.addOrGet(ticket);
+
         ticket1.setCreatedTick(this.ticketTickCounter);
-        if (ticket.getTicketLevel() < ticketLevelAt) {
-            this.ticketTracker.update(chunkPos, ticket.getTicketLevel(), true);
+        if (ticket.getTicketLevel() < j) {
+            this.ticketTracker.update(i, ticket.getTicketLevel(), true);
         }
+
+        return ticket == ticket1; // CraftBukkit
     }
 
-    void removeTicket(long chunkPos, Ticket<?> ticket) {
-        SortedArraySet<Ticket<?>> tickets = this.getTickets(chunkPos);
-        if (tickets.remove(ticket)) {
+    boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
+
+        boolean removed = false; // CraftBukkit
+        if (arraysetsorted.remove(ticket)) {
+            removed = true; // CraftBukkit
         }
 
-        if (tickets.isEmpty()) {
-            this.tickets.remove(chunkPos);
+        if (arraysetsorted.isEmpty()) {
+            this.tickets.remove(i);
         }
 
-        this.ticketTracker.update(chunkPos, getTicketLevelAt(tickets), false);
+        this.ticketTracker.update(i, getTicketLevelAt(arraysetsorted), false);
+        return removed; // CraftBukkit
     }
 
     public <T> void addTicket(TicketType<T> type, ChunkPos pos, int level, T value) {
@@ -174,59 +211,86 @@
 
     public <T> void removeTicket(TicketType<T> type, ChunkPos pos, int level, T value) {
         Ticket<T> ticket = new Ticket<>(type, level, value);
+
         this.removeTicket(pos.toLong(), ticket);
     }
 
     public <T> void addRegionTicket(TicketType<T> type, ChunkPos pos, int distance, T value) {
-        Ticket<T> ticket = new Ticket<>(type, ChunkLevel.byStatus(FullChunkStatus.FULL) - distance, value);
-        long l = pos.toLong();
-        this.addTicket(l, ticket);
-        this.tickingTicketsTracker.addTicket(l, ticket);
+        // CraftBukkit start
+        addRegionTicketAtDistance(type, pos, distance, value);
     }
 
+    public <T> boolean addRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
+        // CraftBukkit end
+        Ticket<T> ticket = new Ticket<>(tickettype, ChunkLevel.byStatus(FullChunkStatus.FULL) - i, t0);
+        long j = chunkcoordintpair.toLong();
+
+        boolean added = this.addTicket(j, ticket); // CraftBukkit
+        this.tickingTicketsTracker.addTicket(j, ticket);
+        return added; // CraftBukkit
+    }
+
     public <T> void removeRegionTicket(TicketType<T> type, ChunkPos pos, int distance, T value) {
-        Ticket<T> ticket = new Ticket<>(type, ChunkLevel.byStatus(FullChunkStatus.FULL) - distance, value);
-        long l = pos.toLong();
-        this.removeTicket(l, ticket);
-        this.tickingTicketsTracker.removeTicket(l, ticket);
+        // CraftBukkit start
+        removeRegionTicketAtDistance(type, pos, distance, value);
     }
 
+    public <T> boolean removeRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
+        // CraftBukkit end
+        Ticket<T> ticket = new Ticket<>(tickettype, ChunkLevel.byStatus(FullChunkStatus.FULL) - i, t0);
+        long j = chunkcoordintpair.toLong();
+
+        boolean removed = this.removeTicket(j, ticket); // CraftBukkit
+        this.tickingTicketsTracker.removeTicket(j, ticket);
+        return removed; // CraftBukkit
+    }
+
     private SortedArraySet<Ticket<?>> getTickets(long chunkPos) {
-        return this.tickets.computeIfAbsent(chunkPos, l -> SortedArraySet.create(4));
+        return (SortedArraySet) this.tickets.computeIfAbsent(chunkPos, (j) -> {
+            return SortedArraySet.create(4);
+        });
     }
 
     protected void updateChunkForced(ChunkPos pos, boolean add) {
         Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, ChunkMap.FORCED_TICKET_LEVEL, pos);
-        long l = pos.toLong();
+        long i = pos.toLong();
+
         if (add) {
-            this.addTicket(l, ticket);
-            this.tickingTicketsTracker.addTicket(l, ticket);
+            this.addTicket(i, ticket);
+            this.tickingTicketsTracker.addTicket(i, ticket);
         } else {
-            this.removeTicket(l, ticket);
-            this.tickingTicketsTracker.removeTicket(l, ticket);
+            this.removeTicket(i, ticket);
+            this.tickingTicketsTracker.removeTicket(i, ticket);
         }
+
     }
 
     public void addPlayer(SectionPos sectionPos, ServerPlayer player) {
-        ChunkPos chunkPos = sectionPos.chunk();
-        long l = chunkPos.toLong();
-        this.playersPerChunk.computeIfAbsent(l, l1 -> new ObjectOpenHashSet<>()).add(player);
-        this.naturalSpawnChunkCounter.update(l, 0, true);
-        this.playerTicketManager.update(l, 0, true);
-        this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkPos, this.getPlayerTicketLevel(), chunkPos);
+        ChunkPos chunkcoordintpair = sectionPos.chunk();
+        long i = chunkcoordintpair.toLong();
+
+        ((ObjectSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
+            return new ObjectOpenHashSet();
+        })).add(player);
+        this.naturalSpawnChunkCounter.update(i, 0, true);
+        this.playerTicketManager.update(i, 0, true);
+        this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair);
     }
 
     public void removePlayer(SectionPos sectionPos, ServerPlayer player) {
-        ChunkPos chunkPos = sectionPos.chunk();
-        long l = chunkPos.toLong();
-        ObjectSet<ServerPlayer> set = this.playersPerChunk.get(l);
-        set.remove(player);
-        if (set.isEmpty()) {
-            this.playersPerChunk.remove(l);
-            this.naturalSpawnChunkCounter.update(l, Integer.MAX_VALUE, false);
-            this.playerTicketManager.update(l, Integer.MAX_VALUE, false);
-            this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkPos, this.getPlayerTicketLevel(), chunkPos);
+        ChunkPos chunkcoordintpair = sectionPos.chunk();
+        long i = chunkcoordintpair.toLong();
+        ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
+        if (objectset == null) return; // CraftBukkit - SPIGOT-6208
+
+        objectset.remove(player);
+        if (objectset.isEmpty()) {
+            this.playersPerChunk.remove(i);
+            this.naturalSpawnChunkCounter.update(i, Integer.MAX_VALUE, false);
+            this.playerTicketManager.update(i, Integer.MAX_VALUE, false);
+            this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair);
         }
+
     }
 
     private int getPlayerTicketLevel() {
@@ -242,8 +306,9 @@
     }
 
     protected String getTicketDebugString(long chunkPos) {
-        SortedArraySet<Ticket<?>> set = this.tickets.get(chunkPos);
-        return set != null && !set.isEmpty() ? set.first().toString() : "no_ticket";
+        SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) this.tickets.get(chunkPos);
+
+        return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
     protected void updatePlayerTickets(int viewDistance) {
@@ -255,6 +320,7 @@
             this.simulationDistance = simulationDistance;
             this.tickingTicketsTracker.replacePlayerTicketsLevel(this.getPlayerTicketLevel());
         }
+
     }
 
     public int getNaturalSpawnChunkCount() {
@@ -272,19 +338,38 @@
     }
 
     private void dumpTickets(String filename) {
-        try (FileOutputStream fileOutputStream = new FileOutputStream(new File(filename))) {
-            for (Entry<SortedArraySet<Ticket<?>>> entry : this.tickets.long2ObjectEntrySet()) {
-                ChunkPos chunkPos = new ChunkPos(entry.getLongKey());
+        try {
+            FileOutputStream fileoutputstream = new FileOutputStream(new File(filename));
 
-                for (Ticket<?> ticket : entry.getValue()) {
-                    fileOutputStream.write(
-                        (chunkPos.x + "\t" + chunkPos.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8)
-                    );
+            try {
+                ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().iterator();
+
+                while (objectiterator.hasNext()) {
+                    Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
+                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
+                    Iterator iterator = ((SortedArraySet) entry.getValue()).iterator();
+
+                    while (iterator.hasNext()) {
+                        Ticket<?> ticket = (Ticket) iterator.next();
+
+                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
+                    }
                 }
+            } catch (Throwable throwable) {
+                try {
+                    fileoutputstream.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+
+                throw throwable;
             }
-        } catch (IOException var10) {
-            LOGGER.error("Failed to dump tickets to {}", filename, var10);
+
+            fileoutputstream.close();
+        } catch (IOException ioexception) {
+            DistanceManager.LOGGER.error("Failed to dump tickets to {}", filename, ioexception);
         }
+
     }
 
     @VisibleForTesting
@@ -293,17 +378,18 @@
     }
 
     public void removeTicketsOnClosing() {
-        ImmutableSet<TicketType<?>> set = ImmutableSet.of(TicketType.UNKNOWN, TicketType.POST_TELEPORT, TicketType.LIGHT);
-        ObjectIterator<Entry<SortedArraySet<Ticket<?>>>> objectIterator = this.tickets.long2ObjectEntrySet().fastIterator();
+        ImmutableSet<TicketType<?>> immutableset = ImmutableSet.of(TicketType.UNKNOWN, TicketType.POST_TELEPORT, TicketType.LIGHT);
+        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
 
-        while (objectIterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = objectIterator.next();
-            Iterator<Ticket<?>> iterator = entry.getValue().iterator();
+        while (objectiterator.hasNext()) {
+            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
+            Iterator<Ticket<?>> iterator = ((SortedArraySet) entry.getValue()).iterator();
             boolean flag = false;
 
             while (iterator.hasNext()) {
-                Ticket<?> ticket = iterator.next();
-                if (!set.contains(ticket.getType())) {
+                Ticket<?> ticket = (Ticket) iterator.next();
+
+                if (!immutableset.contains(ticket.getType())) {
                     iterator.remove();
                     flag = true;
                     this.tickingTicketsTracker.removeTicket(entry.getLongKey(), ticket);
@@ -311,57 +397,79 @@
             }
 
             if (flag) {
-                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt(entry.getValue()), false);
+                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt((SortedArraySet) entry.getValue()), false);
             }
 
-            if (entry.getValue().isEmpty()) {
-                objectIterator.remove();
+            if (((SortedArraySet) entry.getValue()).isEmpty()) {
+                objectiterator.remove();
             }
         }
+
     }
 
     public boolean hasTickets() {
         return !this.tickets.isEmpty();
     }
 
-    class ChunkTicketTracker extends ChunkTracker {
+    // CraftBukkit start
+    public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
+        Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
+
+        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
+            SortedArraySet<Ticket<?>> tickets = entry.getValue();
+            if (tickets.remove(target)) {
+                // copied from removeTicket
+                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt(tickets), false);
+
+                // can't use entry after it's removed
+                if (tickets.isEmpty()) {
+                    iterator.remove();
+                }
+            }
+        }
+    }
+    // CraftBukkit end
+
+    private class ChunkTicketTracker extends ChunkTracker {
+
         private static final int MAX_LEVEL = ChunkLevel.MAX_LEVEL + 1;
 
         public ChunkTicketTracker() {
-            super(MAX_LEVEL + 1, 16, 256);
+            super(DistanceManager.ChunkTicketTracker.MAX_LEVEL + 1, 16, 256);
         }
 
         @Override
         protected int getLevelFromSource(long pos) {
-            SortedArraySet<Ticket<?>> set = DistanceManager.this.tickets.get(pos);
-            if (set == null) {
-                return Integer.MAX_VALUE;
-            } else {
-                return set.isEmpty() ? Integer.MAX_VALUE : set.first().getTicketLevel();
-            }
+            SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(pos);
+
+            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
         }
 
         @Override
         protected int getLevel(long sectionPos) {
             if (!DistanceManager.this.isChunkToRemove(sectionPos)) {
-                ChunkHolder chunk = DistanceManager.this.getChunk(sectionPos);
-                if (chunk != null) {
-                    return chunk.getTicketLevel();
+                ChunkHolder playerchunk = DistanceManager.this.getChunk(sectionPos);
+
+                if (playerchunk != null) {
+                    return playerchunk.getTicketLevel();
                 }
             }
 
-            return MAX_LEVEL;
+            return DistanceManager.ChunkTicketTracker.MAX_LEVEL;
         }
 
         @Override
-        protected void setLevel(long sectionPos, int level) {
-            ChunkHolder chunk = DistanceManager.this.getChunk(sectionPos);
-            int i = chunk == null ? MAX_LEVEL : chunk.getTicketLevel();
-            if (i != level) {
-                ChunkHolder var6 = DistanceManager.this.updateChunkScheduling(sectionPos, level, chunk, i);
-                if (var6 != null) {
-                    DistanceManager.this.chunksToUpdateFutures.add(var6);
+        protected void setLevel(long sectionPos, int j) {
+            ChunkHolder playerchunk = DistanceManager.this.getChunk(sectionPos);
+            int k = playerchunk == null ? DistanceManager.ChunkTicketTracker.MAX_LEVEL : playerchunk.getTicketLevel();
+
+            if (k != j) {
+                playerchunk = DistanceManager.this.updateChunkScheduling(sectionPos, j, playerchunk, k);
+                if (playerchunk != null) {
+                    DistanceManager.this.chunksToUpdateFutures.add(playerchunk);
                 }
+
             }
         }
 
@@ -370,14 +478,15 @@
         }
     }
 
-    class FixedPlayerDistanceChunkTracker extends ChunkTracker {
+    private class FixedPlayerDistanceChunkTracker extends ChunkTracker {
+
         protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
         protected final int maxDistance;
 
-        protected FixedPlayerDistanceChunkTracker(int maxDistance) {
-            super(maxDistance + 2, 16, 256);
-            this.maxDistance = maxDistance;
-            this.chunks.defaultReturnValue((byte)(maxDistance + 2));
+        protected FixedPlayerDistanceChunkTracker(int i) {
+            super(i + 2, 16, 256);
+            this.maxDistance = i;
+            this.chunks.defaultReturnValue((byte) (i + 2));
         }
 
         @Override
@@ -386,19 +495,19 @@
         }
 
         @Override
-        protected void setLevel(long sectionPos, int level) {
-            byte b;
-            if (level > this.maxDistance) {
-                b = this.chunks.remove(sectionPos);
+        protected void setLevel(long sectionPos, int j) {
+            byte b0;
+
+            if (j > this.maxDistance) {
+                b0 = this.chunks.remove(sectionPos);
             } else {
-                b = this.chunks.put(sectionPos, (byte)level);
+                b0 = this.chunks.put(sectionPos, (byte) j);
             }
 
-            this.onLevelChange(sectionPos, b, level);
+            this.onLevelChange(sectionPos, b0, j);
         }
 
-        protected void onLevelChange(long chunkPos, int oldLevel, int newLevel) {
-        }
+        protected void onLevelChange(long chunkPos, int j, int oldLevel) {}
 
         @Override
         protected int getLevelFromSource(long pos) {
@@ -406,8 +515,9 @@
         }
 
         private boolean havePlayer(long chunkPos) {
-            ObjectSet<ServerPlayer> set = DistanceManager.this.playersPerChunk.get(chunkPos);
-            return set != null && !set.isEmpty();
+            ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(chunkPos);
+
+            return objectset != null && !objectset.isEmpty();
         }
 
         public void runAllUpdates() {
@@ -415,95 +525,126 @@
         }
 
         private void dumpChunks(String filename) {
-            try (FileOutputStream fileOutputStream = new FileOutputStream(new File(filename))) {
-                for (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry entry : this.chunks.long2ByteEntrySet()) {
-                    ChunkPos chunkPos = new ChunkPos(entry.getLongKey());
-                    String string = Byte.toString(entry.getByteValue());
-                    fileOutputStream.write((chunkPos.x + "\t" + chunkPos.z + "\t" + string + "\n").getBytes(StandardCharsets.UTF_8));
+            try {
+                FileOutputStream fileoutputstream = new FileOutputStream(new File(filename));
+
+                try {
+                    ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+
+                    while (objectiterator.hasNext()) {
+                        it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                        ChunkPos chunkcoordintpair = new ChunkPos(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey());
+                        String s1 = Byte.toString(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue());
+
+                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + s1 + "\n").getBytes(StandardCharsets.UTF_8));
+                    }
+                } catch (Throwable throwable) {
+                    try {
+                        fileoutputstream.close();
+                    } catch (Throwable throwable1) {
+                        throwable.addSuppressed(throwable1);
+                    }
+
+                    throw throwable;
                 }
-            } catch (IOException var9) {
-                DistanceManager.LOGGER.error("Failed to dump chunks to {}", filename, var9);
+
+                fileoutputstream.close();
+            } catch (IOException ioexception) {
+                DistanceManager.LOGGER.error("Failed to dump chunks to {}", filename, ioexception);
             }
+
         }
     }
 
-    class PlayerTicketTracker extends DistanceManager.FixedPlayerDistanceChunkTracker {
-        private int viewDistance;
+    private class PlayerTicketTracker extends DistanceManager.FixedPlayerDistanceChunkTracker {
+
+        private int viewDistance = 0;
         private final Long2IntMap queueLevels = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
         private final LongSet toUpdate = new LongOpenHashSet();
 
-        protected PlayerTicketTracker(int maxDistance) {
-            super(maxDistance);
-            this.viewDistance = 0;
-            this.queueLevels.defaultReturnValue(maxDistance + 2);
+        protected PlayerTicketTracker(int i) {
+            super(i);
+            this.queueLevels.defaultReturnValue(i + 2);
         }
 
         @Override
-        protected void onLevelChange(long chunkPos, int oldLevel, int newLevel) {
+        protected void onLevelChange(long chunkPos, int j, int oldLevel) {
             this.toUpdate.add(chunkPos);
         }
 
         public void updateViewDistance(int viewDistance) {
-            for (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry entry : this.chunks.long2ByteEntrySet()) {
-                byte byteValue = entry.getByteValue();
-                long longKey = entry.getLongKey();
-                this.onLevelChange(longKey, byteValue, this.haveTicketFor(byteValue), byteValue <= viewDistance);
+            ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+
+            while (objectiterator.hasNext()) {
+                it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
+                long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
+
+                this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= viewDistance);
             }
 
             this.viewDistance = viewDistance;
         }
 
-        private void onLevelChange(long chunkPos, int i, boolean flag, boolean flag1) {
+        private void onLevelChange(long chunkPos, int j, boolean flag, boolean flag1) {
             if (flag != flag1) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, DistanceManager.PLAYER_TICKET_LEVEL, new ChunkPos(chunkPos));
+
                 if (flag1) {
-                    DistanceManager.this.ticketThrottlerInput
-                        .tell(ChunkTaskPriorityQueueSorter.message(() -> DistanceManager.this.mainThreadExecutor.execute(() -> {
-                                if (this.haveTicketFor(this.getLevel(chunkPos))) {
-                                    DistanceManager.this.addTicket(chunkPos, ticket);
-                                    DistanceManager.this.ticketsToRelease.add(chunkPos);
-                                } else {
-                                    DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
-                                    }, chunkPos, false));
-                                }
-                            }), chunkPos, () -> i));
+                    DistanceManager.this.ticketThrottlerInput.tell(ChunkTaskPriorityQueueSorter.message(() -> {
+                        DistanceManager.this.mainThreadExecutor.execute(() -> {
+                            if (this.haveTicketFor(this.getLevel(chunkPos))) {
+                                DistanceManager.this.addTicket(chunkPos, ticket);
+                                DistanceManager.this.ticketsToRelease.add(chunkPos);
+                            } else {
+                                DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
+                                }, chunkPos, false));
+                            }
+
+                        });
+                    }, chunkPos, () -> {
+                        return j;
+                    }));
                 } else {
-                    DistanceManager.this.ticketThrottlerReleaser
-                        .tell(
-                            ChunkTaskPriorityQueueSorter.release(
-                                () -> DistanceManager.this.mainThreadExecutor.execute(() -> DistanceManager.this.removeTicket(chunkPos, ticket)),
-                                chunkPos,
-                                true
-                            )
-                        );
+                    DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
+                        DistanceManager.this.mainThreadExecutor.execute(() -> {
+                            DistanceManager.this.removeTicket(chunkPos, ticket);
+                        });
+                    }, chunkPos, true));
                 }
             }
+
         }
 
         @Override
         public void runAllUpdates() {
             super.runAllUpdates();
             if (!this.toUpdate.isEmpty()) {
-                LongIterator longIterator = this.toUpdate.iterator();
+                LongIterator longiterator = this.toUpdate.iterator();
 
-                while (longIterator.hasNext()) {
-                    long l = longIterator.nextLong();
-                    int i = this.queueLevels.get(l);
-                    int level = this.getLevel(l);
-                    if (i != level) {
-                        DistanceManager.this.ticketThrottler.onLevelChange(new ChunkPos(l), () -> this.queueLevels.get(l), level, i1 -> {
-                            if (i1 >= this.queueLevels.defaultReturnValue()) {
-                                this.queueLevels.remove(l);
+                while (longiterator.hasNext()) {
+                    long i = longiterator.nextLong();
+                    int j = this.queueLevels.get(i);
+                    int k = this.getLevel(i);
+
+                    if (j != k) {
+                        DistanceManager.this.ticketThrottler.onLevelChange(new ChunkPos(i), () -> {
+                            return this.queueLevels.get(i);
+                        }, k, (l) -> {
+                            if (l >= this.queueLevels.defaultReturnValue()) {
+                                this.queueLevels.remove(i);
                             } else {
-                                this.queueLevels.put(l, i1);
+                                this.queueLevels.put(i, l);
                             }
+
                         });
-                        this.onLevelChange(l, level, this.haveTicketFor(i), this.haveTicketFor(level));
+                        this.onLevelChange(i, k, this.haveTicketFor(j), this.haveTicketFor(k));
                     }
                 }
 
                 this.toUpdate.clear();
             }
+
         }
 
         private boolean haveTicketFor(int level) {
