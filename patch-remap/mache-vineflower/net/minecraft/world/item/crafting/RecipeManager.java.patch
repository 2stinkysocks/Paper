--- a/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/net/minecraft/world/item/crafting/RecipeManager.java
@@ -1,8 +1,8 @@
 package net.minecraft.world.item.crafting;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
 import com.google.common.collect.ImmutableMap.Builder;
+import com.google.common.collect.Maps;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonElement;
@@ -14,83 +14,122 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.NonNullList;
+import net.minecraft.world.Container;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.Level;
+import org.slf4j.Logger;
+
+// CraftBukkit start
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
+import net.minecraft.core.registries.BuiltInRegistries;
+// CraftBukkit end
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
 import net.minecraft.util.GsonHelper;
 import net.minecraft.util.profiling.ProfilerFiller;
-import net.minecraft.world.Container;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.level.Level;
-import org.slf4j.Logger;
 
 public class RecipeManager extends SimpleJsonResourceReloadListener {
-    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();
+
+    private static final Gson GSON = (new GsonBuilder()).setPrettyPrinting().disableHtmlEscaping().create();
     private static final Logger LOGGER = LogUtils.getLogger();
-    private Map<RecipeType<?>, Map<ResourceLocation, RecipeHolder<?>>> recipes = ImmutableMap.of();
+    public Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>>> recipes = ImmutableMap.of(); // CraftBukkit
     private Map<ResourceLocation, RecipeHolder<?>> byName = ImmutableMap.of();
     private boolean hasErrors;
 
     public RecipeManager() {
-        super(GSON, "recipes");
+        super(RecipeManager.GSON, "recipes");
     }
 
-    @Override
     protected void apply(Map<ResourceLocation, JsonElement> object, ResourceManager resourceManager, ProfilerFiller profiler) {
         this.hasErrors = false;
-        Map<RecipeType<?>, Builder<ResourceLocation, RecipeHolder<?>>> map = Maps.newHashMap();
+        // CraftBukkit start - SPIGOT-5667 make sure all types are populated and mutable
+        Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>>> map1 = Maps.newHashMap();
+        for (RecipeType<?> recipeType : BuiltInRegistries.RECIPE_TYPE) {
+            map1.put(recipeType, new Object2ObjectLinkedOpenHashMap<>());
+        }
+        // CraftBukkit end
         Builder<ResourceLocation, RecipeHolder<?>> builder = ImmutableMap.builder();
+        Iterator iterator = object.entrySet().iterator();
 
-        for (Entry<ResourceLocation, JsonElement> entry : object.entrySet()) {
-            ResourceLocation resourceLocation = entry.getKey();
+        while (iterator.hasNext()) {
+            Entry<ResourceLocation, JsonElement> entry = (Entry) iterator.next();
+            ResourceLocation minecraftkey = (ResourceLocation) entry.getKey();
 
             try {
-                RecipeHolder<?> recipeHolder = fromJson(resourceLocation, GsonHelper.convertToJsonObject(entry.getValue(), "top element"));
-                map.computeIfAbsent(recipeHolder.value().getType(), type -> ImmutableMap.builder()).put(resourceLocation, recipeHolder);
-                builder.put(resourceLocation, recipeHolder);
-            } catch (IllegalArgumentException | JsonParseException var10) {
-                LOGGER.error("Parsing error loading recipe {}", resourceLocation, var10);
+                RecipeHolder<?> recipeholder = fromJson(minecraftkey, GsonHelper.convertToJsonObject((JsonElement) entry.getValue(), "top element"));
+
+                // CraftBukkit start
+                (map1.computeIfAbsent(recipeholder.value().getType(), (recipes) -> {
+                    return new Object2ObjectLinkedOpenHashMap<>();
+                    // CraftBukkit end
+                })).put(minecraftkey, recipeholder);
+                builder.put(minecraftkey, recipeholder);
+            } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
+                RecipeManager.LOGGER.error("Parsing error loading recipe {}", minecraftkey, jsonparseexception);
             }
         }
 
-        this.recipes = map.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, entry1 -> entry1.getValue().build()));
-        this.byName = builder.build();
-        LOGGER.info("Loaded {} recipes", map.size());
+        this.recipes = (Map) map1.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (entry1) -> {
+            return (entry1.getValue()); // CraftBukkit
+        }));
+        this.byName = Maps.newHashMap(builder.build()); // CraftBukkit
+        RecipeManager.LOGGER.info("Loaded {} recipes", map1.size());
     }
 
+    // CraftBukkit start
+    public void addRecipe(RecipeHolder<?> irecipe) {
+        Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> map = this.recipes.get(irecipe.value().getType()); // CraftBukkit
+
+        if (byName.containsKey(irecipe.id()) || map.containsKey(irecipe.id())) {
+            throw new IllegalStateException("Duplicate recipe ignored with ID " + irecipe.id());
+        } else {
+            map.putAndMoveToFirst(irecipe.id(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+            byName.put(irecipe.id(), irecipe);
+        }
+    }
+    // CraftBukkit end
+
     public boolean hadErrorsLoading() {
         return this.hasErrors;
     }
 
     public <C extends Container, T extends Recipe<C>> Optional<RecipeHolder<T>> getRecipeFor(RecipeType<T> recipeType, C inventory, Level level) {
-        return this.byType(recipeType).values().stream().filter(recipeHolder -> recipeHolder.value().matches(inventory, level)).findFirst();
+        // CraftBukkit start
+        Optional<RecipeHolder<T>> recipe = this.byType(recipeType).values().stream().filter((recipeholder) -> {
+            return recipeholder.value().matches(inventory, level);
+        }).findFirst();
+        inventory.setCurrentRecipe(recipe.orElse(null)); // CraftBukkit - Clear recipe when no recipe is found
+        return recipe;
+        // CraftBukkit end
     }
 
-    public <C extends Container, T extends Recipe<C>> Optional<Pair<ResourceLocation, RecipeHolder<T>>> getRecipeFor(
-        RecipeType<T> recipeType, C inventory, Level level, @Nullable ResourceLocation lastRecipe
-    ) {
+    public <C extends Container, T extends Recipe<C>> Optional<Pair<ResourceLocation, RecipeHolder<T>>> getRecipeFor(RecipeType<T> recipeType, C inventory, Level level, @Nullable ResourceLocation lastRecipe) {
         Map<ResourceLocation, RecipeHolder<T>> map = this.byType(recipeType);
+
         if (lastRecipe != null) {
-            RecipeHolder<T> recipeHolder = map.get(lastRecipe);
-            if (recipeHolder != null && recipeHolder.value().matches(inventory, level)) {
-                return Optional.of(Pair.of(lastRecipe, recipeHolder));
+            RecipeHolder<T> recipeholder = (RecipeHolder) map.get(lastRecipe);
+
+            if (recipeholder != null && recipeholder.value().matches(inventory, level)) {
+                return Optional.of(Pair.of(lastRecipe, recipeholder));
             }
         }
 
-        return map.entrySet()
-            .stream()
-            .filter(entry -> entry.getValue().value().matches(inventory, level))
-            .findFirst()
-            .map(entry -> Pair.of(entry.getKey(), entry.getValue()));
+        return map.entrySet().stream().filter((entry) -> {
+            return ((RecipeHolder) entry.getValue()).value().matches(inventory, level);
+        }).findFirst().map((entry) -> {
+            return Pair.of((ResourceLocation) entry.getKey(), (RecipeHolder) entry.getValue());
+        });
     }
 
     public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getAllRecipesFor(RecipeType<T> recipeType) {
@@ -98,67 +137,96 @@
     }
 
     public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getRecipesFor(RecipeType<T> recipeType, C inventory, Level level) {
-        return this.byType(recipeType)
-            .values()
-            .stream()
-            .filter(recipeHolder -> recipeHolder.value().matches(inventory, level))
-            .sorted(Comparator.comparing(recipeHolder -> recipeHolder.value().getResultItem(level.registryAccess()).getDescriptionId()))
-            .collect(Collectors.toList());
+        return (List) this.byType(recipeType).values().stream().filter((recipeholder) -> {
+            return recipeholder.value().matches(inventory, level);
+        }).sorted(Comparator.comparing((recipeholder) -> {
+            return recipeholder.value().getResultItem(level.registryAccess()).getDescriptionId();
+        })).collect(Collectors.toList());
     }
 
     private <C extends Container, T extends Recipe<C>> Map<ResourceLocation, RecipeHolder<T>> byType(RecipeType<T> recipeType) {
-        return (Map<ResourceLocation, RecipeHolder<T>>) ((Map<ResourceLocation, ?>) this.recipes.getOrDefault(recipeType, Collections.emptyMap()));
+        return (Map) this.recipes.getOrDefault(recipeType, new Object2ObjectLinkedOpenHashMap<>()); // CraftBukkit
     }
 
     public <C extends Container, T extends Recipe<C>> NonNullList<ItemStack> getRemainingItemsFor(RecipeType<T> recipeType, C inventory, Level level) {
-        Optional<RecipeHolder<T>> recipeFor = this.getRecipeFor(recipeType, inventory, level);
-        if (recipeFor.isPresent()) {
-            return recipeFor.get().value().getRemainingItems(inventory);
+        Optional<RecipeHolder<T>> optional = this.getRecipeFor(recipeType, inventory, level);
+
+        if (optional.isPresent()) {
+            return ((RecipeHolder) optional.get()).value().getRemainingItems(inventory);
         } else {
-            NonNullList<ItemStack> list = NonNullList.withSize(inventory.getContainerSize(), ItemStack.EMPTY);
+            NonNullList<ItemStack> nonnulllist = NonNullList.withSize(inventory.getContainerSize(), ItemStack.EMPTY);
 
-            for (int i = 0; i < list.size(); i++) {
-                list.set(i, inventory.getItem(i));
+            for (int i = 0; i < nonnulllist.size(); ++i) {
+                nonnulllist.set(i, inventory.getItem(i));
             }
 
-            return list;
+            return nonnulllist;
         }
     }
 
     public Optional<RecipeHolder<?>> byKey(ResourceLocation recipeId) {
-        return Optional.ofNullable(this.byName.get(recipeId));
+        return Optional.ofNullable((RecipeHolder) this.byName.get(recipeId));
     }
 
     public Collection<RecipeHolder<?>> getRecipes() {
-        return this.recipes.values().stream().flatMap(map -> map.values().stream()).collect(Collectors.toSet());
+        return (Collection) this.recipes.values().stream().flatMap((map) -> {
+            return map.values().stream();
+        }).collect(Collectors.toSet());
     }
 
     public Stream<ResourceLocation> getRecipeIds() {
-        return this.recipes.values().stream().flatMap(map -> map.keySet().stream());
+        return this.recipes.values().stream().flatMap((map) -> {
+            return map.keySet().stream();
+        });
     }
 
-    protected static RecipeHolder<?> fromJson(ResourceLocation resourceLocation, JsonObject jsonObject) {
-        Recipe<?> recipe = Util.getOrThrow(Recipe.CODEC.parse(JsonOps.INSTANCE, jsonObject), JsonParseException::new);
-        return new RecipeHolder<>(resourceLocation, recipe);
+    protected static RecipeHolder<?> fromJson(ResourceLocation minecraftkey, JsonObject jsonobject) {
+        Recipe<?> irecipe = (Recipe) Util.getOrThrow(Recipe.CODEC.parse(JsonOps.INSTANCE, jsonobject), JsonParseException::new);
+
+        return new RecipeHolder<>(minecraftkey, irecipe);
     }
 
     public void replaceRecipes(Iterable<RecipeHolder<?>> recipes) {
         this.hasErrors = false;
-        Map<RecipeType<?>, Map<ResourceLocation, RecipeHolder<?>>> map = Maps.newHashMap();
+        Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>>> map = Maps.newHashMap(); // CraftBukkit
         Builder<ResourceLocation, RecipeHolder<?>> builder = ImmutableMap.builder();
-        recipes.forEach(recipeHolder -> {
-            Map<ResourceLocation, RecipeHolder<?>> map1 = map.computeIfAbsent(recipeHolder.value().getType(), recipeType -> Maps.newHashMap());
-            ResourceLocation resourceLocation = recipeHolder.id();
-            RecipeHolder<?> recipeHolder1 = map1.put(resourceLocation, (RecipeHolder<?>)recipeHolder);
-            builder.put(resourceLocation, (RecipeHolder<?>)recipeHolder);
-            if (recipeHolder1 != null) {
-                throw new IllegalStateException("Duplicate recipe ignored with ID " + resourceLocation);
+
+        recipes.forEach((recipeholder) -> {
+            Map<ResourceLocation, RecipeHolder<?>> map1 = (Map) map.computeIfAbsent(recipeholder.value().getType(), (recipes) -> {
+                return new Object2ObjectLinkedOpenHashMap<>(); // CraftBukkit
+            });
+            ResourceLocation minecraftkey = recipeholder.id();
+            RecipeHolder<?> recipeholder1 = (RecipeHolder) map1.put(minecraftkey, recipeholder);
+
+            builder.put(minecraftkey, recipeholder);
+            if (recipeholder1 != null) {
+                throw new IllegalStateException("Duplicate recipe ignored with ID " + minecraftkey);
             }
         });
         this.recipes = ImmutableMap.copyOf(map);
-        this.byName = builder.build();
+        this.byName = Maps.newHashMap(builder.build()); // CraftBukkit
     }
 
+    // CraftBukkit start
+    public boolean removeRecipe(ResourceLocation mcKey) {
+        for (Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> recipes : recipes.values()) {
+            recipes.remove(mcKey);
+        }
+
+        return byName.remove(mcKey) != null;
+    }
+
+    public void clearRecipes() {
+        this.recipes = Maps.newHashMap();
+
+        for (RecipeType<?> recipeType : BuiltInRegistries.RECIPE_TYPE) {
+            this.recipes.put(recipeType, new Object2ObjectLinkedOpenHashMap<>());
+        }
+
+        this.byName = Maps.newHashMap();
+    }
+    // CraftBukkit end
+
     public static <C extends Container, T extends Recipe<C>> RecipeManager.CachedCheck<C, T> createCheck(final RecipeType<T> recipeType) {
         return new RecipeManager.CachedCheck<C, T>() {
             @Nullable
@@ -166,12 +234,14 @@
 
             @Override
             public Optional<RecipeHolder<T>> getRecipeFor(C container, Level level) {
-                RecipeManager recipeManager = level.getRecipeManager();
-                Optional<Pair<ResourceLocation, RecipeHolder<T>>> recipeFor = recipeManager.getRecipeFor(recipeType, container, level, this.lastRecipe);
-                if (recipeFor.isPresent()) {
-                    Pair<ResourceLocation, RecipeHolder<T>> pair = recipeFor.get();
-                    this.lastRecipe = pair.getFirst();
-                    return Optional.of(pair.getSecond());
+                RecipeManager craftingmanager = level.getRecipeManager();
+                Optional<Pair<ResourceLocation, RecipeHolder<T>>> optional = craftingmanager.getRecipeFor(recipeType, container, level, this.lastRecipe);
+
+                if (optional.isPresent()) {
+                    Pair<ResourceLocation, RecipeHolder<T>> pair = (Pair) optional.get();
+
+                    this.lastRecipe = (ResourceLocation) pair.getFirst();
+                    return Optional.of((RecipeHolder) pair.getSecond());
                 } else {
                     return Optional.empty();
                 }
@@ -180,6 +250,7 @@
     }
 
     public interface CachedCheck<C extends Container, T extends Recipe<C>> {
+
         Optional<RecipeHolder<T>> getRecipeFor(C container, Level level);
     }
 }
