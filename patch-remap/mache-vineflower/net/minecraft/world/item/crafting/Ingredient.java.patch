--- a/net/minecraft/world/item/crafting/Ingredient.java
+++ b/net/minecraft/world/item/crafting/Ingredient.java
@@ -5,13 +5,13 @@
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntComparators;
 import it.unimi.dsi.fastutil.ints.IntList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
@@ -25,43 +25,64 @@
 import net.minecraft.world.entity.player.StackedContents;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.IMaterial;
 
 public final class Ingredient implements Predicate<ItemStack> {
+
     public static final Ingredient EMPTY = new Ingredient(Stream.empty());
-    private final Ingredient.Value[] values;
+    private final Ingredient.Provider[] values;
     @Nullable
-    private ItemStack[] itemStacks;
+    public ItemStack[] itemStacks;
     @Nullable
     private IntList stackingIds;
+    public boolean exact; // CraftBukkit
     public static final Codec<Ingredient> CODEC = codec(true);
     public static final Codec<Ingredient> CODEC_NONEMPTY = codec(false);
 
-    private Ingredient(Stream<? extends Ingredient.Value> values) {
-        this.values = values.toArray(Ingredient.Value[]::new);
+    public Ingredient(Stream<? extends Ingredient.Provider> values) {
+        this.values = (Ingredient.Provider[]) values.toArray((i) -> {
+            return new Ingredient.Provider[i];
+        });
     }
 
-    private Ingredient(Ingredient.Value[] values) {
-        this.values = values;
+    private Ingredient(Ingredient.Provider[] arecipeitemstack_provider) {
+        this.values = arecipeitemstack_provider;
     }
 
     public ItemStack[] getItems() {
         if (this.itemStacks == null) {
-            this.itemStacks = Arrays.stream(this.values).flatMap(value -> value.getItems().stream()).distinct().toArray(ItemStack[]::new);
+            this.itemStacks = (ItemStack[]) Arrays.stream(this.values).flatMap((recipeitemstack_provider) -> {
+                return recipeitemstack_provider.getItems().stream();
+            }).distinct().toArray((i) -> {
+                return new ItemStack[i];
+            });
         }
 
         return this.itemStacks;
     }
 
-    @Override
     public boolean test(@Nullable ItemStack stack) {
         if (stack == null) {
             return false;
         } else if (this.isEmpty()) {
             return stack.isEmpty();
         } else {
-            for (ItemStack itemStack : this.getItems()) {
-                if (itemStack.is(stack.getItem())) {
+            ItemStack[] aitemstack = this.getItems();
+            int i = aitemstack.length;
+
+            for (int j = 0; j < i; ++j) {
+                ItemStack itemstack1 = aitemstack[j];
+
+                // CraftBukkit start
+                if (exact) {
+                    if (itemstack1.getItem() == stack.getItem() && ItemStack.isSameItemSameTags(stack, itemstack1)) {
+                        return true;
+                    }
+
+                    continue;
+                }
+                // CraftBukkit end
+                if (itemstack1.is(stack.getItem())) {
                     return true;
                 }
             }
@@ -72,11 +93,16 @@
 
     public IntList getStackingIds() {
         if (this.stackingIds == null) {
-            ItemStack[] items = this.getItems();
-            this.stackingIds = new IntArrayList(items.length);
+            ItemStack[] aitemstack = this.getItems();
 
-            for (ItemStack itemStack : items) {
-                this.stackingIds.add(StackedContents.getStackingIndex(itemStack));
+            this.stackingIds = new IntArrayList(aitemstack.length);
+            ItemStack[] aitemstack1 = aitemstack;
+            int i = aitemstack.length;
+
+            for (int j = 0; j < i; ++j) {
+                ItemStack itemstack = aitemstack1[j];
+
+                this.stackingIds.add(StackedContents.getStackingIndex(itemstack));
             }
 
             this.stackingIds.sort(IntComparators.NATURAL_COMPARATOR);
@@ -93,21 +119,27 @@
         return this.values.length == 0;
     }
 
-    @Override
     public boolean equals(Object object) {
-        return object instanceof Ingredient ingredient && Arrays.equals((Object[])this.values, (Object[])ingredient.values);
+        if (object instanceof Ingredient) {
+            Ingredient recipeitemstack = (Ingredient) object;
+
+            return Arrays.equals(this.values, recipeitemstack.values);
+        } else {
+            return false;
+        }
     }
 
-    private static Ingredient fromValues(Stream<? extends Ingredient.Value> stream) {
-        Ingredient ingredient = new Ingredient(stream);
-        return ingredient.isEmpty() ? EMPTY : ingredient;
+    private static Ingredient fromValues(Stream<? extends Ingredient.Provider> stream) {
+        Ingredient recipeitemstack = new Ingredient(stream);
+
+        return recipeitemstack.isEmpty() ? Ingredient.EMPTY : recipeitemstack;
     }
 
     public static Ingredient of() {
-        return EMPTY;
+        return Ingredient.EMPTY;
     }
 
-    public static Ingredient of(ItemLike... items) {
+    public static Ingredient of(IMaterial... items) {
         return of(Arrays.stream(items).map(ItemStack::new));
     }
 
@@ -116,7 +148,9 @@
     }
 
     public static Ingredient of(Stream<ItemStack> stacks) {
-        return fromValues(stacks.filter(stack -> !stack.isEmpty()).map(Ingredient.ItemValue::new));
+        return fromValues(stacks.filter((itemstack) -> {
+            return !itemstack.isEmpty();
+        }).map(Ingredient.ItemValue::new));
     }
 
     public static Ingredient of(TagKey<Item> tag) {
@@ -124,67 +158,78 @@
     }
 
     public static Ingredient fromNetwork(FriendlyByteBuf buffer) {
-        return fromValues(buffer.<ItemStack>readList(FriendlyByteBuf::readItem).stream().map(Ingredient.ItemValue::new));
+        return fromValues(buffer.readList(FriendlyByteBuf::readItem).stream().map(Ingredient.ItemValue::new));
     }
 
     private static Codec<Ingredient> codec(boolean flag) {
-        Codec<Ingredient.Value[]> codec = Codec.list(Ingredient.Value.CODEC)
-            .comapFlatMap(
-                list -> !flag && list.size() < 1
-                        ? DataResult.error(() -> "Item array cannot be empty, at least one item must be defined")
-                        : DataResult.success(list.toArray(new Ingredient.Value[0])),
-                List::of
-            );
-        return ExtraCodecs.either(codec, Ingredient.Value.CODEC)
-            .flatComapMap(
-                either -> either.map(Ingredient::new, value -> new Ingredient(new Ingredient.Value[]{value})),
-                ingredient -> {
-                    if (ingredient.values.length == 1) {
-                        return DataResult.success(Either.right(ingredient.values[0]));
-                    } else {
-                        return ingredient.values.length == 0 && !flag
-                            ? DataResult.error(() -> "Item array cannot be empty, at least one item must be defined")
-                            : DataResult.success(Either.left(ingredient.values));
-                    }
-                }
-            );
+        Codec<Ingredient.Provider[]> codec = Codec.list(Ingredient.Provider.CODEC).comapFlatMap((list) -> {
+            return !flag && list.size() < 1 ? DataResult.error(() -> {
+                return "Item array cannot be empty, at least one item must be defined";
+            }) : DataResult.success((Ingredient.Provider[]) list.toArray(new Ingredient.Provider[0]));
+        }, List::of);
+
+        return ExtraCodecs.either(codec, Ingredient.Provider.CODEC).flatComapMap((either) -> {
+            return (Ingredient) either.map(Ingredient::new, (recipeitemstack_provider) -> {
+                return new Ingredient(new Ingredient.Provider[]{recipeitemstack_provider});
+            });
+        }, (recipeitemstack) -> {
+            return recipeitemstack.values.length == 1 ? DataResult.success(Either.right(recipeitemstack.values[0])) : (recipeitemstack.values.length == 0 && !flag ? DataResult.error(() -> {
+                return "Item array cannot be empty, at least one item must be defined";
+            }) : DataResult.success(Either.left(recipeitemstack.values)));
+        });
     }
 
-    static record ItemValue(ItemStack item) implements Ingredient.Value {
-        static final Codec<Ingredient.ItemValue> CODEC = RecordCodecBuilder.create(
-            instance -> instance.group(ItemStack.SINGLE_ITEM_CODEC.fieldOf("item").forGetter(itemValue -> itemValue.item))
-                    .apply(instance, Ingredient.ItemValue::new)
-        );
+    public interface Provider {
 
-        @Override
-        public boolean equals(Object object) {
-            return object instanceof Ingredient.ItemValue itemValue
-                && itemValue.item.getItem().equals(this.item.getItem())
-                && itemValue.item.getCount() == this.item.getCount();
-        }
+        Codec<Ingredient.Provider> CODEC = ExtraCodecs.xor(Ingredient.ItemValue.CODEC, Ingredient.TagValue.CODEC).xmap((either) -> {
+            return (Ingredient.Provider) either.map((recipeitemstack_stackprovider) -> {
+                return recipeitemstack_stackprovider;
+            }, (recipeitemstack_b) -> {
+                return recipeitemstack_b;
+            });
+        }, (recipeitemstack_provider) -> {
+            if (recipeitemstack_provider instanceof Ingredient.TagValue) {
+                Ingredient.TagValue recipeitemstack_b = (Ingredient.TagValue) recipeitemstack_provider;
 
-        @Override
-        public Collection<ItemStack> getItems() {
-            return Collections.singleton(this.item);
-        }
+                return Either.right(recipeitemstack_b);
+            } else if (recipeitemstack_provider instanceof Ingredient.ItemValue) {
+                Ingredient.ItemValue recipeitemstack_stackprovider = (Ingredient.ItemValue) recipeitemstack_provider;
+
+                return Either.left(recipeitemstack_stackprovider);
+            } else {
+                throw new UnsupportedOperationException("This is neither an item value nor a tag value.");
+            }
+        });
+
+        Collection<ItemStack> getItems();
     }
 
-    static record TagValue(TagKey<Item> tag) implements Ingredient.Value {
-        static final Codec<Ingredient.TagValue> CODEC = RecordCodecBuilder.create(
-            instance -> instance.group(TagKey.codec(Registries.ITEM).fieldOf("tag").forGetter(tagValue -> tagValue.tag))
-                    .apply(instance, Ingredient.TagValue::new)
-        );
+    private static record TagValue(TagKey<Item> tag) implements Ingredient.Provider {
 
-        @Override
+        static final Codec<Ingredient.TagValue> CODEC = RecordCodecBuilder.create((instance) -> {
+            return instance.group(TagKey.codec(Registries.ITEM).fieldOf("tag").forGetter((recipeitemstack_b) -> {
+                return recipeitemstack_b.tag;
+            })).apply(instance, Ingredient.TagValue::new);
+        });
+
         public boolean equals(Object object) {
-            return object instanceof Ingredient.TagValue tagValue && tagValue.tag.location().equals(this.tag.location());
+            if (object instanceof Ingredient.TagValue) {
+                Ingredient.TagValue recipeitemstack_b = (Ingredient.TagValue) object;
+
+                return recipeitemstack_b.tag.location().equals(this.tag.location());
+            } else {
+                return false;
+            }
         }
 
         @Override
         public Collection<ItemStack> getItems() {
             List<ItemStack> list = Lists.newArrayList();
+            Iterator iterator = BuiltInRegistries.ITEM.getTagOrEmpty(this.tag).iterator();
 
-            for (Holder<Item> holder : BuiltInRegistries.ITEM.getTagOrEmpty(this.tag)) {
+            while (iterator.hasNext()) {
+                Holder<Item> holder = (Holder) iterator.next();
+
                 list.add(new ItemStack(holder));
             }
 
@@ -192,18 +237,27 @@
         }
     }
 
-    interface Value {
-        Codec<Ingredient.Value> CODEC = ExtraCodecs.xor(Ingredient.ItemValue.CODEC, Ingredient.TagValue.CODEC)
-            .xmap(either -> either.map(itemValue -> itemValue, tagValue -> tagValue), value -> {
-                if (value instanceof Ingredient.TagValue tagValue) {
-                    return Either.right(tagValue);
-                } else if (value instanceof Ingredient.ItemValue itemValue) {
-                    return Either.left(itemValue);
-                } else {
-                    throw new UnsupportedOperationException("This is neither an item value nor a tag value.");
-                }
-            });
+    public static record ItemValue(ItemStack item) implements Ingredient.Provider {
 
-        Collection<ItemStack> getItems();
+        static final Codec<Ingredient.ItemValue> CODEC = RecordCodecBuilder.create((instance) -> {
+            return instance.group(ItemStack.SINGLE_ITEM_CODEC.fieldOf("item").forGetter((recipeitemstack_stackprovider) -> {
+                return recipeitemstack_stackprovider.item;
+            })).apply(instance, Ingredient.ItemValue::new);
+        });
+
+        public boolean equals(Object object) {
+            if (!(object instanceof Ingredient.ItemValue)) {
+                return false;
+            } else {
+                Ingredient.ItemValue recipeitemstack_stackprovider = (Ingredient.ItemValue) object;
+
+                return recipeitemstack_stackprovider.item.getItem().equals(this.item.getItem()) && recipeitemstack_stackprovider.item.getCount() == this.item.getCount();
+            }
+        }
+
+        @Override
+        public Collection<ItemStack> getItems() {
+            return Collections.singleton(this.item);
+        }
     }
 }
