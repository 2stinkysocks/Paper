--- a/net/minecraft/world/entity/monster/Slime.java
+++ b/net/minecraft/world/entity/monster/Slime.java
@@ -23,12 +23,12 @@
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityPose;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.GroupDataEntity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.Pose;
-import net.minecraft.world.entity.SpawnGroupData;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.control.MoveControl;
 import net.minecraft.world.entity.ai.goal.Goal;
@@ -44,7 +44,16 @@
 import net.minecraft.world.phys.Vec3;
 import org.joml.Vector3f;
 
-public class Slime extends Mob implements Enemy {
+// CraftBukkit start
+import java.util.ArrayList;
+import java.util.List;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.EntityTransformEvent;
+import org.bukkit.event.entity.SlimeSplitEvent;
+// CraftBukkit end
+
+public class Slime extends Mob implements IMonster {
+
     private static final EntityDataAccessor<Integer> ID_SIZE = SynchedEntityData.defineId(Slime.class, EntityDataSerializers.INT);
     public static final int MIN_SIZE = 1;
     public static final int MAX_SIZE = 127;
@@ -65,10 +74,9 @@
         this.goalSelector.addGoal(2, new Slime.SlimeAttackGoal(this));
         this.goalSelector.addGoal(3, new Slime.SlimeRandomDirectionGoal(this));
         this.goalSelector.addGoal(5, new Slime.SlimeKeepOnJumpingGoal(this));
-        this.targetSelector
-            .addGoal(
-                1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, livingEntity -> Math.abs(livingEntity.getY() - this.getY()) <= 4.0)
-            );
+        this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entityliving) -> {
+            return Math.abs(entityliving.getY() - this.getY()) <= 4.0D;
+        }));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
     }
 
@@ -80,27 +88,28 @@
     @Override
     protected void defineSynchedData() {
         super.defineSynchedData();
-        this.entityData.define(ID_SIZE, 1);
+        this.entityData.define(Slime.ID_SIZE, 1);
     }
 
     @VisibleForTesting
     public void setSize(int size, boolean resetHealth) {
-        int i = Mth.clamp(size, 1, 127);
-        this.entityData.set(ID_SIZE, i);
+        int j = Mth.clamp(size, 1, 127);
+
+        this.entityData.set(Slime.ID_SIZE, j);
         this.reapplyPosition();
         this.refreshDimensions();
-        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue((double)(i * i));
-        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue((double)(0.2F + 0.1F * (float)i));
-        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue((double)i);
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue((double) (j * j));
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue((double) (0.2F + 0.1F * (float) j));
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue((double) j);
         if (resetHealth) {
             this.setHealth(this.getMaxHealth());
         }
 
-        this.xpReward = i;
+        this.xpReward = j;
     }
 
     public int getSize() {
-        return this.entityData.get(ID_SIZE);
+        return (Integer) this.entityData.get(Slime.ID_SIZE);
     }
 
     @Override
@@ -132,18 +141,19 @@
 
     @Override
     public void tick() {
-        this.squish = this.squish + (this.targetSquish - this.squish) * 0.5F;
+        this.squish += (this.targetSquish - this.squish) * 0.5F;
         this.oSquish = this.squish;
         super.tick();
         if (this.onGround() && !this.wasOnGround) {
-            int size = this.getSize();
+            int i = this.getSize();
 
-            for (int i = 0; i < size * 8; i++) {
-                float f = this.random.nextFloat() * (float) (Math.PI * 2);
+            for (int j = 0; j < i * 8; ++j) {
+                float f = this.random.nextFloat() * 6.2831855F;
                 float f1 = this.random.nextFloat() * 0.5F + 0.5F;
-                float f2 = Mth.sin(f) * (float)size * 0.5F * f1;
-                float f3 = Mth.cos(f) * (float)size * 0.5F * f1;
-                this.level().addParticle(this.getParticleType(), this.getX() + (double)f2, this.getY(), this.getZ() + (double)f3, 0.0, 0.0, 0.0);
+                float f2 = Mth.sin(f) * (float) i * 0.5F * f1;
+                float f3 = Mth.cos(f) * (float) i * 0.5F * f1;
+
+                this.level().addParticle(this.getParticleType(), this.getX() + (double) f2, this.getY(), this.getZ() + (double) f3, 0.0D, 0.0D, 0.0D);
             }
 
             this.playSound(this.getSquishSound(), this.getSoundVolume(), ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F) / 0.8F);
@@ -166,16 +176,17 @@
 
     @Override
     public void refreshDimensions() {
-        double x = this.getX();
-        double y = this.getY();
-        double z = this.getZ();
+        double d0 = this.getX();
+        double d1 = this.getY();
+        double d2 = this.getZ();
+
         super.refreshDimensions();
-        this.setPos(x, y, z);
+        this.setPos(d0, d1, d2);
     }
 
     @Override
     public void onSyncedDataUpdated(EntityDataAccessor<?> key) {
-        if (ID_SIZE.equals(key)) {
+        if (Slime.ID_SIZE.equals(key)) {
             this.refreshDimensions();
             this.setYRot(this.yHeadRot);
             this.yBodyRot = this.yHeadRot;
@@ -189,36 +200,60 @@
 
     @Override
     public EntityType<? extends Slime> getType() {
-        return (EntityType<? extends Slime>)super.getType();
+        return (EntityType<? extends Slime>) super.getType(); // CraftBukkit - decompile error
     }
 
     @Override
     public void remove(Entity.RemovalReason reason) {
-        int size = this.getSize();
-        if (!this.level().isClientSide && size > 1 && this.isDeadOrDying()) {
-            Component customName = this.getCustomName();
-            boolean isNoAi = this.isNoAi();
-            float f = (float)size / 4.0F;
-            int i = size / 2;
-            int i1 = 2 + this.random.nextInt(3);
+        int i = this.getSize();
 
-            for (int i2 = 0; i2 < i1; i2++) {
-                float f1 = ((float)(i2 % 2) - 0.5F) * f;
-                float f2 = ((float)(i2 / 2) - 0.5F) * f;
-                Slime slime = this.getType().create(this.level());
-                if (slime != null) {
+        if (!this.level().isClientSide && i > 1 && this.isDeadOrDying()) {
+            Component ichatbasecomponent = this.getCustomName();
+            boolean flag = this.isNoAi();
+            float f = (float) i / 4.0F;
+            int j = i / 2;
+            int k = 2 + this.random.nextInt(3);
+
+            // CraftBukkit start
+            SlimeSplitEvent event = new SlimeSplitEvent((org.bukkit.entity.Slime) this.getBukkitEntity(), k);
+            this.level().getCraftServer().getPluginManager().callEvent(event);
+
+            if (!event.isCancelled() && event.getCount() > 0) {
+                k = event.getCount();
+            } else {
+                super.remove(reason);
+                return;
+            }
+            List<LivingEntity> slimes = new ArrayList<>(j);
+            // CraftBukkit end
+
+            for (int l = 0; l < k; ++l) {
+                float f1 = ((float) (l % 2) - 0.5F) * f;
+                float f2 = ((float) (l / 2) - 0.5F) * f;
+                Slime entityslime = (Slime) this.getType().create(this.level());
+
+                if (entityslime != null) {
                     if (this.isPersistenceRequired()) {
-                        slime.setPersistenceRequired();
+                        entityslime.setPersistenceRequired();
                     }
 
-                    slime.setCustomName(customName);
-                    slime.setNoAi(isNoAi);
-                    slime.setInvulnerable(this.isInvulnerable());
-                    slime.setSize(i, true);
-                    slime.moveTo(this.getX() + (double)f1, this.getY() + 0.5, this.getZ() + (double)f2, this.random.nextFloat() * 360.0F, 0.0F);
-                    this.level().addFreshEntity(slime);
+                    entityslime.setCustomName(ichatbasecomponent);
+                    entityslime.setNoAi(flag);
+                    entityslime.setInvulnerable(this.isInvulnerable());
+                    entityslime.setSize(j, true);
+                    entityslime.moveTo(this.getX() + (double) f1, this.getY() + 0.5D, this.getZ() + (double) f2, this.random.nextFloat() * 360.0F, 0.0F);
+                    slimes.add(entityslime); // CraftBukkit
                 }
             }
+            // CraftBukkit start
+            if (CraftEventFactory.callEntityTransformEvent(this, slimes, EntityTransformEvent.TransformReason.SPLIT).isCancelled()) {
+                super.remove(reason);
+                return;
+            }
+            for (LivingEntity living : slimes) {
+                this.level().addFreshEntity(living, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.SLIME_SPLIT); // CraftBukkit - SpawnReason
+            }
+            // CraftBukkit end
         }
 
         super.remove(reason);
@@ -228,8 +263,9 @@
     public void push(Entity entity) {
         super.push(entity);
         if (entity instanceof IronGolem && this.isDealsDamage()) {
-            this.dealDamage((LivingEntity)entity);
+            this.dealDamage((LivingEntity) entity);
         }
+
     }
 
     @Override
@@ -237,28 +273,29 @@
         if (this.isDealsDamage()) {
             this.dealDamage(entity);
         }
+
     }
 
     protected void dealDamage(LivingEntity livingEntity) {
         if (this.isAlive()) {
-            int size = this.getSize();
-            if (this.distanceToSqr(livingEntity) < 0.6 * (double)size * 0.6 * (double)size
-                && this.hasLineOfSight(livingEntity)
-                && livingEntity.hurt(this.damageSources().mobAttack(this), this.getAttackDamage())) {
+            int i = this.getSize();
+
+            if (this.distanceToSqr((Entity) livingEntity) < 0.6D * (double) i * 0.6D * (double) i && this.hasLineOfSight(livingEntity) && livingEntity.hurt(this.damageSources().mobAttack(this), this.getAttackDamage())) {
                 this.playSound(SoundEvents.SLIME_ATTACK, 1.0F, (this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F);
                 this.doEnchantDamageEffects(this, livingEntity);
             }
         }
+
     }
 
     @Override
-    protected float getStandingEyeHeight(Pose pose, EntityDimensions size) {
+    protected float getStandingEyeHeight(EntityPose pose, EntityDimensions size) {
         return 0.625F * size.height;
     }
 
     @Override
-    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entityDimensions, float f) {
-        return new Vector3f(0.0F, entityDimensions.height - 0.015625F * (float)this.getSize() * f, 0.0F);
+    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entitysize, float f) {
+        return new Vector3f(0.0F, entitysize.height - 0.015625F * (float) this.getSize() * f, 0.0F);
     }
 
     protected boolean isDealsDamage() {
@@ -266,7 +303,7 @@
     }
 
     protected float getAttackDamage() {
-        return (float)this.getAttributeValue(Attributes.ATTACK_DAMAGE);
+        return (float) this.getAttributeValue(Attributes.ATTACK_DAMAGE);
     }
 
     @Override
@@ -283,21 +320,16 @@
         return this.isTiny() ? SoundEvents.SLIME_SQUISH_SMALL : SoundEvents.SLIME_SQUISH;
     }
 
-    public static boolean checkSlimeSpawnRules(EntityType<Slime> slime, LevelAccessor level, MobSpawnType spawnType, BlockPos pos, RandomSource random) {
-        if (MobSpawnType.isSpawner(spawnType)) {
+    public static boolean checkSlimeSpawnRules(EntityType<Slime> slime, LevelAccessor level, EnumMobSpawn spawnType, BlockPos pos, RandomSource random) {
+        if (EnumMobSpawn.isSpawner(spawnType)) {
             return checkMobSpawnRules(slime, level, spawnType, pos, random);
         } else {
             if (level.getDifficulty() != Difficulty.PEACEFUL) {
-                if (spawnType == MobSpawnType.SPAWNER) {
+                if (spawnType == EnumMobSpawn.SPAWNER) {
                     return checkMobSpawnRules(slime, level, spawnType, pos, random);
                 }
 
-                if (level.getBiome(pos).is(BiomeTags.ALLOWS_SURFACE_SLIME_SPAWNS)
-                    && pos.getY() > 50
-                    && pos.getY() < 70
-                    && random.nextFloat() < 0.5F
-                    && random.nextFloat() < level.getMoonBrightness()
-                    && level.getMaxLocalRawBrightness(pos) <= random.nextInt(8)) {
+                if (level.getBiome(pos).is(BiomeTags.ALLOWS_SURFACE_SLIME_SPAWNS) && pos.getY() > 50 && pos.getY() < 70 && random.nextFloat() < 0.5F && random.nextFloat() < level.getMoonBrightness() && level.getMaxLocalRawBrightness(pos) <= random.nextInt(8)) {
                     return checkMobSpawnRules(slime, level, spawnType, pos, random);
                 }
 
@@ -305,8 +337,9 @@
                     return false;
                 }
 
-                ChunkPos chunkPos = new ChunkPos(pos);
-                boolean flag = WorldgenRandom.seedSlimeChunk(chunkPos.x, chunkPos.z, ((WorldGenLevel)level).getSeed(), 987234911L).nextInt(10) == 0;
+                ChunkPos chunkcoordintpair = new ChunkPos(pos);
+                boolean flag = WorldgenRandom.seedSlimeChunk(chunkcoordintpair.x, chunkcoordintpair.z, ((WorldGenLevel) level).getSeed(), 987234911L).nextInt(10) == 0;
+
                 if (random.nextInt(10) == 0 && flag && pos.getY() < 40) {
                     return checkMobSpawnRules(slime, level, spawnType, pos, random);
                 }
@@ -318,7 +351,7 @@
 
     @Override
     protected float getSoundVolume() {
-        return 0.4F * (float)this.getSize();
+        return 0.4F * (float) this.getSize();
     }
 
     @Override
@@ -332,29 +365,31 @@
 
     @Override
     protected void jumpFromGround() {
-        Vec3 deltaMovement = this.getDeltaMovement();
-        this.setDeltaMovement(deltaMovement.x, (double)this.getJumpPower(), deltaMovement.z);
+        Vec3 vec3d = this.getDeltaMovement();
+
+        this.setDeltaMovement(vec3d.x, (double) this.getJumpPower(), vec3d.z);
         this.hasImpulse = true;
     }
 
     @Nullable
     @Override
-    public SpawnGroupData finalizeSpawn(
-        ServerLevelAccessor level, DifficultyInstance difficulty, MobSpawnType reason, @Nullable SpawnGroupData spawnData, @Nullable CompoundTag dataTag
-    ) {
-        RandomSource random = level.getRandom();
-        int randomInt = random.nextInt(3);
-        if (randomInt < 2 && random.nextFloat() < 0.5F * difficulty.getSpecialMultiplier()) {
-            randomInt++;
+    public GroupDataEntity finalizeSpawn(ServerLevelAccessor level, DifficultyInstance difficulty, EnumMobSpawn reason, @Nullable GroupDataEntity spawnData, @Nullable CompoundTag dataTag) {
+        RandomSource randomsource = level.getRandom();
+        int i = randomsource.nextInt(3);
+
+        if (i < 2 && randomsource.nextFloat() < 0.5F * difficulty.getSpecialMultiplier()) {
+            ++i;
         }
 
-        int i = 1 << randomInt;
-        this.setSize(i, true);
+        int j = 1 << i;
+
+        this.setSize(j, true);
         return super.finalizeSpawn(level, difficulty, reason, spawnData, dataTag);
     }
 
     float getSoundPitch() {
         float f = this.isTiny() ? 1.4F : 0.8F;
+
         return ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F + 1.0F) * f;
     }
 
@@ -363,61 +398,74 @@
     }
 
     @Override
-    public EntityDimensions getDimensions(Pose pose) {
-        return super.getDimensions(pose).scale(0.255F * (float)this.getSize());
+    public EntityDimensions getDimensions(EntityPose pose) {
+        return super.getDimensions(pose).scale(0.255F * (float) this.getSize());
     }
 
-    static class SlimeAttackGoal extends Goal {
+    private static class SlimeMoveControl extends MoveControl {
+
+        private float yRot;
+        private int jumpDelay;
         private final Slime slime;
-        private int growTiredTimer;
+        private boolean isAggressive;
 
-        public SlimeAttackGoal(Slime slime) {
+        public SlimeMoveControl(Slime slime) {
+            super(slime);
             this.slime = slime;
-            this.setFlags(EnumSet.of(Goal.Flag.LOOK));
+            this.yRot = 180.0F * slime.getYRot() / 3.1415927F;
         }
 
-        @Override
-        public boolean canUse() {
-            LivingEntity target = this.slime.getTarget();
-            return target != null && this.slime.canAttack(target) && this.slime.getMoveControl() instanceof Slime.SlimeMoveControl;
+        public void setDirection(float yRot, boolean aggressive) {
+            this.yRot = yRot;
+            this.isAggressive = aggressive;
         }
 
-        @Override
-        public void start() {
-            this.growTiredTimer = reducedTickDelay(300);
-            super.start();
+        public void setWantedMovement(double speed) {
+            this.speedModifier = speed;
+            this.operation = MoveControl.Operation.MOVE_TO;
         }
 
         @Override
-        public boolean canContinueToUse() {
-            LivingEntity target = this.slime.getTarget();
-            return target != null && this.slime.canAttack(target) && --this.growTiredTimer > 0;
-        }
+        public void tick() {
+            this.mob.setYRot(this.rotlerp(this.mob.getYRot(), this.yRot, 90.0F));
+            this.mob.yHeadRot = this.mob.getYRot();
+            this.mob.yBodyRot = this.mob.getYRot();
+            if (this.operation != MoveControl.Operation.MOVE_TO) {
+                this.mob.setZza(0.0F);
+            } else {
+                this.operation = MoveControl.Operation.WAIT;
+                if (this.mob.onGround()) {
+                    this.mob.setSpeed((float) (this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
+                    if (this.jumpDelay-- <= 0) {
+                        this.jumpDelay = this.slime.getJumpDelay();
+                        if (this.isAggressive) {
+                            this.jumpDelay /= 3;
+                        }
 
-        @Override
-        public boolean requiresUpdateEveryTick() {
-            return true;
-        }
+                        this.slime.getJumpControl().jump();
+                        if (this.slime.doPlayJumpSound()) {
+                            this.slime.playSound(this.slime.getJumpSound(), this.slime.getSoundVolume(), this.slime.getSoundPitch());
+                        }
+                    } else {
+                        this.slime.xxa = 0.0F;
+                        this.slime.zza = 0.0F;
+                        this.mob.setSpeed(0.0F);
+                    }
+                } else {
+                    this.mob.setSpeed((float) (this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
+                }
 
-        @Override
-        public void tick() {
-            LivingEntity target = this.slime.getTarget();
-            if (target != null) {
-                this.slime.lookAt(target, 10.0F, 10.0F);
             }
-
-            if (this.slime.getMoveControl() instanceof Slime.SlimeMoveControl slimeMoveControl) {
-                slimeMoveControl.setDirection(this.slime.getYRot(), this.slime.isDealsDamage());
-            }
         }
     }
 
-    static class SlimeFloatGoal extends Goal {
+    private static class SlimeFloatGoal extends Goal {
+
         private final Slime slime;
 
         public SlimeFloatGoal(Slime slime) {
             this.slime = slime;
-            this.setFlags(EnumSet.of(Goal.Flag.JUMP, Goal.Flag.MOVE));
+            this.setFlags(EnumSet.of(Goal.Type.JUMP, Goal.Type.MOVE));
             slime.getNavigation().setCanFloat(true);
         }
 
@@ -437,115 +485,129 @@
                 this.slime.getJumpControl().jump();
             }
 
-            if (this.slime.getMoveControl() instanceof Slime.SlimeMoveControl slimeMoveControl) {
-                slimeMoveControl.setWantedMovement(1.2);
+            MoveControl controllermove = this.slime.getMoveControl();
+
+            if (controllermove instanceof Slime.SlimeMoveControl) {
+                Slime.SlimeMoveControl entityslime_controllermoveslime = (Slime.SlimeMoveControl) controllermove;
+
+                entityslime_controllermoveslime.setWantedMovement(1.2D);
             }
+
         }
     }
 
-    static class SlimeKeepOnJumpingGoal extends Goal {
+    private static class SlimeAttackGoal extends Goal {
+
         private final Slime slime;
+        private int growTiredTimer;
 
-        public SlimeKeepOnJumpingGoal(Slime slime) {
+        public SlimeAttackGoal(Slime slime) {
             this.slime = slime;
-            this.setFlags(EnumSet.of(Goal.Flag.JUMP, Goal.Flag.MOVE));
+            this.setFlags(EnumSet.of(Goal.Type.LOOK));
         }
 
         @Override
         public boolean canUse() {
-            return !this.slime.isPassenger();
+            LivingEntity entityliving = this.slime.getTarget();
+
+            return entityliving == null ? false : (!this.slime.canAttack(entityliving) ? false : this.slime.getMoveControl() instanceof Slime.SlimeMoveControl);
         }
 
         @Override
-        public void tick() {
-            if (this.slime.getMoveControl() instanceof Slime.SlimeMoveControl slimeMoveControl) {
-                slimeMoveControl.setWantedMovement(1.0);
-            }
+        public void start() {
+            this.growTiredTimer = reducedTickDelay(300);
+            super.start();
         }
-    }
 
-    static class SlimeMoveControl extends MoveControl {
-        private float yRot;
-        private int jumpDelay;
-        private final Slime slime;
-        private boolean isAggressive;
+        @Override
+        public boolean canContinueToUse() {
+            LivingEntity entityliving = this.slime.getTarget();
 
-        public SlimeMoveControl(Slime mob) {
-            super(mob);
-            this.slime = mob;
-            this.yRot = 180.0F * mob.getYRot() / (float) Math.PI;
+            return entityliving == null ? false : (!this.slime.canAttack(entityliving) ? false : --this.growTiredTimer > 0);
         }
 
-        public void setDirection(float yRot, boolean aggressive) {
-            this.yRot = yRot;
-            this.isAggressive = aggressive;
+        @Override
+        public boolean requiresUpdateEveryTick() {
+            return true;
         }
 
-        public void setWantedMovement(double speed) {
-            this.speedModifier = speed;
-            this.operation = MoveControl.Operation.MOVE_TO;
-        }
-
         @Override
         public void tick() {
-            this.mob.setYRot(this.rotlerp(this.mob.getYRot(), this.yRot, 90.0F));
-            this.mob.yHeadRot = this.mob.getYRot();
-            this.mob.yBodyRot = this.mob.getYRot();
-            if (this.operation != MoveControl.Operation.MOVE_TO) {
-                this.mob.setZza(0.0F);
-            } else {
-                this.operation = MoveControl.Operation.WAIT;
-                if (this.mob.onGround()) {
-                    this.mob.setSpeed((float)(this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
-                    if (this.jumpDelay-- <= 0) {
-                        this.jumpDelay = this.slime.getJumpDelay();
-                        if (this.isAggressive) {
-                            this.jumpDelay /= 3;
-                        }
+            LivingEntity entityliving = this.slime.getTarget();
 
-                        this.slime.getJumpControl().jump();
-                        if (this.slime.doPlayJumpSound()) {
-                            this.slime.playSound(this.slime.getJumpSound(), this.slime.getSoundVolume(), this.slime.getSoundPitch());
-                        }
-                    } else {
-                        this.slime.xxa = 0.0F;
-                        this.slime.zza = 0.0F;
-                        this.mob.setSpeed(0.0F);
-                    }
-                } else {
-                    this.mob.setSpeed((float)(this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
-                }
+            if (entityliving != null) {
+                this.slime.lookAt(entityliving, 10.0F, 10.0F);
             }
+
+            MoveControl controllermove = this.slime.getMoveControl();
+
+            if (controllermove instanceof Slime.SlimeMoveControl) {
+                Slime.SlimeMoveControl entityslime_controllermoveslime = (Slime.SlimeMoveControl) controllermove;
+
+                entityslime_controllermoveslime.setDirection(this.slime.getYRot(), this.slime.isDealsDamage());
+            }
+
         }
     }
 
-    static class SlimeRandomDirectionGoal extends Goal {
+    private static class SlimeRandomDirectionGoal extends Goal {
+
         private final Slime slime;
         private float chosenDegrees;
         private int nextRandomizeTime;
 
         public SlimeRandomDirectionGoal(Slime slime) {
             this.slime = slime;
-            this.setFlags(EnumSet.of(Goal.Flag.LOOK));
+            this.setFlags(EnumSet.of(Goal.Type.LOOK));
         }
 
         @Override
         public boolean canUse() {
-            return this.slime.getTarget() == null
-                && (this.slime.onGround() || this.slime.isInWater() || this.slime.isInLava() || this.slime.hasEffect(MobEffects.LEVITATION))
-                && this.slime.getMoveControl() instanceof Slime.SlimeMoveControl;
+            return this.slime.getTarget() == null && (this.slime.onGround() || this.slime.isInWater() || this.slime.isInLava() || this.slime.hasEffect(MobEffects.LEVITATION)) && this.slime.getMoveControl() instanceof Slime.SlimeMoveControl;
         }
 
         @Override
         public void tick() {
             if (--this.nextRandomizeTime <= 0) {
                 this.nextRandomizeTime = this.adjustedTickDelay(40 + this.slime.getRandom().nextInt(60));
-                this.chosenDegrees = (float)this.slime.getRandom().nextInt(360);
+                this.chosenDegrees = (float) this.slime.getRandom().nextInt(360);
             }
 
-            if (this.slime.getMoveControl() instanceof Slime.SlimeMoveControl slimeMoveControl) {
-                slimeMoveControl.setDirection(this.chosenDegrees, false);
+            MoveControl controllermove = this.slime.getMoveControl();
+
+            if (controllermove instanceof Slime.SlimeMoveControl) {
+                Slime.SlimeMoveControl entityslime_controllermoveslime = (Slime.SlimeMoveControl) controllermove;
+
+                entityslime_controllermoveslime.setDirection(this.chosenDegrees, false);
             }
+
         }
     }
+
+    private static class SlimeKeepOnJumpingGoal extends Goal {
+
+        private final Slime slime;
+
+        public SlimeKeepOnJumpingGoal(Slime slime) {
+            this.slime = slime;
+            this.setFlags(EnumSet.of(Goal.Type.JUMP, Goal.Type.MOVE));
+        }
+
+        @Override
+        public boolean canUse() {
+            return !this.slime.isPassenger();
+        }
+
+        @Override
+        public void tick() {
+            MoveControl controllermove = this.slime.getMoveControl();
+
+            if (controllermove instanceof Slime.SlimeMoveControl) {
+                Slime.SlimeMoveControl entityslime_controllermoveslime = (Slime.SlimeMoveControl) controllermove;
+
+                entityslime_controllermoveslime.setWantedMovement(1.0D);
+            }
+
+        }
+    }
 }
