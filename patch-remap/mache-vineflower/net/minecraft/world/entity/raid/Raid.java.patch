--- a/net/minecraft/world/entity/raid/Raid.java
+++ b/net/minecraft/world/entity/raid/Raid.java
@@ -4,10 +4,12 @@
 import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
@@ -39,9 +41,10 @@
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMobSpawn;
 import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.GroupDataEntity;
 import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.entity.SpawnPlacements;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.BlockItem;
@@ -58,6 +61,7 @@
 import net.minecraft.world.phys.Vec3;
 
 public class Raid {
+
     private static final int SECTION_RADIUS_FOR_FINDING_NEW_VILLAGE_CENTER = 2;
     private static final int ATTEMPT_RAID_FARTHEST = 0;
     private static final int ATTEMPT_RAID_CLOSE = 1;
@@ -84,26 +88,29 @@
     public static final int RAID_REMOVAL_THRESHOLD_SQR = 12544;
     private final Map<Integer, Raider> groupToLeaderMap = Maps.newHashMap();
     private final Map<Integer, Set<Raider>> groupRaiderMap = Maps.newHashMap();
-    private final Set<UUID> heroesOfTheVillage = Sets.newHashSet();
-    private long ticksActive;
+    public final Set<UUID> heroesOfTheVillage = Sets.newHashSet();
+    public long ticksActive;
     private BlockPos center;
     private final ServerLevel level;
     private boolean started;
     private final int id;
-    private float totalHealth;
-    private int badOmenLevel;
+    public float totalHealth;
+    public int badOmenLevel;
     private boolean active;
     private int groupsSpawned;
-    private final ServerBossEvent raidEvent = new ServerBossEvent(RAID_NAME_COMPONENT, BossEvent.BossBarColor.RED, BossEvent.BossBarOverlay.NOTCHED_10);
+    private final ServerBossEvent raidEvent;
     private int postRaidTicks;
     private int raidCooldownTicks;
-    private final RandomSource random = RandomSource.create();
-    private final int numGroups;
+    private final RandomSource random;
+    public final int numGroups;
     private Raid.RaidStatus status;
     private int celebrationTicks;
-    private Optional<BlockPos> waveSpawnPos = Optional.empty();
+    private Optional<BlockPos> waveSpawnPos;
 
     public Raid(int id, ServerLevel level, BlockPos center) {
+        this.raidEvent = new ServerBossEvent(Raid.RAID_NAME_COMPONENT, BossEvent.BossBarColor.RED, BossEvent.BossBarOverlay.NOTCHED_10);
+        this.random = RandomSource.create();
+        this.waveSpawnPos = Optional.empty();
         this.id = id;
         this.level = level;
         this.active = true;
@@ -115,6 +122,9 @@
     }
 
     public Raid(ServerLevel level, CompoundTag compound) {
+        this.raidEvent = new ServerBossEvent(Raid.RAID_NAME_COMPONENT, BossEvent.BossBarColor.RED, BossEvent.BossBarOverlay.NOTCHED_10);
+        this.random = RandomSource.create();
+        this.waveSpawnPos = Optional.empty();
         this.level = level;
         this.id = compound.getInt("Id");
         this.started = compound.getBoolean("Started");
@@ -130,10 +140,16 @@
         this.status = Raid.RaidStatus.getByName(compound.getString("Status"));
         this.heroesOfTheVillage.clear();
         if (compound.contains("HeroesOfTheVillage", 9)) {
-            for (Tag tag : compound.getList("HeroesOfTheVillage", 11)) {
-                this.heroesOfTheVillage.add(NbtUtils.loadUUID(tag));
+            ListTag nbttaglist = compound.getList("HeroesOfTheVillage", 11);
+            Iterator iterator = nbttaglist.iterator();
+
+            while (iterator.hasNext()) {
+                Tag nbtbase = (Tag) iterator.next();
+
+                this.heroesOfTheVillage.add(NbtUtils.loadUUID(nbtbase));
             }
         }
+
     }
 
     public boolean isOver() {
@@ -160,14 +176,23 @@
         return this.status == Raid.RaidStatus.LOSS;
     }
 
+    // CraftBukkit start
+    public boolean isInProgress() {
+        return this.status == RaidStatus.ONGOING;
+    }
+    // CraftBukkit end
+
     public float getTotalHealth() {
         return this.totalHealth;
     }
 
     public Set<Raider> getAllRaiders() {
         Set<Raider> set = Sets.newHashSet();
+        Iterator iterator = this.groupRaiderMap.values().iterator();
 
-        for (Set<Raider> set1 : this.groupRaiderMap.values()) {
+        while (iterator.hasNext()) {
+            Set<Raider> set1 = (Set) iterator.next();
+
             set.addAll(set1);
         }
 
@@ -187,27 +212,36 @@
     }
 
     private Predicate<ServerPlayer> validPlayer() {
-        return player -> {
-            BlockPos blockPos = player.blockPosition();
-            return player.isAlive() && this.level.getRaidAt(blockPos) == this;
+        return (entityplayer) -> {
+            BlockPos blockposition = entityplayer.blockPosition();
+
+            return entityplayer.isAlive() && this.level.getRaidAt(blockposition) == this;
         };
     }
 
     private void updatePlayers() {
         Set<ServerPlayer> set = Sets.newHashSet(this.raidEvent.getPlayers());
-        List<ServerPlayer> players = this.level.getPlayers(this.validPlayer());
+        List<ServerPlayer> list = this.level.getPlayers(this.validPlayer());
+        Iterator iterator = list.iterator();
 
-        for (ServerPlayer serverPlayer : players) {
-            if (!set.contains(serverPlayer)) {
-                this.raidEvent.addPlayer(serverPlayer);
+        ServerPlayer entityplayer;
+
+        while (iterator.hasNext()) {
+            entityplayer = (ServerPlayer) iterator.next();
+            if (!set.contains(entityplayer)) {
+                this.raidEvent.addPlayer(entityplayer);
             }
         }
 
-        for (ServerPlayer serverPlayerx : set) {
-            if (!players.contains(serverPlayerx)) {
-                this.raidEvent.removePlayer(serverPlayerx);
+        iterator = set.iterator();
+
+        while (iterator.hasNext()) {
+            entityplayer = (ServerPlayer) iterator.next();
+            if (!list.contains(entityplayer)) {
+                this.raidEvent.removePlayer(entityplayer);
             }
         }
+
     }
 
     public int getMaxBadOmenLevel() {
@@ -224,7 +258,7 @@
 
     public void absorbBadOmen(Player player) {
         if (player.hasEffect(MobEffects.BAD_OMEN)) {
-            this.badOmenLevel = this.badOmenLevel + player.getEffect(MobEffects.BAD_OMEN).getAmplifier() + 1;
+            this.badOmenLevel += player.getEffect(MobEffects.BAD_OMEN).getAmplifier() + 1;
             this.badOmenLevel = Mth.clamp(this.badOmenLevel, 0, this.getMaxBadOmenLevel());
         }
 
@@ -241,8 +275,10 @@
         if (!this.isStopped()) {
             if (this.status == Raid.RaidStatus.ONGOING) {
                 boolean flag = this.active;
+
                 this.active = this.level.hasChunkAt(this.center);
                 if (this.level.getDifficulty() == Difficulty.PEACEFUL) {
+                    org.bukkit.craftbukkit.event.CraftEventFactory.callRaidStopEvent(this, org.bukkit.event.raid.RaidStopEvent.Reason.PEACE); // CraftBukkit
                     this.stop();
                     return;
                 }
@@ -262,121 +298,131 @@
                 if (!this.level.isVillage(this.center)) {
                     if (this.groupsSpawned > 0) {
                         this.status = Raid.RaidStatus.LOSS;
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callRaidFinishEvent(this, new java.util.ArrayList<>()); // CraftBukkit
                     } else {
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callRaidStopEvent(this, org.bukkit.event.raid.RaidStopEvent.Reason.NOT_IN_VILLAGE); // CraftBukkit
                         this.stop();
                     }
                 }
 
-                this.ticksActive++;
+                ++this.ticksActive;
                 if (this.ticksActive >= 48000L) {
+                    org.bukkit.craftbukkit.event.CraftEventFactory.callRaidStopEvent(this, org.bukkit.event.raid.RaidStopEvent.Reason.TIMEOUT); // CraftBukkit
                     this.stop();
                     return;
                 }
 
-                int totalRaidersAlive = this.getTotalRaidersAlive();
-                if (totalRaidersAlive == 0 && this.hasMoreWaves()) {
-                    if (this.raidCooldownTicks <= 0) {
-                        if (this.raidCooldownTicks == 0 && this.groupsSpawned > 0) {
-                            this.raidCooldownTicks = 300;
-                            this.raidEvent.setName(RAID_NAME_COMPONENT);
-                            return;
+                int i = this.getTotalRaidersAlive();
+                boolean flag1;
+
+                if (i == 0 && this.hasMoreWaves()) {
+                    if (this.raidCooldownTicks > 0) {
+                        flag1 = this.waveSpawnPos.isPresent();
+                        boolean flag2 = !flag1 && this.raidCooldownTicks % 5 == 0;
+
+                        if (flag1 && !this.level.isPositionEntityTicking((BlockPos) this.waveSpawnPos.get())) {
+                            flag2 = true;
                         }
-                    } else {
-                        boolean isPresent = this.waveSpawnPos.isPresent();
-                        boolean flag1 = !isPresent && this.raidCooldownTicks % 5 == 0;
-                        if (isPresent && !this.level.isPositionEntityTicking(this.waveSpawnPos.get())) {
-                            flag1 = true;
-                        }
 
-                        if (flag1) {
-                            int i = 0;
+                        if (flag2) {
+                            byte b0 = 0;
+
                             if (this.raidCooldownTicks < 100) {
-                                i = 1;
+                                b0 = 1;
                             } else if (this.raidCooldownTicks < 40) {
-                                i = 2;
+                                b0 = 2;
                             }
 
-                            this.waveSpawnPos = this.getValidSpawnPos(i);
+                            this.waveSpawnPos = this.getValidSpawnPos(b0);
                         }
 
                         if (this.raidCooldownTicks == 300 || this.raidCooldownTicks % 20 == 0) {
                             this.updatePlayers();
                         }
 
-                        this.raidCooldownTicks--;
-                        this.raidEvent.setProgress(Mth.clamp((float)(300 - this.raidCooldownTicks) / 300.0F, 0.0F, 1.0F));
+                        --this.raidCooldownTicks;
+                        this.raidEvent.setProgress(Mth.clamp((float) (300 - this.raidCooldownTicks) / 300.0F, 0.0F, 1.0F));
+                    } else if (this.raidCooldownTicks == 0 && this.groupsSpawned > 0) {
+                        this.raidCooldownTicks = 300;
+                        this.raidEvent.setName(Raid.RAID_NAME_COMPONENT);
+                        return;
                     }
                 }
 
                 if (this.ticksActive % 20L == 0L) {
                     this.updatePlayers();
                     this.updateRaiders();
-                    if (totalRaidersAlive > 0) {
-                        if (totalRaidersAlive <= 2) {
-                            this.raidEvent
-                                .setName(
-                                    RAID_NAME_COMPONENT.copy()
-                                        .append(" - ")
-                                        .append(Component.translatable("event.minecraft.raid.raiders_remaining", totalRaidersAlive))
-                                );
+                    if (i > 0) {
+                        if (i <= 2) {
+                            this.raidEvent.setName(Raid.RAID_NAME_COMPONENT.copy().append(" - ").append((Component) Component.translatable("event.minecraft.raid.raiders_remaining", i)));
                         } else {
-                            this.raidEvent.setName(RAID_NAME_COMPONENT);
+                            this.raidEvent.setName(Raid.RAID_NAME_COMPONENT);
                         }
                     } else {
-                        this.raidEvent.setName(RAID_NAME_COMPONENT);
+                        this.raidEvent.setName(Raid.RAID_NAME_COMPONENT);
                     }
                 }
 
-                boolean isPresentx = false;
-                int i1 = 0;
+                flag1 = false;
+                int j = 0;
 
                 while (this.shouldSpawnGroup()) {
-                    BlockPos blockPos = this.waveSpawnPos.isPresent() ? this.waveSpawnPos.get() : this.findRandomSpawnPos(i1, 20);
-                    if (blockPos != null) {
+                    BlockPos blockposition = this.waveSpawnPos.isPresent() ? (BlockPos) this.waveSpawnPos.get() : this.findRandomSpawnPos(j, 20);
+
+                    if (blockposition != null) {
                         this.started = true;
-                        this.spawnGroup(blockPos);
-                        if (!isPresentx) {
-                            this.playSound(blockPos);
-                            isPresentx = true;
+                        this.spawnGroup(blockposition);
+                        if (!flag1) {
+                            this.playSound(blockposition);
+                            flag1 = true;
                         }
                     } else {
-                        i1++;
+                        ++j;
                     }
 
-                    if (i1 > 3) {
+                    if (j > 3) {
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callRaidStopEvent(this, org.bukkit.event.raid.RaidStopEvent.Reason.UNSPAWNABLE);  // CraftBukkit
                         this.stop();
                         break;
                     }
                 }
 
-                if (this.isStarted() && !this.hasMoreWaves() && totalRaidersAlive == 0) {
+                if (this.isStarted() && !this.hasMoreWaves() && i == 0) {
                     if (this.postRaidTicks < 40) {
-                        this.postRaidTicks++;
+                        ++this.postRaidTicks;
                     } else {
                         this.status = Raid.RaidStatus.VICTORY;
+                        Iterator iterator = this.heroesOfTheVillage.iterator();
 
-                        for (UUID uUID : this.heroesOfTheVillage) {
-                            Entity entity = this.level.getEntity(uUID);
+                        List<org.bukkit.entity.Player> winners = new java.util.ArrayList<>(); // CraftBukkit
+                        while (iterator.hasNext()) {
+                            UUID uuid = (UUID) iterator.next();
+                            Entity entity = this.level.getEntity(uuid);
+
                             if (entity instanceof LivingEntity) {
-                                LivingEntity livingEntity = (LivingEntity)entity;
+                                LivingEntity entityliving = (LivingEntity) entity;
+
                                 if (!entity.isSpectator()) {
-                                    livingEntity.addEffect(
-                                        new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.badOmenLevel - 1, false, false, true)
-                                    );
-                                    if (livingEntity instanceof ServerPlayer serverPlayer) {
-                                        serverPlayer.awardStat(Stats.RAID_WIN);
-                                        CriteriaTriggers.RAID_WIN.trigger(serverPlayer);
+                                    entityliving.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.badOmenLevel - 1, false, false, true));
+                                    if (entityliving instanceof ServerPlayer) {
+                                        ServerPlayer entityplayer = (ServerPlayer) entityliving;
+
+                                        entityplayer.awardStat(Stats.RAID_WIN);
+                                        CriteriaTriggers.RAID_WIN.trigger(entityplayer);
+                                        winners.add(entityplayer.getBukkitEntity()); // CraftBukkit
                                     }
                                 }
                             }
                         }
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callRaidFinishEvent(this, winners); // CraftBukkit
                     }
                 }
 
                 this.setDirty();
             } else if (this.isOver()) {
-                this.celebrationTicks++;
+                ++this.celebrationTicks;
                 if (this.celebrationTicks >= 600) {
+                    org.bukkit.craftbukkit.event.CraftEventFactory.callRaidStopEvent(this, org.bukkit.event.raid.RaidStopEvent.Reason.FINISHED); // CraftBukkit
                     this.stop();
                     return;
                 }
@@ -386,28 +432,32 @@
                     this.raidEvent.setVisible(true);
                     if (this.isVictory()) {
                         this.raidEvent.setProgress(0.0F);
-                        this.raidEvent.setName(RAID_BAR_VICTORY_COMPONENT);
+                        this.raidEvent.setName(Raid.RAID_BAR_VICTORY_COMPONENT);
                     } else {
-                        this.raidEvent.setName(RAID_BAR_DEFEAT_COMPONENT);
+                        this.raidEvent.setName(Raid.RAID_BAR_DEFEAT_COMPONENT);
                     }
                 }
             }
+
         }
     }
 
     private void moveRaidCenterToNearbyVillageSection() {
         Stream<SectionPos> stream = SectionPos.cube(SectionPos.of(this.center), 2);
-        stream.filter(this.level::isVillage)
-            .map(SectionPos::center)
-            .min(Comparator.comparingDouble(pos -> pos.distSqr(this.center)))
-            .ifPresent(this::setCenter);
+        ServerLevel worldserver = this.level;
+
+        Objects.requireNonNull(this.level);
+        stream.filter(worldserver::isVillage).map(SectionPos::center).min(Comparator.comparingDouble((blockposition) -> {
+            return blockposition.distSqr(this.center);
+        })).ifPresent(this::setCenter);
     }
 
     private Optional<BlockPos> getValidSpawnPos(int offsetMultiplier) {
-        for (int i = 0; i < 3; i++) {
-            BlockPos blockPos = this.findRandomSpawnPos(offsetMultiplier, 1);
-            if (blockPos != null) {
-                return Optional.of(blockPos);
+        for (int j = 0; j < 3; ++j) {
+            BlockPos blockposition = this.findRandomSpawnPos(offsetMultiplier, 1);
+
+            if (blockposition != null) {
+                return Optional.of(blockposition);
             }
         }
 
@@ -436,123 +486,159 @@
 
     private void updateRaiders() {
         Iterator<Set<Raider>> iterator = this.groupRaiderMap.values().iterator();
-        Set<Raider> set = Sets.newHashSet();
+        HashSet hashset = Sets.newHashSet();
 
         while (iterator.hasNext()) {
-            Set<Raider> set1 = iterator.next();
+            Set<Raider> set = (Set) iterator.next();
+            Iterator iterator1 = set.iterator();
 
-            for (Raider raider : set1) {
-                BlockPos blockPos = raider.blockPosition();
-                if (raider.isRemoved() || raider.level().dimension() != this.level.dimension() || this.center.distSqr(blockPos) >= 12544.0) {
-                    set.add(raider);
-                } else if (raider.tickCount > 600) {
-                    if (this.level.getEntity(raider.getUUID()) == null) {
-                        set.add(raider);
-                    }
+            while (iterator1.hasNext()) {
+                Raider entityraider = (Raider) iterator1.next();
+                BlockPos blockposition = entityraider.blockPosition();
 
-                    if (!this.level.isVillage(blockPos) && raider.getNoActionTime() > 2400) {
-                        raider.setTicksOutsideRaid(raider.getTicksOutsideRaid() + 1);
-                    }
+                if (!entityraider.isRemoved() && entityraider.level().dimension() == this.level.dimension() && this.center.distSqr(blockposition) < 12544.0D) {
+                    if (entityraider.tickCount > 600) {
+                        if (this.level.getEntity(entityraider.getUUID()) == null) {
+                            hashset.add(entityraider);
+                        }
 
-                    if (raider.getTicksOutsideRaid() >= 30) {
-                        set.add(raider);
+                        if (!this.level.isVillage(blockposition) && entityraider.getNoActionTime() > 2400) {
+                            entityraider.setTicksOutsideRaid(entityraider.getTicksOutsideRaid() + 1);
+                        }
+
+                        if (entityraider.getTicksOutsideRaid() >= 30) {
+                            hashset.add(entityraider);
+                        }
                     }
+                } else {
+                    hashset.add(entityraider);
                 }
             }
         }
 
-        for (Raider raider1 : set) {
-            this.removeFromRaid(raider1, true);
+        Iterator iterator2 = hashset.iterator();
+
+        while (iterator2.hasNext()) {
+            Raider entityraider1 = (Raider) iterator2.next();
+
+            this.removeFromRaid(entityraider1, true);
         }
+
     }
 
     private void playSound(BlockPos pos) {
         float f = 13.0F;
-        int i = 64;
-        Collection<ServerPlayer> players = this.raidEvent.getPlayers();
-        long randomLong = this.random.nextLong();
+        boolean flag = true;
+        Collection<ServerPlayer> collection = this.raidEvent.getPlayers();
+        long i = this.random.nextLong();
+        Iterator iterator = this.level.players().iterator();
 
-        for (ServerPlayer serverPlayer : this.level.players()) {
-            Vec3 vec3 = serverPlayer.position();
-            Vec3 vec31 = Vec3.atCenterOf(pos);
-            double squareRoot = Math.sqrt((vec31.x - vec3.x) * (vec31.x - vec3.x) + (vec31.z - vec3.z) * (vec31.z - vec3.z));
-            double d = vec3.x + 13.0 / squareRoot * (vec31.x - vec3.x);
-            double d1 = vec3.z + 13.0 / squareRoot * (vec31.z - vec3.z);
-            if (squareRoot <= 64.0 || players.contains(serverPlayer)) {
-                serverPlayer.connection
-                    .send(new ClientboundSoundPacket(SoundEvents.RAID_HORN, SoundSource.NEUTRAL, d, serverPlayer.getY(), d1, 64.0F, 1.0F, randomLong));
+        while (iterator.hasNext()) {
+            ServerPlayer entityplayer = (ServerPlayer) iterator.next();
+            Vec3 vec3d = entityplayer.position();
+            Vec3 vec3d1 = Vec3.atCenterOf(pos);
+            double d0 = Math.sqrt((vec3d1.x - vec3d.x) * (vec3d1.x - vec3d.x) + (vec3d1.z - vec3d.z) * (vec3d1.z - vec3d.z));
+            double d1 = vec3d.x + 13.0D / d0 * (vec3d1.x - vec3d.x);
+            double d2 = vec3d.z + 13.0D / d0 * (vec3d1.z - vec3d.z);
+
+            if (d0 <= 64.0D || collection.contains(entityplayer)) {
+                entityplayer.connection.send(new ClientboundSoundPacket(SoundEvents.RAID_HORN, SoundSource.NEUTRAL, d1, entityplayer.getY(), d2, 64.0F, 1.0F, i));
             }
         }
+
     }
 
     private void spawnGroup(BlockPos pos) {
         boolean flag = false;
         int i = this.groupsSpawned + 1;
+
         this.totalHealth = 0.0F;
-        DifficultyInstance currentDifficultyAt = this.level.getCurrentDifficultyAt(pos);
-        boolean shouldSpawnBonusGroup = this.shouldSpawnBonusGroup();
+        DifficultyInstance difficultydamagescaler = this.level.getCurrentDifficultyAt(pos);
+        boolean flag1 = this.shouldSpawnBonusGroup();
+        Raid.RaiderType[] araid_wave = Raid.RaiderType.VALUES;
+        int j = araid_wave.length;
+        int k = 0;
 
-        for (Raid.RaiderType raiderType : Raid.RaiderType.VALUES) {
-            int i1 = this.getDefaultNumSpawns(raiderType, i, shouldSpawnBonusGroup)
-                + this.getPotentialBonusSpawns(raiderType, this.random, i, currentDifficultyAt, shouldSpawnBonusGroup);
-            int i2 = 0;
+        // CraftBukkit start
+        Raider leader = null;
+        List<Raider> raiders = new java.util.ArrayList<>();
+        // CraftBukkit end
+        while (k < j) {
+            Raid.RaiderType raid_wave = araid_wave[k];
+            int l = this.getDefaultNumSpawns(raid_wave, i, flag1) + this.getPotentialBonusSpawns(raid_wave, this.random, i, difficultydamagescaler, flag1);
+            int i1 = 0;
+            int j1 = 0;
 
-            for (int i3 = 0; i3 < i1; i3++) {
-                Raider raider = raiderType.entityType.create(this.level);
-                if (raider == null) {
-                    break;
-                }
+            while (true) {
+                if (j1 < l) {
+                    Raider entityraider = (Raider) raid_wave.entityType.create(this.level);
 
-                if (!flag && raider.canBeLeader()) {
-                    raider.setPatrolLeader(true);
-                    this.setLeader(i, raider);
-                    flag = true;
-                }
+                    if (entityraider != null) {
+                        if (!flag && entityraider.canBeLeader()) {
+                            entityraider.setPatrolLeader(true);
+                            this.setLeader(i, entityraider);
+                            flag = true;
+                            leader = entityraider; // CraftBukkit
+                        }
 
-                this.joinRaid(i, raider, pos, false);
-                if (raiderType.entityType == EntityType.RAVAGER) {
-                    Raider raider1 = null;
-                    if (i == this.getNumGroups(Difficulty.NORMAL)) {
-                        raider1 = EntityType.PILLAGER.create(this.level);
-                    } else if (i >= this.getNumGroups(Difficulty.HARD)) {
-                        if (i2 == 0) {
-                            raider1 = EntityType.EVOKER.create(this.level);
-                        } else {
-                            raider1 = EntityType.VINDICATOR.create(this.level);
+                        this.joinRaid(i, entityraider, pos, false);
+                        raiders.add(entityraider); // CraftBukkit
+                        if (raid_wave.entityType == EntityType.RAVAGER) {
+                            Raider entityraider1 = null;
+
+                            if (i == this.getNumGroups(Difficulty.NORMAL)) {
+                                entityraider1 = (Raider) EntityType.PILLAGER.create(this.level);
+                            } else if (i >= this.getNumGroups(Difficulty.HARD)) {
+                                if (i1 == 0) {
+                                    entityraider1 = (Raider) EntityType.EVOKER.create(this.level);
+                                } else {
+                                    entityraider1 = (Raider) EntityType.VINDICATOR.create(this.level);
+                                }
+                            }
+
+                            ++i1;
+                            if (entityraider1 != null) {
+                                this.joinRaid(i, entityraider1, pos, false);
+                                entityraider1.moveTo(pos, 0.0F, 0.0F);
+                                entityraider1.startRiding(entityraider);
+                                raiders.add(entityraider); // CraftBukkit
+                            }
                         }
-                    }
 
-                    i2++;
-                    if (raider1 != null) {
-                        this.joinRaid(i, raider1, pos, false);
-                        raider1.moveTo(pos, 0.0F, 0.0F);
-                        raider1.startRiding(raider);
+                        ++j1;
+                        continue;
                     }
                 }
+
+                ++k;
+                break;
             }
         }
 
         this.waveSpawnPos = Optional.empty();
-        this.groupsSpawned++;
+        ++this.groupsSpawned;
         this.updateBossbar();
         this.setDirty();
+        org.bukkit.craftbukkit.event.CraftEventFactory.callRaidSpawnWaveEvent(this, leader, raiders); // CraftBukkit
     }
 
     public void joinRaid(int wave, Raider raider, @Nullable BlockPos pos, boolean isRecruited) {
-        boolean flag = this.addWaveMob(wave, raider);
-        if (flag) {
+        boolean flag1 = this.addWaveMob(wave, raider);
+
+        if (flag1) {
             raider.setCurrentRaid(this);
             raider.setWave(wave);
             raider.setCanJoinRaid(true);
             raider.setTicksOutsideRaid(0);
             if (!isRecruited && pos != null) {
-                raider.setPos((double)pos.getX() + 0.5, (double)pos.getY() + 1.0, (double)pos.getZ() + 0.5);
-                raider.finalizeSpawn(this.level, this.level.getCurrentDifficultyAt(pos), MobSpawnType.EVENT, null, null);
+                raider.setPos((double) pos.getX() + 0.5D, (double) pos.getY() + 1.0D, (double) pos.getZ() + 0.5D);
+                raider.finalizeSpawn(this.level, this.level.getCurrentDifficultyAt(pos), EnumMobSpawn.EVENT, (GroupDataEntity) null, (CompoundTag) null);
                 raider.applyRaidBuffs(wave, false);
                 raider.setOnGround(true);
-                this.level.addFreshEntityWithPassengers(raider);
+                this.level.addFreshEntityWithPassengers(raider, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.RAID); // CraftBukkit
             }
         }
+
     }
 
     public void updateBossbar() {
@@ -561,10 +647,15 @@
 
     public float getHealthOfLivingRaiders() {
         float f = 0.0F;
+        Iterator iterator = this.groupRaiderMap.values().iterator();
 
-        for (Set<Raider> set : this.groupRaiderMap.values()) {
-            for (Raider raider : set) {
-                f += raider.getHealth();
+        while (iterator.hasNext()) {
+            Set<Raider> set = (Set) iterator.next();
+
+            Raider entityraider;
+
+            for (Iterator iterator1 = set.iterator(); iterator1.hasNext(); f += entityraider.getHealth()) {
+                entityraider = (Raider) iterator1.next();
             }
         }
 
@@ -580,19 +671,22 @@
     }
 
     public void removeFromRaid(Raider raider, boolean wanderedOutOfRaid) {
-        Set<Raider> set = this.groupRaiderMap.get(raider.getWave());
+        Set<Raider> set = (Set) this.groupRaiderMap.get(raider.getWave());
+
         if (set != null) {
-            boolean flag = set.remove(raider);
-            if (flag) {
+            boolean flag1 = set.remove(raider);
+
+            if (flag1) {
                 if (wanderedOutOfRaid) {
-                    this.totalHealth = this.totalHealth - raider.getHealth();
+                    this.totalHealth -= raider.getHealth();
                 }
 
-                raider.setCurrentRaid(null);
+                raider.setCurrentRaid((Raid) null);
                 this.updateBossbar();
                 this.setDirty();
             }
         }
+
     }
 
     private void setDirty() {
@@ -600,50 +694,39 @@
     }
 
     public static ItemStack getLeaderBannerInstance() {
-        ItemStack itemStack = new ItemStack(Items.WHITE_BANNER);
-        CompoundTag compoundTag = new CompoundTag();
-        ListTag list = new BannerPattern.Builder()
-            .addPattern(BannerPatterns.RHOMBUS_MIDDLE, DyeColor.CYAN)
-            .addPattern(BannerPatterns.STRIPE_BOTTOM, DyeColor.LIGHT_GRAY)
-            .addPattern(BannerPatterns.STRIPE_CENTER, DyeColor.GRAY)
-            .addPattern(BannerPatterns.BORDER, DyeColor.LIGHT_GRAY)
-            .addPattern(BannerPatterns.STRIPE_MIDDLE, DyeColor.BLACK)
-            .addPattern(BannerPatterns.HALF_HORIZONTAL, DyeColor.LIGHT_GRAY)
-            .addPattern(BannerPatterns.CIRCLE_MIDDLE, DyeColor.LIGHT_GRAY)
-            .addPattern(BannerPatterns.BORDER, DyeColor.BLACK)
-            .toListTag();
-        compoundTag.put("Patterns", list);
-        BlockItem.setBlockEntityData(itemStack, BlockEntityType.BANNER, compoundTag);
-        itemStack.hideTooltipPart(ItemStack.TooltipPart.ADDITIONAL);
-        itemStack.setHoverName(Component.translatable("block.minecraft.ominous_banner").withStyle(ChatFormatting.GOLD));
-        return itemStack;
+        ItemStack itemstack = new ItemStack(Items.WHITE_BANNER);
+        CompoundTag nbttagcompound = new CompoundTag();
+        ListTag nbttaglist = (new BannerPattern.Builder()).addPattern(BannerPatterns.RHOMBUS_MIDDLE, DyeColor.CYAN).addPattern(BannerPatterns.STRIPE_BOTTOM, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.STRIPE_CENTER, DyeColor.GRAY).addPattern(BannerPatterns.BORDER, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.STRIPE_MIDDLE, DyeColor.BLACK).addPattern(BannerPatterns.HALF_HORIZONTAL, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.CIRCLE_MIDDLE, DyeColor.LIGHT_GRAY).addPattern(BannerPatterns.BORDER, DyeColor.BLACK).toListTag();
+
+        nbttagcompound.put("Patterns", nbttaglist);
+        BlockItem.setBlockEntityData(itemstack, BlockEntityType.BANNER, nbttagcompound);
+        itemstack.hideTooltipPart(ItemStack.HideFlags.ADDITIONAL);
+        itemstack.setHoverName(Component.translatable("block.minecraft.ominous_banner").withStyle(ChatFormatting.GOLD));
+        return itemstack;
     }
 
     @Nullable
     public Raider getLeader(int wave) {
-        return this.groupToLeaderMap.get(wave);
+        return (Raider) this.groupToLeaderMap.get(wave);
     }
 
     @Nullable
     private BlockPos findRandomSpawnPos(int offsetMultiplier, int maxTry) {
-        int i = offsetMultiplier == 0 ? 2 : 2 - offsetMultiplier;
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        int k = offsetMultiplier == 0 ? 2 : 2 - offsetMultiplier;
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-        for (int i1 = 0; i1 < maxTry; i1++) {
-            float f = this.level.random.nextFloat() * (float) (Math.PI * 2);
-            int i2 = this.center.getX() + Mth.floor(Mth.cos(f) * 32.0F * (float)i) + this.level.random.nextInt(5);
-            int i3 = this.center.getZ() + Mth.floor(Mth.sin(f) * 32.0F * (float)i) + this.level.random.nextInt(5);
-            int height = this.level.getHeight(Heightmap.Types.WORLD_SURFACE, i2, i3);
-            mutableBlockPos.set(i2, height, i3);
-            if (!this.level.isVillage(mutableBlockPos) || offsetMultiplier >= 2) {
-                int i4 = 10;
-                if (this.level.hasChunksAt(mutableBlockPos.getX() - 10, mutableBlockPos.getZ() - 10, mutableBlockPos.getX() + 10, mutableBlockPos.getZ() + 10)
-                    && this.level.isPositionEntityTicking(mutableBlockPos)
-                    && (
-                        NaturalSpawner.isSpawnPositionOk(SpawnPlacements.Type.ON_GROUND, this.level, mutableBlockPos, EntityType.RAVAGER)
-                            || this.level.getBlockState(mutableBlockPos.below()).is(Blocks.SNOW) && this.level.getBlockState(mutableBlockPos).isAir()
-                    )) {
-                    return mutableBlockPos;
+        for (int l = 0; l < maxTry; ++l) {
+            float f = this.level.random.nextFloat() * 6.2831855F;
+            int i1 = this.center.getX() + Mth.floor(Mth.cos(f) * 32.0F * (float) k) + this.level.random.nextInt(5);
+            int j1 = this.center.getZ() + Mth.floor(Mth.sin(f) * 32.0F * (float) k) + this.level.random.nextInt(5);
+            int k1 = this.level.getHeight(Heightmap.Types.WORLD_SURFACE, i1, j1);
+
+            blockposition_mutableblockposition.set(i1, k1, j1);
+            if (!this.level.isVillage((BlockPos) blockposition_mutableblockposition) || offsetMultiplier >= 2) {
+                boolean flag = true;
+
+                if (this.level.hasChunksAt(blockposition_mutableblockposition.getX() - 10, blockposition_mutableblockposition.getZ() - 10, blockposition_mutableblockposition.getX() + 10, blockposition_mutableblockposition.getZ() + 10) && this.level.isPositionEntityTicking(blockposition_mutableblockposition) && (NaturalSpawner.isSpawnPositionOk(SpawnPlacements.Surface.ON_GROUND, this.level, blockposition_mutableblockposition, EntityType.RAVAGER) || this.level.getBlockState(blockposition_mutableblockposition.below()).is(Blocks.SNOW) && this.level.getBlockState(blockposition_mutableblockposition).isAir())) {
+                    return blockposition_mutableblockposition;
                 }
             }
         }
@@ -656,25 +739,30 @@
     }
 
     public boolean addWaveMob(int wave, Raider raider, boolean isRecruited) {
-        this.groupRaiderMap.computeIfAbsent(wave, value -> Sets.newHashSet());
-        Set<Raider> set = this.groupRaiderMap.get(wave);
-        Raider raider1 = null;
+        this.groupRaiderMap.computeIfAbsent(wave, (integer) -> {
+            return Sets.newHashSet();
+        });
+        Set<Raider> set = (Set) this.groupRaiderMap.get(wave);
+        Raider entityraider1 = null;
+        Iterator iterator = set.iterator();
 
-        for (Raider raider2 : set) {
-            if (raider2.getUUID().equals(raider.getUUID())) {
-                raider1 = raider2;
+        while (iterator.hasNext()) {
+            Raider entityraider2 = (Raider) iterator.next();
+
+            if (entityraider2.getUUID().equals(raider.getUUID())) {
+                entityraider1 = entityraider2;
                 break;
             }
         }
 
-        if (raider1 != null) {
-            set.remove(raider1);
+        if (entityraider1 != null) {
+            set.remove(entityraider1);
             set.add(raider);
         }
 
         set.add(raider);
         if (isRecruited) {
-            this.totalHealth = this.totalHealth + raider.getHealth();
+            this.totalHealth += raider.getHealth();
         }
 
         this.updateBossbar();
@@ -709,36 +797,37 @@
     }
 
     private int getPotentialBonusSpawns(Raid.RaiderType raiderType, RandomSource random, int wave, DifficultyInstance difficulty, boolean shouldSpawnBonusGroup) {
-        Difficulty difficulty1 = difficulty.getDifficulty();
-        boolean flag = difficulty1 == Difficulty.EASY;
-        boolean flag1 = difficulty1 == Difficulty.NORMAL;
-        int i;
+        Difficulty enumdifficulty = difficulty.getDifficulty();
+        boolean flag1 = enumdifficulty == Difficulty.EASY;
+        boolean flag2 = enumdifficulty == Difficulty.NORMAL;
+        int j;
+
         switch (raiderType) {
             case WITCH:
-                if (flag || wave <= 2 || wave == 4) {
+                if (flag1 || wave <= 2 || wave == 4) {
                     return 0;
                 }
 
-                i = 1;
+                j = 1;
                 break;
             case PILLAGER:
             case VINDICATOR:
-                if (flag) {
-                    i = random.nextInt(2);
-                } else if (flag1) {
-                    i = 1;
+                if (flag1) {
+                    j = random.nextInt(2);
+                } else if (flag2) {
+                    j = 1;
                 } else {
-                    i = 2;
+                    j = 2;
                 }
                 break;
             case RAVAGER:
-                i = !flag && shouldSpawnBonusGroup ? 1 : 0;
+                j = !flag1 && shouldSpawnBonusGroup ? 1 : 0;
                 break;
             default:
                 return 0;
         }
 
-        return i > 0 ? random.nextInt(i + 1) : 0;
+        return j > 0 ? random.nextInt(j + 1) : 0;
     }
 
     public boolean isActive() {
@@ -760,13 +849,16 @@
         compound.putInt("CX", this.center.getX());
         compound.putInt("CY", this.center.getY());
         compound.putInt("CZ", this.center.getZ());
-        ListTag list = new ListTag();
+        ListTag nbttaglist = new ListTag();
+        Iterator iterator = this.heroesOfTheVillage.iterator();
 
-        for (UUID uUID : this.heroesOfTheVillage) {
-            list.add(NbtUtils.createUUID(uUID));
+        while (iterator.hasNext()) {
+            UUID uuid = (UUID) iterator.next();
+
+            nbttaglist.add(NbtUtils.createUUID(uuid));
         }
 
-        compound.put("HeroesOfTheVillage", list);
+        compound.put("HeroesOfTheVillage", nbttaglist);
         return compound;
     }
 
@@ -784,38 +876,42 @@
     }
 
     public float getEnchantOdds() {
-        int badOmenLevel = this.getBadOmenLevel();
-        if (badOmenLevel == 2) {
-            return 0.1F;
-        } else if (badOmenLevel == 3) {
-            return 0.25F;
-        } else if (badOmenLevel == 4) {
-            return 0.5F;
-        } else {
-            return badOmenLevel == 5 ? 0.75F : 0.0F;
-        }
+        int i = this.getBadOmenLevel();
+
+        return i == 2 ? 0.1F : (i == 3 ? 0.25F : (i == 4 ? 0.5F : (i == 5 ? 0.75F : 0.0F)));
     }
 
     public void addHeroOfTheVillage(Entity player) {
         this.heroesOfTheVillage.add(player.getUUID());
     }
 
-    static enum RaidStatus {
-        ONGOING,
-        VICTORY,
-        LOSS,
-        STOPPED;
+    // CraftBukkit start - a method to get all raiders
+    public java.util.Collection<Raider> getRaiders() {
+        return this.groupRaiderMap.values().stream().flatMap(Set::stream).collect(java.util.stream.Collectors.toSet());
+    }
+    // CraftBukkit end
 
+    private static enum RaidStatus {
+
+        ONGOING, VICTORY, LOSS, STOPPED;
+
         private static final Raid.RaidStatus[] VALUES = values();
 
+        private RaidStatus() {}
+
         static Raid.RaidStatus getByName(String name) {
-            for (Raid.RaidStatus raidStatus : VALUES) {
-                if (name.equalsIgnoreCase(raidStatus.name())) {
-                    return raidStatus;
+            Raid.RaidStatus[] araid_status = Raid.RaidStatus.VALUES;
+            int i = araid_status.length;
+
+            for (int j = 0; j < i; ++j) {
+                Raid.RaidStatus raid_status = araid_status[j];
+
+                if (name.equalsIgnoreCase(raid_status.name())) {
+                    return raid_status;
                 }
             }
 
-            return ONGOING;
+            return Raid.RaidStatus.ONGOING;
         }
 
         public String getName() {
@@ -823,20 +919,17 @@
         }
     }
 
-    static enum RaiderType {
-        VINDICATOR(EntityType.VINDICATOR, new int[]{0, 0, 2, 0, 1, 4, 2, 5}),
-        EVOKER(EntityType.EVOKER, new int[]{0, 0, 0, 0, 0, 1, 1, 2}),
-        PILLAGER(EntityType.PILLAGER, new int[]{0, 4, 3, 3, 4, 4, 4, 2}),
-        WITCH(EntityType.WITCH, new int[]{0, 0, 0, 0, 3, 0, 0, 1}),
-        RAVAGER(EntityType.RAVAGER, new int[]{0, 0, 0, 1, 0, 1, 0, 2});
+    private static enum RaiderType {
 
+        VINDICATOR(EntityType.VINDICATOR, new int[]{0, 0, 2, 0, 1, 4, 2, 5}), EVOKER(EntityType.EVOKER, new int[]{0, 0, 0, 0, 0, 1, 1, 2}), PILLAGER(EntityType.PILLAGER, new int[]{0, 4, 3, 3, 4, 4, 4, 2}), WITCH(EntityType.WITCH, new int[]{0, 0, 0, 0, 3, 0, 0, 1}), RAVAGER(EntityType.RAVAGER, new int[]{0, 0, 0, 1, 0, 1, 0, 2});
+
         static final Raid.RaiderType[] VALUES = values();
         final EntityType<? extends Raider> entityType;
         final int[] spawnsPerWaveBeforeBonus;
 
-        private RaiderType(EntityType<? extends Raider> entityType, int[] spawnsPerWaveBeforeBonus) {
-            this.entityType = entityType;
-            this.spawnsPerWaveBeforeBonus = spawnsPerWaveBeforeBonus;
+        private RaiderType(EntityType entitytypes, int[] aint) {
+            this.entityType = entitytypes;
+            this.spawnsPerWaveBeforeBonus = aint;
         }
     }
 }
