--- a/net/minecraft/world/entity/ai/behavior/StopAttackingIfTargetInvalid.java
+++ b/net/minecraft/world/entity/ai/behavior/StopAttackingIfTargetInvalid.java
@@ -3,56 +3,72 @@
 import java.util.Optional;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
-import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.ai.behavior.declarative.BehaviorBuilder;
-import net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 
+// CraftBukkit start
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.EntityTargetEvent;
+// CraftBukkit end
+
 public class StopAttackingIfTargetInvalid {
+
     private static final int TIMEOUT_TO_GET_WITHIN_ATTACK_RANGE = 200;
 
+    public StopAttackingIfTargetInvalid() {}
+
     public static <E extends Mob> BehaviorControl<E> create(BiConsumer<E, LivingEntity> onStopAttacking) {
-        return create(entity -> false, onStopAttacking, true);
+        return create((entityliving) -> {
+            return false;
+        }, onStopAttacking, true);
     }
 
     public static <E extends Mob> BehaviorControl<E> create(Predicate<LivingEntity> canStopAttacking) {
-        return create(canStopAttacking, (entity, target) -> {
+        return create(canStopAttacking, (entityinsentient, entityliving) -> {
         }, true);
     }
 
     public static <E extends Mob> BehaviorControl<E> create() {
-        return create(entity -> false, (entity, target) -> {
+        return create((entityliving) -> {
+            return false;
+        }, (entityinsentient, entityliving) -> {
         }, true);
     }
 
-    public static <E extends Mob> BehaviorControl<E> create(
-        Predicate<LivingEntity> canStopAttacking, BiConsumer<E, LivingEntity> onStopAttacking, boolean canGrowTiredOfTryingToReachTarget
-    ) {
-        return BehaviorBuilder.create(
-            instance -> instance.group(instance.present(MemoryModuleType.ATTACK_TARGET), instance.registered(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE))
-                    .apply(
-                        instance,
-                        (attackTarget, cantReachWalkTargetSince) -> (level, mob, gameTime) -> {
-                                LivingEntity livingEntity = instance.get(attackTarget);
-                                if (mob.canAttack(livingEntity)
-                                    && (!canGrowTiredOfTryingToReachTarget || !isTiredOfTryingToReachTarget(mob, instance.tryGet(cantReachWalkTargetSince)))
-                                    && livingEntity.isAlive()
-                                    && livingEntity.level() == mob.level()
-                                    && !canStopAttacking.test(livingEntity)) {
-                                    return true;
-                                } else {
-                                    onStopAttacking.accept(mob, livingEntity);
-                                    attackTarget.erase();
-                                    return true;
-                                }
-                            }
-                    )
-        );
+    public static <E extends Mob> BehaviorControl<E> create(Predicate<LivingEntity> canStopAttacking, BiConsumer<E, LivingEntity> onStopAttacking, boolean canGrowTiredOfTryingToReachTarget) {
+        return BehaviorBuilder.create((behaviorbuilder_b) -> {
+            return behaviorbuilder_b.group(behaviorbuilder_b.present(MemoryModuleType.ATTACK_TARGET), behaviorbuilder_b.registered(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE)).apply(behaviorbuilder_b, (memoryaccessor, memoryaccessor1) -> {
+                return (worldserver, entityinsentient, i) -> {
+                    LivingEntity entityliving = (LivingEntity) behaviorbuilder_b.get(memoryaccessor);
+
+                    if (entityinsentient.canAttack(entityliving) && (!canGrowTiredOfTryingToReachTarget || !isTiredOfTryingToReachTarget(entityinsentient, behaviorbuilder_b.tryGet(memoryaccessor1))) && entityliving.isAlive() && entityliving.level() == entityinsentient.level() && !canStopAttacking.test(entityliving)) {
+                        return true;
+                    } else {
+                        // CraftBukkit start
+                        LivingEntity old = entityinsentient.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET).orElse(null);
+                        EntityTargetEvent event = CraftEventFactory.callEntityTargetLivingEvent(entityinsentient, null, (old != null && !old.isAlive()) ? EntityTargetEvent.TargetReason.TARGET_DIED : EntityTargetEvent.TargetReason.FORGOT_TARGET);
+                        if (event.isCancelled()) {
+                            return false;
+                        }
+                        if (event.getTarget() == null) {
+                            memoryaccessor.erase();
+                            return true;
+                        }
+                        entityliving = ((CraftLivingEntity) event.getTarget()).getHandle();
+                        // CraftBukkit end
+                        onStopAttacking.accept(entityinsentient, entityliving);
+                        memoryaccessor.erase();
+                        return true;
+                    }
+                };
+            });
+        });
     }
 
     private static boolean isTiredOfTryingToReachTarget(LivingEntity entity, Optional<Long> timeSinceInvalidTarget) {
-        return timeSinceInvalidTarget.isPresent() && entity.level().getGameTime() - timeSinceInvalidTarget.get() > 200L;
+        return timeSinceInvalidTarget.isPresent() && entity.level().getGameTime() - (Long) timeSinceInvalidTarget.get() > 200L;
     }
 }
