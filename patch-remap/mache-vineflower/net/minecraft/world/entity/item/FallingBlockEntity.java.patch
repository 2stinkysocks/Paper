--- a/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.entity.item;
 
 import com.mojang.logging.LogUtils;
+import java.util.Iterator;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReportCategory;
@@ -25,11 +26,13 @@
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntitySelector;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.MoverType;
+import net.minecraft.world.entity.EnumMoveType;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.item.context.DirectionalPlaceContext;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.IMaterial;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.AnvilBlock;
 import net.minecraft.world.level.block.Block;
@@ -38,7 +41,7 @@
 import net.minecraft.world.level.block.Fallable;
 import net.minecraft.world.level.block.FallingBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.phys.BlockHitResult;
@@ -46,61 +49,69 @@
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 
+// CraftBukkit start;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+// CraftBukkit end
+
 public class FallingBlockEntity extends Entity {
+
     private static final Logger LOGGER = LogUtils.getLogger();
-    private BlockState blockState = Blocks.SAND.defaultBlockState();
+    private IBlockData blockState;
     public int time;
-    public boolean dropItem = true;
-    private boolean cancelDrop;
-    private boolean hurtEntities;
-    private int fallDamageMax = 40;
-    private float fallDamagePerDistance;
+    public boolean dropItem;
+    public boolean cancelDrop;
+    public boolean hurtEntities;
+    public int fallDamageMax;
+    public float fallDamagePerDistance;
     @Nullable
     public CompoundTag blockData;
     protected static final EntityDataAccessor<BlockPos> DATA_START_POS = SynchedEntityData.defineId(FallingBlockEntity.class, EntityDataSerializers.BLOCK_POS);
 
     public FallingBlockEntity(EntityType<? extends FallingBlockEntity> entityType, Level level) {
         super(entityType, level);
+        this.blockState = Blocks.SAND.defaultBlockState();
+        this.dropItem = true;
+        this.fallDamageMax = 40;
     }
 
-    private FallingBlockEntity(Level level, double x, double y, double z, BlockState state) {
+    private FallingBlockEntity(Level level, double x, double d1, double y, IBlockData iblockdata) {
         this(EntityType.FALLING_BLOCK, level);
-        this.blockState = state;
+        this.blockState = iblockdata;
         this.blocksBuilding = true;
-        this.setPos(x, y, z);
+        this.setPos(x, d1, y);
         this.setDeltaMovement(Vec3.ZERO);
         this.xo = x;
-        this.yo = y;
-        this.zo = z;
+        this.yo = d1;
+        this.zo = y;
         this.setStartPos(this.blockPosition());
     }
 
-    public static FallingBlockEntity fall(Level level, BlockPos pos, BlockState blockState) {
-        FallingBlockEntity fallingBlockEntity = new FallingBlockEntity(
-            level,
-            (double)pos.getX() + 0.5,
-            (double)pos.getY(),
-            (double)pos.getZ() + 0.5,
-            blockState.hasProperty(BlockStateProperties.WATERLOGGED)
-                ? blockState.setValue(BlockStateProperties.WATERLOGGED, Boolean.valueOf(false))
-                : blockState
-        );
-        level.setBlock(pos, blockState.getFluidState().createLegacyBlock(), 3);
-        level.addFreshEntity(fallingBlockEntity);
-        return fallingBlockEntity;
+    public static FallingBlockEntity fall(Level level, BlockPos pos, IBlockData blockState) {
+        // CraftBukkit start
+        return fall(level, pos, blockState, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
     }
 
+    public static FallingBlockEntity fall(Level world, BlockPos blockposition, IBlockData iblockdata, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason) {
+        // CraftBukkit end
+        FallingBlockEntity entityfallingblock = new FallingBlockEntity(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, iblockdata.hasProperty(BlockStateProperties.WATERLOGGED) ? (IBlockData) iblockdata.setValue(BlockStateProperties.WATERLOGGED, false) : iblockdata);
+        if (!CraftEventFactory.callEntityChangeBlockEvent(entityfallingblock, blockposition, iblockdata.getFluidState().createLegacyBlock())) return entityfallingblock; // CraftBukkit
+
+        world.setBlock(blockposition, iblockdata.getFluidState().createLegacyBlock(), 3);
+        world.addFreshEntity(entityfallingblock, spawnReason); // CraftBukkit
+        return entityfallingblock;
+    }
+
     @Override
     public boolean isAttackable() {
         return false;
     }
 
     public void setStartPos(BlockPos startPos) {
-        this.entityData.set(DATA_START_POS, startPos);
+        this.entityData.set(FallingBlockEntity.DATA_START_POS, startPos);
     }
 
     public BlockPos getStartPos() {
-        return this.entityData.get(DATA_START_POS);
+        return (BlockPos) this.entityData.get(FallingBlockEntity.DATA_START_POS);
     }
 
     @Override
@@ -110,7 +121,7 @@
 
     @Override
     protected void defineSynchedData() {
-        this.entityData.define(DATA_START_POS, BlockPos.ZERO);
+        this.entityData.define(FallingBlockEntity.DATA_START_POS, BlockPos.ZERO);
     }
 
     @Override
@@ -124,112 +135,115 @@
             this.discard();
         } else {
             Block block = this.blockState.getBlock();
-            this.time++;
+
+            ++this.time;
             if (!this.isNoGravity()) {
-                this.setDeltaMovement(this.getDeltaMovement().add(0.0, -0.04, 0.0));
+                this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.04D, 0.0D));
             }
 
-            this.move(MoverType.SELF, this.getDeltaMovement());
+            this.move(EnumMoveType.SELF, this.getDeltaMovement());
             if (!this.level().isClientSide) {
-                BlockPos blockPos = this.blockPosition();
+                BlockPos blockposition = this.blockPosition();
                 boolean flag = this.blockState.getBlock() instanceof ConcretePowderBlock;
-                boolean flag1 = flag && this.level().getFluidState(blockPos).is(FluidTags.WATER);
-                double d = this.getDeltaMovement().lengthSqr();
-                if (flag && d > 1.0) {
-                    BlockHitResult blockHitResult = this.level()
-                        .clip(
-                            new ClipContext(
-                                new Vec3(this.xo, this.yo, this.zo), this.position(), ClipContext.Block.COLLIDER, ClipContext.Fluid.SOURCE_ONLY, this
-                            )
-                        );
-                    if (blockHitResult.getType() != HitResult.Type.MISS && this.level().getFluidState(blockHitResult.getBlockPos()).is(FluidTags.WATER)) {
-                        blockPos = blockHitResult.getBlockPos();
+                boolean flag1 = flag && this.level().getFluidState(blockposition).is(FluidTags.WATER);
+                double d0 = this.getDeltaMovement().lengthSqr();
+
+                if (flag && d0 > 1.0D) {
+                    BlockHitResult movingobjectpositionblock = this.level().clip(new ClipContext(new Vec3(this.xo, this.yo, this.zo), this.position(), ClipContext.Block.COLLIDER, ClipContext.Fluid.SOURCE_ONLY, this));
+
+                    if (movingobjectpositionblock.getType() != HitResult.EnumMovingObjectType.MISS && this.level().getFluidState(movingobjectpositionblock.getBlockPos()).is(FluidTags.WATER)) {
+                        blockposition = movingobjectpositionblock.getBlockPos();
                         flag1 = true;
                     }
                 }
 
-                if (this.onGround() || flag1) {
-                    BlockState blockState = this.level().getBlockState(blockPos);
-                    this.setDeltaMovement(this.getDeltaMovement().multiply(0.7, -0.5, 0.7));
-                    if (!blockState.is(Blocks.MOVING_PISTON)) {
+                if (!this.onGround() && !flag1) {
+                    if (!this.level().isClientSide && (this.time > 100 && (blockposition.getY() <= this.level().getMinBuildHeight() || blockposition.getY() > this.level().getMaxBuildHeight()) || this.time > 600)) {
+                        if (this.dropItem && this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
+                            this.spawnAtLocation((IMaterial) block);
+                        }
+
+                        this.discard();
+                    }
+                } else {
+                    IBlockData iblockdata = this.level().getBlockState(blockposition);
+
+                    this.setDeltaMovement(this.getDeltaMovement().multiply(0.7D, -0.5D, 0.7D));
+                    if (!iblockdata.is(Blocks.MOVING_PISTON)) {
                         if (!this.cancelDrop) {
-                            boolean canBeReplaced = blockState.canBeReplaced(
-                                new DirectionalPlaceContext(this.level(), blockPos, Direction.DOWN, ItemStack.EMPTY, Direction.UP)
-                            );
-                            boolean flag2 = FallingBlock.isFree(this.level().getBlockState(blockPos.below())) && (!flag || !flag1);
-                            boolean flag3 = this.blockState.canSurvive(this.level(), blockPos) && !flag2;
-                            if (canBeReplaced && flag3) {
-                                if (this.blockState.hasProperty(BlockStateProperties.WATERLOGGED)
-                                    && this.level().getFluidState(blockPos).getType() == Fluids.WATER) {
-                                    this.blockState = this.blockState.setValue(BlockStateProperties.WATERLOGGED, Boolean.valueOf(true));
+                            boolean flag2 = iblockdata.canBeReplaced((BlockPlaceContext) (new DirectionalPlaceContext(this.level(), blockposition, Direction.DOWN, ItemStack.EMPTY, Direction.UP)));
+                            boolean flag3 = FallingBlock.isFree(this.level().getBlockState(blockposition.below())) && (!flag || !flag1);
+                            boolean flag4 = this.blockState.canSurvive(this.level(), blockposition) && !flag3;
+
+                            if (flag2 && flag4) {
+                                if (this.blockState.hasProperty(BlockStateProperties.WATERLOGGED) && this.level().getFluidState(blockposition).getType() == Fluids.WATER) {
+                                    this.blockState = (IBlockData) this.blockState.setValue(BlockStateProperties.WATERLOGGED, true);
                                 }
 
-                                if (this.level().setBlock(blockPos, this.blockState, 3)) {
-                                    ((ServerLevel)this.level())
-                                        .getChunkSource()
-                                        .chunkMap
-                                        .broadcast(this, new ClientboundBlockUpdatePacket(blockPos, this.level().getBlockState(blockPos)));
+                                // CraftBukkit start
+                                if (!CraftEventFactory.callEntityChangeBlockEvent(this, blockposition, this.blockState)) {
+                                    this.discard(); // SPIGOT-6586 called before the event in previous versions
+                                    return;
+                                }
+                                // CraftBukkit end
+                                if (this.level().setBlock(blockposition, this.blockState, 3)) {
+                                    ((ServerLevel) this.level()).getChunkSource().chunkMap.broadcast(this, new ClientboundBlockUpdatePacket(blockposition, this.level().getBlockState(blockposition)));
                                     this.discard();
                                     if (block instanceof Fallable) {
-                                        ((Fallable)block).onLand(this.level(), blockPos, this.blockState, blockState, this);
+                                        ((Fallable) block).onLand(this.level(), blockposition, this.blockState, iblockdata, this);
                                     }
 
                                     if (this.blockData != null && this.blockState.hasBlockEntity()) {
-                                        BlockEntity blockEntity = this.level().getBlockEntity(blockPos);
-                                        if (blockEntity != null) {
-                                            CompoundTag compoundTag = blockEntity.saveWithoutMetadata();
+                                        BlockEntity tileentity = this.level().getBlockEntity(blockposition);
 
-                                            for (String string : this.blockData.getAllKeys()) {
-                                                compoundTag.put(string, this.blockData.get(string).copy());
+                                        if (tileentity != null) {
+                                            CompoundTag nbttagcompound = tileentity.saveWithoutMetadata();
+                                            Iterator iterator = this.blockData.getAllKeys().iterator();
+
+                                            while (iterator.hasNext()) {
+                                                String s = (String) iterator.next();
+
+                                                nbttagcompound.put(s, this.blockData.get(s).copy());
                                             }
 
                                             try {
-                                                blockEntity.load(compoundTag);
-                                            } catch (Exception var15) {
-                                                LOGGER.error("Failed to load block entity from falling block", (Throwable)var15);
+                                                tileentity.load(nbttagcompound);
+                                            } catch (Exception exception) {
+                                                FallingBlockEntity.LOGGER.error("Failed to load block entity from falling block", exception);
                                             }
 
-                                            blockEntity.setChanged();
+                                            tileentity.setChanged();
                                         }
                                     }
                                 } else if (this.dropItem && this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
                                     this.discard();
-                                    this.callOnBrokenAfterFall(block, blockPos);
-                                    this.spawnAtLocation(block);
+                                    this.callOnBrokenAfterFall(block, blockposition);
+                                    this.spawnAtLocation((IMaterial) block);
                                 }
                             } else {
                                 this.discard();
                                 if (this.dropItem && this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
-                                    this.callOnBrokenAfterFall(block, blockPos);
-                                    this.spawnAtLocation(block);
+                                    this.callOnBrokenAfterFall(block, blockposition);
+                                    this.spawnAtLocation((IMaterial) block);
                                 }
                             }
                         } else {
                             this.discard();
-                            this.callOnBrokenAfterFall(block, blockPos);
+                            this.callOnBrokenAfterFall(block, blockposition);
                         }
                     }
-                } else if (!this.level().isClientSide
-                    && (
-                        this.time > 100 && (blockPos.getY() <= this.level().getMinBuildHeight() || blockPos.getY() > this.level().getMaxBuildHeight())
-                            || this.time > 600
-                    )) {
-                    if (this.dropItem && this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
-                        this.spawnAtLocation(block);
-                    }
-
-                    this.discard();
                 }
             }
 
-            this.setDeltaMovement(this.getDeltaMovement().scale(0.98));
+            this.setDeltaMovement(this.getDeltaMovement().scale(0.98D));
         }
     }
 
     public void callOnBrokenAfterFall(Block block, BlockPos pos) {
         if (block instanceof Fallable) {
-            ((Fallable)block).onBrokenAfterFall(this.level(), pos, this);
+            ((Fallable) block).onBrokenAfterFall(this.level(), pos, this);
         }
+
     }
 
     @Override
@@ -237,23 +251,40 @@
         if (!this.hurtEntities) {
             return false;
         } else {
-            int ceil = Mth.ceil(fallDistance - 1.0F);
-            if (ceil < 0) {
+            int i = Mth.ceil(fallDistance - 1.0F);
+
+            if (i < 0) {
                 return false;
             } else {
                 Predicate<Entity> predicate = EntitySelector.NO_CREATIVE_OR_SPECTATOR.and(EntitySelector.LIVING_ENTITY_STILL_ALIVE);
-                DamageSource damageSource = this.blockState.getBlock() instanceof Fallable fallable
-                    ? fallable.getFallDamageSource(this)
-                    : this.damageSources().fallingBlock(this);
-                float f = (float)Math.min(Mth.floor((float)ceil * this.fallDamagePerDistance), this.fallDamageMax);
-                this.level().getEntities(this, this.getBoundingBox(), predicate).forEach(entity -> entity.hurt(damageSource, f));
-                boolean isAnvil = this.blockState.is(BlockTags.ANVIL);
-                if (isAnvil && f > 0.0F && this.random.nextFloat() < 0.05F + (float)ceil * 0.05F) {
-                    BlockState blockState = AnvilBlock.damage(this.blockState);
-                    if (blockState == null) {
+                Block block = this.blockState.getBlock();
+                DamageSource damagesource1;
+
+                if (block instanceof Fallable) {
+                    Fallable fallable = (Fallable) block;
+
+                    damagesource1 = fallable.getFallDamageSource(this);
+                } else {
+                    damagesource1 = this.damageSources().fallingBlock(this);
+                }
+
+                DamageSource damagesource2 = damagesource1;
+                float f2 = (float) Math.min(Mth.floor((float) i * this.fallDamagePerDistance), this.fallDamageMax);
+
+                this.level().getEntities((Entity) this, this.getBoundingBox(), predicate).forEach((entity) -> {
+                    CraftEventFactory.entityDamage = this; // CraftBukkit
+                    entity.hurt(damagesource2, f2);
+                    CraftEventFactory.entityDamage = null; // CraftBukkit
+                });
+                boolean flag = this.blockState.is(BlockTags.ANVIL);
+
+                if (flag && f2 > 0.0F && this.random.nextFloat() < 0.05F + (float) i * 0.05F) {
+                    IBlockData iblockdata = AnvilBlock.damage(this.blockState);
+
+                    if (iblockdata == null) {
                         this.cancelDrop = true;
                     } else {
-                        this.blockState = blockState;
+                        this.blockState = iblockdata;
                     }
                 }
 
@@ -301,6 +332,7 @@
         if (this.blockState.isAir()) {
             this.blockState = Blocks.SAND.defaultBlockState();
         }
+
     }
 
     public void setHurtsEntities(float fallDamagePerDistance, int fallDamageMax) {
@@ -321,10 +353,10 @@
     @Override
     public void fillCrashReportCategory(CrashReportCategory category) {
         super.fillCrashReportCategory(category);
-        category.setDetail("Immitating BlockState", this.blockState.toString());
+        category.setDetail("Immitating BlockState", (Object) this.blockState.toString());
     }
 
-    public BlockState getBlockState() {
+    public IBlockData getBlockState() {
         return this.blockState;
     }
 
@@ -348,10 +380,11 @@
         super.recreateFromPacket(packet);
         this.blockState = Block.stateById(packet.getData());
         this.blocksBuilding = true;
-        double x = packet.getX();
-        double y = packet.getY();
-        double z = packet.getZ();
-        this.setPos(x, y, z);
+        double d0 = packet.getX();
+        double d1 = packet.getY();
+        double d2 = packet.getZ();
+
+        this.setPos(d0, d1, d2);
         this.setStartPos(this.blockPosition());
     }
 }
