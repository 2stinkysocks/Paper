--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1,16 +1,18 @@
 package net.minecraft.world.entity;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
-import com.google.common.collect.ImmutableList.Builder;
+import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
@@ -41,10 +43,10 @@
 import net.minecraft.nbt.FloatTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.StringTag;
+import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.Style;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
 import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
@@ -68,9 +70,9 @@
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.INamableTileEntity;
 import net.minecraft.world.InteractionResult;
-import net.minecraft.world.Nameable;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.damagesource.DamageSources;
 import net.minecraft.world.entity.item.ItemEntity;
@@ -85,28 +87,29 @@
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.IMaterial;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.EnumRenderType;
 import net.minecraft.world.level.block.FenceGateBlock;
 import net.minecraft.world.level.block.HoneyBlock;
 import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.RenderShape;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.SoundType;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.dimension.DimensionType;
+import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.entity.EntityAccess;
 import net.minecraft.world.level.entity.EntityInLevelCallback;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.material.EnumPistonReaction;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
-import net.minecraft.world.level.material.PushReaction;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.level.portal.PortalShape;
 import net.minecraft.world.phys.AABB;
@@ -123,8 +126,63 @@
 import net.minecraft.world.scores.Team;
 import org.joml.Vector3f;
 import org.slf4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.block.BlockFace;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.event.CraftPortalEvent;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.entity.Pose;
+import org.bukkit.event.entity.EntityAirChangeEvent;
+import org.bukkit.event.entity.EntityCombustEvent;
+import org.bukkit.event.entity.EntityDropItemEvent;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.event.entity.EntityPoseChangeEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.plugin.PluginManager;
+// CraftBukkit end
 
-public abstract class Entity implements Nameable, EntityAccess, CommandSource, ScoreHolder {
+public abstract class Entity implements INamableTileEntity, EntityAccess, CommandSource, ScoreHolder {
+
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+    static boolean isLevelAtLeast(CompoundTag tag, int level) {
+        return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
+    }
+
+    private CraftEntity bukkitEntity;
+
+    public CraftEntity getBukkitEntity() {
+        if (bukkitEntity == null) {
+            bukkitEntity = CraftEntity.getEntity(level.getCraftServer(), this);
+        }
+        return bukkitEntity;
+    }
+
+    @Override
+    public CommandSender getBukkitSender(CommandSourceStack wrapper) {
+        return getBukkitEntity();
+    }
+
+    // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+    public int getDefaultMaxAirSupply() {
+        return TOTAL_AIR_SUPPLY;
+    }
+    // CraftBukkit end
+
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final String ID_TAG = "id";
     public static final String PASSENGERS_TAG = "Passengers";
@@ -134,21 +192,21 @@
     public static final int TOTAL_AIR_SUPPLY = 300;
     public static final int MAX_ENTITY_TAG_COUNT = 1024;
     public static final float DELTA_AFFECTED_BY_BLOCKS_BELOW_0_2 = 0.2F;
-    public static final double DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5 = 0.500001;
-    public static final double DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0 = 0.999999;
+    public static final double DELTA_AFFECTED_BY_BLOCKS_BELOW_0_5 = 0.500001D;
+    public static final double DELTA_AFFECTED_BY_BLOCKS_BELOW_1_0 = 0.999999D;
     public static final float BREATHING_DISTANCE_BELOW_EYES = 0.11111111F;
     public static final int BASE_TICKS_REQUIRED_TO_FREEZE = 140;
     public static final int FREEZE_HURT_FREQUENCY = 40;
-    private static final AABB INITIAL_AABB = new AABB(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-    private static final double WATER_FLOW_SCALE = 0.014;
-    private static final double LAVA_FAST_FLOW_SCALE = 0.007;
-    private static final double LAVA_SLOW_FLOW_SCALE = 0.0023333333333333335;
+    private static final AABB INITIAL_AABB = new AABB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+    private static final double WATER_FLOW_SCALE = 0.014D;
+    private static final double LAVA_FAST_FLOW_SCALE = 0.007D;
+    private static final double LAVA_SLOW_FLOW_SCALE = 0.0023333333333333335D;
     public static final String UUID_TAG = "UUID";
-    private static double viewScale = 1.0;
+    private static double viewScale = 1.0D;
     private final EntityType<?> type;
-    private int id = ENTITY_COUNTER.incrementAndGet();
+    private int id;
     public boolean blocksBuilding;
-    private ImmutableList<Entity> passengers = ImmutableList.of();
+    public ImmutableList<Entity> passengers;
     protected int boardingCooldown;
     @Nullable
     private Entity vehicle;
@@ -159,19 +217,19 @@
     private Vec3 position;
     private BlockPos blockPosition;
     private ChunkPos chunkPosition;
-    private Vec3 deltaMovement = Vec3.ZERO;
+    private Vec3 deltaMovement;
     private float yRot;
     private float xRot;
     public float yRotO;
     public float xRotO;
-    private AABB bb = INITIAL_AABB;
-    private boolean onGround;
+    private AABB bb;
+    public boolean onGround;
     public boolean horizontalCollision;
     public boolean verticalCollision;
     public boolean verticalCollisionBelow;
     public boolean minorHorizontalCollision;
     public boolean hurtMarked;
-    protected Vec3 stuckSpeedMultiplier = Vec3.ZERO;
+    protected Vec3 stuckSpeedMultiplier;
     @Nullable
     private Entity.RemovalReason removalReason;
     public static final float DEFAULT_BB_WIDTH = 0.6F;
@@ -181,21 +239,21 @@
     public float moveDist;
     public float flyDist;
     public float fallDistance;
-    private float nextStep = 1.0F;
+    private float nextStep;
     public double xOld;
     public double yOld;
     public double zOld;
     private float maxUpStep;
     public boolean noPhysics;
-    protected final RandomSource random = RandomSource.create();
+    public final RandomSource random;
     public int tickCount;
-    private int remainingFireTicks = -this.getFireImmuneTicks();
-    protected boolean wasTouchingWater;
-    protected Object2DoubleMap<TagKey<Fluid>> fluidHeight = new Object2DoubleArrayMap<>(2);
+    private int remainingFireTicks;
+    public boolean wasTouchingWater;
+    protected Object2DoubleMap<TagKey<Fluid>> fluidHeight;
     protected boolean wasEyeInWater;
-    private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
+    private final Set<TagKey<Fluid>> fluidOnEyes;
     public int invulnerableTime;
-    protected boolean firstTick = true;
+    protected boolean firstTick;
     protected final SynchedEntityData entityData;
     protected static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
     protected static final int FLAG_ONFIRE = 0;
@@ -206,43 +264,84 @@
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
     private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
-    private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(
-        Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT
-    );
+    private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
     private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    protected static final EntityDataAccessor<Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
+    protected static final EntityDataAccessor<EntityPose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
     private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
-    private EntityInLevelCallback levelCallback = EntityInLevelCallback.NULL;
-    private final VecDeltaCodec packetPositionCodec = new VecDeltaCodec();
+    private EntityInLevelCallback levelCallback;
+    private final VecDeltaCodec packetPositionCodec;
     public boolean noCulling;
     public boolean hasImpulse;
-    private int portalCooldown;
+    public int portalCooldown;
     protected boolean isInsidePortal;
     protected int portalTime;
     protected BlockPos portalEntrancePos;
     private boolean invulnerable;
-    protected UUID uuid = Mth.createInsecureUUID(this.random);
-    protected String stringUUID = this.uuid.toString();
+    protected UUID uuid;
+    protected String stringUUID;
     private boolean hasGlowingTag;
-    private final Set<String> tags = Sets.newHashSet();
-    private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
+    private final Set<String> tags;
+    private final double[] pistonDeltas;
     private long pistonDeltasGameTime;
     private EntityDimensions dimensions;
     private float eyeHeight;
     public boolean isInPowderSnow;
     public boolean wasInPowderSnow;
     public boolean wasOnFire;
-    public Optional<BlockPos> mainSupportingBlockPos = Optional.empty();
-    private boolean onGroundNoBlocks = false;
+    public Optional<BlockPos> mainSupportingBlockPos;
+    private boolean onGroundNoBlocks;
     private float crystalSoundIntensity;
     private int lastCrystalSoundPlayTick;
-    private boolean hasVisualFire;
+    public boolean hasVisualFire;
     @Nullable
-    private BlockState feetBlockState = null;
+    private IBlockData feetBlockState;
+    // CraftBukkit start
+    public boolean persist = true;
+    public boolean visibleByDefault = true;
+    public boolean valid;
+    public boolean inWorld = false;
+    public boolean generation;
+    public int maxAirTicks = getDefaultMaxAirSupply(); // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+    public org.bukkit.projectiles.ProjectileSource projectileSource; // For projectiles only
+    public boolean lastDamageCancelled; // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Keep track if the event was canceled
+    public boolean persistentInvisibility = false;
+    public BlockPos lastLavaContact;
+    // Marks an entity, that it was removed by a plugin via Entity#remove
+    // Main use case currently is for SPIGOT-7487, preventing dropping of leash when leash is removed
+    public boolean pluginRemoved = false;
 
+    public float getBukkitYaw() {
+        return this.yRot;
+    }
+
+    public boolean isChunkLoaded() {
+        return level.hasChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4);
+    }
+    // CraftBukkit end
+
     public Entity(EntityType<?> entityType, Level level) {
+        this.id = Entity.ENTITY_COUNTER.incrementAndGet();
+        this.passengers = ImmutableList.of();
+        this.deltaMovement = Vec3.ZERO;
+        this.bb = Entity.INITIAL_AABB;
+        this.stuckSpeedMultiplier = Vec3.ZERO;
+        this.nextStep = 1.0F;
+        this.random = RandomSource.create();
+        this.remainingFireTicks = -this.getFireImmuneTicks();
+        this.fluidHeight = new Object2DoubleArrayMap(2);
+        this.fluidOnEyes = new HashSet();
+        this.firstTick = true;
+        this.levelCallback = EntityInLevelCallback.NULL;
+        this.packetPositionCodec = new VecDeltaCodec();
+        this.uuid = Mth.createInsecureUUID(this.random);
+        this.stringUUID = this.uuid.toString();
+        this.tags = Sets.newHashSet();
+        this.pistonDeltas = new double[]{0.0D, 0.0D, 0.0D};
+        this.mainSupportingBlockPos = Optional.empty();
+        this.onGroundNoBlocks = false;
+        this.feetBlockState = null;
         this.type = entityType;
         this.level = level;
         this.dimensions = entityType.getDimensions();
@@ -250,28 +349,30 @@
         this.blockPosition = BlockPos.ZERO;
         this.chunkPosition = ChunkPos.ZERO;
         this.entityData = new SynchedEntityData(this);
-        this.entityData.define(DATA_SHARED_FLAGS_ID, (byte)0);
-        this.entityData.define(DATA_AIR_SUPPLY_ID, this.getMaxAirSupply());
-        this.entityData.define(DATA_CUSTOM_NAME_VISIBLE, false);
-        this.entityData.define(DATA_CUSTOM_NAME, Optional.empty());
-        this.entityData.define(DATA_SILENT, false);
-        this.entityData.define(DATA_NO_GRAVITY, false);
-        this.entityData.define(DATA_POSE, Pose.STANDING);
-        this.entityData.define(DATA_TICKS_FROZEN, 0);
+        this.entityData.define(Entity.DATA_SHARED_FLAGS_ID, (byte) 0);
+        this.entityData.define(Entity.DATA_AIR_SUPPLY_ID, this.getMaxAirSupply());
+        this.entityData.define(Entity.DATA_CUSTOM_NAME_VISIBLE, false);
+        this.entityData.define(Entity.DATA_CUSTOM_NAME, Optional.empty());
+        this.entityData.define(Entity.DATA_SILENT, false);
+        this.entityData.define(Entity.DATA_NO_GRAVITY, false);
+        this.entityData.define(Entity.DATA_POSE, EntityPose.STANDING);
+        this.entityData.define(Entity.DATA_TICKS_FROZEN, 0);
         this.defineSynchedData();
-        this.setPos(0.0, 0.0, 0.0);
-        this.eyeHeight = this.getEyeHeight(Pose.STANDING, this.dimensions);
+        this.setPos(0.0D, 0.0D, 0.0D);
+        this.eyeHeight = this.getEyeHeight(EntityPose.STANDING, this.dimensions);
     }
 
-    public boolean isColliding(BlockPos pos, BlockState state) {
-        VoxelShape collisionShape = state.getCollisionShape(this.level(), pos, CollisionContext.of(this));
-        VoxelShape voxelShape = collisionShape.move((double)pos.getX(), (double)pos.getY(), (double)pos.getZ());
-        return Shapes.joinIsNotEmpty(voxelShape, Shapes.create(this.getBoundingBox()), BooleanOp.AND);
+    public boolean isColliding(BlockPos pos, IBlockData state) {
+        VoxelShape voxelshape = state.getCollisionShape(this.level(), pos, CollisionContext.of(this));
+        VoxelShape voxelshape1 = voxelshape.move((double) pos.getX(), (double) pos.getY(), (double) pos.getZ());
+
+        return Shapes.joinIsNotEmpty(voxelshape1, Shapes.create(this.getBoundingBox()), BooleanOp.AND);
     }
 
     public int getTeamColor() {
-        Team team = this.getTeam();
-        return team != null && team.getColor().getColor() != null ? team.getColor().getColor() : 16777215;
+        PlayerTeam scoreboardteam = this.getTeam();
+
+        return scoreboardteam != null && scoreboardteam.getColor().getColor() != null ? scoreboardteam.getColor().getColor() : 16777215;
     }
 
     public boolean isSpectator() {
@@ -286,10 +387,11 @@
         if (this.isPassenger()) {
             this.stopRiding();
         }
+
     }
 
-    public void syncPacketPositionCodec(double x, double y, double z) {
-        this.packetPositionCodec.setBase(new Vec3(x, y, z));
+    public void syncPacketPositionCodec(double x, double d1, double y) {
+        this.packetPositionCodec.setBase(new Vec3(x, d1, y));
     }
 
     public VecDeltaCodec getPositionCodec() {
@@ -314,7 +416,7 @@
     }
 
     public boolean addTag(String tag) {
-        return this.tags.size() < 1024 && this.tags.add(tag);
+        return this.tags.size() >= 1024 ? false : this.tags.add(tag);
     }
 
     public boolean removeTag(String tag) {
@@ -336,12 +438,10 @@
         return this.entityData;
     }
 
-    @Override
     public boolean equals(Object object) {
-        return object instanceof Entity && ((Entity)object).id == this.id;
+        return object instanceof Entity ? ((Entity) object).id == this.id : false;
     }
 
-    @Override
     public int hashCode() {
         return this.id;
     }
@@ -350,18 +450,23 @@
         this.setRemoved(reason);
     }
 
-    public void onClientRemoval() {
-    }
+    public void onClientRemoval() {}
 
-    public void setPose(Pose pose) {
-        this.entityData.set(DATA_POSE, pose);
+    public void setPose(EntityPose pose) {
+        // CraftBukkit start
+        if (pose == this.getPose()) {
+            return;
+        }
+        this.level.getCraftServer().getPluginManager().callEvent(new EntityPoseChangeEvent(this.getBukkitEntity(), Pose.values()[pose.ordinal()]));
+        // CraftBukkit end
+        this.entityData.set(Entity.DATA_POSE, pose);
     }
 
-    public Pose getPose() {
-        return this.entityData.get(DATA_POSE);
+    public EntityPose getPose() {
+        return (EntityPose) this.entityData.get(Entity.DATA_POSE);
     }
 
-    public boolean hasPose(Pose pose) {
+    public boolean hasPose(EntityPose pose) {
         return this.getPose() == pose;
     }
 
@@ -369,14 +474,42 @@
         return this.position().closerThan(entity.position(), distance);
     }
 
-    public boolean closerThan(Entity entity, double horizontalDistance, double verticalDistance) {
-        double d = entity.getX() - this.getX();
-        double d1 = entity.getY() - this.getY();
-        double d2 = entity.getZ() - this.getZ();
-        return Mth.lengthSquared(d, d2) < Mth.square(horizontalDistance) && Mth.square(d1) < Mth.square(verticalDistance);
+    public boolean closerThan(Entity entity, double horizontalDistance, double d1) {
+        double d2 = entity.getX() - this.getX();
+        double d3 = entity.getY() - this.getY();
+        double d4 = entity.getZ() - this.getZ();
+
+        return Mth.lengthSquared(d2, d4) < Mth.square(horizontalDistance) && Mth.square(d3) < Mth.square(d1);
     }
 
     protected void setRot(float yRot, float xRot) {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(yRot)) {
+            yRot = 0;
+        }
+
+        if (yRot == Float.POSITIVE_INFINITY || yRot == Float.NEGATIVE_INFINITY) {
+            if (this instanceof ServerPlayer) {
+                this.level.getCraftServer().getLogger().warning(this.getScoreboardName() + " was caught trying to crash the server with an invalid yaw");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)");
+            }
+            yRot = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(xRot)) {
+            xRot = 0;
+        }
+
+        if (xRot == Float.POSITIVE_INFINITY || xRot == Float.NEGATIVE_INFINITY) {
+            if (this instanceof ServerPlayer) {
+                this.level.getCraftServer().getLogger().warning(this.getScoreboardName() + " was caught trying to crash the server with an invalid pitch");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)");
+            }
+            xRot = 0;
+        }
+        // CraftBukkit end
+
         this.setYRot(yRot % 360.0F);
         this.setXRot(xRot % 360.0F);
     }
@@ -385,8 +518,8 @@
         this.setPos(pos.x(), pos.y(), pos.z());
     }
 
-    public void setPos(double x, double y, double z) {
-        this.setPosRaw(x, y, z);
+    public void setPos(double x, double d1, double y) {
+        this.setPosRaw(x, d1, y);
         this.setBoundingBox(this.makeBoundingBox());
     }
 
@@ -398,9 +531,10 @@
         this.setPos(this.position.x, this.position.y, this.position.z);
     }
 
-    public void turn(double yRot, double xRot) {
-        float f = (float)xRot * 0.15F;
-        float f1 = (float)yRot * 0.15F;
+    public void turn(double yRot, double d1) {
+        float f = (float) d1 * 0.15F;
+        float f1 = (float) yRot * 0.15F;
+
         this.setXRot(this.getXRot() + f);
         this.setYRot(this.getYRot() + f1);
         this.setXRot(Mth.clamp(this.getXRot(), -90.0F, 90.0F));
@@ -410,12 +544,22 @@
         if (this.vehicle != null) {
             this.vehicle.onPassengerTurned(this);
         }
+
     }
 
     public void tick() {
         this.baseTick();
     }
 
+    // CraftBukkit start
+    public void postTick() {
+        // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
+        if (!(this instanceof ServerPlayer)) {
+            this.handleNetherPortal();
+        }
+    }
+    // CraftBukkit end
+
     public void baseTick() {
         this.level().getProfiler().push("entityBaseTick");
         this.feetBlockState = null;
@@ -424,13 +568,13 @@
         }
 
         if (this.boardingCooldown > 0) {
-            this.boardingCooldown--;
+            --this.boardingCooldown;
         }
 
         this.walkDistO = this.walkDist;
         this.xRotO = this.getXRot();
         this.yRotO = this.getYRot();
-        this.handleNetherPortal();
+        if (this instanceof ServerPlayer) this.handleNetherPortal(); // CraftBukkit - // Moved up to postTick
         if (this.canSpawnSprintParticle()) {
             this.spawnSprintParticle();
         }
@@ -458,13 +602,17 @@
 
             if (this.getTicksFrozen() > 0) {
                 this.setTicksFrozen(0);
-                this.level().levelEvent(null, 1009, this.blockPosition, 1);
+                this.level().levelEvent((Player) null, 1009, this.blockPosition, 1);
             }
         }
 
         if (this.isInLava()) {
             this.lavaHurt();
             this.fallDistance *= 0.5F;
+            // CraftBukkit start
+        } else {
+            this.lastLavaContact = null;
+            // CraftBukkit end
         }
 
         this.checkBelowWorld();
@@ -481,9 +629,10 @@
     }
 
     public void checkBelowWorld() {
-        if (this.getY() < (double)(this.level().getMinBuildHeight() - 64)) {
+        if (this.getY() < (double) (this.level().getMinBuildHeight() - 64)) {
             this.onBelowWorld();
         }
+
     }
 
     public void setPortalCooldown() {
@@ -504,8 +653,9 @@
 
     protected void processPortalCooldown() {
         if (this.isOnPortalCooldown()) {
-            this.portalCooldown--;
+            --this.portalCooldown;
         }
+
     }
 
     public int getPortalWaitTime() {
@@ -514,22 +664,58 @@
 
     public void lavaHurt() {
         if (!this.fireImmune()) {
-            this.setSecondsOnFire(15);
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof net.minecraft.world.entity.LivingEntity && remainingFireTicks <= 0) {
+                // not on fire yet
+                org.bukkit.block.Block damager = (lastLavaContact == null) ? null : org.bukkit.craftbukkit.block.CraftBlock.at(level, lastLavaContact);
+                org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                this.level.getCraftServer().getPluginManager().callEvent(combustEvent);
+
+                if (!combustEvent.isCancelled()) {
+                    this.setSecondsOnFire(combustEvent.getDuration(), false);
+                }
+            } else {
+                // This will be called every single tick the entity is in lava, so don't throw an event
+                this.setSecondsOnFire(15, false);
+            }
+            CraftEventFactory.blockDamage = (lastLavaContact) == null ? null : org.bukkit.craftbukkit.block.CraftBlock.at(level, lastLavaContact);
             if (this.hurt(this.damageSources().lava(), 4.0F)) {
                 this.playSound(SoundEvents.GENERIC_BURN, 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
             }
+            CraftEventFactory.blockDamage = null;
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
+
         }
     }
 
     public void setSecondsOnFire(int seconds) {
-        int i = seconds * 20;
-        if (this instanceof LivingEntity) {
-            i = ProtectionEnchantment.getFireAfterDampener((LivingEntity)this, i);
+        // CraftBukkit start
+        this.setSecondsOnFire(seconds, true);
+    }
+
+    public void setSecondsOnFire(int i, boolean callEvent) {
+        if (callEvent) {
+            EntityCombustEvent event = new EntityCombustEvent(this.getBukkitEntity(), i);
+            this.level.getCraftServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+
+            i = event.getDuration();
         }
+        // CraftBukkit end
+        int j = i * 20;
 
-        if (this.remainingFireTicks < i) {
-            this.setRemainingFireTicks(i);
+        if (this instanceof net.minecraft.world.entity.LivingEntity) {
+            j = ProtectionEnchantment.getFireAfterDampener((net.minecraft.world.entity.LivingEntity) this, j);
         }
+
+        if (this.remainingFireTicks < j) {
+            this.setRemainingFireTicks(j);
+        }
+
     }
 
     public void setRemainingFireTicks(int remainingFireTicks) {
@@ -548,8 +734,8 @@
         this.discard();
     }
 
-    public boolean isFree(double x, double y, double z) {
-        return this.isFree(this.getBoundingBox().move(x, y, z));
+    public boolean isFree(double x, double d1, double y) {
+        return this.isFree(this.getBoundingBox().move(x, d1, y));
     }
 
     private boolean isFree(AABB box) {
@@ -558,7 +744,7 @@
 
     public void setOnGround(boolean onGround) {
         this.onGround = onGround;
-        this.checkSupportingBlock(onGround, null);
+        this.checkSupportingBlock(onGround, (Vec3) null);
     }
 
     public void setOnGroundWithKnownMovement(boolean onGround, Vec3 movement) {
@@ -567,20 +753,24 @@
     }
 
     public boolean isSupportedBy(BlockPos pos) {
-        return this.mainSupportingBlockPos.isPresent() && this.mainSupportingBlockPos.get().equals(pos);
+        return this.mainSupportingBlockPos.isPresent() && ((BlockPos) this.mainSupportingBlockPos.get()).equals(pos);
     }
 
     protected void checkSupportingBlock(boolean onGround, @Nullable Vec3 movement) {
         if (onGround) {
-            AABB boundingBox = this.getBoundingBox();
-            AABB aABB = new AABB(boundingBox.minX, boundingBox.minY - 1.0E-6, boundingBox.minZ, boundingBox.maxX, boundingBox.minY, boundingBox.maxZ);
-            Optional<BlockPos> optional = this.level.findSupportingBlock(this, aABB);
-            if (optional.isPresent() || this.onGroundNoBlocks) {
+            AABB axisalignedbb = this.getBoundingBox();
+            AABB axisalignedbb1 = new AABB(axisalignedbb.minX, axisalignedbb.minY - 1.0E-6D, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxZ);
+            Optional<BlockPos> optional = this.level.findSupportingBlock(this, axisalignedbb1);
+
+            if (!optional.isPresent() && !this.onGroundNoBlocks) {
+                if (movement != null) {
+                    AABB axisalignedbb2 = axisalignedbb1.move(-movement.x, 0.0D, -movement.z);
+
+                    optional = this.level.findSupportingBlock(this, axisalignedbb2);
+                    this.mainSupportingBlockPos = optional;
+                }
+            } else {
                 this.mainSupportingBlockPos = optional;
-            } else if (movement != null) {
-                AABB aABB1 = aABB.move(-movement.x, 0.0, -movement.z);
-                optional = this.level.findSupportingBlock(this, aABB1);
-                this.mainSupportingBlockPos = optional;
             }
 
             this.onGroundNoBlocks = optional.isEmpty();
@@ -590,18 +780,19 @@
                 this.mainSupportingBlockPos = Optional.empty();
             }
         }
+
     }
 
     public boolean onGround() {
         return this.onGround;
     }
 
-    public void move(MoverType type, Vec3 pos) {
+    public void move(EnumMoveType type, Vec3 pos) {
         if (this.noPhysics) {
             this.setPos(this.getX() + pos.x, this.getY() + pos.y, this.getZ() + pos.z);
         } else {
             this.wasOnFire = this.isOnFire();
-            if (type == MoverType.PISTON) {
+            if (type == EnumMoveType.PISTON) {
                 pos = this.limitPistonMovement(pos);
                 if (pos.equals(Vec3.ZERO)) {
                     return;
@@ -609,108 +800,138 @@
             }
 
             this.level().getProfiler().push("move");
-            if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7) {
+            if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
                 pos = pos.multiply(this.stuckSpeedMultiplier);
                 this.stuckSpeedMultiplier = Vec3.ZERO;
                 this.setDeltaMovement(Vec3.ZERO);
             }
 
-            Vec3 var23 = this.maybeBackOffFromEdge(pos, type);
-            Vec3 vec3 = this.collide(var23);
-            double d = vec3.lengthSqr();
-            if (d > 1.0E-7) {
-                if (this.fallDistance != 0.0F && d >= 1.0) {
-                    BlockHitResult blockHitResult = this.level()
-                        .clip(
-                            new ClipContext(this.position(), this.position().add(vec3), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this)
-                        );
-                    if (blockHitResult.getType() != HitResult.Type.MISS) {
+            pos = this.maybeBackOffFromEdge(pos, type);
+            Vec3 vec3d1 = this.collide(pos);
+            double d0 = vec3d1.lengthSqr();
+
+            if (d0 > 1.0E-7D) {
+                if (this.fallDistance != 0.0F && d0 >= 1.0D) {
+                    BlockHitResult movingobjectpositionblock = this.level().clip(new ClipContext(this.position(), this.position().add(vec3d1), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this));
+
+                    if (movingobjectpositionblock.getType() != HitResult.EnumMovingObjectType.MISS) {
                         this.resetFallDistance();
                     }
                 }
 
-                this.setPos(this.getX() + vec3.x, this.getY() + vec3.y, this.getZ() + vec3.z);
+                this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
             }
 
             this.level().getProfiler().pop();
             this.level().getProfiler().push("rest");
-            boolean flag = !Mth.equal(var23.x, vec3.x);
-            boolean flag1 = !Mth.equal(var23.z, vec3.z);
+            boolean flag = !Mth.equal(pos.x, vec3d1.x);
+            boolean flag1 = !Mth.equal(pos.z, vec3d1.z);
+
             this.horizontalCollision = flag || flag1;
-            this.verticalCollision = var23.y != vec3.y;
-            this.verticalCollisionBelow = this.verticalCollision && var23.y < 0.0;
+            this.verticalCollision = pos.y != vec3d1.y;
+            this.verticalCollisionBelow = this.verticalCollision && pos.y < 0.0D;
             if (this.horizontalCollision) {
-                this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3);
+                this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3d1);
             } else {
                 this.minorHorizontalCollision = false;
             }
 
-            this.setOnGroundWithKnownMovement(this.verticalCollisionBelow, vec3);
-            BlockPos onPosLegacy = this.getOnPosLegacy();
-            BlockState blockState = this.level().getBlockState(onPosLegacy);
-            this.checkFallDamage(vec3.y, this.onGround(), blockState, onPosLegacy);
+            this.setOnGroundWithKnownMovement(this.verticalCollisionBelow, vec3d1);
+            BlockPos blockposition = this.getOnPosLegacy();
+            IBlockData iblockdata = this.level().getBlockState(blockposition);
+
+            this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
             if (this.isRemoved()) {
                 this.level().getProfiler().pop();
             } else {
                 if (this.horizontalCollision) {
-                    Vec3 deltaMovement = this.getDeltaMovement();
-                    this.setDeltaMovement(flag ? 0.0 : deltaMovement.x, deltaMovement.y, flag1 ? 0.0 : deltaMovement.z);
+                    Vec3 vec3d2 = this.getDeltaMovement();
+
+                    this.setDeltaMovement(flag ? 0.0D : vec3d2.x, vec3d2.y, flag1 ? 0.0D : vec3d2.z);
                 }
 
-                Block block = blockState.getBlock();
-                if (var23.y != vec3.y) {
+                Block block = iblockdata.getBlock();
+
+                if (pos.y != vec3d1.y) {
                     block.updateEntityAfterFallOn(this.level(), this);
                 }
 
+                // CraftBukkit start
+                if (horizontalCollision && getBukkitEntity() instanceof Vehicle) {
+                    Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                    org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
+
+                    if (pos.x > vec3d1.x) {
+                        bl = bl.getRelative(BlockFace.EAST);
+                    } else if (pos.x < vec3d1.x) {
+                        bl = bl.getRelative(BlockFace.WEST);
+                    } else if (pos.z > vec3d1.z) {
+                        bl = bl.getRelative(BlockFace.SOUTH);
+                    } else if (pos.z < vec3d1.z) {
+                        bl = bl.getRelative(BlockFace.NORTH);
+                    }
+
+                    if (!bl.getType().isAir()) {
+                        VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                        level.getCraftServer().getPluginManager().callEvent(event);
+                    }
+                }
+                // CraftBukkit end
+
                 if (this.onGround()) {
-                    block.stepOn(this.level(), onPosLegacy, blockState, this);
+                    block.stepOn(this.level(), blockposition, iblockdata, this);
                 }
 
-                Entity.MovementEmission movementEmission = this.getMovementEmission();
-                if (movementEmission.emitsAnything() && !this.isPassenger()) {
-                    double d1 = vec3.x;
-                    double d2 = vec3.y;
-                    double d3 = vec3.z;
-                    this.flyDist = this.flyDist + (float)(vec3.length() * 0.6);
-                    BlockPos onPos = this.getOnPos();
-                    BlockState blockState1 = this.level().getBlockState(onPos);
-                    boolean isStateClimbable = this.isStateClimbable(blockState1);
-                    if (!isStateClimbable) {
-                        d2 = 0.0;
+                Entity.MovementEmission entity_movementemission = this.getMovementEmission();
+
+                if (entity_movementemission.emitsAnything() && !this.isPassenger()) {
+                    double d1 = vec3d1.x;
+                    double d2 = vec3d1.y;
+                    double d3 = vec3d1.z;
+
+                    this.flyDist += (float) (vec3d1.length() * 0.6D);
+                    BlockPos blockposition1 = this.getOnPos();
+                    IBlockData iblockdata1 = this.level().getBlockState(blockposition1);
+                    boolean flag2 = this.isStateClimbable(iblockdata1);
+
+                    if (!flag2) {
+                        d2 = 0.0D;
                     }
 
-                    this.walkDist = this.walkDist + (float)vec3.horizontalDistance() * 0.6F;
-                    this.moveDist = this.moveDist + (float)Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3) * 0.6F;
-                    if (this.moveDist > this.nextStep && !blockState1.isAir()) {
-                        boolean flag2 = onPos.equals(onPosLegacy);
-                        boolean flag3 = this.vibrationAndSoundEffectsFromBlock(onPosLegacy, blockState, movementEmission.emitsSounds(), flag2, var23);
-                        if (!flag2) {
-                            flag3 |= this.vibrationAndSoundEffectsFromBlock(onPos, blockState1, false, movementEmission.emitsEvents(), var23);
+                    this.walkDist += (float) vec3d1.horizontalDistance() * 0.6F;
+                    this.moveDist += (float) Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3) * 0.6F;
+                    if (this.moveDist > this.nextStep && !iblockdata1.isAir()) {
+                        boolean flag3 = blockposition1.equals(blockposition);
+                        boolean flag4 = this.vibrationAndSoundEffectsFromBlock(blockposition, iblockdata, entity_movementemission.emitsSounds(), flag3, pos);
+
+                        if (!flag3) {
+                            flag4 |= this.vibrationAndSoundEffectsFromBlock(blockposition1, iblockdata1, false, entity_movementemission.emitsEvents(), pos);
                         }
 
-                        if (flag3) {
+                        if (flag4) {
                             this.nextStep = this.nextStep();
                         } else if (this.isInWater()) {
                             this.nextStep = this.nextStep();
-                            if (movementEmission.emitsSounds()) {
+                            if (entity_movementemission.emitsSounds()) {
                                 this.waterSwimSound();
                             }
 
-                            if (movementEmission.emitsEvents()) {
+                            if (entity_movementemission.emitsEvents()) {
                                 this.gameEvent(GameEvent.SWIM);
                             }
                         }
-                    } else if (blockState1.isAir()) {
+                    } else if (iblockdata1.isAir()) {
                         this.processFlappingMovement();
                     }
                 }
 
                 this.tryCheckInsideBlocks();
-                float blockSpeedFactor = this.getBlockSpeedFactor();
-                this.setDeltaMovement(this.getDeltaMovement().multiply((double)blockSpeedFactor, 1.0, (double)blockSpeedFactor));
-                if (this.level()
-                    .getBlockStatesIfLoaded(this.getBoundingBox().deflate(1.0E-6))
-                    .noneMatch(loadedState -> loadedState.is(BlockTags.FIRE) || loadedState.is(Blocks.LAVA))) {
+                float f = this.getBlockSpeedFactor();
+
+                this.setDeltaMovement(this.getDeltaMovement().multiply((double) f, 1.0D, (double) f));
+                if (this.level().getBlockStatesIfLoaded(this.getBoundingBox().deflate(1.0E-6D)).noneMatch((iblockdata2) -> {
+                    return iblockdata2.is(BlockTags.FIRE) || iblockdata2.is(Blocks.LAVA);
+                })) {
                     if (this.remainingFireTicks <= 0) {
                         this.setRemainingFireTicks(-this.getFireImmuneTicks());
                     }
@@ -729,16 +950,17 @@
         }
     }
 
-    private boolean isStateClimbable(BlockState state) {
+    private boolean isStateClimbable(IBlockData state) {
         return state.is(BlockTags.CLIMBABLE) || state.is(Blocks.POWDER_SNOW);
     }
 
-    private boolean vibrationAndSoundEffectsFromBlock(BlockPos pos, BlockState state, boolean playStepSound, boolean broadcastGameEvent, Vec3 vec3) {
+    private boolean vibrationAndSoundEffectsFromBlock(BlockPos pos, IBlockData state, boolean playStepSound, boolean broadcastGameEvent, Vec3 vec3d) {
         if (state.isAir()) {
             return false;
         } else {
-            boolean isStateClimbable = this.isStateClimbable(state);
-            if ((this.onGround() || isStateClimbable || this.isCrouching() && vec3.y == 0.0 || this.isOnRails()) && !this.isSwimming()) {
+            boolean flag2 = this.isStateClimbable(state);
+
+            if ((this.onGround() || flag2 || this.isCrouching() && vec3d.y == 0.0D || this.isOnRails()) && !this.isSwimming()) {
                 if (playStepSound) {
                     this.walkingStepSound(pos, state);
                 }
@@ -761,11 +983,12 @@
     protected void tryCheckInsideBlocks() {
         try {
             this.checkInsideBlocks();
-        } catch (Throwable var4) {
-            CrashReport crashReport = CrashReport.forThrowable(var4, "Checking entity block collision");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being checked for collision");
-            this.fillCrashReportCategory(crashReportCategory);
-            throw new ReportedException(crashReport);
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.forThrowable(throwable, "Checking entity block collision");
+            CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Entity being checked for collision");
+
+            this.fillCrashReportCategory(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
         }
     }
 
@@ -788,8 +1011,10 @@
                 this.gameEvent(GameEvent.FLAP);
             }
         }
+
     }
 
+    /** @deprecated */
     @Deprecated
     public BlockPos getOnPosLegacy() {
         return this.getOnPos(0.2F);
@@ -805,66 +1030,64 @@
 
     protected BlockPos getOnPos(float yOffset) {
         if (this.mainSupportingBlockPos.isPresent()) {
-            BlockPos blockPos = this.mainSupportingBlockPos.get();
-            if (!(yOffset > 1.0E-5F)) {
-                return blockPos;
+            BlockPos blockposition = (BlockPos) this.mainSupportingBlockPos.get();
+
+            if (yOffset <= 1.0E-5F) {
+                return blockposition;
             } else {
-                BlockState blockState = this.level().getBlockState(blockPos);
-                return (!((double)yOffset <= 0.5) || !blockState.is(BlockTags.FENCES))
-                        && !blockState.is(BlockTags.WALLS)
-                        && !(blockState.getBlock() instanceof FenceGateBlock)
-                    ? blockPos.atY(Mth.floor(this.position.y - (double)yOffset))
-                    : blockPos;
+                IBlockData iblockdata = this.level().getBlockState(blockposition);
+
+                return ((double) yOffset > 0.5D || !iblockdata.is(BlockTags.FENCES)) && !iblockdata.is(BlockTags.WALLS) && !(iblockdata.getBlock() instanceof FenceGateBlock) ? blockposition.atY(Mth.floor(this.position.y - (double) yOffset)) : blockposition;
             }
         } else {
-            int floor = Mth.floor(this.position.x);
-            int floor1 = Mth.floor(this.position.y - (double)yOffset);
-            int floor2 = Mth.floor(this.position.z);
-            return new BlockPos(floor, floor1, floor2);
+            int i = Mth.floor(this.position.x);
+            int j = Mth.floor(this.position.y - (double) yOffset);
+            int k = Mth.floor(this.position.z);
+
+            return new BlockPos(i, j, k);
         }
     }
 
     protected float getBlockJumpFactor() {
-        float jumpFactor = this.level().getBlockState(this.blockPosition()).getBlock().getJumpFactor();
-        float jumpFactor1 = this.level().getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).getBlock().getJumpFactor();
-        return (double)jumpFactor == 1.0 ? jumpFactor1 : jumpFactor;
+        float f = this.level().getBlockState(this.blockPosition()).getBlock().getJumpFactor();
+        float f1 = this.level().getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).getBlock().getJumpFactor();
+
+        return (double) f == 1.0D ? f1 : f;
     }
 
     protected float getBlockSpeedFactor() {
-        BlockState blockState = this.level().getBlockState(this.blockPosition());
-        float speedFactor = blockState.getBlock().getSpeedFactor();
-        if (!blockState.is(Blocks.WATER) && !blockState.is(Blocks.BUBBLE_COLUMN)) {
-            return (double)speedFactor == 1.0
-                ? this.level().getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).getBlock().getSpeedFactor()
-                : speedFactor;
-        } else {
-            return speedFactor;
-        }
+        IBlockData iblockdata = this.level().getBlockState(this.blockPosition());
+        float f = iblockdata.getBlock().getSpeedFactor();
+
+        return !iblockdata.is(Blocks.WATER) && !iblockdata.is(Blocks.BUBBLE_COLUMN) ? ((double) f == 1.0D ? this.level().getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).getBlock().getSpeedFactor() : f) : f;
     }
 
-    protected Vec3 maybeBackOffFromEdge(Vec3 vec, MoverType mover) {
+    protected Vec3 maybeBackOffFromEdge(Vec3 vec, EnumMoveType mover) {
         return vec;
     }
 
     protected Vec3 limitPistonMovement(Vec3 pos) {
-        if (pos.lengthSqr() <= 1.0E-7) {
+        if (pos.lengthSqr() <= 1.0E-7D) {
             return pos;
         } else {
-            long gameTime = this.level().getGameTime();
-            if (gameTime != this.pistonDeltasGameTime) {
-                Arrays.fill(this.pistonDeltas, 0.0);
-                this.pistonDeltasGameTime = gameTime;
+            long i = this.level().getGameTime();
+
+            if (i != this.pistonDeltasGameTime) {
+                Arrays.fill(this.pistonDeltas, 0.0D);
+                this.pistonDeltasGameTime = i;
             }
 
-            if (pos.x != 0.0) {
-                double d = this.applyPistonMovementRestriction(Direction.Axis.X, pos.x);
-                return Math.abs(d) <= 1.0E-5F ? Vec3.ZERO : new Vec3(d, 0.0, 0.0);
-            } else if (pos.y != 0.0) {
-                double d = this.applyPistonMovementRestriction(Direction.Axis.Y, pos.y);
-                return Math.abs(d) <= 1.0E-5F ? Vec3.ZERO : new Vec3(0.0, d, 0.0);
-            } else if (pos.z != 0.0) {
-                double d = this.applyPistonMovementRestriction(Direction.Axis.Z, pos.z);
-                return Math.abs(d) <= 1.0E-5F ? Vec3.ZERO : new Vec3(0.0, 0.0, d);
+            double d0;
+
+            if (pos.x != 0.0D) {
+                d0 = this.applyPistonMovementRestriction(Direction.Axis.X, pos.x);
+                return Math.abs(d0) <= 9.999999747378752E-6D ? Vec3.ZERO : new Vec3(d0, 0.0D, 0.0D);
+            } else if (pos.y != 0.0D) {
+                d0 = this.applyPistonMovementRestriction(Direction.Axis.Y, pos.y);
+                return Math.abs(d0) <= 9.999999747378752E-6D ? Vec3.ZERO : new Vec3(0.0D, d0, 0.0D);
+            } else if (pos.z != 0.0D) {
+                d0 = this.applyPistonMovementRestriction(Direction.Axis.Z, pos.z);
+                return Math.abs(d0) <= 9.999999747378752E-6D ? Vec3.ZERO : new Vec3(0.0D, 0.0D, d0);
             } else {
                 return Vec3.ZERO;
             }
@@ -873,50 +1096,54 @@
 
     private double applyPistonMovementRestriction(Direction.Axis axis, double distance) {
         int i = axis.ordinal();
-        double d = Mth.clamp(distance + this.pistonDeltas[i], -0.51, 0.51);
-        distance = d - this.pistonDeltas[i];
-        this.pistonDeltas[i] = d;
+        double d1 = Mth.clamp(distance + this.pistonDeltas[i], -0.51D, 0.51D);
+
+        distance = d1 - this.pistonDeltas[i];
+        this.pistonDeltas[i] = d1;
         return distance;
     }
 
     private Vec3 collide(Vec3 vec) {
-        AABB boundingBox = this.getBoundingBox();
-        List<VoxelShape> entityCollisions = this.level().getEntityCollisions(this, boundingBox.expandTowards(vec));
-        Vec3 vec3 = vec.lengthSqr() == 0.0 ? vec : collideBoundingBox(this, vec, boundingBox, this.level(), entityCollisions);
-        boolean flag = vec.x != vec3.x;
-        boolean flag1 = vec.y != vec3.y;
-        boolean flag2 = vec.z != vec3.z;
-        boolean flag3 = this.onGround() || flag1 && vec.y < 0.0;
+        AABB axisalignedbb = this.getBoundingBox();
+        List<VoxelShape> list = this.level().getEntityCollisions(this, axisalignedbb.expandTowards(vec));
+        Vec3 vec3d1 = vec.lengthSqr() == 0.0D ? vec : collideBoundingBox(this, vec, axisalignedbb, this.level(), list);
+        boolean flag = vec.x != vec3d1.x;
+        boolean flag1 = vec.y != vec3d1.y;
+        boolean flag2 = vec.z != vec3d1.z;
+        boolean flag3 = this.onGround() || flag1 && vec.y < 0.0D;
+
         if (this.maxUpStep() > 0.0F && flag3 && (flag || flag2)) {
-            Vec3 vec31 = collideBoundingBox(this, new Vec3(vec.x, (double)this.maxUpStep(), vec.z), boundingBox, this.level(), entityCollisions);
-            Vec3 vec32 = collideBoundingBox(
-                this, new Vec3(0.0, (double)this.maxUpStep(), 0.0), boundingBox.expandTowards(vec.x, 0.0, vec.z), this.level(), entityCollisions
-            );
-            if (vec32.y < (double)this.maxUpStep()) {
-                Vec3 vec33 = collideBoundingBox(this, new Vec3(vec.x, 0.0, vec.z), boundingBox.move(vec32), this.level(), entityCollisions).add(vec32);
-                if (vec33.horizontalDistanceSqr() > vec31.horizontalDistanceSqr()) {
-                    vec31 = vec33;
+            Vec3 vec3d2 = collideBoundingBox(this, new Vec3(vec.x, (double) this.maxUpStep(), vec.z), axisalignedbb, this.level(), list);
+            Vec3 vec3d3 = collideBoundingBox(this, new Vec3(0.0D, (double) this.maxUpStep(), 0.0D), axisalignedbb.expandTowards(vec.x, 0.0D, vec.z), this.level(), list);
+
+            if (vec3d3.y < (double) this.maxUpStep()) {
+                Vec3 vec3d4 = collideBoundingBox(this, new Vec3(vec.x, 0.0D, vec.z), axisalignedbb.move(vec3d3), this.level(), list).add(vec3d3);
+
+                if (vec3d4.horizontalDistanceSqr() > vec3d2.horizontalDistanceSqr()) {
+                    vec3d2 = vec3d4;
                 }
             }
 
-            if (vec31.horizontalDistanceSqr() > vec3.horizontalDistanceSqr()) {
-                return vec31.add(collideBoundingBox(this, new Vec3(0.0, -vec31.y + vec.y, 0.0), boundingBox.move(vec31), this.level(), entityCollisions));
+            if (vec3d2.horizontalDistanceSqr() > vec3d1.horizontalDistanceSqr()) {
+                return vec3d2.add(collideBoundingBox(this, new Vec3(0.0D, -vec3d2.y + vec.y, 0.0D), axisalignedbb.move(vec3d2), this.level(), list));
             }
         }
 
-        return vec3;
+        return vec3d1;
     }
 
     public static Vec3 collideBoundingBox(@Nullable Entity entity, Vec3 vec, AABB collisionBox, Level level, List<VoxelShape> potentialHits) {
         Builder<VoxelShape> builder = ImmutableList.builderWithExpectedSize(potentialHits.size() + 1);
+
         if (!potentialHits.isEmpty()) {
             builder.addAll(potentialHits);
         }
 
-        WorldBorder worldBorder = level.getWorldBorder();
-        boolean flag = entity != null && worldBorder.isInsideCloseToBorder(entity, collisionBox.expandTowards(vec));
+        WorldBorder worldborder = level.getWorldBorder();
+        boolean flag = entity != null && worldborder.isInsideCloseToBorder(entity, collisionBox.expandTowards(vec));
+
         if (flag) {
-            builder.add(worldBorder.getCollisionShape());
+            builder.add(worldborder.getCollisionShape());
         }
 
         builder.addAll(level.getBlockCollisions(entity, collisionBox.expandTowards(vec)));
@@ -927,41 +1154,43 @@
         if (shapes.isEmpty()) {
             return deltaMovement;
         } else {
-            double d = deltaMovement.x;
+            double d0 = deltaMovement.x;
             double d1 = deltaMovement.y;
             double d2 = deltaMovement.z;
-            if (d1 != 0.0) {
+
+            if (d1 != 0.0D) {
                 d1 = Shapes.collide(Direction.Axis.Y, entityBB, shapes, d1);
-                if (d1 != 0.0) {
-                    entityBB = entityBB.move(0.0, d1, 0.0);
+                if (d1 != 0.0D) {
+                    entityBB = entityBB.move(0.0D, d1, 0.0D);
                 }
             }
 
-            boolean flag = Math.abs(d) < Math.abs(d2);
-            if (flag && d2 != 0.0) {
+            boolean flag = Math.abs(d0) < Math.abs(d2);
+
+            if (flag && d2 != 0.0D) {
                 d2 = Shapes.collide(Direction.Axis.Z, entityBB, shapes, d2);
-                if (d2 != 0.0) {
-                    entityBB = entityBB.move(0.0, 0.0, d2);
+                if (d2 != 0.0D) {
+                    entityBB = entityBB.move(0.0D, 0.0D, d2);
                 }
             }
 
-            if (d != 0.0) {
-                d = Shapes.collide(Direction.Axis.X, entityBB, shapes, d);
-                if (!flag && d != 0.0) {
-                    entityBB = entityBB.move(d, 0.0, 0.0);
+            if (d0 != 0.0D) {
+                d0 = Shapes.collide(Direction.Axis.X, entityBB, shapes, d0);
+                if (!flag && d0 != 0.0D) {
+                    entityBB = entityBB.move(d0, 0.0D, 0.0D);
                 }
             }
 
-            if (!flag && d2 != 0.0) {
+            if (!flag && d2 != 0.0D) {
                 d2 = Shapes.collide(Direction.Axis.Z, entityBB, shapes, d2);
             }
 
-            return new Vec3(d, d1, d2);
+            return new Vec3(d0, d1, d2);
         }
     }
 
     protected float nextStep() {
-        return (float)((int)this.moveDist + 1);
+        return (float) ((int) this.moveDist + 1);
     }
 
     protected SoundEvent getSwimSound() {
@@ -976,41 +1205,57 @@
         return SoundEvents.GENERIC_SPLASH;
     }
 
+    // CraftBukkit start - Add delegate methods
+    public SoundEvent getSwimSound0() {
+        return getSwimSound();
+    }
+
+    public SoundEvent getSwimSplashSound0() {
+        return getSwimSplashSound();
+    }
+
+    public SoundEvent getSwimHighSpeedSplashSound0() {
+        return getSwimHighSpeedSplashSound();
+    }
+    // CraftBukkit end
+
     protected void checkInsideBlocks() {
-        AABB boundingBox = this.getBoundingBox();
-        BlockPos blockPos = BlockPos.containing(boundingBox.minX + 1.0E-7, boundingBox.minY + 1.0E-7, boundingBox.minZ + 1.0E-7);
-        BlockPos blockPos1 = BlockPos.containing(boundingBox.maxX - 1.0E-7, boundingBox.maxY - 1.0E-7, boundingBox.maxZ - 1.0E-7);
-        if (this.level().hasChunksAt(blockPos, blockPos1)) {
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+        AABB axisalignedbb = this.getBoundingBox();
+        BlockPos blockposition = BlockPos.containing(axisalignedbb.minX + 1.0E-7D, axisalignedbb.minY + 1.0E-7D, axisalignedbb.minZ + 1.0E-7D);
+        BlockPos blockposition1 = BlockPos.containing(axisalignedbb.maxX - 1.0E-7D, axisalignedbb.maxY - 1.0E-7D, axisalignedbb.maxZ - 1.0E-7D);
 
-            for (int x = blockPos.getX(); x <= blockPos1.getX(); x++) {
-                for (int y = blockPos.getY(); y <= blockPos1.getY(); y++) {
-                    for (int z = blockPos.getZ(); z <= blockPos1.getZ(); z++) {
+        if (this.level().hasChunksAt(blockposition, blockposition1)) {
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+
+            for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
+                for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
+                    for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
                         if (!this.isAlive()) {
                             return;
                         }
 
-                        mutableBlockPos.set(x, y, z);
-                        BlockState blockState = this.level().getBlockState(mutableBlockPos);
+                        blockposition_mutableblockposition.set(i, j, k);
+                        IBlockData iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
 
                         try {
-                            blockState.entityInside(this.level(), mutableBlockPos, this);
-                            this.onInsideBlock(blockState);
-                        } catch (Throwable var12) {
-                            CrashReport crashReport = CrashReport.forThrowable(var12, "Colliding entity with block");
-                            CrashReportCategory crashReportCategory = crashReport.addCategory("Block being collided with");
-                            CrashReportCategory.populateBlockDetails(crashReportCategory, this.level(), mutableBlockPos, blockState);
-                            throw new ReportedException(crashReport);
+                            iblockdata.entityInside(this.level(), blockposition_mutableblockposition, this);
+                            this.onInsideBlock(iblockdata);
+                        } catch (Throwable throwable) {
+                            CrashReport crashreport = CrashReport.forThrowable(throwable, "Colliding entity with block");
+                            CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Block being collided with");
+
+                            CrashReportCategory.populateBlockDetails(crashreportsystemdetails, this.level(), blockposition_mutableblockposition, iblockdata);
+                            throw new ReportedException(crashreport);
                         }
                     }
                 }
             }
         }
-    }
 
-    protected void onInsideBlock(BlockState state) {
     }
 
+    protected void onInsideBlock(IBlockData state) {}
+
     public void gameEvent(GameEvent event, @Nullable Entity entity) {
         this.level().gameEvent(entity, event, this.position);
     }
@@ -1019,54 +1264,59 @@
         this.gameEvent(event, this);
     }
 
-    private void walkingStepSound(BlockPos pos, BlockState state) {
+    private void walkingStepSound(BlockPos pos, IBlockData state) {
         this.playStepSound(pos, state);
         if (this.shouldPlayAmethystStepSound(state)) {
             this.playAmethystStepSound();
         }
+
     }
 
     protected void waterSwimSound() {
-        Entity entity = Objects.requireNonNullElse(this.getControllingPassenger(), this);
+        Entity entity = (Entity) Objects.requireNonNullElse(this.getControllingPassenger(), this);
         float f = entity == this ? 0.35F : 0.4F;
-        Vec3 deltaMovement = entity.getDeltaMovement();
-        float min = Math.min(
-            1.0F, (float)Math.sqrt(deltaMovement.x * deltaMovement.x * 0.2F + deltaMovement.y * deltaMovement.y + deltaMovement.z * deltaMovement.z * 0.2F) * f
-        );
-        this.playSwimSound(min);
+        Vec3 vec3d = entity.getDeltaMovement();
+        float f1 = Math.min(1.0F, (float) Math.sqrt(vec3d.x * vec3d.x * 0.20000000298023224D + vec3d.y * vec3d.y + vec3d.z * vec3d.z * 0.20000000298023224D) * f);
+
+        this.playSwimSound(f1);
     }
 
     protected BlockPos getPrimaryStepSoundBlockPos(BlockPos pos) {
-        BlockPos blockPos = pos.above();
-        BlockState blockState = this.level().getBlockState(blockPos);
-        return !blockState.is(BlockTags.INSIDE_STEP_SOUND_BLOCKS) && !blockState.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS) ? pos : blockPos;
+        BlockPos blockposition1 = pos.above();
+        IBlockData iblockdata = this.level().getBlockState(blockposition1);
+
+        return !iblockdata.is(BlockTags.INSIDE_STEP_SOUND_BLOCKS) && !iblockdata.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS) ? pos : blockposition1;
     }
 
-    protected void playCombinationStepSounds(BlockState primaryState, BlockState secondaryState) {
-        SoundType soundType = primaryState.getSoundType();
-        this.playSound(soundType.getStepSound(), soundType.getVolume() * 0.15F, soundType.getPitch());
+    protected void playCombinationStepSounds(IBlockData primaryState, IBlockData secondaryState) {
+        SoundType soundeffecttype = primaryState.getSoundType();
+
+        this.playSound(soundeffecttype.getStepSound(), soundeffecttype.getVolume() * 0.15F, soundeffecttype.getPitch());
         this.playMuffledStepSound(secondaryState);
     }
 
-    protected void playMuffledStepSound(BlockState state) {
-        SoundType soundType = state.getSoundType();
-        this.playSound(soundType.getStepSound(), soundType.getVolume() * 0.05F, soundType.getPitch() * 0.8F);
+    protected void playMuffledStepSound(IBlockData state) {
+        SoundType soundeffecttype = state.getSoundType();
+
+        this.playSound(soundeffecttype.getStepSound(), soundeffecttype.getVolume() * 0.05F, soundeffecttype.getPitch() * 0.8F);
     }
 
-    protected void playStepSound(BlockPos pos, BlockState state) {
-        SoundType soundType = state.getSoundType();
-        this.playSound(soundType.getStepSound(), soundType.getVolume() * 0.15F, soundType.getPitch());
+    protected void playStepSound(BlockPos pos, IBlockData state) {
+        SoundType soundeffecttype = state.getSoundType();
+
+        this.playSound(soundeffecttype.getStepSound(), soundeffecttype.getVolume() * 0.15F, soundeffecttype.getPitch());
     }
 
-    private boolean shouldPlayAmethystStepSound(BlockState state) {
+    private boolean shouldPlayAmethystStepSound(IBlockData state) {
         return state.is(BlockTags.CRYSTAL_SOUND_BLOCKS) && this.tickCount >= this.lastCrystalSoundPlayTick + 20;
     }
 
     private void playAmethystStepSound() {
-        this.crystalSoundIntensity = this.crystalSoundIntensity * (float)Math.pow(0.997, (double)(this.tickCount - this.lastCrystalSoundPlayTick));
+        this.crystalSoundIntensity *= (float) Math.pow(0.997D, (double) (this.tickCount - this.lastCrystalSoundPlayTick));
         this.crystalSoundIntensity = Math.min(1.0F, this.crystalSoundIntensity + 0.07F);
         float f = 0.5F + this.crystalSoundIntensity * this.random.nextFloat() * 1.2F;
         float f1 = 0.1F + this.crystalSoundIntensity * 1.2F;
+
         this.playSound(SoundEvents.AMETHYST_BLOCK_CHIME, f1, f);
         this.lastCrystalSoundPlayTick = this.tickCount;
     }
@@ -1075,8 +1325,7 @@
         this.playSound(this.getSwimSound(), volume, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
     }
 
-    protected void onFlap() {
-    }
+    protected void onFlap() {}
 
     protected boolean isFlapping() {
         return false;
@@ -1084,30 +1333,32 @@
 
     public void playSound(SoundEvent sound, float volume, float pitch) {
         if (!this.isSilent()) {
-            this.level().playSound(null, this.getX(), this.getY(), this.getZ(), sound, this.getSoundSource(), volume, pitch);
+            this.level().playSound((Player) null, this.getX(), this.getY(), this.getZ(), sound, this.getSoundSource(), volume, pitch);
         }
+
     }
 
     public void playSound(SoundEvent sound) {
         if (!this.isSilent()) {
             this.playSound(sound, 1.0F, 1.0F);
         }
+
     }
 
     public boolean isSilent() {
-        return this.entityData.get(DATA_SILENT);
+        return (Boolean) this.entityData.get(Entity.DATA_SILENT);
     }
 
     public void setSilent(boolean isSilent) {
-        this.entityData.set(DATA_SILENT, isSilent);
+        this.entityData.set(Entity.DATA_SILENT, isSilent);
     }
 
     public boolean isNoGravity() {
-        return this.entityData.get(DATA_NO_GRAVITY);
+        return (Boolean) this.entityData.get(Entity.DATA_NO_GRAVITY);
     }
 
     public void setNoGravity(boolean noGravity) {
-        this.entityData.set(DATA_NO_GRAVITY, noGravity);
+        this.entityData.set(Entity.DATA_NO_GRAVITY, noGravity);
     }
 
     protected Entity.MovementEmission getMovementEmission() {
@@ -1118,22 +1369,20 @@
         return false;
     }
 
-    protected void checkFallDamage(double y, boolean onGround, BlockState state, BlockPos pos) {
-        if (onGround) {
+    protected void checkFallDamage(double y, boolean flag, IBlockData onGround, BlockPos state) {
+        if (flag) {
             if (this.fallDistance > 0.0F) {
-                state.getBlock().fallOn(this.level(), state, pos, this, this.fallDistance);
-                this.level()
-                    .gameEvent(
-                        GameEvent.HIT_GROUND,
-                        this.position,
-                        GameEvent.Context.of(this, this.mainSupportingBlockPos.<BlockState>map(blockPos -> this.level().getBlockState(blockPos)).orElse(state))
-                    );
+                onGround.getBlock().fallOn(this.level(), onGround, state, this, this.fallDistance);
+                this.level().gameEvent(GameEvent.HIT_GROUND, this.position, GameEvent.Context.of(this, (IBlockData) this.mainSupportingBlockPos.map((blockposition1) -> {
+                    return this.level().getBlockState(blockposition1);
+                }).orElse(onGround)));
             }
 
             this.resetFallDistance();
-        } else if (y < 0.0) {
-            this.fallDistance -= (float)y;
+        } else if (y < 0.0D) {
+            this.fallDistance -= (float) y;
         }
+
     }
 
     public boolean fireImmune() {
@@ -1145,7 +1394,11 @@
             return false;
         } else {
             if (this.isVehicle()) {
-                for (Entity entity : this.getPassengers()) {
+                Iterator iterator = this.getPassengers().iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
+
                     entity.causeFallDamage(fallDistance, multiplier, source);
                 }
             }
@@ -1159,9 +1412,9 @@
     }
 
     private boolean isInRain() {
-        BlockPos blockPos = this.blockPosition();
-        return this.level().isRainingAt(blockPos)
-            || this.level().isRainingAt(BlockPos.containing((double)blockPos.getX(), this.getBoundingBox().maxY, (double)blockPos.getZ()));
+        BlockPos blockposition = this.blockPosition();
+
+        return this.level().isRainingAt(blockposition) || this.level().isRainingAt(BlockPos.containing((double) blockposition.getX(), this.getBoundingBox().maxY, (double) blockposition.getZ()));
     }
 
     private boolean isInBubbleColumn() {
@@ -1192,27 +1445,33 @@
         if (this.isSwimming()) {
             this.setSwimming(this.isSprinting() && this.isInWater() && !this.isPassenger());
         } else {
-            this.setSwimming(
-                this.isSprinting() && this.isUnderWater() && !this.isPassenger() && this.level().getFluidState(this.blockPosition).is(FluidTags.WATER)
-            );
+            this.setSwimming(this.isSprinting() && this.isUnderWater() && !this.isPassenger() && this.level().getFluidState(this.blockPosition).is(FluidTags.WATER));
         }
+
     }
 
     protected boolean updateInWaterStateAndDoFluidPushing() {
         this.fluidHeight.clear();
         this.updateInWaterStateAndDoWaterCurrentPushing();
-        double d = this.level().dimensionType().ultraWarm() ? 0.007 : 0.0023333333333333335;
-        boolean flag = this.updateFluidHeightAndDoFluidPushing(FluidTags.LAVA, d);
+        double d0 = this.level().dimensionType().ultraWarm() ? 0.007D : 0.0023333333333333335D;
+        boolean flag = this.updateFluidHeightAndDoFluidPushing(FluidTags.LAVA, d0);
+
         return this.isInWater() || flag;
     }
 
     void updateInWaterStateAndDoWaterCurrentPushing() {
-        if (this.getVehicle() instanceof Boat boat && !boat.isUnderWater()) {
-            this.wasTouchingWater = false;
-            return;
+        Entity entity = this.getVehicle();
+
+        if (entity instanceof Boat) {
+            Boat entityboat = (Boat) entity;
+
+            if (!entityboat.isUnderWater()) {
+                this.wasTouchingWater = false;
+                return;
+            }
         }
 
-        if (this.updateFluidHeightAndDoFluidPushing(FluidTags.WATER, 0.014)) {
+        if (this.updateFluidHeightAndDoFluidPushing(FluidTags.WATER, 0.014D)) {
             if (!this.wasTouchingWater && !this.firstTick) {
                 this.doWaterSplashEffect();
             }
@@ -1223,70 +1482,77 @@
         } else {
             this.wasTouchingWater = false;
         }
+
     }
 
     private void updateFluidOnEyes() {
         this.wasEyeInWater = this.isEyeInFluid(FluidTags.WATER);
         this.fluidOnEyes.clear();
-        double d = this.getEyeY() - 0.11111111F;
-        if (this.getVehicle() instanceof Boat boat && !boat.isUnderWater() && boat.getBoundingBox().maxY >= d && boat.getBoundingBox().minY <= d) {
-            return;
+        double d0 = this.getEyeY() - 0.1111111119389534D;
+        Entity entity = this.getVehicle();
+
+        if (entity instanceof Boat) {
+            Boat entityboat = (Boat) entity;
+
+            if (!entityboat.isUnderWater() && entityboat.getBoundingBox().maxY >= d0 && entityboat.getBoundingBox().minY <= d0) {
+                return;
+            }
         }
 
-        BlockPos blockPos = BlockPos.containing(this.getX(), d, this.getZ());
-        FluidState fluidState = this.level().getFluidState(blockPos);
-        double d1 = (double)((float)blockPos.getY() + fluidState.getHeight(this.level(), blockPos));
-        if (d1 > d) {
-            fluidState.getTags().forEach(this.fluidOnEyes::add);
+        BlockPos blockposition = BlockPos.containing(this.getX(), d0, this.getZ());
+        FluidState fluid = this.level().getFluidState(blockposition);
+        double d1 = (double) ((float) blockposition.getY() + fluid.getHeight(this.level(), blockposition));
+
+        if (d1 > d0) {
+            Stream stream = fluid.getTags();
+            Set set = this.fluidOnEyes;
+
+            Objects.requireNonNull(this.fluidOnEyes);
+            stream.forEach(set::add);
         }
+
     }
 
     protected void doWaterSplashEffect() {
-        Entity entity = Objects.requireNonNullElse(this.getControllingPassenger(), this);
+        Entity entity = (Entity) Objects.requireNonNullElse(this.getControllingPassenger(), this);
         float f = entity == this ? 0.2F : 0.9F;
-        Vec3 deltaMovement = entity.getDeltaMovement();
-        float min = Math.min(
-            1.0F, (float)Math.sqrt(deltaMovement.x * deltaMovement.x * 0.2F + deltaMovement.y * deltaMovement.y + deltaMovement.z * deltaMovement.z * 0.2F) * f
-        );
-        if (min < 0.25F) {
-            this.playSound(this.getSwimSplashSound(), min, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+        Vec3 vec3d = entity.getDeltaMovement();
+        float f1 = Math.min(1.0F, (float) Math.sqrt(vec3d.x * vec3d.x * 0.20000000298023224D + vec3d.y * vec3d.y + vec3d.z * vec3d.z * 0.20000000298023224D) * f);
+
+        if (f1 < 0.25F) {
+            this.playSound(this.getSwimSplashSound(), f1, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
         } else {
-            this.playSound(this.getSwimHighSpeedSplashSound(), min, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+            this.playSound(this.getSwimHighSpeedSplashSound(), f1, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
         }
 
-        float f1 = (float)Mth.floor(this.getY());
+        float f2 = (float) Mth.floor(this.getY());
 
-        for (int i = 0; (float)i < 1.0F + this.dimensions.width * 20.0F; i++) {
-            double d = (this.random.nextDouble() * 2.0 - 1.0) * (double)this.dimensions.width;
-            double d1 = (this.random.nextDouble() * 2.0 - 1.0) * (double)this.dimensions.width;
-            this.level()
-                .addParticle(
-                    ParticleTypes.BUBBLE,
-                    this.getX() + d,
-                    (double)(f1 + 1.0F),
-                    this.getZ() + d1,
-                    deltaMovement.x,
-                    deltaMovement.y - this.random.nextDouble() * 0.2F,
-                    deltaMovement.z
-                );
+        double d0;
+        double d1;
+        int i;
+
+        for (i = 0; (float) i < 1.0F + this.dimensions.width * 20.0F; ++i) {
+            d0 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.dimensions.width;
+            d1 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.dimensions.width;
+            this.level().addParticle(ParticleTypes.BUBBLE, this.getX() + d0, (double) (f2 + 1.0F), this.getZ() + d1, vec3d.x, vec3d.y - this.random.nextDouble() * 0.20000000298023224D, vec3d.z);
         }
 
-        for (int i = 0; (float)i < 1.0F + this.dimensions.width * 20.0F; i++) {
-            double d = (this.random.nextDouble() * 2.0 - 1.0) * (double)this.dimensions.width;
-            double d1 = (this.random.nextDouble() * 2.0 - 1.0) * (double)this.dimensions.width;
-            this.level()
-                .addParticle(ParticleTypes.SPLASH, this.getX() + d, (double)(f1 + 1.0F), this.getZ() + d1, deltaMovement.x, deltaMovement.y, deltaMovement.z);
+        for (i = 0; (float) i < 1.0F + this.dimensions.width * 20.0F; ++i) {
+            d0 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.dimensions.width;
+            d1 = (this.random.nextDouble() * 2.0D - 1.0D) * (double) this.dimensions.width;
+            this.level().addParticle(ParticleTypes.SPLASH, this.getX() + d0, (double) (f2 + 1.0F), this.getZ() + d1, vec3d.x, vec3d.y, vec3d.z);
         }
 
         this.gameEvent(GameEvent.SPLASH);
     }
 
+    /** @deprecated */
     @Deprecated
-    protected BlockState getBlockStateOnLegacy() {
+    protected IBlockData getBlockStateOnLegacy() {
         return this.level().getBlockState(this.getOnPosLegacy());
     }
 
-    public BlockState getBlockStateOn() {
+    public IBlockData getBlockStateOn() {
         return this.level().getBlockState(this.getOnPos());
     }
 
@@ -1295,26 +1561,26 @@
     }
 
     protected void spawnSprintParticle() {
-        BlockPos onPosLegacy = this.getOnPosLegacy();
-        BlockState blockState = this.level().getBlockState(onPosLegacy);
-        if (blockState.getRenderShape() != RenderShape.INVISIBLE) {
-            Vec3 deltaMovement = this.getDeltaMovement();
-            BlockPos blockPos = this.blockPosition();
-            double d = this.getX() + (this.random.nextDouble() - 0.5) * (double)this.dimensions.width;
-            double d1 = this.getZ() + (this.random.nextDouble() - 0.5) * (double)this.dimensions.width;
-            if (blockPos.getX() != onPosLegacy.getX()) {
-                d = Mth.clamp(d, (double)onPosLegacy.getX(), (double)onPosLegacy.getX() + 1.0);
+        BlockPos blockposition = this.getOnPosLegacy();
+        IBlockData iblockdata = this.level().getBlockState(blockposition);
+
+        if (iblockdata.getRenderShape() != EnumRenderType.INVISIBLE) {
+            Vec3 vec3d = this.getDeltaMovement();
+            BlockPos blockposition1 = this.blockPosition();
+            double d0 = this.getX() + (this.random.nextDouble() - 0.5D) * (double) this.dimensions.width;
+            double d1 = this.getZ() + (this.random.nextDouble() - 0.5D) * (double) this.dimensions.width;
+
+            if (blockposition1.getX() != blockposition.getX()) {
+                d0 = Mth.clamp(d0, (double) blockposition.getX(), (double) blockposition.getX() + 1.0D);
             }
 
-            if (blockPos.getZ() != onPosLegacy.getZ()) {
-                d1 = Mth.clamp(d1, (double)onPosLegacy.getZ(), (double)onPosLegacy.getZ() + 1.0);
+            if (blockposition1.getZ() != blockposition.getZ()) {
+                d1 = Mth.clamp(d1, (double) blockposition.getZ(), (double) blockposition.getZ() + 1.0D);
             }
 
-            this.level()
-                .addParticle(
-                    new BlockParticleOption(ParticleTypes.BLOCK, blockState), d, this.getY() + 0.1, d1, deltaMovement.x * -4.0, 1.5, deltaMovement.z * -4.0
-                );
+            this.level().addParticle(new BlockParticleOption(ParticleTypes.BLOCK, iblockdata), d0, this.getY() + 0.1D, d1, vec3d.x * -4.0D, 1.5D, vec3d.z * -4.0D);
         }
+
     }
 
     public boolean isEyeInFluid(TagKey<Fluid> fluidTag) {
@@ -1322,96 +1588,103 @@
     }
 
     public boolean isInLava() {
-        return !this.firstTick && this.fluidHeight.getDouble(FluidTags.LAVA) > 0.0;
+        return !this.firstTick && this.fluidHeight.getDouble(FluidTags.LAVA) > 0.0D;
     }
 
     public void moveRelative(float amount, Vec3 relative) {
-        Vec3 inputVector = getInputVector(relative, amount, this.getYRot());
-        this.setDeltaMovement(this.getDeltaMovement().add(inputVector));
+        Vec3 vec3d1 = getInputVector(relative, amount, this.getYRot());
+
+        this.setDeltaMovement(this.getDeltaMovement().add(vec3d1));
     }
 
     private static Vec3 getInputVector(Vec3 relative, float motionScaler, float facing) {
-        double d = relative.lengthSqr();
-        if (d < 1.0E-7) {
+        double d0 = relative.lengthSqr();
+
+        if (d0 < 1.0E-7D) {
             return Vec3.ZERO;
         } else {
-            Vec3 vec3 = (d > 1.0 ? relative.normalize() : relative).scale((double)motionScaler);
-            float sin = Mth.sin(facing * (float) (Math.PI / 180.0));
-            float cos = Mth.cos(facing * (float) (Math.PI / 180.0));
-            return new Vec3(vec3.x * (double)cos - vec3.z * (double)sin, vec3.y, vec3.z * (double)cos + vec3.x * (double)sin);
+            Vec3 vec3d1 = (d0 > 1.0D ? relative.normalize() : relative).scale((double) motionScaler);
+            float f2 = Mth.sin(facing * 0.017453292F);
+            float f3 = Mth.cos(facing * 0.017453292F);
+
+            return new Vec3(vec3d1.x * (double) f3 - vec3d1.z * (double) f2, vec3d1.y, vec3d1.z * (double) f3 + vec3d1.x * (double) f2);
         }
     }
 
+    /** @deprecated */
     @Deprecated
     public float getLightLevelDependentMagicValue() {
-        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ())
-            ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ()))
-            : 0.0F;
+        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())) : 0.0F;
     }
 
-    public void absMoveTo(double x, double y, double z, float yRot, float xRot) {
-        this.absMoveTo(x, y, z);
-        this.setYRot(yRot % 360.0F);
-        this.setXRot(Mth.clamp(xRot, -90.0F, 90.0F) % 360.0F);
+    public void absMoveTo(double x, double d1, double y, float f, float z) {
+        this.absMoveTo(x, d1, y);
+        this.setYRot(f % 360.0F);
+        this.setXRot(Mth.clamp(z, -90.0F, 90.0F) % 360.0F);
         this.yRotO = this.getYRot();
         this.xRotO = this.getXRot();
     }
 
-    public void absMoveTo(double x, double y, double z) {
-        double d = Mth.clamp(x, -3.0E7, 3.0E7);
-        double d1 = Mth.clamp(z, -3.0E7, 3.0E7);
-        this.xo = d;
-        this.yo = y;
-        this.zo = d1;
-        this.setPos(d, y, d1);
+    public void absMoveTo(double x, double d1, double y) {
+        double d3 = Mth.clamp(x, -3.0E7D, 3.0E7D);
+        double d4 = Mth.clamp(y, -3.0E7D, 3.0E7D);
+
+        this.xo = d3;
+        this.yo = d1;
+        this.zo = d4;
+        this.setPos(d3, d1, d4);
+        if (valid) level.getChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4); // CraftBukkit
     }
 
     public void moveTo(Vec3 vec) {
         this.moveTo(vec.x, vec.y, vec.z);
     }
 
-    public void moveTo(double x, double y, double z) {
-        this.moveTo(x, y, z, this.getYRot(), this.getXRot());
+    public void moveTo(double x, double d1, double y) {
+        this.moveTo(x, d1, y, this.getYRot(), this.getXRot());
     }
 
     public void moveTo(BlockPos pos, float yRot, float xRot) {
-        this.moveTo((double)pos.getX() + 0.5, (double)pos.getY(), (double)pos.getZ() + 0.5, yRot, xRot);
+        this.moveTo((double) pos.getX() + 0.5D, (double) pos.getY(), (double) pos.getZ() + 0.5D, yRot, xRot);
     }
 
-    public void moveTo(double x, double y, double z, float yRot, float xRot) {
-        this.setPosRaw(x, y, z);
-        this.setYRot(yRot);
-        this.setXRot(xRot);
+    public void moveTo(double x, double d1, double y, float f, float z) {
+        this.setPosRaw(x, d1, y);
+        this.setYRot(f);
+        this.setXRot(z);
         this.setOldPosAndRot();
         this.reapplyPosition();
     }
 
     public final void setOldPosAndRot() {
-        double x = this.getX();
-        double y = this.getY();
-        double z = this.getZ();
-        this.xo = x;
-        this.yo = y;
-        this.zo = z;
-        this.xOld = x;
-        this.yOld = y;
-        this.zOld = z;
+        double d0 = this.getX();
+        double d1 = this.getY();
+        double d2 = this.getZ();
+
+        this.xo = d0;
+        this.yo = d1;
+        this.zo = d2;
+        this.xOld = d0;
+        this.yOld = d1;
+        this.zOld = d2;
         this.yRotO = this.getYRot();
         this.xRotO = this.getXRot();
     }
 
     public float distanceTo(Entity entity) {
-        float f = (float)(this.getX() - entity.getX());
-        float f1 = (float)(this.getY() - entity.getY());
-        float f2 = (float)(this.getZ() - entity.getZ());
+        float f = (float) (this.getX() - entity.getX());
+        float f1 = (float) (this.getY() - entity.getY());
+        float f2 = (float) (this.getZ() - entity.getZ());
+
         return Mth.sqrt(f * f + f1 * f1 + f2 * f2);
     }
 
-    public double distanceToSqr(double x, double y, double z) {
-        double d = this.getX() - x;
-        double d1 = this.getY() - y;
-        double d2 = this.getZ() - z;
-        return d * d + d1 * d1 + d2 * d2;
+    public double distanceToSqr(double x, double d1, double y) {
+        double d3 = this.getX() - x;
+        double d4 = this.getY() - d1;
+        double d5 = this.getZ() - y;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
     }
 
     public double distanceToSqr(Entity entity) {
@@ -1419,48 +1692,51 @@
     }
 
     public double distanceToSqr(Vec3 vec) {
-        double d = this.getX() - vec.x;
+        double d0 = this.getX() - vec.x;
         double d1 = this.getY() - vec.y;
         double d2 = this.getZ() - vec.z;
-        return d * d + d1 * d1 + d2 * d2;
-    }
 
-    public void playerTouch(Player player) {
+        return d0 * d0 + d1 * d1 + d2 * d2;
     }
 
+    public void playerTouch(Player player) {}
+
     public void push(Entity entity) {
         if (!this.isPassengerOfSameVehicle(entity)) {
             if (!entity.noPhysics && !this.noPhysics) {
-                double d = entity.getX() - this.getX();
+                double d0 = entity.getX() - this.getX();
                 double d1 = entity.getZ() - this.getZ();
-                double max = Mth.absMax(d, d1);
-                if (max >= 0.01F) {
-                    max = Math.sqrt(max);
-                    double var10 = d / max;
-                    double var13 = d1 / max;
-                    double d2 = 1.0 / max;
-                    if (d2 > 1.0) {
-                        d2 = 1.0;
+                double d2 = Mth.absMax(d0, d1);
+
+                if (d2 >= 0.009999999776482582D) {
+                    d2 = Math.sqrt(d2);
+                    d0 /= d2;
+                    d1 /= d2;
+                    double d3 = 1.0D / d2;
+
+                    if (d3 > 1.0D) {
+                        d3 = 1.0D;
                     }
 
-                    d = var10 * d2;
-                    d1 = var13 * d2;
-                    double var12 = d * 0.05F;
-                    double var15 = d1 * 0.05F;
+                    d0 *= d3;
+                    d1 *= d3;
+                    d0 *= 0.05000000074505806D;
+                    d1 *= 0.05000000074505806D;
                     if (!this.isVehicle() && this.isPushable()) {
-                        this.push(-var12, 0.0, -var15);
+                        this.push(-d0, 0.0D, -d1);
                     }
 
                     if (!entity.isVehicle() && entity.isPushable()) {
-                        entity.push(var12, 0.0, var15);
+                        entity.push(d0, 0.0D, d1);
                     }
                 }
+
             }
         }
     }
 
-    public void push(double x, double y, double z) {
-        this.setDeltaMovement(this.getDeltaMovement().add(x, y, z));
+    public void push(double x, double d1, double y) {
+        this.setDeltaMovement(this.getDeltaMovement().add(x, d1, y));
         this.hasImpulse = true;
     }
 
@@ -1490,13 +1766,14 @@
     }
 
     protected final Vec3 calculateViewVector(float xRot, float yRot) {
-        float f = xRot * (float) (Math.PI / 180.0);
-        float f1 = -yRot * (float) (Math.PI / 180.0);
-        float cos = Mth.cos(f1);
-        float sin = Mth.sin(f1);
-        float cos1 = Mth.cos(f);
-        float sin1 = Mth.sin(f);
-        return new Vec3((double)(sin * cos1), (double)(-sin1), (double)(cos * cos1));
+        float f2 = xRot * 0.017453292F;
+        float f3 = -yRot * 0.017453292F;
+        float f4 = Mth.cos(f3);
+        float f5 = Mth.sin(f3);
+        float f6 = Mth.cos(f2);
+        float f7 = Mth.sin(f2);
+
+        return new Vec3((double) (f5 * f6), (double) (-f7), (double) (f4 * f6));
     }
 
     public final Vec3 getUpVector(float partialTicks) {
@@ -1512,10 +1789,11 @@
     }
 
     public final Vec3 getEyePosition(float partialTicks) {
-        double d = Mth.lerp((double)partialTicks, this.xo, this.getX());
-        double d1 = Mth.lerp((double)partialTicks, this.yo, this.getY()) + (double)this.getEyeHeight();
-        double d2 = Mth.lerp((double)partialTicks, this.zo, this.getZ());
-        return new Vec3(d, d1, d2);
+        double d0 = Mth.lerp((double) partialTicks, this.xo, this.getX());
+        double d1 = Mth.lerp((double) partialTicks, this.yo, this.getY()) + (double) this.getEyeHeight();
+        double d2 = Mth.lerp((double) partialTicks, this.zo, this.getZ());
+
+        return new Vec3(d0, d1, d2);
     }
 
     public Vec3 getLightProbePosition(float partialTicks) {
@@ -1523,18 +1801,19 @@
     }
 
     public final Vec3 getPosition(float partialTicks) {
-        double d = Mth.lerp((double)partialTicks, this.xo, this.getX());
-        double d1 = Mth.lerp((double)partialTicks, this.yo, this.getY());
-        double d2 = Mth.lerp((double)partialTicks, this.zo, this.getZ());
-        return new Vec3(d, d1, d2);
+        double d0 = Mth.lerp((double) partialTicks, this.xo, this.getX());
+        double d1 = Mth.lerp((double) partialTicks, this.yo, this.getY());
+        double d2 = Mth.lerp((double) partialTicks, this.zo, this.getZ());
+
+        return new Vec3(d0, d1, d2);
     }
 
-    public HitResult pick(double hitDistance, float partialTicks, boolean hitFluids) {
-        Vec3 eyePosition = this.getEyePosition(partialTicks);
-        Vec3 viewVector = this.getViewVector(partialTicks);
-        Vec3 vec3 = eyePosition.add(viewVector.x * hitDistance, viewVector.y * hitDistance, viewVector.z * hitDistance);
-        return this.level()
-            .clip(new ClipContext(eyePosition, vec3, ClipContext.Block.OUTLINE, hitFluids ? ClipContext.Fluid.ANY : ClipContext.Fluid.NONE, this));
+    public HitResult pick(double hitDistance, float f, boolean partialTicks) {
+        Vec3 vec3d = this.getEyePosition(f);
+        Vec3 vec3d1 = this.getViewVector(f);
+        Vec3 vec3d2 = vec3d.add(vec3d1.x * hitDistance, vec3d1.y * hitDistance, vec3d1.z * hitDistance);
+
+        return this.level().clip(new ClipContext(vec3d, vec3d2, ClipContext.Block.OUTLINE, partialTicks ? ClipContext.Fluid.ANY : ClipContext.Fluid.NONE, this));
     }
 
     public boolean canBeHitByProjectile() {
@@ -1549,151 +1828,224 @@
         return false;
     }
 
+    // CraftBukkit start - collidable API
+    public boolean canCollideWithBukkit(Entity entity) {
+        return isPushable();
+    }
+    // CraftBukkit end
+
     public void awardKillScore(Entity killed, int scoreValue, DamageSource source) {
         if (killed instanceof ServerPlayer) {
-            CriteriaTriggers.ENTITY_KILLED_PLAYER.trigger((ServerPlayer)killed, this, source);
+            CriteriaTriggers.ENTITY_KILLED_PLAYER.trigger((ServerPlayer) killed, this, source);
         }
+
     }
 
-    public boolean shouldRender(double x, double y, double z) {
-        double d = this.getX() - x;
-        double d1 = this.getY() - y;
-        double d2 = this.getZ() - z;
-        double d3 = d * d + d1 * d1 + d2 * d2;
-        return this.shouldRenderAtSqrDistance(d3);
+    public boolean shouldRender(double x, double d1, double y) {
+        double d3 = this.getX() - x;
+        double d4 = this.getY() - d1;
+        double d5 = this.getZ() - y;
+        double d6 = d3 * d3 + d4 * d4 + d5 * d5;
+
+        return this.shouldRenderAtSqrDistance(d6);
     }
 
     public boolean shouldRenderAtSqrDistance(double distance) {
-        double size = this.getBoundingBox().getSize();
-        if (Double.isNaN(size)) {
-            size = 1.0;
+        double d1 = this.getBoundingBox().getSize();
+
+        if (Double.isNaN(d1)) {
+            d1 = 1.0D;
         }
 
-        size *= 64.0 * viewScale;
-        return distance < size * size;
+        d1 *= 64.0D * Entity.viewScale;
+        return distance < d1 * d1;
     }
 
     public boolean saveAsPassenger(CompoundTag compound) {
+        // CraftBukkit start - allow excluding certain data when saving
+        return saveAsPassenger(compound, true);
+    }
+
+    public boolean saveAsPassenger(CompoundTag nbttagcompound, boolean includeAll) {
+        // CraftBukkit end
         if (this.removalReason != null && !this.removalReason.shouldSave()) {
             return false;
         } else {
-            String encodeId = this.getEncodeId();
-            if (encodeId == null) {
+            String s = this.getEncodeId();
+
+            if (!this.persist || s == null) { // CraftBukkit - persist flag
                 return false;
             } else {
-                compound.putString("id", encodeId);
-                this.saveWithoutId(compound);
+                nbttagcompound.putString("id", s);
+                this.saveWithoutId(nbttagcompound, includeAll); // CraftBukkit - pass on includeAll
                 return true;
             }
         }
     }
 
     public boolean save(CompoundTag compound) {
-        return !this.isPassenger() && this.saveAsPassenger(compound);
+        return this.isPassenger() ? false : this.saveAsPassenger(compound);
     }
 
     public CompoundTag saveWithoutId(CompoundTag compound) {
+        // CraftBukkit start - allow excluding certain data when saving
+        return saveWithoutId(compound, true);
+    }
+
+    public CompoundTag saveWithoutId(CompoundTag nbttagcompound, boolean includeAll) {
+        // CraftBukkit end
         try {
-            if (this.vehicle != null) {
-                compound.put("Pos", this.newDoubleList(this.vehicle.getX(), this.getY(), this.vehicle.getZ()));
-            } else {
-                compound.put("Pos", this.newDoubleList(this.getX(), this.getY(), this.getZ()));
+            // CraftBukkit start - selectively save position
+            if (includeAll) {
+                if (this.vehicle != null) {
+                    nbttagcompound.put("Pos", this.newDoubleList(this.vehicle.getX(), this.getY(), this.vehicle.getZ()));
+                } else {
+                    nbttagcompound.put("Pos", this.newDoubleList(this.getX(), this.getY(), this.getZ()));
+                }
             }
+            // CraftBukkit end
 
-            Vec3 deltaMovement = this.getDeltaMovement();
-            compound.put("Motion", this.newDoubleList(deltaMovement.x, deltaMovement.y, deltaMovement.z));
-            compound.put("Rotation", this.newFloatList(this.getYRot(), this.getXRot()));
-            compound.putFloat("FallDistance", this.fallDistance);
-            compound.putShort("Fire", (short)this.remainingFireTicks);
-            compound.putShort("Air", (short)this.getAirSupply());
-            compound.putBoolean("OnGround", this.onGround());
-            compound.putBoolean("Invulnerable", this.invulnerable);
-            compound.putInt("PortalCooldown", this.portalCooldown);
-            compound.putUUID("UUID", this.getUUID());
-            Component customName = this.getCustomName();
-            if (customName != null) {
-                compound.putString("CustomName", Component.Serializer.toJson(customName));
+            Vec3 vec3d = this.getDeltaMovement();
+
+            nbttagcompound.put("Motion", this.newDoubleList(vec3d.x, vec3d.y, vec3d.z));
+
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.yRot)) {
+                this.yRot = 0;
             }
 
+            if (Float.isNaN(this.xRot)) {
+                this.xRot = 0;
+            }
+            // CraftBukkit end
+
+            nbttagcompound.put("Rotation", this.newFloatList(this.getYRot(), this.getXRot()));
+            nbttagcompound.putFloat("FallDistance", this.fallDistance);
+            nbttagcompound.putShort("Fire", (short) this.remainingFireTicks);
+            nbttagcompound.putShort("Air", (short) this.getAirSupply());
+            nbttagcompound.putBoolean("OnGround", this.onGround());
+            nbttagcompound.putBoolean("Invulnerable", this.invulnerable);
+            nbttagcompound.putInt("PortalCooldown", this.portalCooldown);
+            // CraftBukkit start - selectively save uuid and world
+            if (includeAll) {
+                nbttagcompound.putUUID("UUID", this.getUUID());
+                // PAIL: Check above UUID reads 1.8 properly, ie: UUIDMost / UUIDLeast
+                nbttagcompound.putLong("WorldUUIDLeast", ((ServerLevel) this.level).getWorld().getUID().getLeastSignificantBits());
+                nbttagcompound.putLong("WorldUUIDMost", ((ServerLevel) this.level).getWorld().getUID().getMostSignificantBits());
+            }
+            nbttagcompound.putInt("Bukkit.updateLevel", CURRENT_LEVEL);
+            if (!this.persist) {
+                nbttagcompound.putBoolean("Bukkit.persist", this.persist);
+            }
+            if (!this.visibleByDefault) {
+                nbttagcompound.putBoolean("Bukkit.visibleByDefault", this.visibleByDefault);
+            }
+            if (this.persistentInvisibility) {
+                nbttagcompound.putBoolean("Bukkit.invisible", this.persistentInvisibility);
+            }
+            // SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+            if (maxAirTicks != getDefaultMaxAirSupply()) {
+                nbttagcompound.putInt("Bukkit.MaxAirSupply", getMaxAirSupply());
+            }
+            // CraftBukkit end
+            Component ichatbasecomponent = this.getCustomName();
+
+            if (ichatbasecomponent != null) {
+                nbttagcompound.putString("CustomName", Component.Serializer.toJson(ichatbasecomponent));
+            }
+
             if (this.isCustomNameVisible()) {
-                compound.putBoolean("CustomNameVisible", this.isCustomNameVisible());
+                nbttagcompound.putBoolean("CustomNameVisible", this.isCustomNameVisible());
             }
 
             if (this.isSilent()) {
-                compound.putBoolean("Silent", this.isSilent());
+                nbttagcompound.putBoolean("Silent", this.isSilent());
             }
 
             if (this.isNoGravity()) {
-                compound.putBoolean("NoGravity", this.isNoGravity());
+                nbttagcompound.putBoolean("NoGravity", this.isNoGravity());
             }
 
             if (this.hasGlowingTag) {
-                compound.putBoolean("Glowing", true);
+                nbttagcompound.putBoolean("Glowing", true);
             }
 
-            int ticksFrozen = this.getTicksFrozen();
-            if (ticksFrozen > 0) {
-                compound.putInt("TicksFrozen", this.getTicksFrozen());
+            int i = this.getTicksFrozen();
+
+            if (i > 0) {
+                nbttagcompound.putInt("TicksFrozen", this.getTicksFrozen());
             }
 
             if (this.hasVisualFire) {
-                compound.putBoolean("HasVisualFire", this.hasVisualFire);
+                nbttagcompound.putBoolean("HasVisualFire", this.hasVisualFire);
             }
 
+            ListTag nbttaglist;
+            Iterator iterator;
+
             if (!this.tags.isEmpty()) {
-                ListTag list = new ListTag();
+                nbttaglist = new ListTag();
+                iterator = this.tags.iterator();
 
-                for (String string : this.tags) {
-                    list.add(StringTag.valueOf(string));
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+
+                    nbttaglist.add(StringTag.valueOf(s));
                 }
 
-                compound.put("Tags", list);
+                nbttagcompound.put("Tags", nbttaglist);
             }
 
-            this.addAdditionalSaveData(compound);
+            this.addAdditionalSaveData(nbttagcompound, includeAll); // CraftBukkit - pass on includeAll
             if (this.isVehicle()) {
-                ListTag list = new ListTag();
+                nbttaglist = new ListTag();
+                iterator = this.getPassengers().iterator();
 
-                for (Entity entity : this.getPassengers()) {
-                    CompoundTag compoundTag = new CompoundTag();
-                    if (entity.saveAsPassenger(compoundTag)) {
-                        list.add(compoundTag);
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
+                    CompoundTag nbttagcompound1 = new CompoundTag();
+
+                    if (entity.saveAsPassenger(nbttagcompound1, includeAll)) { // CraftBukkit - pass on includeAll
+                        nbttaglist.add(nbttagcompound1);
                     }
                 }
 
-                if (!list.isEmpty()) {
-                    compound.put("Passengers", list);
+                if (!nbttaglist.isEmpty()) {
+                    nbttagcompound.put("Passengers", nbttaglist);
                 }
             }
 
-            return compound;
-        } catch (Throwable var9) {
-            CrashReport crashReport = CrashReport.forThrowable(var9, "Saving entity NBT");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being saved");
-            this.fillCrashReportCategory(crashReportCategory);
-            throw new ReportedException(crashReport);
+            // CraftBukkit start - stores eventually existing bukkit values
+            if (this.bukkitEntity != null) {
+                this.bukkitEntity.storeBukkitValues(nbttagcompound);
+            }
+            // CraftBukkit end
+            return nbttagcompound;
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.forThrowable(throwable, "Saving entity NBT");
+            CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Entity being saved");
+
+            this.fillCrashReportCategory(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
         }
     }
 
     public void load(CompoundTag compound) {
         try {
-            ListTag list = compound.getList("Pos", 6);
-            ListTag list1 = compound.getList("Motion", 6);
-            ListTag list2 = compound.getList("Rotation", 5);
-            double _double = list1.getDouble(0);
-            double _double1 = list1.getDouble(1);
-            double _double2 = list1.getDouble(2);
-            this.setDeltaMovement(
-                Math.abs(_double) > 10.0 ? 0.0 : _double, Math.abs(_double1) > 10.0 ? 0.0 : _double1, Math.abs(_double2) > 10.0 ? 0.0 : _double2
-            );
-            double d = 3.0000512E7;
-            this.setPosRaw(
-                Mth.clamp(list.getDouble(0), -3.0000512E7, 3.0000512E7),
-                Mth.clamp(list.getDouble(1), -2.0E7, 2.0E7),
-                Mth.clamp(list.getDouble(2), -3.0000512E7, 3.0000512E7)
-            );
-            this.setYRot(list2.getFloat(0));
-            this.setXRot(list2.getFloat(1));
+            ListTag nbttaglist = compound.getList("Pos", 6);
+            ListTag nbttaglist1 = compound.getList("Motion", 6);
+            ListTag nbttaglist2 = compound.getList("Rotation", 5);
+            double d0 = nbttaglist1.getDouble(0);
+            double d1 = nbttaglist1.getDouble(1);
+            double d2 = nbttaglist1.getDouble(2);
+
+            this.setDeltaMovement(Math.abs(d0) > 10.0D ? 0.0D : d0, Math.abs(d1) > 10.0D ? 0.0D : d1, Math.abs(d2) > 10.0D ? 0.0D : d2);
+            double d3 = 3.0000512E7D;
+
+            this.setPosRaw(Mth.clamp(nbttaglist.getDouble(0), -3.0000512E7D, 3.0000512E7D), Mth.clamp(nbttaglist.getDouble(1), -2.0E7D, 2.0E7D), Mth.clamp(nbttaglist.getDouble(2), -3.0000512E7D, 3.0000512E7D));
+            this.setYRot(nbttaglist2.getFloat(0));
+            this.setXRot(nbttaglist2.getFloat(1));
             this.setOldPosAndRot();
             this.setYHeadRot(this.getYRot());
             this.setYBodyRot(this.getYRot());
@@ -1711,49 +2063,92 @@
                 this.stringUUID = this.uuid.toString();
             }
 
-            if (!Double.isFinite(this.getX()) || !Double.isFinite(this.getY()) || !Double.isFinite(this.getZ())) {
-                throw new IllegalStateException("Entity has invalid position");
-            } else if (Double.isFinite((double)this.getYRot()) && Double.isFinite((double)this.getXRot())) {
-                this.reapplyPosition();
-                this.setRot(this.getYRot(), this.getXRot());
-                if (compound.contains("CustomName", 8)) {
-                    String string = compound.getString("CustomName");
+            if (Double.isFinite(this.getX()) && Double.isFinite(this.getY()) && Double.isFinite(this.getZ())) {
+                if (Double.isFinite((double) this.getYRot()) && Double.isFinite((double) this.getXRot())) {
+                    this.reapplyPosition();
+                    this.setRot(this.getYRot(), this.getXRot());
+                    if (compound.contains("CustomName", 8)) {
+                        String s = compound.getString("CustomName");
 
-                    try {
-                        this.setCustomName(Component.Serializer.fromJson(string));
-                    } catch (Exception var16) {
-                        LOGGER.warn("Failed to parse entity custom name {}", string, var16);
+                        try {
+                            this.setCustomName(Component.Serializer.fromJson(s));
+                        } catch (Exception exception) {
+                            Entity.LOGGER.warn("Failed to parse entity custom name {}", s, exception);
+                        }
                     }
-                }
 
-                this.setCustomNameVisible(compound.getBoolean("CustomNameVisible"));
-                this.setSilent(compound.getBoolean("Silent"));
-                this.setNoGravity(compound.getBoolean("NoGravity"));
-                this.setGlowingTag(compound.getBoolean("Glowing"));
-                this.setTicksFrozen(compound.getInt("TicksFrozen"));
-                this.hasVisualFire = compound.getBoolean("HasVisualFire");
-                if (compound.contains("Tags", 9)) {
-                    this.tags.clear();
-                    ListTag list3 = compound.getList("Tags", 8);
-                    int min = Math.min(list3.size(), 1024);
+                    this.setCustomNameVisible(compound.getBoolean("CustomNameVisible"));
+                    this.setSilent(compound.getBoolean("Silent"));
+                    this.setNoGravity(compound.getBoolean("NoGravity"));
+                    this.setGlowingTag(compound.getBoolean("Glowing"));
+                    this.setTicksFrozen(compound.getInt("TicksFrozen"));
+                    this.hasVisualFire = compound.getBoolean("HasVisualFire");
+                    if (compound.contains("Tags", 9)) {
+                        this.tags.clear();
+                        ListTag nbttaglist3 = compound.getList("Tags", 8);
+                        int i = Math.min(nbttaglist3.size(), 1024);
 
-                    for (int i = 0; i < min; i++) {
-                        this.tags.add(list3.getString(i));
+                        for (int j = 0; j < i; ++j) {
+                            this.tags.add(nbttaglist3.getString(j));
+                        }
                     }
-                }
 
-                this.readAdditionalSaveData(compound);
-                if (this.repositionEntityAfterLoad()) {
-                    this.reapplyPosition();
+                    this.readAdditionalSaveData(compound);
+                    if (this.repositionEntityAfterLoad()) {
+                        this.reapplyPosition();
+                    }
+
+                } else {
+                    throw new IllegalStateException("Entity has invalid rotation");
                 }
             } else {
-                throw new IllegalStateException("Entity has invalid rotation");
+                throw new IllegalStateException("Entity has invalid position");
             }
-        } catch (Throwable var17) {
-            CrashReport crashReport = CrashReport.forThrowable(var17, "Loading entity NBT");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being loaded");
-            this.fillCrashReportCategory(crashReportCategory);
-            throw new ReportedException(crashReport);
+
+            // CraftBukkit start
+            this.persist = !compound.contains("Bukkit.persist") || compound.getBoolean("Bukkit.persist");
+            this.visibleByDefault = !compound.contains("Bukkit.visibleByDefault") || compound.getBoolean("Bukkit.visibleByDefault");
+            // SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+            if (compound.contains("Bukkit.MaxAirSupply")) {
+                maxAirTicks = compound.getInt("Bukkit.MaxAirSupply");
+            }
+            // CraftBukkit end
+
+            // CraftBukkit start - Reset world
+            if (this instanceof ServerPlayer) {
+                Server server = Bukkit.getServer();
+                org.bukkit.World bworld = null;
+
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = compound.getString("world");
+
+                if (compound.contains("WorldUUIDMost") && compound.contains("WorldUUIDLeast")) {
+                    UUID uid = new UUID(compound.getLong("WorldUUIDMost"), compound.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                } else {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null) {
+                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getLevel(Level.OVERWORLD).getWorld();
+                }
+
+                ((ServerPlayer) this).setLevel(bworld == null ? null : ((CraftWorld) bworld).getHandle());
+            }
+            this.getBukkitEntity().readBukkitValues(compound);
+            if (compound.contains("Bukkit.invisible")) {
+                boolean bukkitInvisible = compound.getBoolean("Bukkit.invisible");
+                this.setInvisible(bukkitInvisible);
+                this.persistentInvisibility = bukkitInvisible;
+            }
+            // CraftBukkit end
+
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.forThrowable(throwable, "Loading entity NBT");
+            CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Entity being loaded");
+
+            this.fillCrashReportCategory(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
         }
     }
 
@@ -1762,44 +2157,59 @@
     }
 
     @Nullable
-    protected final String getEncodeId() {
-        EntityType<?> type = this.getType();
-        ResourceLocation key = EntityType.getKey(type);
-        return type.canSerialize() && key != null ? key.toString() : null;
+    public final String getEncodeId() {
+        EntityType<?> entitytypes = this.getType();
+        ResourceLocation minecraftkey = EntityType.getKey(entitytypes);
+
+        return entitytypes.canSerialize() && minecraftkey != null ? minecraftkey.toString() : null;
     }
 
+    // CraftBukkit start - allow excluding certain data when saving
+    protected void addAdditionalSaveData(CompoundTag nbttagcompound, boolean includeAll) {
+        addAdditionalSaveData(nbttagcompound);
+    }
+    // CraftBukkit end
+
     protected abstract void readAdditionalSaveData(CompoundTag compound);
 
     protected abstract void addAdditionalSaveData(CompoundTag compound);
 
     protected ListTag newDoubleList(double... numbers) {
-        ListTag list = new ListTag();
+        ListTag nbttaglist = new ListTag();
+        double[] adouble1 = numbers;
+        int i = numbers.length;
 
-        for (double d : numbers) {
-            list.add(DoubleTag.valueOf(d));
+        for (int j = 0; j < i; ++j) {
+            double d0 = adouble1[j];
+
+            nbttaglist.add(DoubleTag.valueOf(d0));
         }
 
-        return list;
+        return nbttaglist;
     }
 
     protected ListTag newFloatList(float... numbers) {
-        ListTag list = new ListTag();
+        ListTag nbttaglist = new ListTag();
+        float[] afloat1 = numbers;
+        int i = numbers.length;
 
-        for (float f : numbers) {
-            list.add(FloatTag.valueOf(f));
+        for (int j = 0; j < i; ++j) {
+            float f = afloat1[j];
+
+            nbttaglist.add(FloatTag.valueOf(f));
         }
 
-        return list;
+        return nbttaglist;
     }
 
     @Nullable
-    public ItemEntity spawnAtLocation(ItemLike item) {
+    public ItemEntity spawnAtLocation(IMaterial item) {
         return this.spawnAtLocation(item, 0);
     }
 
     @Nullable
-    public ItemEntity spawnAtLocation(ItemLike item, int offsetY) {
-        return this.spawnAtLocation(new ItemStack(item), (float)offsetY);
+    public ItemEntity spawnAtLocation(IMaterial item, int offsetY) {
+        return this.spawnAtLocation(new ItemStack(item), (float) offsetY);
     }
 
     @Nullable
@@ -1814,10 +2224,24 @@
         } else if (this.level().isClientSide) {
             return null;
         } else {
-            ItemEntity itemEntity = new ItemEntity(this.level(), this.getX(), this.getY() + (double)offsetY, this.getZ(), stack);
-            itemEntity.setDefaultPickUpDelay();
-            this.level().addFreshEntity(itemEntity);
-            return itemEntity;
+            // CraftBukkit start - Capture drops for death event
+            if (this instanceof net.minecraft.world.entity.LivingEntity && !((net.minecraft.world.entity.LivingEntity) this).forceDrops) {
+                ((net.minecraft.world.entity.LivingEntity) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(stack));
+                return null;
+            }
+            // CraftBukkit end
+            ItemEntity entityitem = new ItemEntity(this.level(), this.getX(), this.getY() + (double) offsetY, this.getZ(), stack);
+
+            entityitem.setDefaultPickUpDelay();
+            // CraftBukkit start
+            EntityDropItemEvent event = new EntityDropItemEvent(this.getBukkitEntity(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+            Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return null;
+            }
+            // CraftBukkit end
+            this.level().addFreshEntity(entityitem);
+            return entityitem;
         }
     }
 
@@ -1830,25 +2254,17 @@
             return false;
         } else {
             float f = this.dimensions.width * 0.8F;
-            AABB aABB = AABB.ofSize(this.getEyePosition(), (double)f, 1.0E-6, (double)f);
-            return BlockPos.betweenClosedStream(aABB)
-                .anyMatch(
-                    blockPos -> {
-                        BlockState blockState = this.level().getBlockState(blockPos);
-                        return !blockState.isAir()
-                            && blockState.isSuffocating(this.level(), blockPos)
-                            && Shapes.joinIsNotEmpty(
-                                blockState.getCollisionShape(this.level(), blockPos)
-                                    .move((double)blockPos.getX(), (double)blockPos.getY(), (double)blockPos.getZ()),
-                                Shapes.create(aABB),
-                                BooleanOp.AND
-                            );
-                    }
-                );
+            AABB axisalignedbb = AABB.ofSize(this.getEyePosition(), (double) f, 1.0E-6D, (double) f);
+
+            return BlockPos.betweenClosedStream(axisalignedbb).anyMatch((blockposition) -> {
+                IBlockData iblockdata = this.level().getBlockState(blockposition);
+
+                return !iblockdata.isAir() && iblockdata.isSuffocating(this.level(), blockposition) && Shapes.joinIsNotEmpty(iblockdata.getCollisionShape(this.level(), blockposition).move((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()), Shapes.create(axisalignedbb), BooleanOp.AND);
+            });
         }
     }
 
-    public InteractionResult interact(Player player, InteractionHand hand) {
+    public InteractionResult interact(Player player, EnumHand hand) {
         return InteractionResult.PASS;
     }
 
@@ -1875,13 +2291,13 @@
     }
 
     protected void positionRider(Entity passenger, Entity.MoveFunction callback) {
-        Vec3 passengerRidingPosition = this.getPassengerRidingPosition(passenger);
-        callback.accept(passenger, passengerRidingPosition.x, passengerRidingPosition.y + (double)passenger.getMyRidingOffset(this), passengerRidingPosition.z);
-    }
+        Vec3 vec3d = this.getPassengerRidingPosition(passenger);
 
-    public void onPassengerTurned(Entity entityToUpdate) {
+        callback.accept(passenger, vec3d.x, vec3d.y + (double) passenger.getMyRidingOffset(this), vec3d.z);
     }
 
+    public void onPassengerTurned(Entity entityToUpdate) {}
+
     public float getMyRidingOffset(Entity entity) {
         return this.ridingOffset(entity);
     }
@@ -1891,11 +2307,11 @@
     }
 
     public Vec3 getPassengerRidingPosition(Entity entity) {
-        return new Vec3(this.getPassengerAttachmentPoint(entity, this.dimensions, 1.0F).rotateY(-this.yRot * (float) (Math.PI / 180.0))).add(this.position());
+        return (new Vec3(this.getPassengerAttachmentPoint(entity, this.dimensions, 1.0F).rotateY(-this.yRot * 0.017453292F))).add(this.position());
     }
 
-    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entityDimensions, float f) {
-        return new Vector3f(0.0F, entityDimensions.height, 0.0F);
+    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entitysize, float f) {
+        return new Vector3f(0.0F, entitysize.height, 0.0F);
     }
 
     public boolean startRiding(Entity vehicle) {
@@ -1903,7 +2319,7 @@
     }
 
     public boolean showVehicleHealth() {
-        return this instanceof LivingEntity;
+        return this instanceof net.minecraft.world.entity.LivingEntity;
     }
 
     public boolean startRiding(Entity vehicle, boolean force) {
@@ -1912,26 +2328,40 @@
         } else if (!vehicle.couldAcceptPassenger()) {
             return false;
         } else {
-            for (Entity entity = vehicle; entity.vehicle != null; entity = entity.vehicle) {
-                if (entity.vehicle == this) {
+            for (Entity entity1 = vehicle; entity1.vehicle != null; entity1 = entity1.vehicle) {
+                if (entity1.vehicle == this) {
                     return false;
                 }
             }
 
-            if (force || this.canRide(vehicle) && vehicle.canAddPassenger(this)) {
+            if (!force && (!this.canRide(vehicle) || !vehicle.canAddPassenger(this))) {
+                return false;
+            } else {
+                // CraftBukkit start
+                if (vehicle.getBukkitEntity() instanceof Vehicle && this.getBukkitEntity() instanceof LivingEntity) {
+                    VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) vehicle.getBukkitEntity(), this.getBukkitEntity());
+                    // Suppress during worldgen
+                    if (this.valid) {
+                        Bukkit.getPluginManager().callEvent(event);
+                    }
+                    if (event.isCancelled()) {
+                        return false;
+                    }
+                }
+                // CraftBukkit end
                 if (this.isPassenger()) {
                     this.stopRiding();
                 }
 
-                this.setPose(Pose.STANDING);
+                this.setPose(EntityPose.STANDING);
                 this.vehicle = vehicle;
                 this.vehicle.addPassenger(this);
-                vehicle.getIndirectPassengersStream()
-                    .filter(entity1 -> entity1 instanceof ServerPlayer)
-                    .forEach(entity1 -> CriteriaTriggers.START_RIDING_TRIGGER.trigger((ServerPlayer)entity1));
+                vehicle.getIndirectPassengersStream().filter((entity2) -> {
+                    return entity2 instanceof ServerPlayer;
+                }).forEach((entity2) -> {
+                    CriteriaTriggers.START_RIDING_TRIGGER.trigger((ServerPlayer) entity2);
+                });
                 return true;
-            } else {
-                return false;
             }
         }
     }
@@ -1941,17 +2371,20 @@
     }
 
     public void ejectPassengers() {
-        for (int i = this.passengers.size() - 1; i >= 0; i--) {
-            this.passengers.get(i).stopRiding();
+        for (int i = this.passengers.size() - 1; i >= 0; --i) {
+            ((Entity) this.passengers.get(i)).stopRiding();
         }
+
     }
 
     public void removeVehicle() {
         if (this.vehicle != null) {
             Entity entity = this.vehicle;
+
             this.vehicle = null;
-            entity.removePassenger(this);
+            if (!entity.removePassenger(this)) this.vehicle = entity; // CraftBukkit
         }
+
     }
 
     public void stopRiding() {
@@ -1966,6 +2399,7 @@
                 this.passengers = ImmutableList.of(passenger);
             } else {
                 List<Entity> list = Lists.newArrayList(this.passengers);
+
                 if (!this.level().isClientSide && passenger instanceof Player && !(this.getFirstPassenger() instanceof Player)) {
                     list.add(0, passenger);
                 } else {
@@ -1979,19 +2413,41 @@
         }
     }
 
-    protected void removePassenger(Entity passenger) {
-        if (passenger.getVehicle() == this) {
+    protected boolean removePassenger(Entity entity) { // CraftBukkit
+        if (entity.getVehicle() == this) {
             throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
         } else {
-            if (this.passengers.size() == 1 && this.passengers.get(0) == passenger) {
+            // CraftBukkit start
+            CraftEntity craft = (CraftEntity) entity.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) {
+                VehicleExitEvent event = new VehicleExitEvent(
+                        (Vehicle) getBukkitEntity(),
+                        (LivingEntity) entity.getBukkitEntity()
+                );
+                // Suppress during worldgen
+                if (this.valid) {
+                    Bukkit.getPluginManager().callEvent(event);
+                }
+                CraftEntity craftn = (CraftEntity) entity.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return false;
+                }
+            }
+            // CraftBukkit end
+            if (this.passengers.size() == 1 && this.passengers.get(0) == entity) {
                 this.passengers = ImmutableList.of();
             } else {
-                this.passengers = this.passengers.stream().filter(entity -> entity != passenger).collect(ImmutableList.toImmutableList());
+                this.passengers = (ImmutableList) this.passengers.stream().filter((entity1) -> {
+                    return entity1 != entity;
+                }).collect(ImmutableList.toImmutableList());
             }
 
-            passenger.boardingCooldown = 60;
-            this.gameEvent(GameEvent.ENTITY_DISMOUNT, passenger);
+            entity.boardingCooldown = 60;
+            this.gameEvent(GameEvent.ENTITY_DISMOUNT, entity);
         }
+        return true; // CraftBukkit
     }
 
     protected boolean canAddPassenger(Entity passenger) {
@@ -2002,8 +2458,8 @@
         return true;
     }
 
-    public void lerpTo(double d, double d1, double d2, float f, float f1, int i) {
-        this.setPos(d, d1, d2);
+    public void lerpTo(double d0, double d1, double d2, float f, float f1, int i) {
+        this.setPos(d0, d1, d2);
         this.setRot(f, f1);
     }
 
@@ -2040,12 +2496,14 @@
     }
 
     public Vec3 getHandHoldingItemAngle(Item item) {
-        if (!(this instanceof Player player)) {
+        if (!(this instanceof Player)) {
             return Vec3.ZERO;
         } else {
-            boolean flag = player.getOffhandItem().is(item) && !player.getMainHandItem().is(item);
-            HumanoidArm humanoidArm = flag ? player.getMainArm().getOpposite() : player.getMainArm();
-            return this.calculateViewVector(0.0F, this.getYRot() + (float)(humanoidArm == HumanoidArm.RIGHT ? 80 : -80)).scale(0.5);
+            Player entityhuman = (Player) this;
+            boolean flag = entityhuman.getOffhandItem().is(item) && !entityhuman.getMainHandItem().is(item);
+            HumanoidArm enummainhand = flag ? entityhuman.getMainArm().getOpposite() : entityhuman.getMainArm();
+
+            return this.calculateViewVector(0.0F, this.getYRot() + (float) (enummainhand == HumanoidArm.RIGHT ? 80 : -80)).scale(0.5D);
         }
     }
 
@@ -2071,17 +2529,25 @@
 
     protected void handleNetherPortal() {
         if (this.level() instanceof ServerLevel) {
-            int portalWaitTime = this.getPortalWaitTime();
-            ServerLevel serverLevel = (ServerLevel)this.level();
+            int i = this.getPortalWaitTime();
+            ServerLevel worldserver = (ServerLevel) this.level();
+
             if (this.isInsidePortal) {
-                MinecraftServer server = serverLevel.getServer();
-                ResourceKey<Level> resourceKey = this.level().dimension() == Level.NETHER ? Level.OVERWORLD : Level.NETHER;
-                ServerLevel level = server.getLevel(resourceKey);
-                if (level != null && server.isNetherEnabled() && !this.isPassenger() && this.portalTime++ >= portalWaitTime) {
+                MinecraftServer minecraftserver = worldserver.getServer();
+                ResourceKey<Level> resourcekey = this.level().getTypeKey() == LevelStem.NETHER ? Level.OVERWORLD : Level.NETHER; // CraftBukkit
+                ServerLevel worldserver1 = minecraftserver.getLevel(resourcekey);
+
+                if (true && !this.isPassenger() && this.portalTime++ >= i) { // CraftBukkit
                     this.level().getProfiler().push("portal");
-                    this.portalTime = portalWaitTime;
+                    this.portalTime = i;
                     this.setPortalCooldown();
-                    this.changeDimension(level);
+                    // CraftBukkit start
+                    if (this instanceof ServerPlayer) {
+                        ((ServerPlayer) this).changeDimension(worldserver1, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL);
+                    } else {
+                        this.changeDimension(worldserver1);
+                    }
+                    // CraftBukkit end
                     this.level().getProfiler().pop();
                 }
 
@@ -2104,40 +2570,39 @@
         return 300;
     }
 
-    public void lerpMotion(double x, double y, double z) {
-        this.setDeltaMovement(x, y, z);
+    public void lerpMotion(double x, double d1, double y) {
+        this.setDeltaMovement(x, d1, y);
     }
 
-    public void handleDamageEvent(DamageSource damageSource) {
-    }
+    public void handleDamageEvent(DamageSource damageSource) {}
 
     public void handleEntityEvent(byte id) {
         switch (id) {
             case 53:
                 HoneyBlock.showSlideParticles(this);
+            default:
         }
     }
 
-    public void animateHurt(float yaw) {
-    }
+    public void animateHurt(float yaw) {}
 
     public Iterable<ItemStack> getHandSlots() {
-        return EMPTY_LIST;
+        return Entity.EMPTY_LIST;
     }
 
     public Iterable<ItemStack> getArmorSlots() {
-        return EMPTY_LIST;
+        return Entity.EMPTY_LIST;
     }
 
     public Iterable<ItemStack> getAllSlots() {
         return Iterables.concat(this.getHandSlots(), this.getArmorSlots());
     }
 
-    public void setItemSlot(EquipmentSlot slot, ItemStack stack) {
-    }
+    public void setItemSlot(EquipmentSlot slot, ItemStack stack) {}
 
     public boolean isOnFire() {
         boolean flag = this.level() != null && this.level().isClientSide;
+
         return !this.fireImmune() && (this.remainingFireTicks > 0 || flag && this.getSharedFlag(0));
     }
 
@@ -2182,7 +2647,7 @@
     }
 
     public boolean isCrouching() {
-        return this.hasPose(Pose.CROUCHING);
+        return this.hasPose(EntityPose.CROUCHING);
     }
 
     public boolean isSprinting() {
@@ -2198,7 +2663,7 @@
     }
 
     public boolean isVisuallySwimming() {
-        return this.hasPose(Pose.SWIMMING);
+        return this.hasPose(EntityPose.SWIMMING);
     }
 
     public boolean isVisuallyCrawling() {
@@ -2206,6 +2671,13 @@
     }
 
     public void setSwimming(boolean swimming) {
+        // CraftBukkit start
+        if (valid && this.isSwimming() != swimming && this instanceof net.minecraft.world.entity.LivingEntity) {
+            if (CraftEventFactory.callToggleSwimEvent((net.minecraft.world.entity.LivingEntity) this, swimming).isCancelled()) {
+                return;
+            }
+        }
+        // CraftBukkit end
         this.setSharedFlag(4, swimming);
     }
 
@@ -2230,8 +2702,9 @@
         if (player.isSpectator()) {
             return false;
         } else {
-            Team team = this.getTeam();
-            return (team == null || player == null || player.getTeam() != team || !team.canSeeFriendlyInvisibles()) && this.isInvisible();
+            PlayerTeam scoreboardteam = this.getTeam();
+
+            return scoreboardteam != null && player != null && player.getTeam() == scoreboardteam && scoreboardteam.canSeeFriendlyInvisibles() ? false : this.isInvisible();
         }
     }
 
@@ -2239,8 +2712,7 @@
         return false;
     }
 
-    public void updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> listenerConsumer) {
-    }
+    public void updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> listenerConsumer) {}
 
     @Nullable
     public PlayerTeam getTeam() {
@@ -2248,53 +2720,71 @@
     }
 
     public boolean isAlliedTo(Entity entity) {
-        return this.isAlliedTo(entity.getTeam());
+        return this.isAlliedTo((Team) entity.getTeam());
     }
 
     public boolean isAlliedTo(Team team) {
-        return this.getTeam() != null && this.getTeam().isAlliedTo(team);
+        return this.getTeam() != null ? this.getTeam().isAlliedTo(team) : false;
     }
 
+    // CraftBukkit - start
     public void setInvisible(boolean invisible) {
-        this.setSharedFlag(5, invisible);
+        if (!this.persistentInvisibility) { // Prevent Minecraft from removing our invisibility flag
+            this.setSharedFlag(5, invisible);
+        }
+        // CraftBukkit - end
     }
 
-    protected boolean getSharedFlag(int flag) {
-        return (this.entityData.get(DATA_SHARED_FLAGS_ID) & 1 << flag) != 0;
+    public boolean getSharedFlag(int flag) {
+        return ((Byte) this.entityData.get(Entity.DATA_SHARED_FLAGS_ID) & 1 << flag) != 0;
     }
 
-    protected void setSharedFlag(int flag, boolean set) {
-        byte b = this.entityData.get(DATA_SHARED_FLAGS_ID);
+    public void setSharedFlag(int flag, boolean set) {
+        byte b0 = (Byte) this.entityData.get(Entity.DATA_SHARED_FLAGS_ID);
+
         if (set) {
-            this.entityData.set(DATA_SHARED_FLAGS_ID, (byte)(b | 1 << flag));
+            this.entityData.set(Entity.DATA_SHARED_FLAGS_ID, (byte) (b0 | 1 << flag));
         } else {
-            this.entityData.set(DATA_SHARED_FLAGS_ID, (byte)(b & ~(1 << flag)));
+            this.entityData.set(Entity.DATA_SHARED_FLAGS_ID, (byte) (b0 & ~(1 << flag)));
         }
+
     }
 
     public int getMaxAirSupply() {
-        return 300;
+        return maxAirTicks; // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
     }
 
     public int getAirSupply() {
-        return this.entityData.get(DATA_AIR_SUPPLY_ID);
+        return (Integer) this.entityData.get(Entity.DATA_AIR_SUPPLY_ID);
     }
 
     public void setAirSupply(int air) {
-        this.entityData.set(DATA_AIR_SUPPLY_ID, air);
+        // CraftBukkit start
+        EntityAirChangeEvent event = new EntityAirChangeEvent(this.getBukkitEntity(), air);
+        // Suppress during worldgen
+        if (this.valid) {
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+        }
+        if (event.isCancelled() && this.getAirSupply() != air) {
+            this.entityData.markDirty(Entity.DATA_AIR_SUPPLY_ID);
+            return;
+        }
+        this.entityData.set(Entity.DATA_AIR_SUPPLY_ID, event.getAmount());
+        // CraftBukkit end
     }
 
     public int getTicksFrozen() {
-        return this.entityData.get(DATA_TICKS_FROZEN);
+        return (Integer) this.entityData.get(Entity.DATA_TICKS_FROZEN);
     }
 
     public void setTicksFrozen(int ticksFrozen) {
-        this.entityData.set(DATA_TICKS_FROZEN, ticksFrozen);
+        this.entityData.set(Entity.DATA_TICKS_FROZEN, ticksFrozen);
     }
 
     public float getPercentFrozen() {
-        int ticksRequiredToFreeze = this.getTicksRequiredToFreeze();
-        return (float)Math.min(this.getTicksFrozen(), ticksRequiredToFreeze) / (float)ticksRequiredToFreeze;
+        int i = this.getTicksRequiredToFreeze();
+
+        return (float) Math.min(this.getTicksFrozen(), i) / (float) i;
     }
 
     public boolean isFullyFrozen() {
@@ -2307,102 +2797,146 @@
 
     public void thunderHit(ServerLevel level, LightningBolt lightning) {
         this.setRemainingFireTicks(this.remainingFireTicks + 1);
+        // CraftBukkit start
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = lightning.getBukkitEntity();
+        final PluginManager pluginManager = Bukkit.getPluginManager();
+        // CraftBukkit end
+
         if (this.remainingFireTicks == 0) {
-            this.setSecondsOnFire(8);
+            // CraftBukkit start - Call a combust event when lightning strikes
+            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+            if (!entityCombustEvent.isCancelled()) {
+                this.setSecondsOnFire(entityCombustEvent.getDuration(), false);
+            }
+            // CraftBukkit end
         }
 
-        this.hurt(this.damageSources().lightningBolt(), 5.0F);
+        // CraftBukkit start
+        if (thisBukkitEntity instanceof Hanging) {
+            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
+            pluginManager.callEvent(hangingEvent);
+
+            if (hangingEvent.isCancelled()) {
+                return;
+            }
+        }
+
+        if (this.fireImmune()) {
+            return;
+        }
+        CraftEventFactory.entityDamage = lightning;
+        if (!this.hurt(this.damageSources().lightningBolt(), 5.0F)) {
+            CraftEventFactory.entityDamage = null;
+            return;
+        }
+        // CraftBukkit end
     }
 
     public void onAboveBubbleCol(boolean downwards) {
-        Vec3 deltaMovement = this.getDeltaMovement();
-        double max;
+        Vec3 vec3d = this.getDeltaMovement();
+        double d0;
+
         if (downwards) {
-            max = Math.max(-0.9, deltaMovement.y - 0.03);
+            d0 = Math.max(-0.9D, vec3d.y - 0.03D);
         } else {
-            max = Math.min(1.8, deltaMovement.y + 0.1);
+            d0 = Math.min(1.8D, vec3d.y + 0.1D);
         }
 
-        this.setDeltaMovement(deltaMovement.x, max, deltaMovement.z);
+        this.setDeltaMovement(vec3d.x, d0, vec3d.z);
     }
 
     public void onInsideBubbleColumn(boolean downwards) {
-        Vec3 deltaMovement = this.getDeltaMovement();
-        double max;
+        Vec3 vec3d = this.getDeltaMovement();
+        double d0;
+
         if (downwards) {
-            max = Math.max(-0.3, deltaMovement.y - 0.03);
+            d0 = Math.max(-0.3D, vec3d.y - 0.03D);
         } else {
-            max = Math.min(0.7, deltaMovement.y + 0.06);
+            d0 = Math.min(0.7D, vec3d.y + 0.06D);
         }
 
-        this.setDeltaMovement(deltaMovement.x, max, deltaMovement.z);
+        this.setDeltaMovement(vec3d.x, d0, vec3d.z);
         this.resetFallDistance();
     }
 
-    public boolean killedEntity(ServerLevel level, LivingEntity entity) {
+    public boolean killedEntity(ServerLevel level, net.minecraft.world.entity.LivingEntity entity) {
         return true;
     }
 
     public void checkSlowFallDistance() {
-        if (this.getDeltaMovement().y() > -0.5 && this.fallDistance > 1.0F) {
+        if (this.getDeltaMovement().y() > -0.5D && this.fallDistance > 1.0F) {
             this.fallDistance = 1.0F;
         }
+
     }
 
     public void resetFallDistance() {
         this.fallDistance = 0.0F;
     }
 
-    protected void moveTowardsClosestSpace(double x, double y, double z) {
-        BlockPos blockPos = BlockPos.containing(x, y, z);
-        Vec3 vec3 = new Vec3(x - (double)blockPos.getX(), y - (double)blockPos.getY(), z - (double)blockPos.getZ());
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
-        Direction direction = Direction.UP;
-        double d = Double.MAX_VALUE;
+    protected void moveTowardsClosestSpace(double x, double d1, double y) {
+        BlockPos blockposition = BlockPos.containing(x, d1, y);
+        Vec3 vec3d = new Vec3(x - (double) blockposition.getX(), d1 - (double) blockposition.getY(), y - (double) blockposition.getZ());
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+        Direction enumdirection = Direction.UP;
+        double d3 = Double.MAX_VALUE;
+        Direction[] aenumdirection = new Direction[]{Direction.NORTH, Direction.SOUTH, Direction.WEST, Direction.EAST, Direction.UP};
+        int i = aenumdirection.length;
 
-        for (Direction direction1 : new Direction[]{Direction.NORTH, Direction.SOUTH, Direction.WEST, Direction.EAST, Direction.UP}) {
-            mutableBlockPos.setWithOffset(blockPos, direction1);
-            if (!this.level().getBlockState(mutableBlockPos).isCollisionShapeFullBlock(this.level(), mutableBlockPos)) {
-                double d1 = vec3.get(direction1.getAxis());
-                double d2 = direction1.getAxisDirection() == Direction.AxisDirection.POSITIVE ? 1.0 - d1 : d1;
-                if (d2 < d) {
-                    d = d2;
-                    direction = direction1;
+        for (int j = 0; j < i; ++j) {
+            Direction enumdirection1 = aenumdirection[j];
+
+            blockposition_mutableblockposition.setWithOffset(blockposition, enumdirection1);
+            if (!this.level().getBlockState(blockposition_mutableblockposition).isCollisionShapeFullBlock(this.level(), blockposition_mutableblockposition)) {
+                double d4 = vec3d.get(enumdirection1.getAxis());
+                double d5 = enumdirection1.getAxisDirection() == Direction.AxisDirection.POSITIVE ? 1.0D - d4 : d4;
+
+                if (d5 < d3) {
+                    d3 = d5;
+                    enumdirection = enumdirection1;
                 }
             }
         }
 
         float f = this.random.nextFloat() * 0.2F + 0.1F;
-        float f1 = (float)direction.getAxisDirection().getStep();
-        Vec3 vec31 = this.getDeltaMovement().scale(0.75);
-        if (direction.getAxis() == Direction.Axis.X) {
-            this.setDeltaMovement((double)(f1 * f), vec31.y, vec31.z);
-        } else if (direction.getAxis() == Direction.Axis.Y) {
-            this.setDeltaMovement(vec31.x, (double)(f1 * f), vec31.z);
-        } else if (direction.getAxis() == Direction.Axis.Z) {
-            this.setDeltaMovement(vec31.x, vec31.y, (double)(f1 * f));
+        float f1 = (float) enumdirection.getAxisDirection().getStep();
+        Vec3 vec3d1 = this.getDeltaMovement().scale(0.75D);
+
+        if (enumdirection.getAxis() == Direction.Axis.X) {
+            this.setDeltaMovement((double) (f1 * f), vec3d1.y, vec3d1.z);
+        } else if (enumdirection.getAxis() == Direction.Axis.Y) {
+            this.setDeltaMovement(vec3d1.x, (double) (f1 * f), vec3d1.z);
+        } else if (enumdirection.getAxis() == Direction.Axis.Z) {
+            this.setDeltaMovement(vec3d1.x, vec3d1.y, (double) (f1 * f));
         }
+
     }
 
-    public void makeStuckInBlock(BlockState state, Vec3 motionMultiplier) {
+    public void makeStuckInBlock(IBlockData state, Vec3 motionMultiplier) {
         this.resetFallDistance();
         this.stuckSpeedMultiplier = motionMultiplier;
     }
 
     private static Component removeAction(Component name) {
-        MutableComponent mutableComponent = name.plainCopy().setStyle(name.getStyle().withClickEvent(null));
+        MutableComponent ichatmutablecomponent = name.plainCopy().setStyle(name.getStyle().withClickEvent((ClickEvent) null));
+        Iterator iterator = name.getSiblings().iterator();
 
-        for (Component component : name.getSiblings()) {
-            mutableComponent.append(removeAction(component));
+        while (iterator.hasNext()) {
+            Component ichatbasecomponent1 = (Component) iterator.next();
+
+            ichatmutablecomponent.append(removeAction(ichatbasecomponent1));
         }
 
-        return mutableComponent;
+        return ichatmutablecomponent;
     }
 
     @Override
     public Component getName() {
-        Component customName = this.getCustomName();
-        return customName != null ? removeAction(customName) : this.getTypeName();
+        Component ichatbasecomponent = this.getCustomName();
+
+        return ichatbasecomponent != null ? removeAction(ichatbasecomponent) : this.getTypeName();
     }
 
     protected Component getTypeName() {
@@ -2417,11 +2951,9 @@
         return 0.0F;
     }
 
-    public void setYHeadRot(float yHeadRot) {
-    }
+    public void setYHeadRot(float yHeadRot) {}
 
-    public void setYBodyRot(float yBodyRot) {
-    }
+    public void setYBodyRot(float yBodyRot) {}
 
     public boolean isAttackable() {
         return true;
@@ -2431,40 +2963,14 @@
         return false;
     }
 
-    @Override
     public String toString() {
-        String string = this.level() == null ? "~NULL~" : this.level().toString();
-        return this.removalReason != null
-            ? String.format(
-                Locale.ROOT,
-                "%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f, removed=%s]",
-                this.getClass().getSimpleName(),
-                this.getName().getString(),
-                this.id,
-                string,
-                this.getX(),
-                this.getY(),
-                this.getZ(),
-                this.removalReason
-            )
-            : String.format(
-                Locale.ROOT,
-                "%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]",
-                this.getClass().getSimpleName(),
-                this.getName().getString(),
-                this.id,
-                string,
-                this.getX(),
-                this.getY(),
-                this.getZ()
-            );
+        String s = this.level() == null ? "~NULL~" : this.level().toString();
+
+        return this.removalReason != null ? String.format(Locale.ROOT, "%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f, removed=%s]", this.getClass().getSimpleName(), this.getName().getString(), this.id, s, this.getX(), this.getY(), this.getZ(), this.removalReason) : String.format(Locale.ROOT, "%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]", this.getClass().getSimpleName(), this.getName().getString(), this.id, s, this.getX(), this.getY(), this.getZ());
     }
 
     public boolean isInvulnerableTo(DamageSource source) {
-        return this.isRemoved()
-            || this.invulnerable && !source.is(DamageTypeTags.BYPASSES_INVULNERABILITY) && !source.isCreativePlayer()
-            || source.is(DamageTypeTags.IS_FIRE) && this.fireImmune()
-            || source.is(DamageTypeTags.IS_FALL) && this.getType().is(EntityTypeTags.FALL_DAMAGE_IMMUNE);
+        return this.isRemoved() || this.invulnerable && !source.is(DamageTypeTags.BYPASSES_INVULNERABILITY) && !source.isCreativePlayer() || source.is(DamageTypeTags.IS_FIRE) && this.fireImmune() || source.is(DamageTypeTags.IS_FALL) && this.getType().is(EntityTypeTags.FALL_DAMAGE_IMMUNE);
     }
 
     public boolean isInvulnerable() {
@@ -2480,39 +2986,77 @@
     }
 
     public void restoreFrom(Entity entity) {
-        CompoundTag compoundTag = entity.saveWithoutId(new CompoundTag());
-        compoundTag.remove("Dimension");
-        this.load(compoundTag);
+        CompoundTag nbttagcompound = entity.saveWithoutId(new CompoundTag());
+
+        nbttagcompound.remove("Dimension");
+        this.load(nbttagcompound);
         this.portalCooldown = entity.portalCooldown;
         this.portalEntrancePos = entity.portalEntrancePos;
     }
 
     @Nullable
     public Entity changeDimension(ServerLevel destination) {
+        // CraftBukkit start
+        return teleportTo(destination, null);
+    }
+
+    @Nullable
+    public Entity teleportTo(ServerLevel worldserver, Vec3 location) {
+        // CraftBukkit end
         if (this.level() instanceof ServerLevel && !this.isRemoved()) {
             this.level().getProfiler().push("changeDimension");
-            this.unRide();
+            // CraftBukkit start
+            // this.unRide();
+            if (worldserver == null) {
+                return null;
+            }
+            // CraftBukkit end
             this.level().getProfiler().push("reposition");
-            PortalInfo portalInfo = this.findDimensionEntryPoint(destination);
-            if (portalInfo == null) {
+            PortalInfo shapedetectorshape = (location == null) ? this.findDimensionEntryPoint(worldserver) : new PortalInfo(new Vec3(location.x(), location.y(), location.z()), Vec3.ZERO, this.yRot, this.xRot, worldserver, null); // CraftBukkit
+
+            if (shapedetectorshape == null) {
                 return null;
             } else {
+                // CraftBukkit start
+                worldserver = shapedetectorshape.world;
+                if (worldserver == level) {
+                    // SPIGOT-6782: Just move the entity if a plugin changed the world to the one the entity is already in
+                    moveTo(shapedetectorshape.pos.x, shapedetectorshape.pos.y, shapedetectorshape.pos.z, shapedetectorshape.yRot, shapedetectorshape.xRot);
+                    setDeltaMovement(shapedetectorshape.speed);
+                    return this;
+                }
+                this.unRide();
+                // CraftBukkit end
+
                 this.level().getProfiler().popPush("reloading");
-                Entity entity = this.getType().create(destination);
+                Entity entity = this.getType().create(worldserver);
+
                 if (entity != null) {
                     entity.restoreFrom(this);
-                    entity.moveTo(portalInfo.pos.x, portalInfo.pos.y, portalInfo.pos.z, portalInfo.yRot, entity.getXRot());
-                    entity.setDeltaMovement(portalInfo.speed);
-                    destination.addDuringTeleport(entity);
-                    if (destination.dimension() == Level.END) {
-                        ServerLevel.makeObsidianPlatform(destination);
+                    entity.moveTo(shapedetectorshape.pos.x, shapedetectorshape.pos.y, shapedetectorshape.pos.z, shapedetectorshape.yRot, entity.getXRot());
+                    entity.setDeltaMovement(shapedetectorshape.speed);
+                    // CraftBukkit start - Don't spawn the new entity if the current entity isn't spawned
+                    if (this.inWorld) {
+                        worldserver.addDuringTeleport(entity);
+                        if (worldserver.getTypeKey() == LevelStem.END) { // CraftBukkit
+                            ServerLevel.makeObsidianPlatform(worldserver, this); // CraftBukkit
+                        }
                     }
+                    // CraftBukkit end
+                    // CraftBukkit start - Forward the CraftEntity to the new entity
+                    this.getBukkitEntity().setHandle(entity);
+                    entity.bukkitEntity = this.getBukkitEntity();
+
+                    if (this instanceof Mob) {
+                        ((Mob) this).dropLeash(true, false); // Unleash to prevent duping of leads.
+                    }
+                    // CraftBukkit end
                 }
 
                 this.removeAfterChangingDimensions();
                 this.level().getProfiler().pop();
-                ((ServerLevel)this.level()).resetEmptyTime();
-                destination.resetEmptyTime();
+                ((ServerLevel) this.level()).resetEmptyTime();
+                worldserver.resetEmptyTime();
                 this.level().getProfiler().pop();
                 return entity;
             }
@@ -2527,54 +3071,69 @@
 
     @Nullable
     protected PortalInfo findDimensionEntryPoint(ServerLevel destination) {
-        boolean flag = this.level().dimension() == Level.END && destination.dimension() == Level.OVERWORLD;
-        boolean flag1 = destination.dimension() == Level.END;
+        // CraftBukkit start
+        if (destination == null) {
+            return null;
+        }
+        boolean flag = this.level().getTypeKey() == LevelStem.END && destination.getTypeKey() == LevelStem.OVERWORLD; // fromEndToOverworld
+        boolean flag1 = destination.getTypeKey() == LevelStem.END; // targetIsEnd
+        // CraftBukkit end
+
         if (!flag && !flag1) {
-            boolean flag2 = destination.dimension() == Level.NETHER;
-            if (this.level().dimension() != Level.NETHER && !flag2) {
+            boolean flag2 = destination.getTypeKey() == LevelStem.NETHER; // CraftBukkit
+
+            if (this.level().getTypeKey() != LevelStem.NETHER && !flag2) { // CraftBukkit
                 return null;
             } else {
-                WorldBorder worldBorder = destination.getWorldBorder();
-                double teleportationScale = DimensionType.getTeleportationScale(this.level().dimensionType(), destination.dimensionType());
-                BlockPos blockPos1 = worldBorder.clampToBounds(this.getX() * teleportationScale, this.getY(), this.getZ() * teleportationScale);
-                return this.getExitPortal(destination, blockPos1, flag2, worldBorder)
-                    .map(
-                        foundRectangle -> {
-                            BlockState blockState = this.level().getBlockState(this.portalEntrancePos);
-                            Direction.Axis axis;
-                            Vec3 relativePortalPosition;
-                            if (blockState.hasProperty(BlockStateProperties.HORIZONTAL_AXIS)) {
-                                axis = blockState.getValue(BlockStateProperties.HORIZONTAL_AXIS);
-                                BlockUtil.FoundRectangle largestRectangleAround = BlockUtil.getLargestRectangleAround(
-                                    this.portalEntrancePos, axis, 21, Direction.Axis.Y, 21, blockPos2 -> this.level().getBlockState(blockPos2) == blockState
-                                );
-                                relativePortalPosition = this.getRelativePortalPosition(axis, largestRectangleAround);
-                            } else {
-                                axis = Direction.Axis.X;
-                                relativePortalPosition = new Vec3(0.5, 0.0, 0.0);
-                            }
-        
-                            return PortalShape.createPortalInfo(
-                                destination, foundRectangle, axis, relativePortalPosition, this, this.getDeltaMovement(), this.getYRot(), this.getXRot()
-                            );
-                        }
-                    )
-                    .orElse(null);
+                WorldBorder worldborder = destination.getWorldBorder();
+                double d0 = DimensionType.getTeleportationScale(this.level().dimensionType(), destination.dimensionType());
+                BlockPos blockposition = worldborder.clampToBounds(this.getX() * d0, this.getY(), this.getZ() * d0);
+                // CraftBukkit start
+                CraftPortalEvent event = callPortalEvent(this, destination, new Vec3(blockposition.getX(), blockposition.getY(), blockposition.getZ()), PlayerTeleportEvent.TeleportCause.NETHER_PORTAL, flag2 ? 16 : 128, 16);
+                if (event == null) {
+                    return null;
+                }
+                final ServerLevel worldserverFinal = destination = ((CraftWorld) event.getTo().getWorld()).getHandle();
+                worldborder = worldserverFinal.getWorldBorder();
+                blockposition = worldborder.clampToBounds(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
+
+                return (PortalInfo) this.getExitPortal(destination, blockposition, flag2, worldborder, event.getSearchRadius(), event.getCanCreatePortal(), event.getCreationRadius()).map((blockutil_rectangle) -> {
+                    // CraftBukkit end
+                    IBlockData iblockdata = this.level().getBlockState(this.portalEntrancePos);
+                    Direction.Axis enumdirection_enumaxis;
+                    Vec3 vec3d;
+
+                    if (iblockdata.hasProperty(BlockStateProperties.HORIZONTAL_AXIS)) {
+                        enumdirection_enumaxis = (Direction.Axis) iblockdata.getValue(BlockStateProperties.HORIZONTAL_AXIS);
+                        BlockUtil.FoundRectangle blockutil_rectangle1 = BlockUtil.getLargestRectangleAround(this.portalEntrancePos, enumdirection_enumaxis, 21, Direction.Axis.Y, 21, (blockposition1) -> {
+                            return this.level().getBlockState(blockposition1) == iblockdata;
+                        });
+
+                        vec3d = this.getRelativePortalPosition(enumdirection_enumaxis, blockutil_rectangle1);
+                    } else {
+                        enumdirection_enumaxis = Direction.Axis.X;
+                        vec3d = new Vec3(0.5D, 0.0D, 0.0D);
+                    }
+
+                    return PortalShape.createPortalInfo(worldserverFinal, blockutil_rectangle, enumdirection_enumaxis, vec3d, this, this.getDeltaMovement(), this.getYRot(), this.getXRot(), event); // CraftBukkit
+                }).orElse(null); // CraftBukkit - decompile error
             }
         } else {
-            BlockPos blockPos;
+            BlockPos blockposition1;
+
             if (flag1) {
-                blockPos = ServerLevel.END_SPAWN_POINT;
+                blockposition1 = ServerLevel.END_SPAWN_POINT;
             } else {
-                blockPos = destination.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, destination.getSharedSpawnPos());
+                blockposition1 = destination.getHeightmapPos(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, destination.getSharedSpawnPos());
             }
+            // CraftBukkit start
+            CraftPortalEvent event = callPortalEvent(this, destination, new Vec3(blockposition1.getX() + 0.5D, blockposition1.getY(), blockposition1.getZ() + 0.5D), PlayerTeleportEvent.TeleportCause.END_PORTAL, 0, 0);
+            if (event == null) {
+                return null;
+            }
 
-            return new PortalInfo(
-                new Vec3((double)blockPos.getX() + 0.5, (double)blockPos.getY(), (double)blockPos.getZ() + 0.5),
-                this.getDeltaMovement(),
-                this.getYRot(),
-                this.getXRot()
-            );
+            return new PortalInfo(new Vec3(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ()), this.getDeltaMovement(), this.getYRot(), this.getXRot(), ((CraftWorld) event.getTo().getWorld()).getHandle(), event);
+            // CraftBukkit end
         }
     }
 
@@ -2582,21 +3141,34 @@
         return PortalShape.getRelativePosition(portal, axis, this.position(), this.getDimensions(this.getPose()));
     }
 
-    protected Optional<BlockUtil.FoundRectangle> getExitPortal(ServerLevel destination, BlockPos findFrom, boolean isToNether, WorldBorder worldBorder) {
-        return destination.getPortalForcer().findPortalAround(findFrom, isToNether, worldBorder);
+    // CraftBukkit start
+    protected CraftPortalEvent callPortalEvent(Entity entity, ServerLevel exitWorldServer, Vec3 exitPosition, PlayerTeleportEvent.TeleportCause cause, int searchRadius, int creationRadius) {
+        org.bukkit.entity.Entity bukkitEntity = entity.getBukkitEntity();
+        Location enter = bukkitEntity.getLocation();
+        Location exit = CraftLocation.toBukkit(exitPosition, exitWorldServer.getWorld());
+
+        EntityPortalEvent event = new EntityPortalEvent(bukkitEntity, enter, exit, searchRadius);
+        event.getEntity().getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !entity.isAlive()) {
+            return null;
+        }
+        return new CraftPortalEvent(event);
     }
 
+    protected Optional<BlockUtil.FoundRectangle> getExitPortal(ServerLevel worldserver, BlockPos blockposition, boolean flag, WorldBorder worldborder, int searchRadius, boolean canCreatePortal, int createRadius) {
+        return worldserver.getPortalForcer().findPortalAround(blockposition, worldborder, searchRadius);
+        // CraftBukkit end
+    }
+
     public boolean canChangeDimensions() {
         return !this.isPassenger() && !this.isVehicle();
     }
 
-    public float getBlockExplosionResistance(
-        Explosion explosion, BlockGetter level, BlockPos pos, BlockState blockState, FluidState fluidState, float explosionPower
-    ) {
+    public float getBlockExplosionResistance(Explosion explosion, BlockGetter level, BlockPos pos, IBlockData blockState, FluidState fluidState, float explosionPower) {
         return explosionPower;
     }
 
-    public boolean shouldBlockExplode(Explosion explosion, BlockGetter level, BlockPos pos, BlockState blockState, float explosionPower) {
+    public boolean shouldBlockExplode(Explosion explosion, BlockGetter level, BlockPos pos, IBlockData blockState, float explosionPower) {
         return true;
     }
 
@@ -2609,17 +3181,26 @@
     }
 
     public void fillCrashReportCategory(CrashReportCategory category) {
-        category.setDetail("Entity Type", () -> EntityType.getKey(this.getType()) + " (" + this.getClass().getCanonicalName() + ")");
-        category.setDetail("Entity ID", this.id);
-        category.setDetail("Entity Name", () -> this.getName().getString());
-        category.setDetail("Entity's Exact location", String.format(Locale.ROOT, "%.2f, %.2f, %.2f", this.getX(), this.getY(), this.getZ()));
-        category.setDetail(
-            "Entity's Block location", CrashReportCategory.formatLocation(this.level(), Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()))
-        );
-        Vec3 deltaMovement = this.getDeltaMovement();
-        category.setDetail("Entity's Momentum", String.format(Locale.ROOT, "%.2f, %.2f, %.2f", deltaMovement.x, deltaMovement.y, deltaMovement.z));
-        category.setDetail("Entity's Passengers", () -> this.getPassengers().toString());
-        category.setDetail("Entity's Vehicle", () -> String.valueOf(this.getVehicle()));
+        category.setDetail("Entity Type", () -> {
+            ResourceLocation minecraftkey = EntityType.getKey(this.getType());
+
+            return minecraftkey + " (" + this.getClass().getCanonicalName() + ")";
+        });
+        category.setDetail("Entity ID", (Object) this.id);
+        category.setDetail("Entity Name", () -> {
+            return this.getName().getString();
+        });
+        category.setDetail("Entity's Exact location", (Object) String.format(Locale.ROOT, "%.2f, %.2f, %.2f", this.getX(), this.getY(), this.getZ()));
+        category.setDetail("Entity's Block location", (Object) CrashReportCategory.formatLocation(this.level(), Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ())));
+        Vec3 vec3d = this.getDeltaMovement();
+
+        category.setDetail("Entity's Momentum", (Object) String.format(Locale.ROOT, "%.2f, %.2f, %.2f", vec3d.x, vec3d.y, vec3d.z));
+        category.setDetail("Entity's Passengers", () -> {
+            return this.getPassengers().toString();
+        });
+        category.setDetail("Entity's Vehicle", () -> {
+            return String.valueOf(this.getVehicle());
+        });
     }
 
     public boolean displayFireAnimation() {
@@ -2650,144 +3231,164 @@
     }
 
     public static double getViewScale() {
-        return viewScale;
+        return Entity.viewScale;
     }
 
     public static void setViewScale(double renderDistWeight) {
-        viewScale = renderDistWeight;
+        Entity.viewScale = renderDistWeight;
     }
 
     @Override
     public Component getDisplayName() {
-        return PlayerTeam.formatNameForTeam(this.getTeam(), this.getName())
-            .withStyle(style -> style.withHoverEvent(this.createHoverEvent()).withInsertion(this.getStringUUID()));
+        return PlayerTeam.formatNameForTeam(this.getTeam(), this.getName()).withStyle((chatmodifier) -> {
+            return chatmodifier.withHoverEvent(this.createHoverEvent()).withInsertion(this.getStringUUID());
+        });
     }
 
     public void setCustomName(@Nullable Component name) {
-        this.entityData.set(DATA_CUSTOM_NAME, Optional.ofNullable(name));
+        this.entityData.set(Entity.DATA_CUSTOM_NAME, Optional.ofNullable(name));
     }
 
     @Nullable
     @Override
     public Component getCustomName() {
-        return this.entityData.get(DATA_CUSTOM_NAME).orElse(null);
+        return (Component) ((Optional) this.entityData.get(Entity.DATA_CUSTOM_NAME)).orElse((Object) null);
     }
 
     @Override
     public boolean hasCustomName() {
-        return this.entityData.get(DATA_CUSTOM_NAME).isPresent();
+        return ((Optional) this.entityData.get(Entity.DATA_CUSTOM_NAME)).isPresent();
     }
 
     public void setCustomNameVisible(boolean alwaysRenderNameTag) {
-        this.entityData.set(DATA_CUSTOM_NAME_VISIBLE, alwaysRenderNameTag);
+        this.entityData.set(Entity.DATA_CUSTOM_NAME_VISIBLE, alwaysRenderNameTag);
     }
 
     public boolean isCustomNameVisible() {
-        return this.entityData.get(DATA_CUSTOM_NAME_VISIBLE);
+        return (Boolean) this.entityData.get(Entity.DATA_CUSTOM_NAME_VISIBLE);
     }
 
-    public final void teleportToWithTicket(double x, double y, double z) {
+    public final void teleportToWithTicket(double x, double d1, double y) {
         if (this.level() instanceof ServerLevel) {
-            ChunkPos chunkPos = new ChunkPos(BlockPos.containing(x, y, z));
-            ((ServerLevel)this.level()).getChunkSource().addRegionTicket(TicketType.POST_TELEPORT, chunkPos, 0, this.getId());
-            this.level().getChunk(chunkPos.x, chunkPos.z);
-            this.teleportTo(x, y, z);
+            ChunkPos chunkcoordintpair = new ChunkPos(BlockPos.containing(x, d1, y));
+
+            ((ServerLevel) this.level()).getChunkSource().addRegionTicket(TicketType.POST_TELEPORT, chunkcoordintpair, 0, this.getId());
+            this.level().getChunk(chunkcoordintpair.x, chunkcoordintpair.z);
+            this.teleportTo(x, d1, y);
         }
     }
 
-    public boolean teleportTo(ServerLevel level, double x, double y, double z, Set<RelativeMovement> relativeMovements, float yRot, float xRot) {
-        float f = Mth.clamp(xRot, -90.0F, 90.0F);
+    // CraftBukkit start
+    public boolean teleportTo(ServerLevel worldserver, double d0, double d1, double d2, Set<RelativeMovement> set, float f, float f1, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        return this.teleportTo(worldserver, d0, d1, d2, set, f, f1);
+    }
+    // CraftBukkit end
+
+    public boolean teleportTo(ServerLevel level, double x, double d1, double y, Set<RelativeMovement> set, float z, float f1) {
+        float f2 = Mth.clamp(f1, -90.0F, 90.0F);
+
         if (level == this.level()) {
-            this.moveTo(x, y, z, yRot, f);
+            this.moveTo(x, d1, y, z, f2);
             this.teleportPassengers();
-            this.setYHeadRot(yRot);
+            this.setYHeadRot(z);
         } else {
             this.unRide();
             Entity entity = this.getType().create(level);
+
             if (entity == null) {
                 return false;
             }
 
             entity.restoreFrom(this);
-            entity.moveTo(x, y, z, yRot, f);
-            entity.setYHeadRot(yRot);
+            entity.moveTo(x, d1, y, z, f2);
+            entity.setYHeadRot(z);
             this.setRemoved(Entity.RemovalReason.CHANGED_DIMENSION);
-            level.addDuringTeleport(entity);
+            // CraftBukkit start - Don't spawn the new entity if the current entity isn't spawned
+            if (inWorld) {
+                level.addDuringTeleport(entity);
+            }
+            // CraftBukkit end
         }
 
         return true;
     }
 
-    public void dismountTo(double x, double y, double z) {
-        this.teleportTo(x, y, z);
+    public void dismountTo(double x, double d1, double y) {
+        this.teleportTo(x, d1, y);
     }
 
-    public void teleportTo(double x, double y, double z) {
+    public void teleportTo(double x, double d1, double y) {
         if (this.level() instanceof ServerLevel) {
-            this.moveTo(x, y, z, this.getYRot(), this.getXRot());
+            this.moveTo(x, d1, y, this.getYRot(), this.getXRot());
             this.teleportPassengers();
         }
     }
 
     private void teleportPassengers() {
-        this.getSelfAndPassengers().forEach(entity -> {
-            for (Entity entity1 : entity.passengers) {
+        this.getSelfAndPassengers().forEach((entity) -> {
+            UnmodifiableIterator unmodifiableiterator = entity.passengers.iterator();
+
+            while (unmodifiableiterator.hasNext()) {
+                Entity entity1 = (Entity) unmodifiableiterator.next();
+
                 entity.positionRider(entity1, Entity::moveTo);
             }
+
         });
     }
 
-    public void teleportRelative(double dx, double dy, double dz) {
-        this.teleportTo(this.getX() + dx, this.getY() + dy, this.getZ() + dz);
+    public void teleportRelative(double dx, double d1, double dy) {
+        this.teleportTo(this.getX() + dx, this.getY() + d1, this.getZ() + dy);
     }
 
     public boolean shouldShowName() {
         return this.isCustomNameVisible();
     }
 
-    public void onSyncedDataUpdated(List<SynchedEntityData.DataValue<?>> dataValues) {
-    }
+    public void onSyncedDataUpdated(List<SynchedEntityData.DataValue<?>> dataValues) {}
 
     public void onSyncedDataUpdated(EntityDataAccessor<?> key) {
-        if (DATA_POSE.equals(key)) {
+        if (Entity.DATA_POSE.equals(key)) {
             this.refreshDimensions();
         }
+
     }
 
+    /** @deprecated */
     @Deprecated
     protected void fixupDimensions() {
-        Pose pose = this.getPose();
-        EntityDimensions dimensions = this.getDimensions(pose);
-        this.dimensions = dimensions;
-        this.eyeHeight = this.getEyeHeight(pose, dimensions);
+        EntityPose entitypose = this.getPose();
+        EntityDimensions entitysize = this.getDimensions(entitypose);
+
+        this.dimensions = entitysize;
+        this.eyeHeight = this.getEyeHeight(entitypose, entitysize);
     }
 
     public void refreshDimensions() {
-        EntityDimensions entityDimensions = this.dimensions;
-        Pose pose = this.getPose();
-        EntityDimensions dimensions = this.getDimensions(pose);
-        this.dimensions = dimensions;
-        this.eyeHeight = this.getEyeHeight(pose, dimensions);
+        EntityDimensions entitysize = this.dimensions;
+        EntityPose entitypose = this.getPose();
+        EntityDimensions entitysize1 = this.getDimensions(entitypose);
+
+        this.dimensions = entitysize1;
+        this.eyeHeight = this.getEyeHeight(entitypose, entitysize1);
         this.reapplyPosition();
-        boolean flag = (double)dimensions.width <= 4.0 && (double)dimensions.height <= 4.0;
-        if (!this.level().isClientSide
-            && !this.firstTick
-            && !this.noPhysics
-            && flag
-            && (dimensions.width > entityDimensions.width || dimensions.height > entityDimensions.height)
-            && !(this instanceof Player)) {
-            Vec3 vec3 = this.position().add(0.0, (double)entityDimensions.height / 2.0, 0.0);
-            double d = (double)Math.max(0.0F, dimensions.width - entityDimensions.width) + 1.0E-6;
-            double d1 = (double)Math.max(0.0F, dimensions.height - entityDimensions.height) + 1.0E-6;
-            VoxelShape voxelShape = Shapes.create(AABB.ofSize(vec3, d, d1, d));
-            this.level()
-                .findFreePosition(this, voxelShape, vec3, (double)dimensions.width, (double)dimensions.height, (double)dimensions.width)
-                .ifPresent(vec31 -> this.setPos(vec31.add(0.0, (double)(-dimensions.height) / 2.0, 0.0)));
+        boolean flag = (double) entitysize1.width <= 4.0D && (double) entitysize1.height <= 4.0D;
+
+        if (!this.level().isClientSide && !this.firstTick && !this.noPhysics && flag && (entitysize1.width > entitysize.width || entitysize1.height > entitysize.height) && !(this instanceof Player)) {
+            Vec3 vec3d = this.position().add(0.0D, (double) entitysize.height / 2.0D, 0.0D);
+            double d0 = (double) Math.max(0.0F, entitysize1.width - entitysize.width) + 1.0E-6D;
+            double d1 = (double) Math.max(0.0F, entitysize1.height - entitysize.height) + 1.0E-6D;
+            VoxelShape voxelshape = Shapes.create(AABB.ofSize(vec3d, d0, d1, d0));
+
+            this.level().findFreePosition(this, voxelshape, vec3d, (double) entitysize1.width, (double) entitysize1.height, (double) entitysize1.width).ifPresent((vec3d1) -> {
+                this.setPos(vec3d1.add(0.0D, (double) (-entitysize1.height) / 2.0D, 0.0D));
+            });
         }
+
     }
 
     public Direction getDirection() {
-        return Direction.fromYRot((double)this.getYRot());
+        return Direction.fromYRot((double) this.getYRot());
     }
 
     public Direction getMotionDirection() {
@@ -2812,14 +3413,33 @@
     }
 
     public final void setBoundingBox(AABB bb) {
-        this.bb = bb;
+        // CraftBukkit start - block invalid bounding boxes
+        double minX = bb.minX,
+                minY = bb.minY,
+                minZ = bb.minZ,
+                maxX = bb.maxX,
+                maxY = bb.maxY,
+                maxZ = bb.maxZ;
+        double len = bb.maxX - bb.minX;
+        if (len < 0) maxX = minX;
+        if (len > 64) maxX = minX + 64.0;
+
+        len = bb.maxY - bb.minY;
+        if (len < 0) maxY = minY;
+        if (len > 64) maxY = minY + 64.0;
+
+        len = bb.maxZ - bb.minZ;
+        if (len < 0) maxZ = minZ;
+        if (len > 64) maxZ = minZ + 64.0;
+        this.bb = new AABB(minX, minY, minZ, maxX, maxY, maxZ);
+        // CraftBukkit end
     }
 
-    protected float getEyeHeight(Pose pose, EntityDimensions dimensions) {
+    protected float getEyeHeight(EntityPose pose, EntityDimensions dimensions) {
         return dimensions.height * 0.85F;
     }
 
-    public float getEyeHeight(Pose pose) {
+    public float getEyeHeight(EntityPose pose) {
         return this.getEyeHeight(pose, this.getDimensions(pose));
     }
 
@@ -2832,7 +3452,7 @@
     }
 
     protected Vec3 getLeashOffset() {
-        return new Vec3(0.0, (double)this.getEyeHeight(), (double)(this.getBbWidth() * 0.4F));
+        return new Vec3(0.0D, (double) this.getEyeHeight(), (double) (this.getBbWidth() * 0.4F));
     }
 
     public SlotAccess getSlot(int slot) {
@@ -2840,8 +3460,7 @@
     }
 
     @Override
-    public void sendSystemMessage(Component component) {
-    }
+    public void sendSystemMessage(Component component) {}
 
     public Level getCommandSenderWorld() {
         return this.level();
@@ -2852,7 +3471,7 @@
         return this.level().getServer();
     }
 
-    public InteractionResult interactAt(Player player, Vec3 vec, InteractionHand hand) {
+    public InteractionResult interactAt(Player player, Vec3 vec, EnumHand hand) {
         return InteractionResult.PASS;
     }
 
@@ -2860,22 +3479,21 @@
         return false;
     }
 
-    public void doEnchantDamageEffects(LivingEntity attacker, Entity target) {
-        if (target instanceof LivingEntity) {
-            EnchantmentHelper.doPostHurtEffects((LivingEntity)target, attacker);
+    public void doEnchantDamageEffects(net.minecraft.world.entity.LivingEntity attacker, Entity target) {
+        if (target instanceof net.minecraft.world.entity.LivingEntity) {
+            EnchantmentHelper.doPostHurtEffects((net.minecraft.world.entity.LivingEntity) target, attacker);
         }
 
         EnchantmentHelper.doPostDamageEffects(attacker, target);
     }
 
-    public void startSeenByPlayer(ServerPlayer serverPlayer) {
-    }
+    public void startSeenByPlayer(ServerPlayer serverPlayer) {}
 
-    public void stopSeenByPlayer(ServerPlayer serverPlayer) {
-    }
+    public void stopSeenByPlayer(ServerPlayer serverPlayer) {}
 
     public float rotate(Rotation transformRotation) {
         float f = Mth.wrapDegrees(this.getYRot());
+
         switch (transformRotation) {
             case CLOCKWISE_180:
                 return f + 180.0F;
@@ -2890,6 +3508,7 @@
 
     public float mirror(Mirror transformMirror) {
         float f = Mth.wrapDegrees(this.getYRot());
+
         switch (transformMirror) {
             case FRONT_BACK:
                 return -f;
@@ -2905,7 +3524,7 @@
     }
 
     @Nullable
-    public LivingEntity getControllingPassenger() {
+    public net.minecraft.world.entity.LivingEntity getControllingPassenger() {
         return null;
     }
 
@@ -2919,7 +3538,7 @@
 
     @Nullable
     public Entity getFirstPassenger() {
-        return this.passengers.isEmpty() ? null : this.passengers.get(0);
+        return this.passengers.isEmpty() ? null : (Entity) this.passengers.get(0);
     }
 
     public boolean hasPassenger(Entity entity) {
@@ -2927,13 +3546,19 @@
     }
 
     public boolean hasPassenger(Predicate<Entity> predicate) {
-        for (Entity entity : this.passengers) {
-            if (predicate.test(entity)) {
-                return true;
+        UnmodifiableIterator unmodifiableiterator = this.passengers.iterator();
+
+        Entity entity;
+
+        do {
+            if (!unmodifiableiterator.hasNext()) {
+                return false;
             }
-        }
 
-        return false;
+            entity = (Entity) unmodifiableiterator.next();
+        } while (!predicate.test(entity));
+
+        return true;
     }
 
     private Stream<Entity> getIndirectPassengersStream() {
@@ -2951,11 +3576,15 @@
     }
 
     public Iterable<Entity> getIndirectPassengers() {
-        return () -> this.getIndirectPassengersStream().iterator();
+        return () -> {
+            return this.getIndirectPassengersStream().iterator();
+        };
     }
 
     public int countPlayerPassengers() {
-        return (int)this.getIndirectPassengersStream().filter(entity -> entity instanceof Player).count();
+        return (int) this.getIndirectPassengersStream().filter((entity) -> {
+            return entity instanceof Player;
+        }).count();
     }
 
     public boolean hasExactlyOnePlayerPassenger() {
@@ -2963,10 +3592,10 @@
     }
 
     public Entity getRootVehicle() {
-        Entity entity = this;
+        Entity entity;
 
-        while (entity.isPassenger()) {
-            entity = entity.getVehicle();
+        for (entity = this; entity.isPassenger(); entity = entity.getVehicle()) {
+            ;
         }
 
         return entity;
@@ -2980,28 +3609,38 @@
         if (!entity.isPassenger()) {
             return false;
         } else {
-            Entity vehicle = entity.getVehicle();
-            return vehicle == this || this.hasIndirectPassenger(vehicle);
+            Entity entity1 = entity.getVehicle();
+
+            return entity1 == this ? true : this.hasIndirectPassenger(entity1);
         }
     }
 
     public boolean isControlledByLocalInstance() {
-        return this.getControllingPassenger() instanceof Player player ? player.isLocalPlayer() : this.isEffectiveAi();
+        net.minecraft.world.entity.LivingEntity entityliving = this.getControllingPassenger();
+
+        if (entityliving instanceof Player) {
+            Player entityhuman = (Player) entityliving;
+
+            return entityhuman.isLocalPlayer();
+        } else {
+            return this.isEffectiveAi();
+        }
     }
 
     public boolean isEffectiveAi() {
         return !this.level().isClientSide;
     }
 
-    protected static Vec3 getCollisionHorizontalEscapeVector(double vehicleWidth, double passengerWidth, float yRot) {
-        double d = (vehicleWidth + passengerWidth + 1.0E-5F) / 2.0;
-        float f = -Mth.sin(yRot * (float) (Math.PI / 180.0));
-        float cos = Mth.cos(yRot * (float) (Math.PI / 180.0));
-        float max = Math.max(Math.abs(f), Math.abs(cos));
-        return new Vec3((double)f * d / (double)max, 0.0, (double)cos * d / (double)max);
+    protected static Vec3 getCollisionHorizontalEscapeVector(double vehicleWidth, double d1, float passengerWidth) {
+        double d2 = (vehicleWidth + d1 + 9.999999747378752E-6D) / 2.0D;
+        float f1 = -Mth.sin(passengerWidth * 0.017453292F);
+        float f2 = Mth.cos(passengerWidth * 0.017453292F);
+        float f3 = Math.max(Math.abs(f1), Math.abs(f2));
+
+        return new Vec3((double) f1 * d2 / (double) f3, 0.0D, (double) f2 * d2 / (double) f3);
     }
 
-    public Vec3 getDismountLocationForPassenger(LivingEntity passenger) {
+    public Vec3 getDismountLocationForPassenger(net.minecraft.world.entity.LivingEntity passenger) {
         return new Vec3(this.getX(), this.getBoundingBox().maxY, this.getZ());
     }
 
@@ -3015,30 +3654,20 @@
         return this.vehicle != null && this.vehicle.getControllingPassenger() == this ? this.vehicle : null;
     }
 
-    public PushReaction getPistonPushReaction() {
-        return PushReaction.NORMAL;
+    public EnumPistonReaction getPistonPushReaction() {
+        return EnumPistonReaction.NORMAL;
     }
 
     public SoundSource getSoundSource() {
         return SoundSource.NEUTRAL;
     }
 
-    protected int getFireImmuneTicks() {
+    public int getFireImmuneTicks() {
         return 1;
     }
 
     public CommandSourceStack createCommandSourceStack() {
-        return new CommandSourceStack(
-            this,
-            this.position(),
-            this.getRotationVector(),
-            this.level() instanceof ServerLevel ? (ServerLevel)this.level() : null,
-            this.getPermissionLevel(),
-            this.getName().getString(),
-            this.getDisplayName(),
-            this.level().getServer(),
-            this
-        );
+        return new CommandSourceStack(this, this.position(), this.getRotationVector(), this.level() instanceof ServerLevel ? (ServerLevel) this.level() : null, this.getPermissionLevel(), this.getName().getString(), this.getDisplayName(), this.level().getServer(), this);
     }
 
     protected int getPermissionLevel() {
@@ -3065,13 +3694,14 @@
     }
 
     public void lookAt(EntityAnchorArgument.Anchor anchor, Vec3 target) {
-        Vec3 vec3 = anchor.apply(this);
-        double d = target.x - vec3.x;
-        double d1 = target.y - vec3.y;
-        double d2 = target.z - vec3.z;
-        double squareRoot = Math.sqrt(d * d + d2 * d2);
-        this.setXRot(Mth.wrapDegrees((float)(-(Mth.atan2(d1, squareRoot) * 180.0F / (float)Math.PI))));
-        this.setYRot(Mth.wrapDegrees((float)(Mth.atan2(d2, d) * 180.0F / (float)Math.PI) - 90.0F));
+        Vec3 vec3d1 = anchor.apply(this);
+        double d0 = target.x - vec3d1.x;
+        double d1 = target.y - vec3d1.y;
+        double d2 = target.z - vec3d1.z;
+        double d3 = Math.sqrt(d0 * d0 + d2 * d2);
+
+        this.setXRot(Mth.wrapDegrees((float) (-(Mth.atan2(d1, d3) * 57.2957763671875D))));
+        this.setYRot(Mth.wrapDegrees((float) (Mth.atan2(d2, d0) * 57.2957763671875D) - 90.0F));
         this.setYHeadRot(this.getYRot());
         this.xRotO = this.getXRot();
         this.yRotO = this.getYRot();
@@ -3081,76 +3711,87 @@
         if (this.touchingUnloadedChunk()) {
             return false;
         } else {
-            AABB aABB = this.getBoundingBox().deflate(0.001);
-            int floor = Mth.floor(aABB.minX);
-            int ceil = Mth.ceil(aABB.maxX);
-            int floor1 = Mth.floor(aABB.minY);
-            int ceil1 = Mth.ceil(aABB.maxY);
-            int floor2 = Mth.floor(aABB.minZ);
-            int ceil2 = Mth.ceil(aABB.maxZ);
-            double d = 0.0;
-            boolean isPushedByFluid = this.isPushedByFluid();
-            boolean flag = false;
-            Vec3 vec3 = Vec3.ZERO;
-            int i = 0;
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+            AABB axisalignedbb = this.getBoundingBox().deflate(0.001D);
+            int i = Mth.floor(axisalignedbb.minX);
+            int j = Mth.ceil(axisalignedbb.maxX);
+            int k = Mth.floor(axisalignedbb.minY);
+            int l = Mth.ceil(axisalignedbb.maxY);
+            int i1 = Mth.floor(axisalignedbb.minZ);
+            int j1 = Mth.ceil(axisalignedbb.maxZ);
+            double d1 = 0.0D;
+            boolean flag = this.isPushedByFluid();
+            boolean flag1 = false;
+            Vec3 vec3d = Vec3.ZERO;
+            int k1 = 0;
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-            for (int i1 = floor; i1 < ceil; i1++) {
-                for (int i2 = floor1; i2 < ceil1; i2++) {
-                    for (int i3 = floor2; i3 < ceil2; i3++) {
-                        mutableBlockPos.set(i1, i2, i3);
-                        FluidState fluidState = this.level().getFluidState(mutableBlockPos);
-                        if (fluidState.is(fluidTag)) {
-                            double d1 = (double)((float)i2 + fluidState.getHeight(this.level(), mutableBlockPos));
-                            if (d1 >= aABB.minY) {
-                                flag = true;
-                                d = Math.max(d1 - aABB.minY, d);
-                                if (isPushedByFluid) {
-                                    Vec3 flow = fluidState.getFlow(this.level(), mutableBlockPos);
-                                    if (d < 0.4) {
-                                        flow = flow.scale(d);
+            for (int l1 = i; l1 < j; ++l1) {
+                for (int i2 = k; i2 < l; ++i2) {
+                    for (int j2 = i1; j2 < j1; ++j2) {
+                        blockposition_mutableblockposition.set(l1, i2, j2);
+                        FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
+
+                        if (fluid.is(fluidTag)) {
+                            double d2 = (double) ((float) i2 + fluid.getHeight(this.level(), blockposition_mutableblockposition));
+
+                            if (d2 >= axisalignedbb.minY) {
+                                flag1 = true;
+                                d1 = Math.max(d2 - axisalignedbb.minY, d1);
+                                if (flag) {
+                                    Vec3 vec3d1 = fluid.getFlow(this.level(), blockposition_mutableblockposition);
+
+                                    if (d1 < 0.4D) {
+                                        vec3d1 = vec3d1.scale(d1);
                                     }
 
-                                    vec3 = vec3.add(flow);
-                                    i++;
+                                    vec3d = vec3d.add(vec3d1);
+                                    ++k1;
                                 }
+                                // CraftBukkit start - store last lava contact location
+                                if (fluidTag == FluidTags.LAVA) {
+                                    this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                                }
+                                // CraftBukkit end
                             }
                         }
                     }
                 }
             }
 
-            if (vec3.length() > 0.0) {
-                if (i > 0) {
-                    vec3 = vec3.scale(1.0 / (double)i);
+            if (vec3d.length() > 0.0D) {
+                if (k1 > 0) {
+                    vec3d = vec3d.scale(1.0D / (double) k1);
                 }
 
                 if (!(this instanceof Player)) {
-                    vec3 = vec3.normalize();
+                    vec3d = vec3d.normalize();
                 }
 
-                Vec3 deltaMovement = this.getDeltaMovement();
-                Vec3 var25 = vec3.scale(motionScale * 1.0);
-                double d2 = 0.003;
-                if (Math.abs(deltaMovement.x) < 0.003 && Math.abs(deltaMovement.z) < 0.003 && var25.length() < 0.0045000000000000005) {
-                    var25 = var25.normalize().scale(0.0045000000000000005);
+                Vec3 vec3d2 = this.getDeltaMovement();
+
+                vec3d = vec3d.scale(motionScale * 1.0D);
+                double d3 = 0.003D;
+
+                if (Math.abs(vec3d2.x) < 0.003D && Math.abs(vec3d2.z) < 0.003D && vec3d.length() < 0.0045000000000000005D) {
+                    vec3d = vec3d.normalize().scale(0.0045000000000000005D);
                 }
 
-                this.setDeltaMovement(this.getDeltaMovement().add(var25));
+                this.setDeltaMovement(this.getDeltaMovement().add(vec3d));
             }
 
-            this.fluidHeight.put(fluidTag, d);
-            return flag;
+            this.fluidHeight.put(fluidTag, d1);
+            return flag1;
         }
     }
 
     public boolean touchingUnloadedChunk() {
-        AABB aABB = this.getBoundingBox().inflate(1.0);
-        int floor = Mth.floor(aABB.minX);
-        int ceil = Mth.ceil(aABB.maxX);
-        int floor1 = Mth.floor(aABB.minZ);
-        int ceil1 = Mth.ceil(aABB.maxZ);
-        return !this.level().hasChunksAt(floor, floor1, ceil, ceil1);
+        AABB axisalignedbb = this.getBoundingBox().inflate(1.0D);
+        int i = Mth.floor(axisalignedbb.minX);
+        int j = Mth.ceil(axisalignedbb.maxX);
+        int k = Mth.floor(axisalignedbb.minZ);
+        int l = Mth.ceil(axisalignedbb.maxZ);
+
+        return !this.level().hasChunksAt(i, k, j, l);
     }
 
     public double getFluidHeight(TagKey<Fluid> fluidTag) {
@@ -3158,7 +3799,7 @@
     }
 
     public double getFluidJumpThreshold() {
-        return (double)this.getEyeHeight() < 0.4 ? 0.0 : 0.4;
+        return (double) this.getEyeHeight() < 0.4D ? 0.0D : 0.4D;
     }
 
     public final float getBbWidth() {
@@ -3177,7 +3818,7 @@
         return new ClientboundAddEntityPacket(this);
     }
 
-    public EntityDimensions getDimensions(Pose pose) {
+    public EntityDimensions getDimensions(EntityPose pose) {
         return this.type.getDimensions();
     }
 
@@ -3194,7 +3835,7 @@
         return this.blockPosition;
     }
 
-    public BlockState getFeetBlockState() {
+    public IBlockData getFeetBlockState() {
         if (this.feetBlockState == null) {
             this.feetBlockState = this.level().getBlockState(this.blockPosition());
         }
@@ -3218,8 +3859,8 @@
         this.setDeltaMovement(this.getDeltaMovement().add(addend));
     }
 
-    public void setDeltaMovement(double x, double y, double z) {
-        this.setDeltaMovement(new Vec3(x, y, z));
+    public void setDeltaMovement(double x, double d1, double y) {
+        this.setDeltaMovement(new Vec3(x, d1, y));
     }
 
     public final int getBlockX() {
@@ -3231,11 +3872,11 @@
     }
 
     public double getX(double scale) {
-        return this.position.x + (double)this.getBbWidth() * scale;
+        return this.position.x + (double) this.getBbWidth() * scale;
     }
 
     public double getRandomX(double scale) {
-        return this.getX((2.0 * this.random.nextDouble() - 1.0) * scale);
+        return this.getX((2.0D * this.random.nextDouble() - 1.0D) * scale);
     }
 
     public final int getBlockY() {
@@ -3247,7 +3888,7 @@
     }
 
     public double getY(double scale) {
-        return this.position.y + (double)this.getBbHeight() * scale;
+        return this.position.y + (double) this.getBbHeight() * scale;
     }
 
     public double getRandomY() {
@@ -3255,7 +3896,7 @@
     }
 
     public double getEyeY() {
-        return this.position.y + (double)this.eyeHeight;
+        return this.position.y + (double) this.eyeHeight;
     }
 
     public final int getBlockZ() {
@@ -3267,48 +3908,50 @@
     }
 
     public double getZ(double scale) {
-        return this.position.z + (double)this.getBbWidth() * scale;
+        return this.position.z + (double) this.getBbWidth() * scale;
     }
 
     public double getRandomZ(double scale) {
-        return this.getZ((2.0 * this.random.nextDouble() - 1.0) * scale);
+        return this.getZ((2.0D * this.random.nextDouble() - 1.0D) * scale);
     }
 
-    public final void setPosRaw(double x, double y, double z) {
-        if (this.position.x != x || this.position.y != y || this.position.z != z) {
-            this.position = new Vec3(x, y, z);
-            int floor = Mth.floor(x);
-            int floor1 = Mth.floor(y);
-            int floor2 = Mth.floor(z);
-            if (floor != this.blockPosition.getX() || floor1 != this.blockPosition.getY() || floor2 != this.blockPosition.getZ()) {
-                this.blockPosition = new BlockPos(floor, floor1, floor2);
+    public final void setPosRaw(double x, double d1, double y) {
+        if (this.position.x != x || this.position.y != d1 || this.position.z != y) {
+            this.position = new Vec3(x, d1, y);
+            int i = Mth.floor(x);
+            int j = Mth.floor(d1);
+            int k = Mth.floor(y);
+
+            if (i != this.blockPosition.getX() || j != this.blockPosition.getY() || k != this.blockPosition.getZ()) {
+                this.blockPosition = new BlockPos(i, j, k);
                 this.feetBlockState = null;
-                if (SectionPos.blockToSectionCoord(floor) != this.chunkPosition.x || SectionPos.blockToSectionCoord(floor2) != this.chunkPosition.z) {
+                if (SectionPos.blockToSectionCoord(i) != this.chunkPosition.x || SectionPos.blockToSectionCoord(k) != this.chunkPosition.z) {
                     this.chunkPosition = new ChunkPos(this.blockPosition);
                 }
             }
 
             this.levelCallback.onMove();
         }
-    }
 
-    public void checkDespawn() {
     }
 
+    public void checkDespawn() {}
+
     public Vec3 getRopeHoldPosition(float partialTicks) {
-        return this.getPosition(partialTicks).add(0.0, (double)this.eyeHeight * 0.7, 0.0);
+        return this.getPosition(partialTicks).add(0.0D, (double) this.eyeHeight * 0.7D, 0.0D);
     }
 
     public void recreateFromPacket(ClientboundAddEntityPacket packet) {
-        int id = packet.getId();
-        double x = packet.getX();
-        double y = packet.getY();
-        double z = packet.getZ();
-        this.syncPacketPositionCodec(x, y, z);
-        this.moveTo(x, y, z);
+        int i = packet.getId();
+        double d0 = packet.getX();
+        double d1 = packet.getY();
+        double d2 = packet.getZ();
+
+        this.syncPacketPositionCodec(d0, d1, d2);
+        this.moveTo(d0, d1, d2);
         this.setXRot(packet.getXRot());
         this.setYRot(packet.getYRot());
-        this.setId(id);
+        this.setId(i);
         this.setUUID(packet.getUUID());
     }
 
@@ -3392,7 +4035,7 @@
         this.levelCallback.onRemove(removalReason);
     }
 
-    protected void unsetRemoved() {
+    public void unsetRemoved() {
         this.removalReason = null;
     }
 
@@ -3403,9 +4046,7 @@
 
     @Override
     public boolean shouldBeSaved() {
-        return (this.removalReason == null || this.removalReason.shouldSave())
-            && !this.isPassenger()
-            && (!this.isVehicle() || !this.hasExactlyOnePlayerPassenger());
+        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !this.hasExactlyOnePlayerPassenger());
     }
 
     @Override
@@ -3429,34 +4070,49 @@
         return this.level().damageSources();
     }
 
-    protected void lerpPositionAndRotationStep(int i, double d, double d1, double d2, double d3, double d4) {
-        double d5 = 1.0 / (double)i;
-        double d6 = Mth.lerp(d5, this.getX(), d);
+    protected void lerpPositionAndRotationStep(int i, double d0, double d1, double d2, double d3, double d4) {
+        double d5 = 1.0D / (double) i;
+        double d6 = Mth.lerp(d5, this.getX(), d0);
         double d7 = Mth.lerp(d5, this.getY(), d1);
         double d8 = Mth.lerp(d5, this.getZ(), d2);
-        float f = (float)Mth.rotLerp(d5, (double)this.getYRot(), d3);
-        float f1 = (float)Mth.lerp(d5, (double)this.getXRot(), d4);
+        float f = (float) Mth.rotLerp(d5, (double) this.getYRot(), d3);
+        float f1 = (float) Mth.lerp(d5, (double) this.getXRot(), d4);
+
         this.setPos(d6, d7, d8);
         this.setRot(f, f1);
     }
 
-    @FunctionalInterface
-    public interface MoveFunction {
-        void accept(Entity entity, double x, double d, double y);
+    public static enum RemovalReason {
+
+        KILLED(true, false), DISCARDED(true, false), UNLOADED_TO_CHUNK(false, true), UNLOADED_WITH_PLAYER(false, false), CHANGED_DIMENSION(false, false);
+
+        private final boolean destroy;
+        private final boolean save;
+
+        private RemovalReason(boolean flag, boolean flag1) {
+            this.destroy = flag;
+            this.save = flag1;
+        }
+
+        public boolean shouldDestroy() {
+            return this.destroy;
+        }
+
+        public boolean shouldSave() {
+            return this.save;
+        }
     }
 
     public static enum MovementEmission {
-        NONE(false, false),
-        SOUNDS(true, false),
-        EVENTS(false, true),
-        ALL(true, true);
 
+        NONE(false, false), SOUNDS(true, false), EVENTS(false, true), ALL(true, true);
+
         final boolean sounds;
         final boolean events;
 
-        private MovementEmission(boolean sounds, boolean events) {
-            this.sounds = sounds;
-            this.events = events;
+        private MovementEmission(boolean flag, boolean flag1) {
+            this.sounds = flag;
+            this.events = flag1;
         }
 
         public boolean emitsAnything() {
@@ -3472,27 +4128,9 @@
         }
     }
 
-    public static enum RemovalReason {
-        KILLED(true, false),
-        DISCARDED(true, false),
-        UNLOADED_TO_CHUNK(false, true),
-        UNLOADED_WITH_PLAYER(false, false),
-        CHANGED_DIMENSION(false, false);
+    @FunctionalInterface
+    public interface MoveFunction {
 
-        private final boolean destroy;
-        private final boolean save;
-
-        private RemovalReason(boolean destroy, boolean save) {
-            this.destroy = destroy;
-            this.save = save;
-        }
-
-        public boolean shouldDestroy() {
-            return this.destroy;
-        }
-
-        public boolean shouldSave() {
-            return this.save;
-        }
+        void accept(Entity entity, double x, double d1, double y);
     }
 }
