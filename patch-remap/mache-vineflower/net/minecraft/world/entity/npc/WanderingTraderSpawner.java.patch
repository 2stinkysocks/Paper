--- a/net/minecraft/world/entity/npc/WanderingTraderSpawner.java
+++ b/net/minecraft/world/entity/npc/WanderingTraderSpawner.java
@@ -1,20 +1,20 @@
 package net.minecraft.world.entity.npc;
 
+import java.util.Iterator;
 import java.util.Optional;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.tags.BiomeTags;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.MobSpawnType;
+import net.minecraft.world.entity.EnumMobSpawn;
 import net.minecraft.world.entity.SpawnPlacements;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
 import net.minecraft.world.entity.ai.village.poi.PoiTypes;
 import net.minecraft.world.entity.animal.horse.TraderLlama;
-import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.CustomSpawner;
 import net.minecraft.world.level.GameRules;
@@ -24,6 +24,7 @@
 import net.minecraft.world.level.storage.ServerLevelData;
 
 public class WanderingTraderSpawner implements CustomSpawner {
+
     private static final int DEFAULT_TICK_DELAY = 1200;
     public static final int DEFAULT_SPAWN_DELAY = 24000;
     private static final int MIN_SPAWN_CHANCE = 25;
@@ -48,6 +49,7 @@
             this.spawnChance = 25;
             serverLevelData.setWanderingTraderSpawnChance(this.spawnChance);
         }
+
     }
 
     @Override
@@ -68,6 +70,7 @@
                     return 0;
                 } else {
                     int i = this.spawnChance;
+
                     this.spawnChance = Mth.clamp(this.spawnChance + 25, 25, 75);
                     this.serverLevelData.setWanderingTraderSpawnChance(this.spawnChance);
                     if (this.random.nextInt(100) > i) {
@@ -84,33 +87,40 @@
     }
 
     private boolean spawn(ServerLevel serverLevel) {
-        Player randomPlayer = serverLevel.getRandomPlayer();
-        if (randomPlayer == null) {
+        ServerPlayer entityplayer = serverLevel.getRandomPlayer();
+
+        if (entityplayer == null) {
             return true;
         } else if (this.random.nextInt(10) != 0) {
             return false;
         } else {
-            BlockPos blockPos = randomPlayer.blockPosition();
-            int i = 48;
-            PoiManager poiManager = serverLevel.getPoiManager();
-            Optional<BlockPos> optional = poiManager.find(holder -> holder.is(PoiTypes.MEETING), blockPos3 -> true, blockPos, 48, PoiManager.Occupancy.ANY);
-            BlockPos blockPos1 = optional.orElse(blockPos);
-            BlockPos blockPos2 = this.findSpawnPositionNear(serverLevel, blockPos1, 48);
-            if (blockPos2 != null && this.hasEnoughSpace(serverLevel, blockPos2)) {
-                if (serverLevel.getBiome(blockPos2).is(BiomeTags.WITHOUT_WANDERING_TRADER_SPAWNS)) {
+            BlockPos blockposition = entityplayer.blockPosition();
+            boolean flag = true;
+            PoiManager villageplace = serverLevel.getPoiManager();
+            Optional<BlockPos> optional = villageplace.find((holder) -> {
+                return holder.is(PoiTypes.MEETING);
+            }, (blockposition1) -> {
+                return true;
+            }, blockposition, 48, PoiManager.Occupancy.ANY);
+            BlockPos blockposition1 = (BlockPos) optional.orElse(blockposition);
+            BlockPos blockposition2 = this.findSpawnPositionNear(serverLevel, blockposition1, 48);
+
+            if (blockposition2 != null && this.hasEnoughSpace(serverLevel, blockposition2)) {
+                if (serverLevel.getBiome(blockposition2).is(BiomeTags.WITHOUT_WANDERING_TRADER_SPAWNS)) {
                     return false;
                 }
 
-                WanderingTrader wanderingTrader = EntityType.WANDERING_TRADER.spawn(serverLevel, blockPos2, MobSpawnType.EVENT);
-                if (wanderingTrader != null) {
-                    for (int i1 = 0; i1 < 2; i1++) {
-                        this.tryToSpawnLlamaFor(serverLevel, wanderingTrader, 4);
+                WanderingTrader entityvillagertrader = (WanderingTrader) EntityType.WANDERING_TRADER.spawn(serverLevel, blockposition2, EnumMobSpawn.EVENT, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.NATURAL); // CraftBukkit
+
+                if (entityvillagertrader != null) {
+                    for (int i = 0; i < 2; ++i) {
+                        this.tryToSpawnLlamaFor(serverLevel, entityvillagertrader, 4);
                     }
 
-                    this.serverLevelData.setWanderingTraderId(wanderingTrader.getUUID());
-                    wanderingTrader.setDespawnDelay(48000);
-                    wanderingTrader.setWanderTarget(blockPos1);
-                    wanderingTrader.restrictTo(blockPos1, 16);
+                    this.serverLevelData.setWanderingTraderId(entityvillagertrader.getUUID());
+                    // entityvillagertrader.setDespawnDelay(48000); // CraftBukkit - moved to EntityVillagerTrader constructor. This lets the value be modified by plugins on CreatureSpawnEvent
+                    entityvillagertrader.setWanderTarget(blockposition1);
+                    entityvillagertrader.restrictTo(blockposition1, 16);
                     return true;
                 }
             }
@@ -120,40 +130,49 @@
     }
 
     private void tryToSpawnLlamaFor(ServerLevel serverLevel, WanderingTrader trader, int maxDistance) {
-        BlockPos blockPos = this.findSpawnPositionNear(serverLevel, trader.blockPosition(), maxDistance);
-        if (blockPos != null) {
-            TraderLlama traderLlama = EntityType.TRADER_LLAMA.spawn(serverLevel, blockPos, MobSpawnType.EVENT);
-            if (traderLlama != null) {
-                traderLlama.setLeashedTo(trader, true);
+        BlockPos blockposition = this.findSpawnPositionNear(serverLevel, trader.blockPosition(), maxDistance);
+
+        if (blockposition != null) {
+            TraderLlama entityllamatrader = (TraderLlama) EntityType.TRADER_LLAMA.spawn(serverLevel, blockposition, EnumMobSpawn.EVENT, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.NATURAL); // CraftBukkit
+
+            if (entityllamatrader != null) {
+                entityllamatrader.setLeashedTo(trader, true);
             }
         }
     }
 
     @Nullable
     private BlockPos findSpawnPositionNear(LevelReader level, BlockPos pos, int maxDistance) {
-        BlockPos blockPos = null;
+        BlockPos blockposition1 = null;
 
-        for (int i = 0; i < 10; i++) {
-            int i1 = pos.getX() + this.random.nextInt(maxDistance * 2) - maxDistance;
-            int i2 = pos.getZ() + this.random.nextInt(maxDistance * 2) - maxDistance;
-            int height = level.getHeight(Heightmap.Types.WORLD_SURFACE, i1, i2);
-            BlockPos blockPos1 = new BlockPos(i1, height, i2);
-            if (NaturalSpawner.isSpawnPositionOk(SpawnPlacements.Type.ON_GROUND, level, blockPos1, EntityType.WANDERING_TRADER)) {
-                blockPos = blockPos1;
+        for (int j = 0; j < 10; ++j) {
+            int k = pos.getX() + this.random.nextInt(maxDistance * 2) - maxDistance;
+            int l = pos.getZ() + this.random.nextInt(maxDistance * 2) - maxDistance;
+            int i1 = level.getHeight(Heightmap.Types.WORLD_SURFACE, k, l);
+            BlockPos blockposition2 = new BlockPos(k, i1, l);
+
+            if (NaturalSpawner.isSpawnPositionOk(SpawnPlacements.Surface.ON_GROUND, level, blockposition2, EntityType.WANDERING_TRADER)) {
+                blockposition1 = blockposition2;
                 break;
             }
         }
 
-        return blockPos;
+        return blockposition1;
     }
 
     private boolean hasEnoughSpace(BlockGetter level, BlockPos pos) {
-        for (BlockPos blockPos : BlockPos.betweenClosed(pos, pos.offset(1, 2, 1))) {
-            if (!level.getBlockState(blockPos).getCollisionShape(level, blockPos).isEmpty()) {
-                return false;
+        Iterator iterator = BlockPos.betweenClosed(pos, pos.offset(1, 2, 1)).iterator();
+
+        BlockPos blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
             }
-        }
 
-        return true;
+            blockposition1 = (BlockPos) iterator.next();
+        } while (level.getBlockState(blockposition1).getCollisionShape(level, blockposition1).isEmpty());
+
+        return false;
     }
 }
