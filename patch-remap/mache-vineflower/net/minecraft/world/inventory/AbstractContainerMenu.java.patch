--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -8,7 +8,9 @@
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntList;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Set;
@@ -17,9 +19,10 @@
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
-import net.minecraft.core.BlockPos;
 import net.minecraft.core.NonNullList;
 import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.Container;
@@ -28,12 +31,24 @@
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import org.slf4j.Logger;
 
+// CraftBukkit start
+import com.google.common.base.Preconditions;
+import java.util.HashMap;
+import java.util.Map;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.Event.Result;
+import org.bukkit.event.inventory.InventoryDragEvent;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryView;
+// CraftBukkit end
+
 public abstract class AbstractContainerMenu {
+
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final int SLOT_CLICKED_OUTSIDE = -999;
     public static final int QUICKCRAFT_TYPE_CHARITABLE = 0;
@@ -43,37 +58,62 @@
     public static final int QUICKCRAFT_HEADER_CONTINUE = 1;
     public static final int QUICKCRAFT_HEADER_END = 2;
     public static final int CARRIED_SLOT_SIZE = Integer.MAX_VALUE;
-    private final NonNullList<ItemStack> lastSlots = NonNullList.create();
-    public final NonNullList<Slot> slots = NonNullList.create();
+    public NonNullList<ItemStack> lastSlots = NonNullList.create();
+    public NonNullList<Slot> slots = NonNullList.create();
     private final List<DataSlot> dataSlots = Lists.newArrayList();
-    private ItemStack carried = ItemStack.EMPTY;
-    private final NonNullList<ItemStack> remoteSlots = NonNullList.create();
-    private final IntList remoteDataSlots = new IntArrayList();
-    private ItemStack remoteCarried = ItemStack.EMPTY;
+    private ItemStack carried;
+    public NonNullList<ItemStack> remoteSlots;
+    private final IntList remoteDataSlots;
+    private ItemStack remoteCarried;
     private int stateId;
     @Nullable
     private final MenuType<?> menuType;
     public final int containerId;
-    private int quickcraftType = -1;
+    private int quickcraftType;
     private int quickcraftStatus;
-    private final Set<Slot> quickcraftSlots = Sets.newHashSet();
-    private final List<ContainerListener> containerListeners = Lists.newArrayList();
+    private final Set<Slot> quickcraftSlots;
+    private final List<ContainerListener> containerListeners;
     @Nullable
     private ContainerSynchronizer synchronizer;
     private boolean suppressRemoteUpdates;
 
+    // CraftBukkit start
+    public boolean checkReachable = true;
+    public abstract InventoryView getBukkitView();
+    public void transferTo(AbstractContainerMenu other, org.bukkit.craftbukkit.entity.CraftHumanEntity player) {
+        InventoryView source = this.getBukkitView(), destination = other.getBukkitView();
+        ((CraftInventory) source.getTopInventory()).getInventory().onClose(player);
+        ((CraftInventory) source.getBottomInventory()).getInventory().onClose(player);
+        ((CraftInventory) destination.getTopInventory()).getInventory().onOpen(player);
+        ((CraftInventory) destination.getBottomInventory()).getInventory().onOpen(player);
+    }
+    private Component title;
+    public final Component getTitle() {
+        Preconditions.checkState(this.title != null, "Title not set");
+        return this.title;
+    }
+    public final void setTitle(Component title) {
+        Preconditions.checkState(this.title == null, "Title already set");
+        this.title = title;
+    }
+    // CraftBukkit end
+
     protected AbstractContainerMenu(@Nullable MenuType<?> menuType, int containerId) {
+        this.carried = ItemStack.EMPTY;
+        this.remoteSlots = NonNullList.create();
+        this.remoteDataSlots = new IntArrayList();
+        this.remoteCarried = ItemStack.EMPTY;
+        this.quickcraftType = -1;
+        this.quickcraftSlots = Sets.newHashSet();
+        this.containerListeners = Lists.newArrayList();
         this.menuType = menuType;
         this.containerId = containerId;
     }
 
     protected static boolean stillValid(ContainerLevelAccess access, Player player, Block targetBlock) {
-        return access.evaluate(
-            (level, blockPos) -> !level.getBlockState(blockPos).is(targetBlock)
-                    ? false
-                    : player.distanceToSqr((double)blockPos.getX() + 0.5, (double)blockPos.getY() + 0.5, (double)blockPos.getZ() + 0.5) <= 64.0,
-            true
-        );
+        return (Boolean) access.evaluate((world, blockposition) -> {
+            return !world.getBlockState(blockposition).is(targetBlock) ? false : player.distanceToSqr((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D) <= 64.0D;
+        }, true);
     }
 
     public MenuType<?> getType() {
@@ -85,16 +125,18 @@
     }
 
     protected static void checkContainerSize(Container container, int minSize) {
-        int containerSize = container.getContainerSize();
-        if (containerSize < minSize) {
-            throw new IllegalArgumentException("Container size " + containerSize + " is smaller than expected " + minSize);
+        int j = container.getContainerSize();
+
+        if (j < minSize) {
+            throw new IllegalArgumentException("Container size " + j + " is smaller than expected " + minSize);
         }
     }
 
     protected static void checkContainerDataCount(ContainerData intArray, int minSize) {
-        int count = intArray.getCount();
-        if (count < minSize) {
-            throw new IllegalArgumentException("Container data count " + count + " is smaller than expected " + minSize);
+        int j = intArray.getCount();
+
+        if (j < minSize) {
+            throw new IllegalArgumentException("Container data count " + j + " is smaller than expected " + minSize);
         }
     }
 
@@ -117,9 +159,10 @@
     }
 
     protected void addDataSlots(ContainerData array) {
-        for (int i = 0; i < array.getCount(); i++) {
+        for (int i = 0; i < array.getCount(); ++i) {
             this.addDataSlot(DataSlot.forContainer(array, i));
         }
+
     }
 
     public void addSlotListener(ContainerListener listener) {
@@ -137,67 +180,94 @@
     public void sendAllDataToRemote() {
         int i = 0;
 
-        for (int size = this.slots.size(); i < size; i++) {
-            this.remoteSlots.set(i, this.slots.get(i).getItem().copy());
+        int j;
+
+        for (j = this.slots.size(); i < j; ++i) {
+            this.remoteSlots.set(i, ((Slot) this.slots.get(i)).getItem().copy());
         }
 
         this.remoteCarried = this.getCarried().copy();
         i = 0;
 
-        for (int size = this.dataSlots.size(); i < size; i++) {
-            this.remoteDataSlots.set(i, this.dataSlots.get(i).get());
+        for (j = this.dataSlots.size(); i < j; ++i) {
+            this.remoteDataSlots.set(i, ((DataSlot) this.dataSlots.get(i)).get());
         }
 
         if (this.synchronizer != null) {
             this.synchronizer.sendInitialData(this, this.remoteSlots, this.remoteCarried, this.remoteDataSlots.toIntArray());
         }
+
     }
 
+    // CraftBukkit start
+    public void broadcastCarriedItem() {
+        this.remoteCarried = this.getCarried().copy();
+        if (this.synchronizer != null) {
+            this.synchronizer.sendCarriedChange(this, this.remoteCarried);
+        }
+    }
+    // CraftBukkit end
+
     public void removeSlotListener(ContainerListener listener) {
         this.containerListeners.remove(listener);
     }
 
     public NonNullList<ItemStack> getItems() {
-        NonNullList<ItemStack> list = NonNullList.create();
+        NonNullList<ItemStack> nonnulllist = NonNullList.create();
+        Iterator iterator = this.slots.iterator();
 
-        for (Slot slot : this.slots) {
-            list.add(slot.getItem());
+        while (iterator.hasNext()) {
+            Slot slot = (Slot) iterator.next();
+
+            nonnulllist.add(slot.getItem());
         }
 
-        return list;
+        return nonnulllist;
     }
 
     public void broadcastChanges() {
-        for (int i = 0; i < this.slots.size(); i++) {
-            ItemStack item = this.slots.get(i).getItem();
-            Supplier<ItemStack> supplier = Suppliers.memoize(item::copy);
-            this.triggerSlotListeners(i, item, supplier);
-            this.synchronizeSlotToRemote(i, item, supplier);
+        int i;
+
+        for (i = 0; i < this.slots.size(); ++i) {
+            ItemStack itemstack = ((Slot) this.slots.get(i)).getItem();
+
+            Objects.requireNonNull(itemstack);
+            Supplier<ItemStack> supplier = Suppliers.memoize(itemstack::copy);
+
+            this.triggerSlotListeners(i, itemstack, supplier);
+            this.synchronizeSlotToRemote(i, itemstack, supplier);
         }
 
         this.synchronizeCarriedToRemote();
 
-        for (int i = 0; i < this.dataSlots.size(); i++) {
-            DataSlot dataSlot = this.dataSlots.get(i);
-            int i1 = dataSlot.get();
-            if (dataSlot.checkAndClearUpdateFlag()) {
-                this.updateDataSlotListeners(i, i1);
+        for (i = 0; i < this.dataSlots.size(); ++i) {
+            DataSlot containerproperty = (DataSlot) this.dataSlots.get(i);
+            int j = containerproperty.get();
+
+            if (containerproperty.checkAndClearUpdateFlag()) {
+                this.updateDataSlotListeners(i, j);
             }
 
-            this.synchronizeDataSlotToRemote(i, i1);
+            this.synchronizeDataSlotToRemote(i, j);
         }
+
     }
 
     public void broadcastFullState() {
-        for (int i = 0; i < this.slots.size(); i++) {
-            ItemStack item = this.slots.get(i).getItem();
-            this.triggerSlotListeners(i, item, item::copy);
+        int i;
+
+        for (i = 0; i < this.slots.size(); ++i) {
+            ItemStack itemstack = ((Slot) this.slots.get(i)).getItem();
+
+            Objects.requireNonNull(itemstack);
+            this.triggerSlotListeners(i, itemstack, itemstack::copy);
         }
 
-        for (int i = 0; i < this.dataSlots.size(); i++) {
-            DataSlot dataSlot = this.dataSlots.get(i);
-            if (dataSlot.checkAndClearUpdateFlag()) {
-                this.updateDataSlotListeners(i, dataSlot.get());
+        for (i = 0; i < this.dataSlots.size(); ++i) {
+            DataSlot containerproperty = (DataSlot) this.dataSlots.get(i);
+
+            if (containerproperty.checkAndClearUpdateFlag()) {
+                this.updateDataSlotListeners(i, containerproperty.get());
             }
         }
 
@@ -205,45 +275,61 @@
     }
 
     private void updateDataSlotListeners(int slotIndex, int value) {
-        for (ContainerListener containerListener : this.containerListeners) {
-            containerListener.dataChanged(this, slotIndex, value);
+        Iterator iterator = this.containerListeners.iterator();
+
+        while (iterator.hasNext()) {
+            ContainerListener icrafting = (ContainerListener) iterator.next();
+
+            icrafting.dataChanged(this, slotIndex, value);
         }
+
     }
 
     private void triggerSlotListeners(int slotIndex, ItemStack stack, Supplier<ItemStack> supplier) {
-        ItemStack itemStack = this.lastSlots.get(slotIndex);
-        if (!ItemStack.matches(itemStack, stack)) {
-            ItemStack itemStack1 = supplier.get();
-            this.lastSlots.set(slotIndex, itemStack1);
+        ItemStack itemstack1 = (ItemStack) this.lastSlots.get(slotIndex);
 
-            for (ContainerListener containerListener : this.containerListeners) {
-                containerListener.slotChanged(this, slotIndex, itemStack1);
+        if (!ItemStack.matches(itemstack1, stack)) {
+            ItemStack itemstack2 = (ItemStack) supplier.get();
+
+            this.lastSlots.set(slotIndex, itemstack2);
+            Iterator iterator = this.containerListeners.iterator();
+
+            while (iterator.hasNext()) {
+                ContainerListener icrafting = (ContainerListener) iterator.next();
+
+                icrafting.slotChanged(this, slotIndex, itemstack2);
             }
         }
+
     }
 
     private void synchronizeSlotToRemote(int slotIndex, ItemStack stack, Supplier<ItemStack> supplier) {
         if (!this.suppressRemoteUpdates) {
-            ItemStack itemStack = this.remoteSlots.get(slotIndex);
-            if (!ItemStack.matches(itemStack, stack)) {
-                ItemStack itemStack1 = supplier.get();
-                this.remoteSlots.set(slotIndex, itemStack1);
+            ItemStack itemstack1 = (ItemStack) this.remoteSlots.get(slotIndex);
+
+            if (!ItemStack.matches(itemstack1, stack)) {
+                ItemStack itemstack2 = (ItemStack) supplier.get();
+
+                this.remoteSlots.set(slotIndex, itemstack2);
                 if (this.synchronizer != null) {
-                    this.synchronizer.sendSlotChange(this, slotIndex, itemStack1);
+                    this.synchronizer.sendSlotChange(this, slotIndex, itemstack2);
                 }
             }
+
         }
     }
 
     private void synchronizeDataSlotToRemote(int slotIndex, int value) {
         if (!this.suppressRemoteUpdates) {
-            int _int = this.remoteDataSlots.getInt(slotIndex);
-            if (_int != value) {
+            int k = this.remoteDataSlots.getInt(slotIndex);
+
+            if (k != value) {
                 this.remoteDataSlots.set(slotIndex, value);
                 if (this.synchronizer != null) {
                     this.synchronizer.sendDataChange(this, slotIndex, value);
                 }
             }
+
         }
     }
 
@@ -255,6 +341,7 @@
                     this.synchronizer.sendCarriedChange(this, this.remoteCarried);
                 }
             }
+
         }
     }
 
@@ -266,7 +353,7 @@
         if (slot >= 0 && slot < this.remoteSlots.size()) {
             this.remoteSlots.set(slot, stack);
         } else {
-            LOGGER.debug("Incorrect slot index: {} available slots: {}", slot, this.remoteSlots.size());
+            AbstractContainerMenu.LOGGER.debug("Incorrect slot index: {} available slots: {}", slot, this.remoteSlots.size());
         }
     }
 
@@ -279,33 +366,45 @@
     }
 
     public Slot getSlot(int slotId) {
-        return this.slots.get(slotId);
+        return (Slot) this.slots.get(slotId);
     }
 
     public abstract ItemStack quickMoveStack(Player player, int index);
 
-    public void clicked(int slotId, int button, ClickType clickType, Player player) {
+    public void clicked(int slotId, int button, InventoryClickType clickType, Player player) {
         try {
             this.doClick(slotId, button, clickType, player);
-        } catch (Exception var8) {
-            CrashReport crashReport = CrashReport.forThrowable(var8, "Container click");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Click info");
-            crashReportCategory.setDetail("Menu Type", () -> this.menuType != null ? BuiltInRegistries.MENU.getKey(this.menuType).toString() : "<no type>");
-            crashReportCategory.setDetail("Menu Class", () -> this.getClass().getCanonicalName());
-            crashReportCategory.setDetail("Slot Count", this.slots.size());
-            crashReportCategory.setDetail("Slot", slotId);
-            crashReportCategory.setDetail("Button", button);
-            crashReportCategory.setDetail("Type", clickType);
-            throw new ReportedException(crashReport);
+        } catch (Exception exception) {
+            CrashReport crashreport = CrashReport.forThrowable(exception, "Container click");
+            CrashReportCategory crashreportsystemdetails = crashreport.addCategory("Click info");
+
+            crashreportsystemdetails.setDetail("Menu Type", () -> {
+                return this.menuType != null ? BuiltInRegistries.MENU.getKey(this.menuType).toString() : "<no type>";
+            });
+            crashreportsystemdetails.setDetail("Menu Class", () -> {
+                return this.getClass().getCanonicalName();
+            });
+            crashreportsystemdetails.setDetail("Slot Count", (Object) this.slots.size());
+            crashreportsystemdetails.setDetail("Slot", (Object) slotId);
+            crashreportsystemdetails.setDetail("Button", (Object) button);
+            crashreportsystemdetails.setDetail("Type", (Object) clickType);
+            throw new ReportedException(crashreport);
         }
     }
 
-    private void doClick(int slotId, int button, ClickType clickType, Player player) {
-        Inventory inventory = player.getInventory();
-        if (clickType == ClickType.QUICK_CRAFT) {
-            int i = this.quickcraftStatus;
+    private void doClick(int slotId, int button, InventoryClickType clickType, Player player) {
+        Inventory playerinventory = player.getInventory();
+        Slot slot;
+        ItemStack itemstack;
+        int k;
+        ItemStack itemstack1;
+        int l;
+
+        if (clickType == InventoryClickType.QUICK_CRAFT) {
+            int i1 = this.quickcraftStatus;
+
             this.quickcraftStatus = getQuickcraftHeader(button);
-            if ((i != 1 || this.quickcraftStatus != 2) && i != this.quickcraftStatus) {
+            if ((i1 != 1 || this.quickcraftStatus != 2) && i1 != this.quickcraftStatus) {
                 this.resetQuickCraft();
             } else if (this.getCarried().isEmpty()) {
                 this.resetQuickCraft();
@@ -318,48 +417,82 @@
                     this.resetQuickCraft();
                 }
             } else if (this.quickcraftStatus == 1) {
-                Slot slot = this.slots.get(slotId);
-                ItemStack carried = this.getCarried();
-                if (canItemQuickReplace(slot, carried, true)
-                    && slot.mayPlace(carried)
-                    && (this.quickcraftType == 2 || carried.getCount() > this.quickcraftSlots.size())
-                    && this.canDragTo(slot)) {
+                slot = (Slot) this.slots.get(slotId);
+                itemstack = this.getCarried();
+                if (canItemQuickReplace(slot, itemstack, true) && slot.mayPlace(itemstack) && (this.quickcraftType == 2 || itemstack.getCount() > this.quickcraftSlots.size()) && this.canDragTo(slot)) {
                     this.quickcraftSlots.add(slot);
                 }
             } else if (this.quickcraftStatus == 2) {
                 if (!this.quickcraftSlots.isEmpty()) {
-                    if (this.quickcraftSlots.size() == 1) {
-                        int i1 = this.quickcraftSlots.iterator().next().index;
+                    if (false && this.quickcraftSlots.size() == 1) { // CraftBukkit - treat everything as a drag since we are unable to easily call InventoryClickEvent instead
+                        k = ((Slot) this.quickcraftSlots.iterator().next()).index;
                         this.resetQuickCraft();
-                        this.doClick(i1, this.quickcraftType, ClickType.PICKUP, player);
+                        this.doClick(k, this.quickcraftType, InventoryClickType.PICKUP, player);
                         return;
                     }
 
-                    ItemStack itemStack = this.getCarried().copy();
-                    if (itemStack.isEmpty()) {
+                    itemstack1 = this.getCarried().copy();
+                    if (itemstack1.isEmpty()) {
                         this.resetQuickCraft();
                         return;
                     }
 
-                    int count = this.getCarried().getCount();
+                    l = this.getCarried().getCount();
+                    Iterator iterator = this.quickcraftSlots.iterator();
 
-                    for (Slot slot1 : this.quickcraftSlots) {
-                        ItemStack carried1 = this.getCarried();
-                        if (slot1 != null
-                            && canItemQuickReplace(slot1, carried1, true)
-                            && slot1.mayPlace(carried1)
-                            && (this.quickcraftType == 2 || carried1.getCount() >= this.quickcraftSlots.size())
-                            && this.canDragTo(slot1)) {
-                            int i2 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
-                            int min = Math.min(itemStack.getMaxStackSize(), slot1.getMaxStackSize(itemStack));
-                            int min1 = Math.min(getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemStack) + i2, min);
-                            count -= min1 - i2;
-                            slot1.setByPlayer(itemStack.copyWithCount(min1));
+                    Map<Integer, ItemStack> draggedSlots = new HashMap<Integer, ItemStack>(); // CraftBukkit - Store slots from drag in map (raw slot id -> new stack)
+                    while (iterator.hasNext()) {
+                        Slot slot1 = (Slot) iterator.next();
+                        ItemStack itemstack2 = this.getCarried();
+
+                        if (slot1 != null && canItemQuickReplace(slot1, itemstack2, true) && slot1.mayPlace(itemstack2) && (this.quickcraftType == 2 || itemstack2.getCount() >= this.quickcraftSlots.size()) && this.canDragTo(slot1)) {
+                            int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
+                            int k1 = Math.min(itemstack1.getMaxStackSize(), slot1.getMaxStackSize(itemstack1));
+                            int l1 = Math.min(getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
+
+                            l -= l1 - j1;
+                            // slot1.setByPlayer(itemstack1.copyWithCount(l1));
+                            draggedSlots.put(slot1.index, itemstack1.copyWithCount(l1)); // CraftBukkit - Put in map instead of setting
                         }
                     }
 
-                    itemStack.setCount(count);
-                    this.setCarried(itemStack);
+                    // CraftBukkit start - InventoryDragEvent
+                    InventoryView view = getBukkitView();
+                    org.bukkit.inventory.ItemStack newcursor = CraftItemStack.asCraftMirror(itemstack1);
+                    newcursor.setAmount(l);
+                    Map<Integer, org.bukkit.inventory.ItemStack> eventmap = new HashMap<Integer, org.bukkit.inventory.ItemStack>();
+                    for (Map.Entry<Integer, ItemStack> ditem : draggedSlots.entrySet()) {
+                        eventmap.put(ditem.getKey(), CraftItemStack.asBukkitCopy(ditem.getValue()));
+                    }
+
+                    // It's essential that we set the cursor to the new value here to prevent item duplication if a plugin closes the inventory.
+                    ItemStack oldCursor = this.getCarried();
+                    this.setCarried(CraftItemStack.asNMSCopy(newcursor));
+
+                    InventoryDragEvent event = new InventoryDragEvent(view, (newcursor.getType() != org.bukkit.Material.AIR ? newcursor : null), CraftItemStack.asBukkitCopy(oldCursor), this.quickcraftType == 1, eventmap);
+                    player.level().getCraftServer().getPluginManager().callEvent(event);
+
+                    // Whether or not a change was made to the inventory that requires an update.
+                    boolean needsUpdate = event.getResult() != Result.DEFAULT;
+
+                    if (event.getResult() != Result.DENY) {
+                        for (Map.Entry<Integer, ItemStack> dslot : draggedSlots.entrySet()) {
+                            view.setItem(dslot.getKey(), CraftItemStack.asBukkitCopy(dslot.getValue()));
+                        }
+                        // The only time the carried item will be set to null is if the inventory is closed by the server.
+                        // If the inventory is closed by the server, then the cursor items are dropped.  This is why we change the cursor early.
+                        if (this.getCarried() != null) {
+                            this.setCarried(CraftItemStack.asNMSCopy(event.getCursor()));
+                            needsUpdate = true;
+                        }
+                    } else {
+                        this.setCarried(oldCursor);
+                    }
+
+                    if (needsUpdate && player instanceof ServerPlayer) {
+                        this.sendAllDataToRemote();
+                    }
+                    // CraftBukkit end
                 }
 
                 this.resetQuickCraft();
@@ -368,154 +501,181 @@
             }
         } else if (this.quickcraftStatus != 0) {
             this.resetQuickCraft();
-        } else if ((clickType == ClickType.PICKUP || clickType == ClickType.QUICK_MOVE) && (button == 0 || button == 1)) {
-            ClickAction clickAction = button == 0 ? ClickAction.PRIMARY : ClickAction.SECONDARY;
-            if (slotId == -999) {
-                if (!this.getCarried().isEmpty()) {
-                    if (clickAction == ClickAction.PRIMARY) {
-                        player.drop(this.getCarried(), true);
-                        this.setCarried(ItemStack.EMPTY);
-                    } else {
-                        player.drop(this.getCarried().split(1), true);
+        } else {
+            int i2;
+
+            if ((clickType == InventoryClickType.PICKUP || clickType == InventoryClickType.QUICK_MOVE) && (button == 0 || button == 1)) {
+                ClickAction clickaction = button == 0 ? ClickAction.PRIMARY : ClickAction.SECONDARY;
+
+                if (slotId == -999) {
+                    if (!this.getCarried().isEmpty()) {
+                        if (clickaction == ClickAction.PRIMARY) {
+                            // CraftBukkit start
+                            ItemStack carried = this.getCarried();
+                            this.setCarried(ItemStack.EMPTY);
+                            player.drop(carried, true);
+                            // CraftBukkit start
+                        } else {
+                            player.drop(this.getCarried().split(1), true);
+                        }
                     }
-                }
-            } else if (clickType == ClickType.QUICK_MOVE) {
-                if (slotId < 0) {
-                    return;
-                }
+                } else if (clickType == InventoryClickType.QUICK_MOVE) {
+                    if (slotId < 0) {
+                        return;
+                    }
 
-                Slot slot = this.slots.get(slotId);
-                if (!slot.mayPickup(player)) {
-                    return;
-                }
+                    slot = (Slot) this.slots.get(slotId);
+                    if (!slot.mayPickup(player)) {
+                        return;
+                    }
 
-                ItemStack carried = this.quickMoveStack(player, slotId);
+                    for (itemstack = this.quickMoveStack(player, slotId); !itemstack.isEmpty() && ItemStack.isSameItem(slot.getItem(), itemstack); itemstack = this.quickMoveStack(player, slotId)) {
+                        ;
+                    }
+                } else {
+                    if (slotId < 0) {
+                        return;
+                    }
 
-                while (!carried.isEmpty() && ItemStack.isSameItem(slot.getItem(), carried)) {
-                    carried = this.quickMoveStack(player, slotId);
-                }
-            } else {
-                if (slotId < 0) {
-                    return;
-                }
+                    slot = (Slot) this.slots.get(slotId);
+                    itemstack = slot.getItem();
+                    ItemStack itemstack3 = this.getCarried();
 
-                Slot slot = this.slots.get(slotId);
-                ItemStack carried = slot.getItem();
-                ItemStack carried2 = this.getCarried();
-                player.updateTutorialInventoryAction(carried2, slot.getItem(), clickAction);
-                if (!this.tryItemClickBehaviourOverride(player, clickAction, slot, carried, carried2)) {
-                    if (carried.isEmpty()) {
-                        if (!carried2.isEmpty()) {
-                            int i3 = clickAction == ClickAction.PRIMARY ? carried2.getCount() : 1;
-                            this.setCarried(slot.safeInsert(carried2, i3));
-                        }
-                    } else if (slot.mayPickup(player)) {
-                        if (carried2.isEmpty()) {
-                            int i3 = clickAction == ClickAction.PRIMARY ? carried.getCount() : (carried.getCount() + 1) / 2;
-                            Optional<ItemStack> optional = slot.tryRemove(i3, Integer.MAX_VALUE, player);
-                            optional.ifPresent(stack -> {
-                                this.setCarried(stack);
-                                slot.onTake(player, stack);
-                            });
-                        } else if (slot.mayPlace(carried2)) {
-                            if (ItemStack.isSameItemSameTags(carried, carried2)) {
-                                int i3 = clickAction == ClickAction.PRIMARY ? carried2.getCount() : 1;
-                                this.setCarried(slot.safeInsert(carried2, i3));
-                            } else if (carried2.getCount() <= slot.getMaxStackSize(carried2)) {
-                                this.setCarried(carried);
-                                slot.setByPlayer(carried2);
+                    player.updateTutorialInventoryAction(itemstack3, slot.getItem(), clickaction);
+                    if (!this.tryItemClickBehaviourOverride(player, clickaction, slot, itemstack, itemstack3)) {
+                        if (itemstack.isEmpty()) {
+                            if (!itemstack3.isEmpty()) {
+                                i2 = clickaction == ClickAction.PRIMARY ? itemstack3.getCount() : 1;
+                                this.setCarried(slot.safeInsert(itemstack3, i2));
                             }
-                        } else if (ItemStack.isSameItemSameTags(carried, carried2)) {
-                            Optional<ItemStack> optional1 = slot.tryRemove(carried.getCount(), carried2.getMaxStackSize() - carried2.getCount(), player);
-                            optional1.ifPresent(stack -> {
-                                carried2.grow(stack.getCount());
-                                slot.onTake(player, stack);
-                            });
+                        } else if (slot.mayPickup(player)) {
+                            if (itemstack3.isEmpty()) {
+                                i2 = clickaction == ClickAction.PRIMARY ? itemstack.getCount() : (itemstack.getCount() + 1) / 2;
+                                Optional<ItemStack> optional = slot.tryRemove(i2, Integer.MAX_VALUE, player);
+
+                                optional.ifPresent((itemstack4) -> {
+                                    this.setCarried(itemstack4);
+                                    slot.onTake(player, itemstack4);
+                                });
+                            } else if (slot.mayPlace(itemstack3)) {
+                                if (ItemStack.isSameItemSameTags(itemstack, itemstack3)) {
+                                    i2 = clickaction == ClickAction.PRIMARY ? itemstack3.getCount() : 1;
+                                    this.setCarried(slot.safeInsert(itemstack3, i2));
+                                } else if (itemstack3.getCount() <= slot.getMaxStackSize(itemstack3)) {
+                                    this.setCarried(itemstack);
+                                    slot.setByPlayer(itemstack3);
+                                }
+                            } else if (ItemStack.isSameItemSameTags(itemstack, itemstack3)) {
+                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), itemstack3.getMaxStackSize() - itemstack3.getCount(), player);
+
+                                optional1.ifPresent((itemstack4) -> {
+                                    itemstack3.grow(itemstack4.getCount());
+                                    slot.onTake(player, itemstack4);
+                                });
+                            }
                         }
                     }
-                }
 
-                slot.setChanged();
-            }
-        } else if (clickType == ClickType.SWAP && (button >= 0 && button < 9 || button == 40)) {
-            ItemStack item = inventory.getItem(button);
-            Slot slot = this.slots.get(slotId);
-            ItemStack carried = slot.getItem();
-            if (!item.isEmpty() || !carried.isEmpty()) {
-                if (item.isEmpty()) {
-                    if (slot.mayPickup(player)) {
-                        inventory.setItem(button, carried);
-                        slot.onSwapCraft(carried.getCount());
-                        slot.setByPlayer(ItemStack.EMPTY);
-                        slot.onTake(player, carried);
-                    }
-                } else if (carried.isEmpty()) {
-                    if (slot.mayPlace(item)) {
-                        int maxStackSize = slot.getMaxStackSize(item);
-                        if (item.getCount() > maxStackSize) {
-                            slot.setByPlayer(item.split(maxStackSize));
-                        } else {
-                            inventory.setItem(button, ItemStack.EMPTY);
-                            slot.setByPlayer(item);
+                    slot.setChanged();
+                    // CraftBukkit start - Make sure the client has the right slot contents
+                    if (player instanceof ServerPlayer && slot.getMaxStackSize() != 64) {
+                        ((ServerPlayer) player).connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), slot.index, slot.getItem()));
+                        // Updating a crafting inventory makes the client reset the result slot, have to send it again
+                        if (this.getBukkitView().getType() == InventoryType.WORKBENCH || this.getBukkitView().getType() == InventoryType.CRAFTING) {
+                            ((ServerPlayer) player).connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), 0, this.getSlot(0).getItem()));
                         }
                     }
-                } else if (slot.mayPickup(player) && slot.mayPlace(item)) {
-                    int maxStackSize = slot.getMaxStackSize(item);
-                    if (item.getCount() > maxStackSize) {
-                        slot.setByPlayer(item.split(maxStackSize));
-                        slot.onTake(player, carried);
-                        if (!inventory.add(carried)) {
-                            player.drop(carried, true);
+                    // CraftBukkit end
+                }
+            } else {
+                int j2;
+
+                if (clickType == InventoryClickType.SWAP && (button >= 0 && button < 9 || button == 40)) {
+                    ItemStack itemstack4 = playerinventory.getItem(button);
+
+                    slot = (Slot) this.slots.get(slotId);
+                    itemstack = slot.getItem();
+                    if (!itemstack4.isEmpty() || !itemstack.isEmpty()) {
+                        if (itemstack4.isEmpty()) {
+                            if (slot.mayPickup(player)) {
+                                playerinventory.setItem(button, itemstack);
+                                slot.onSwapCraft(itemstack.getCount());
+                                slot.setByPlayer(ItemStack.EMPTY);
+                                slot.onTake(player, itemstack);
+                            }
+                        } else if (itemstack.isEmpty()) {
+                            if (slot.mayPlace(itemstack4)) {
+                                j2 = slot.getMaxStackSize(itemstack4);
+                                if (itemstack4.getCount() > j2) {
+                                    slot.setByPlayer(itemstack4.split(j2));
+                                } else {
+                                    playerinventory.setItem(button, ItemStack.EMPTY);
+                                    slot.setByPlayer(itemstack4);
+                                }
+                            }
+                        } else if (slot.mayPickup(player) && slot.mayPlace(itemstack4)) {
+                            j2 = slot.getMaxStackSize(itemstack4);
+                            if (itemstack4.getCount() > j2) {
+                                slot.setByPlayer(itemstack4.split(j2));
+                                slot.onTake(player, itemstack);
+                                if (!playerinventory.add(itemstack)) {
+                                    player.drop(itemstack, true);
+                                }
+                            } else {
+                                playerinventory.setItem(button, itemstack);
+                                slot.setByPlayer(itemstack4);
+                                slot.onTake(player, itemstack);
+                            }
                         }
-                    } else {
-                        inventory.setItem(button, carried);
-                        slot.setByPlayer(item);
-                        slot.onTake(player, carried);
                     }
-                }
-            }
-        } else if (clickType == ClickType.CLONE && player.getAbilities().instabuild && this.getCarried().isEmpty() && slotId >= 0) {
-            Slot slot2 = this.slots.get(slotId);
-            if (slot2.hasItem()) {
-                ItemStack itemStack = slot2.getItem();
-                this.setCarried(itemStack.copyWithCount(itemStack.getMaxStackSize()));
-            }
-        } else if (clickType == ClickType.THROW && this.getCarried().isEmpty() && slotId >= 0) {
-            Slot slot2 = this.slots.get(slotId);
-            int i1 = button == 0 ? 1 : slot2.getItem().getCount();
-            ItemStack carried = slot2.safeTake(i1, Integer.MAX_VALUE, player);
-            player.drop(carried, true);
-        } else if (clickType == ClickType.PICKUP_ALL && slotId >= 0) {
-            Slot slot2 = this.slots.get(slotId);
-            ItemStack itemStack = this.getCarried();
-            if (!itemStack.isEmpty() && (!slot2.hasItem() || !slot2.mayPickup(player))) {
-                int count = button == 0 ? 0 : this.slots.size() - 1;
-                int maxStackSize = button == 0 ? 1 : -1;
+                } else {
+                    Slot slot2;
 
-                for (int i3 = 0; i3 < 2; i3++) {
-                    for (int i4 = count; i4 >= 0 && i4 < this.slots.size() && itemStack.getCount() < itemStack.getMaxStackSize(); i4 += maxStackSize) {
-                        Slot slot3 = this.slots.get(i4);
-                        if (slot3.hasItem()
-                            && canItemQuickReplace(slot3, itemStack, true)
-                            && slot3.mayPickup(player)
-                            && this.canTakeItemForPickAll(itemStack, slot3)) {
-                            ItemStack item1 = slot3.getItem();
-                            if (i3 != 0 || item1.getCount() != item1.getMaxStackSize()) {
-                                ItemStack itemStack1 = slot3.safeTake(item1.getCount(), itemStack.getMaxStackSize() - itemStack.getCount(), player);
-                                itemStack.grow(itemStack1.getCount());
+                    if (clickType == InventoryClickType.CLONE && player.getAbilities().instabuild && this.getCarried().isEmpty() && slotId >= 0) {
+                        slot2 = (Slot) this.slots.get(slotId);
+                        if (slot2.hasItem()) {
+                            itemstack1 = slot2.getItem();
+                            this.setCarried(itemstack1.copyWithCount(itemstack1.getMaxStackSize()));
+                        }
+                    } else if (clickType == InventoryClickType.THROW && this.getCarried().isEmpty() && slotId >= 0) {
+                        slot2 = (Slot) this.slots.get(slotId);
+                        k = button == 0 ? 1 : slot2.getItem().getCount();
+                        itemstack = slot2.safeTake(k, Integer.MAX_VALUE, player);
+                        player.drop(itemstack, true);
+                    } else if (clickType == InventoryClickType.PICKUP_ALL && slotId >= 0) {
+                        slot2 = (Slot) this.slots.get(slotId);
+                        itemstack1 = this.getCarried();
+                        if (!itemstack1.isEmpty() && (!slot2.hasItem() || !slot2.mayPickup(player))) {
+                            l = button == 0 ? 0 : this.slots.size() - 1;
+                            j2 = button == 0 ? 1 : -1;
+
+                            for (i2 = 0; i2 < 2; ++i2) {
+                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < itemstack1.getMaxStackSize(); k2 += j2) {
+                                    Slot slot3 = (Slot) this.slots.get(k2);
+
+                                    if (slot3.hasItem() && canItemQuickReplace(slot3, itemstack1, true) && slot3.mayPickup(player) && this.canTakeItemForPickAll(itemstack1, slot3)) {
+                                        ItemStack itemstack5 = slot3.getItem();
+
+                                        if (i2 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
+                                            ItemStack itemstack6 = slot3.safeTake(itemstack5.getCount(), itemstack1.getMaxStackSize() - itemstack1.getCount(), player);
+
+                                            itemstack1.grow(itemstack6.getCount());
+                                        }
+                                    }
+                                }
                             }
                         }
                     }
                 }
             }
         }
+
     }
 
     private boolean tryItemClickBehaviourOverride(Player player, ClickAction action, Slot slot, ItemStack clickedItem, ItemStack carriedItem) {
-        FeatureFlagSet featureFlagSet = player.level().enabledFeatures();
-        return carriedItem.isItemEnabled(featureFlagSet) && carriedItem.overrideStackedOnOther(slot, action, player)
-            || clickedItem.isItemEnabled(featureFlagSet)
-                && clickedItem.overrideOtherStackedOnMe(carriedItem, slot, action, player, this.createCarriedSlotAccess());
+        FeatureFlagSet featureflagset = player.level().enabledFeatures();
+
+        return carriedItem.isItemEnabled(featureflagset) && carriedItem.overrideStackedOnOther(slot, action, player) ? true : clickedItem.isItemEnabled(featureflagset) && clickedItem.overrideOtherStackedOnMe(carriedItem, slot, action, player, this.createCarriedSlotAccess());
     }
 
     private SlotAccess createCarriedSlotAccess() {
@@ -539,31 +699,39 @@
 
     public void removed(Player player) {
         if (player instanceof ServerPlayer) {
-            ItemStack carried = this.getCarried();
-            if (!carried.isEmpty()) {
-                if (player.isAlive() && !((ServerPlayer)player).hasDisconnected()) {
-                    player.getInventory().placeItemBackInInventory(carried);
+            ItemStack itemstack = this.getCarried();
+
+            if (!itemstack.isEmpty()) {
+                this.setCarried(ItemStack.EMPTY); // CraftBukkit - SPIGOT-4556 - from below
+                if (player.isAlive() && !((ServerPlayer) player).hasDisconnected()) {
+                    player.getInventory().placeItemBackInInventory(itemstack);
                 } else {
-                    player.drop(carried, false);
+                    player.drop(itemstack, false);
                 }
 
-                this.setCarried(ItemStack.EMPTY);
+                // this.setCarried(ItemStack.EMPTY); // CraftBukkit - moved up
             }
         }
+
     }
 
     protected void clearContainer(Player player, Container container) {
-        if (!player.isAlive() || player instanceof ServerPlayer && ((ServerPlayer)player).hasDisconnected()) {
-            for (int i = 0; i < container.getContainerSize(); i++) {
-                player.drop(container.removeItemNoUpdate(i), false);
+        int i;
+
+        if (player.isAlive() && (!(player instanceof ServerPlayer) || !((ServerPlayer) player).hasDisconnected())) {
+            for (i = 0; i < container.getContainerSize(); ++i) {
+                Inventory playerinventory = player.getInventory();
+
+                if (playerinventory.player instanceof ServerPlayer) {
+                    playerinventory.placeItemBackInInventory(container.removeItemNoUpdate(i));
+                }
             }
+
         } else {
-            for (int i = 0; i < container.getContainerSize(); i++) {
-                Inventory inventory = player.getInventory();
-                if (inventory.player instanceof ServerPlayer) {
-                    inventory.placeItemBackInInventory(container.removeItemNoUpdate(i));
-                }
+            for (i = 0; i < container.getContainerSize(); ++i) {
+                player.drop(container.removeItemNoUpdate(i), false);
             }
+
         }
     }
 
@@ -577,8 +745,8 @@
     }
 
     public void initializeContents(int stateId, List<ItemStack> items, ItemStack carried) {
-        for (int i = 0; i < items.size(); i++) {
-            this.getSlot(i).set(items.get(i));
+        for (int j = 0; j < items.size(); ++j) {
+            this.getSlot(j).set((ItemStack) items.get(j));
         }
 
         this.carried = carried;
@@ -586,76 +754,97 @@
     }
 
     public void setData(int id, int data) {
-        this.dataSlots.get(id).set(data);
+        ((DataSlot) this.dataSlots.get(id)).set(data);
     }
 
     public abstract boolean stillValid(Player player);
 
     protected boolean moveItemStackTo(ItemStack stack, int startIndex, int endIndex, boolean reverseDirection) {
-        boolean flag = false;
-        int i = startIndex;
+        boolean flag1 = false;
+        int k = startIndex;
+
         if (reverseDirection) {
-            i = endIndex - 1;
+            k = endIndex - 1;
         }
 
+        Slot slot;
+        ItemStack itemstack1;
+
         if (stack.isStackable()) {
-            while (!stack.isEmpty() && (reverseDirection ? i >= startIndex : i < endIndex)) {
-                Slot slot = this.slots.get(i);
-                ItemStack item = slot.getItem();
-                if (!item.isEmpty() && ItemStack.isSameItemSameTags(stack, item)) {
-                    int i1 = item.getCount() + stack.getCount();
-                    if (i1 <= stack.getMaxStackSize()) {
+            while (!stack.isEmpty()) {
+                if (reverseDirection) {
+                    if (k < startIndex) {
+                        break;
+                    }
+                } else if (k >= endIndex) {
+                    break;
+                }
+
+                slot = (Slot) this.slots.get(k);
+                itemstack1 = slot.getItem();
+                if (!itemstack1.isEmpty() && ItemStack.isSameItemSameTags(stack, itemstack1)) {
+                    int l = itemstack1.getCount() + stack.getCount();
+
+                    if (l <= stack.getMaxStackSize()) {
                         stack.setCount(0);
-                        item.setCount(i1);
+                        itemstack1.setCount(l);
                         slot.setChanged();
-                        flag = true;
-                    } else if (item.getCount() < stack.getMaxStackSize()) {
-                        stack.shrink(stack.getMaxStackSize() - item.getCount());
-                        item.setCount(stack.getMaxStackSize());
+                        flag1 = true;
+                    } else if (itemstack1.getCount() < stack.getMaxStackSize()) {
+                        stack.shrink(stack.getMaxStackSize() - itemstack1.getCount());
+                        itemstack1.setCount(stack.getMaxStackSize());
                         slot.setChanged();
-                        flag = true;
+                        flag1 = true;
                     }
                 }
 
                 if (reverseDirection) {
-                    i--;
+                    --k;
                 } else {
-                    i++;
+                    ++k;
                 }
             }
         }
 
         if (!stack.isEmpty()) {
             if (reverseDirection) {
-                i = endIndex - 1;
+                k = endIndex - 1;
             } else {
-                i = startIndex;
+                k = startIndex;
             }
 
-            while (reverseDirection ? i >= startIndex : i < endIndex) {
-                Slot slotx = this.slots.get(i);
-                ItemStack itemx = slotx.getItem();
-                if (itemx.isEmpty() && slotx.mayPlace(stack)) {
-                    if (stack.getCount() > slotx.getMaxStackSize()) {
-                        slotx.setByPlayer(stack.split(slotx.getMaxStackSize()));
+            while (true) {
+                if (reverseDirection) {
+                    if (k < startIndex) {
+                        break;
+                    }
+                } else if (k >= endIndex) {
+                    break;
+                }
+
+                slot = (Slot) this.slots.get(k);
+                itemstack1 = slot.getItem();
+                if (itemstack1.isEmpty() && slot.mayPlace(stack)) {
+                    if (stack.getCount() > slot.getMaxStackSize()) {
+                        slot.setByPlayer(stack.split(slot.getMaxStackSize()));
                     } else {
-                        slotx.setByPlayer(stack.split(stack.getCount()));
+                        slot.setByPlayer(stack.split(stack.getCount()));
                     }
 
-                    slotx.setChanged();
-                    flag = true;
+                    slot.setChanged();
+                    flag1 = true;
                     break;
                 }
 
                 if (reverseDirection) {
-                    i--;
+                    --k;
                 } else {
-                    i++;
+                    ++k;
                 }
             }
         }
 
-        return flag;
+        return flag1;
     }
 
     public static int getQuickcraftType(int eventButton) {
@@ -671,7 +860,7 @@
     }
 
     public static boolean isValidQuickcraftType(int dragMode, Player player) {
-        return dragMode == 0 || dragMode == 1 || dragMode == 2 && player.getAbilities().instabuild;
+        return dragMode == 0 ? true : (dragMode == 1 ? true : dragMode == 2 && player.getAbilities().instabuild);
     }
 
     protected void resetQuickCraft() {
@@ -680,19 +869,29 @@
     }
 
     public static boolean canItemQuickReplace(@Nullable Slot slot, ItemStack stack, boolean stackSizeMatters) {
-        boolean flag = slot == null || !slot.hasItem();
-        return !flag && ItemStack.isSameItemSameTags(stack, slot.getItem())
-            ? slot.getItem().getCount() + (stackSizeMatters ? 0 : stack.getCount()) <= stack.getMaxStackSize()
-            : flag;
+        boolean flag1 = slot == null || !slot.hasItem();
+
+        return !flag1 && ItemStack.isSameItemSameTags(stack, slot.getItem()) ? slot.getItem().getCount() + (stackSizeMatters ? 0 : stack.getCount()) <= stack.getMaxStackSize() : flag1;
     }
 
     public static int getQuickCraftPlaceCount(Set<Slot> slots, int type, ItemStack stack) {
-        return switch (type) {
-            case 0 -> Mth.floor((float)stack.getCount() / (float)slots.size());
-            case 1 -> 1;
-            case 2 -> stack.getItem().getMaxStackSize();
-            default -> stack.getCount();
-        };
+        int j;
+
+        switch (type) {
+            case 0:
+                j = Mth.floor((float) stack.getCount() / (float) slots.size());
+                break;
+            case 1:
+                j = 1;
+                break;
+            case 2:
+                j = stack.getItem().getMaxStackSize();
+                break;
+            default:
+                j = stack.getCount();
+        }
+
+        return j;
     }
 
     public boolean canDragTo(Slot slot) {
@@ -700,7 +899,7 @@
     }
 
     public static int getRedstoneSignalFromBlockEntity(@Nullable BlockEntity blockEntity) {
-        return blockEntity instanceof Container ? getRedstoneSignalFromContainer((Container)blockEntity) : 0;
+        return blockEntity instanceof Container ? getRedstoneSignalFromContainer((Container) blockEntity) : 0;
     }
 
     public static int getRedstoneSignalFromContainer(@Nullable Container container) {
@@ -709,14 +908,15 @@
         } else {
             float f = 0.0F;
 
-            for (int i = 0; i < container.getContainerSize(); i++) {
-                ItemStack item = container.getItem(i);
-                if (!item.isEmpty()) {
-                    f += (float)item.getCount() / (float)Math.min(container.getMaxStackSize(), item.getMaxStackSize());
+            for (int i = 0; i < container.getContainerSize(); ++i) {
+                ItemStack itemstack = container.getItem(i);
+
+                if (!itemstack.isEmpty()) {
+                    f += (float) itemstack.getCount() / (float) Math.min(container.getMaxStackSize(), itemstack.getMaxStackSize());
                 }
             }
 
-            f /= (float)container.getContainerSize();
+            f /= (float) container.getContainerSize();
             return Mth.lerpDiscrete(f, 0, 15);
         }
     }
@@ -726,6 +926,11 @@
     }
 
     public ItemStack getCarried() {
+        // CraftBukkit start
+        if (this.carried.isEmpty()) {
+            this.setCarried(ItemStack.EMPTY);
+        }
+        // CraftBukkit end
         return this.carried;
     }
 
@@ -740,26 +945,32 @@
     public void transferState(AbstractContainerMenu menu) {
         Table<Container, Integer, Integer> table = HashBasedTable.create();
 
-        for (int i = 0; i < menu.slots.size(); i++) {
-            Slot slot = menu.slots.get(i);
+        Slot slot;
+        int i;
+
+        for (i = 0; i < menu.slots.size(); ++i) {
+            slot = (Slot) menu.slots.get(i);
             table.put(slot.container, slot.getContainerSlot(), i);
         }
 
-        for (int i = 0; i < this.slots.size(); i++) {
-            Slot slot = this.slots.get(i);
-            Integer integer = table.get(slot.container, slot.getContainerSlot());
+        for (i = 0; i < this.slots.size(); ++i) {
+            slot = (Slot) this.slots.get(i);
+            Integer integer = (Integer) table.get(slot.container, slot.getContainerSlot());
+
             if (integer != null) {
-                this.lastSlots.set(i, menu.lastSlots.get(integer));
-                this.remoteSlots.set(i, menu.remoteSlots.get(integer));
+                this.lastSlots.set(i, (ItemStack) menu.lastSlots.get(integer));
+                this.remoteSlots.set(i, (ItemStack) menu.remoteSlots.get(integer));
             }
         }
+
     }
 
     public OptionalInt findSlot(Container container, int slotIndex) {
-        for (int i = 0; i < this.slots.size(); i++) {
-            Slot slot = this.slots.get(i);
+        for (int j = 0; j < this.slots.size(); ++j) {
+            Slot slot = (Slot) this.slots.get(j);
+
             if (slot.container == container && slotIndex == slot.getContainerSlot()) {
-                return OptionalInt.of(i);
+                return OptionalInt.of(j);
             }
         }
 
