--- a/net/minecraft/world/SimpleContainer.java
+++ b/net/minecraft/world/SimpleContainer.java
@@ -1,6 +1,7 @@
 package net.minecraft.world;
 
 import com.google.common.collect.Lists;
+import java.util.Iterator;
 import java.util.List;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
@@ -13,17 +14,76 @@
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 
+// CraftBukkit start
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.entity.HumanEntity;
+// CraftBukkit end
+
 public class SimpleContainer implements Container, StackedContentsCompatible {
+
     private final int size;
-    private final NonNullList<ItemStack> items;
+    public final NonNullList<ItemStack> items;
     @Nullable
     private List<ContainerListener> listeners;
 
+    // CraftBukkit start - add fields and methods
+    public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    private int maxStack = MAX_STACK;
+    protected org.bukkit.inventory.InventoryHolder bukkitOwner;
+
+    public List<ItemStack> getContents() {
+        return this.items;
+    }
+
+    public void onOpen(CraftHumanEntity who) {
+        transaction.add(who);
+    }
+
+    public void onClose(CraftHumanEntity who) {
+        transaction.remove(who);
+    }
+
+    public List<HumanEntity> getViewers() {
+        return transaction;
+    }
+
+    @Override
+    public int getMaxStackSize() {
+        return maxStack;
+    }
+
+    public void setMaxStackSize(int i) {
+        maxStack = i;
+    }
+
+    public org.bukkit.inventory.InventoryHolder getOwner() {
+        return bukkitOwner;
+    }
+
+    @Override
+    public Location getLocation() {
+        return null;
+    }
+
+    public SimpleContainer(SimpleContainer original) {
+        this(original.size);
+        for (int slot = 0; slot < original.size; slot++) {
+            this.items.set(slot, original.items.get(slot).copy());
+        }
+    }
+
     public SimpleContainer(int size) {
-        this.size = size;
-        this.items = NonNullList.withSize(size, ItemStack.EMPTY);
+        this(size, null);
     }
 
+    public SimpleContainer(int i, org.bukkit.inventory.InventoryHolder owner) {
+        this.bukkitOwner = owner;
+        // CraftBukkit end
+        this.size = i;
+        this.items = NonNullList.withSize(i, ItemStack.EMPTY);
+    }
+
     public SimpleContainer(ItemStack... items) {
         this.size = items.length;
         this.items = NonNullList.of(ItemStack.EMPTY, items);
@@ -41,71 +101,82 @@
         if (this.listeners != null) {
             this.listeners.remove(listener);
         }
+
     }
 
     @Override
     public ItemStack getItem(int index) {
-        return index >= 0 && index < this.items.size() ? this.items.get(index) : ItemStack.EMPTY;
+        return index >= 0 && index < this.items.size() ? (ItemStack) this.items.get(index) : ItemStack.EMPTY;
     }
 
     public List<ItemStack> removeAllItems() {
-        List<ItemStack> list = this.items.stream().filter(stack -> !stack.isEmpty()).collect(Collectors.toList());
+        List<ItemStack> list = (List) this.items.stream().filter((itemstack) -> {
+            return !itemstack.isEmpty();
+        }).collect(Collectors.toList());
+
         this.clearContent();
         return list;
     }
 
     @Override
     public ItemStack removeItem(int index, int count) {
-        ItemStack itemStack = ContainerHelper.removeItem(this.items, index, count);
-        if (!itemStack.isEmpty()) {
+        ItemStack itemstack = ContainerHelper.removeItem(this.items, index, count);
+
+        if (!itemstack.isEmpty()) {
             this.setChanged();
         }
 
-        return itemStack;
+        return itemstack;
     }
 
     public ItemStack removeItemType(Item item, int amount) {
-        ItemStack itemStack = new ItemStack(item, 0);
+        ItemStack itemstack = new ItemStack(item, 0);
 
-        for (int i = this.size - 1; i >= 0; i--) {
-            ItemStack item1 = this.getItem(i);
-            if (item1.getItem().equals(item)) {
-                int i1 = amount - itemStack.getCount();
-                ItemStack itemStack1 = item1.split(i1);
-                itemStack.grow(itemStack1.getCount());
-                if (itemStack.getCount() == amount) {
+        for (int j = this.size - 1; j >= 0; --j) {
+            ItemStack itemstack1 = this.getItem(j);
+
+            if (itemstack1.getItem().equals(item)) {
+                int k = amount - itemstack.getCount();
+                ItemStack itemstack2 = itemstack1.split(k);
+
+                itemstack.grow(itemstack2.getCount());
+                if (itemstack.getCount() == amount) {
                     break;
                 }
             }
         }
 
-        if (!itemStack.isEmpty()) {
+        if (!itemstack.isEmpty()) {
             this.setChanged();
         }
 
-        return itemStack;
+        return itemstack;
     }
 
     public ItemStack addItem(ItemStack stack) {
         if (stack.isEmpty()) {
             return ItemStack.EMPTY;
         } else {
-            ItemStack itemStack = stack.copy();
-            this.moveItemToOccupiedSlotsWithSameType(itemStack);
-            if (itemStack.isEmpty()) {
+            ItemStack itemstack1 = stack.copy();
+
+            this.moveItemToOccupiedSlotsWithSameType(itemstack1);
+            if (itemstack1.isEmpty()) {
                 return ItemStack.EMPTY;
             } else {
-                this.moveItemToEmptySlots(itemStack);
-                return itemStack.isEmpty() ? ItemStack.EMPTY : itemStack;
+                this.moveItemToEmptySlots(itemstack1);
+                return itemstack1.isEmpty() ? ItemStack.EMPTY : itemstack1;
             }
         }
     }
 
     public boolean canAddItem(ItemStack stack) {
         boolean flag = false;
+        Iterator iterator = this.items.iterator();
 
-        for (ItemStack itemStack : this.items) {
-            if (itemStack.isEmpty() || ItemStack.isSameItemSameTags(itemStack, stack) && itemStack.getCount() < itemStack.getMaxStackSize()) {
+        while (iterator.hasNext()) {
+            ItemStack itemstack1 = (ItemStack) iterator.next();
+
+            if (itemstack1.isEmpty() || ItemStack.isSameItemSameTags(itemstack1, stack) && itemstack1.getCount() < itemstack1.getMaxStackSize()) {
                 flag = true;
                 break;
             }
@@ -116,12 +187,13 @@
 
     @Override
     public ItemStack removeItemNoUpdate(int index) {
-        ItemStack itemStack = this.items.get(index);
-        if (itemStack.isEmpty()) {
+        ItemStack itemstack = (ItemStack) this.items.get(index);
+
+        if (itemstack.isEmpty()) {
             return ItemStack.EMPTY;
         } else {
             this.items.set(index, ItemStack.EMPTY);
-            return itemStack;
+            return itemstack;
         }
     }
 
@@ -142,22 +214,33 @@
 
     @Override
     public boolean isEmpty() {
-        for (ItemStack itemStack : this.items) {
-            if (!itemStack.isEmpty()) {
-                return false;
+        Iterator iterator = this.items.iterator();
+
+        ItemStack itemstack;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
             }
-        }
 
-        return true;
+            itemstack = (ItemStack) iterator.next();
+        } while (itemstack.isEmpty());
+
+        return false;
     }
 
     @Override
     public void setChanged() {
         if (this.listeners != null) {
-            for (ContainerListener containerListener : this.listeners) {
-                containerListener.containerChanged(this);
+            Iterator iterator = this.listeners.iterator();
+
+            while (iterator.hasNext()) {
+                ContainerListener iinventorylistener = (ContainerListener) iterator.next();
+
+                iinventorylistener.containerChanged(this);
             }
         }
+
     }
 
     @Override
@@ -173,70 +256,85 @@
 
     @Override
     public void fillStackedContents(StackedContents helper) {
-        for (ItemStack itemStack : this.items) {
-            helper.accountStack(itemStack);
+        Iterator iterator = this.items.iterator();
+
+        while (iterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) iterator.next();
+
+            helper.accountStack(itemstack);
         }
+
     }
 
-    @Override
     public String toString() {
-        return this.items.stream().filter(stack -> !stack.isEmpty()).collect(Collectors.toList()).toString();
+        return ((List) this.items.stream().filter((itemstack) -> {
+            return !itemstack.isEmpty();
+        }).collect(Collectors.toList())).toString();
     }
 
     private void moveItemToEmptySlots(ItemStack stack) {
-        for (int i = 0; i < this.size; i++) {
-            ItemStack item = this.getItem(i);
-            if (item.isEmpty()) {
+        for (int i = 0; i < this.size; ++i) {
+            ItemStack itemstack1 = this.getItem(i);
+
+            if (itemstack1.isEmpty()) {
                 this.setItem(i, stack.copyAndClear());
                 return;
             }
         }
+
     }
 
     private void moveItemToOccupiedSlotsWithSameType(ItemStack stack) {
-        for (int i = 0; i < this.size; i++) {
-            ItemStack item = this.getItem(i);
-            if (ItemStack.isSameItemSameTags(item, stack)) {
-                this.moveItemsBetweenStacks(stack, item);
+        for (int i = 0; i < this.size; ++i) {
+            ItemStack itemstack1 = this.getItem(i);
+
+            if (ItemStack.isSameItemSameTags(itemstack1, stack)) {
+                this.moveItemsBetweenStacks(stack, itemstack1);
                 if (stack.isEmpty()) {
                     return;
                 }
             }
         }
+
     }
 
     private void moveItemsBetweenStacks(ItemStack stack, ItemStack other) {
-        int min = Math.min(this.getMaxStackSize(), other.getMaxStackSize());
-        int min1 = Math.min(stack.getCount(), min - other.getCount());
-        if (min1 > 0) {
-            other.grow(min1);
-            stack.shrink(min1);
+        int i = Math.min(this.getMaxStackSize(), other.getMaxStackSize());
+        int j = Math.min(stack.getCount(), i - other.getCount());
+
+        if (j > 0) {
+            other.grow(j);
+            stack.shrink(j);
             this.setChanged();
         }
+
     }
 
     public void fromTag(ListTag containerNbt) {
         this.clearContent();
 
-        for (int i = 0; i < containerNbt.size(); i++) {
-            ItemStack itemStack = ItemStack.of(containerNbt.getCompound(i));
-            if (!itemStack.isEmpty()) {
-                this.addItem(itemStack);
+        for (int i = 0; i < containerNbt.size(); ++i) {
+            ItemStack itemstack = ItemStack.of(containerNbt.getCompound(i));
+
+            if (!itemstack.isEmpty()) {
+                this.addItem(itemstack);
             }
         }
+
     }
 
     public ListTag createTag() {
-        ListTag list = new ListTag();
+        ListTag nbttaglist = new ListTag();
 
-        for (int i = 0; i < this.getContainerSize(); i++) {
-            ItemStack item = this.getItem(i);
-            if (!item.isEmpty()) {
-                list.add(item.save(new CompoundTag()));
+        for (int i = 0; i < this.getContainerSize(); ++i) {
+            ItemStack itemstack = this.getItem(i);
+
+            if (!itemstack.isEmpty()) {
+                nbttaglist.add(itemstack.save(new CompoundTag()));
             }
         }
 
-        return list;
+        return nbttaglist;
     }
 
     public NonNullList<ItemStack> getItems() {
