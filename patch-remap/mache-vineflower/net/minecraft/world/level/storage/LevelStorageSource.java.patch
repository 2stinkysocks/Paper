--- a/net/minecraft/world/level/storage/LevelStorageSource.java
+++ b/net/minecraft/world/level/storage/LevelStorageSource.java
@@ -3,6 +3,7 @@
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
 import java.io.BufferedOutputStream;
@@ -12,6 +13,7 @@
 import java.nio.file.FileVisitResult;
 import java.nio.file.Files;
 import java.nio.file.InvalidPathException;
+import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.nio.file.PathMatcher;
 import java.nio.file.Paths;
@@ -42,6 +44,7 @@
 import net.minecraft.FileUtil;
 import net.minecraft.ReportedException;
 import net.minecraft.Util;
+import net.minecraft.core.HolderLookup;
 import net.minecraft.core.Registry;
 import net.minecraft.core.RegistryAccess;
 import net.minecraft.nbt.CompoundTag;
@@ -68,7 +71,6 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelSettings;
 import net.minecraft.world.level.WorldDataConfiguration;
-import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.levelgen.WorldDimensions;
 import net.minecraft.world.level.levelgen.WorldGenSettings;
@@ -79,25 +81,16 @@
 import org.slf4j.Logger;
 
 public class LevelStorageSource {
+
     static final Logger LOGGER = LogUtils.getLogger();
-    static final DateTimeFormatter FORMATTER = new DateTimeFormatterBuilder()
-        .appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
-        .appendLiteral('-')
-        .appendValue(ChronoField.MONTH_OF_YEAR, 2)
-        .appendLiteral('-')
-        .appendValue(ChronoField.DAY_OF_MONTH, 2)
-        .appendLiteral('_')
-        .appendValue(ChronoField.HOUR_OF_DAY, 2)
-        .appendLiteral('-')
-        .appendValue(ChronoField.MINUTE_OF_HOUR, 2)
-        .appendLiteral('-')
-        .appendValue(ChronoField.SECOND_OF_MINUTE, 2)
-        .toFormatter();
+    static final DateTimeFormatter FORMATTER = (new DateTimeFormatterBuilder()).appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).appendLiteral('_').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral('-').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral('-').appendValue(ChronoField.SECOND_OF_MINUTE, 2).toFormatter();
     private static final String TAG_DATA = "Data";
-    private static final PathMatcher NO_SYMLINKS_ALLOWED = path -> false;
+    private static final PathMatcher NO_SYMLINKS_ALLOWED = (path) -> {
+        return false;
+    };
     public static final String ALLOWED_SYMLINKS_CONFIG_NAME = "allowed_symlinks.txt";
     private static final int UNCOMPRESSED_NBT_QUOTA = 104857600;
-    private final Path baseDir;
+    public final Path baseDir;
     private final Path backupDir;
     final DataFixer fixerUpper;
     private final DirectoryValidator worldDirValidator;
@@ -107,8 +100,8 @@
 
         try {
             FileUtil.createDirectoriesSafe(baseDir);
-        } catch (IOException var6) {
-            throw new UncheckedIOException(var6);
+        } catch (IOException ioexception) {
+            throw new UncheckedIOException(ioexception);
         }
 
         this.baseDir = baseDir;
@@ -117,119 +110,173 @@
     }
 
     public static DirectoryValidator parseValidator(Path validator) {
-        if (Files.exists(validator)) {
+        if (Files.exists(validator, new LinkOption[0])) {
             try {
-                DirectoryValidator var2;
-                try (BufferedReader bufferedReader = Files.newBufferedReader(validator)) {
-                    var2 = new DirectoryValidator(PathAllowList.readPlain(bufferedReader));
+                BufferedReader bufferedreader = Files.newBufferedReader(validator);
+
+                DirectoryValidator directoryvalidator;
+
+                try {
+                    directoryvalidator = new DirectoryValidator(PathAllowList.readPlain(bufferedreader));
+                } catch (Throwable throwable) {
+                    if (bufferedreader != null) {
+                        try {
+                            bufferedreader.close();
+                        } catch (Throwable throwable1) {
+                            throwable.addSuppressed(throwable1);
+                        }
+                    }
+
+                    throw throwable;
                 }
 
-                return var2;
-            } catch (Exception var6) {
-                LOGGER.error("Failed to parse {}, disallowing all symbolic links", "allowed_symlinks.txt", var6);
+                if (bufferedreader != null) {
+                    bufferedreader.close();
+                }
+
+                return directoryvalidator;
+            } catch (Exception exception) {
+                LevelStorageSource.LOGGER.error("Failed to parse {}, disallowing all symbolic links", "allowed_symlinks.txt", exception);
             }
         }
 
-        return new DirectoryValidator(NO_SYMLINKS_ALLOWED);
+        return new DirectoryValidator(LevelStorageSource.NO_SYMLINKS_ALLOWED);
     }
 
     public static LevelStorageSource createDefault(Path savesDir) {
-        DirectoryValidator directoryValidator = parseValidator(savesDir.resolve("allowed_symlinks.txt"));
-        return new LevelStorageSource(savesDir, savesDir.resolve("../backups"), directoryValidator, DataFixers.getDataFixer());
+        DirectoryValidator directoryvalidator = parseValidator(savesDir.resolve("allowed_symlinks.txt"));
+
+        return new LevelStorageSource(savesDir, savesDir.resolve("../backups"), directoryvalidator, DataFixers.getDataFixer());
     }
 
     public static WorldDataConfiguration readDataConfig(Dynamic<?> dynamic) {
-        return WorldDataConfiguration.CODEC.parse(dynamic).resultOrPartial(LOGGER::error).orElse(WorldDataConfiguration.DEFAULT);
+        DataResult<WorldDataConfiguration> dataresult = WorldDataConfiguration.CODEC.parse(dynamic); // CraftBukkit - decompile error
+        Logger logger = LevelStorageSource.LOGGER;
+
+        Objects.requireNonNull(logger);
+        return (WorldDataConfiguration) dataresult.resultOrPartial(logger::error).orElse(WorldDataConfiguration.DEFAULT);
     }
 
-    public static WorldLoader.PackConfig getPackConfig(Dynamic<?> dynamic, PackRepository packRepository, boolean flag) {
-        return new WorldLoader.PackConfig(packRepository, readDataConfig(dynamic), flag, false);
+    public static WorldLoader.d getPackConfig(Dynamic<?> dynamic, PackRepository resourcepackrepository, boolean flag) {
+        return new WorldLoader.d(resourcepackrepository, readDataConfig(dynamic), flag, false);
     }
 
-    public static LevelDataAndDimensions getLevelDataAndDimensions(
-        Dynamic<?> dynamic, WorldDataConfiguration worldDataConfiguration, Registry<LevelStem> registry, RegistryAccess.Frozen frozen
-    ) {
-        Dynamic<?> dynamic1 = wrapWithRegistryOps(dynamic, frozen);
+    public static LevelDataAndDimensions getLevelDataAndDimensions(Dynamic<?> dynamic, WorldDataConfiguration worlddataconfiguration, Registry<LevelStem> iregistry, RegistryAccess.Dimension iregistrycustom_dimension) {
+        Dynamic<?> dynamic1 = wrapWithRegistryOps(dynamic, iregistrycustom_dimension);
         Dynamic<?> dynamic2 = dynamic1.get("WorldGenSettings").orElseEmptyMap();
-        WorldGenSettings worldGenSettings = WorldGenSettings.CODEC.parse(dynamic2).getOrThrow(false, Util.prefix("WorldGenSettings: ", LOGGER::error));
-        LevelSettings levelSettings = LevelSettings.parse(dynamic1, worldDataConfiguration);
-        WorldDimensions.Complete complete = worldGenSettings.dimensions().bake(registry);
-        Lifecycle lifecycle = complete.lifecycle().add(frozen.allRegistriesLifecycle());
-        PrimaryLevelData primaryLevelData = PrimaryLevelData.parse(
-            dynamic1, levelSettings, complete.specialWorldProperty(), worldGenSettings.options(), lifecycle
-        );
-        return new LevelDataAndDimensions(primaryLevelData, complete);
+        DataResult dataresult = WorldGenSettings.CODEC.parse(dynamic2);
+        Logger logger = LevelStorageSource.LOGGER;
+
+        Objects.requireNonNull(logger);
+        WorldGenSettings generatorsettings = (WorldGenSettings) dataresult.getOrThrow(false, Util.prefix("WorldGenSettings: ", logger::error));
+        LevelSettings worldsettings = LevelSettings.parse(dynamic1, worlddataconfiguration);
+        WorldDimensions.b worlddimensions_b = generatorsettings.dimensions().bake(iregistry);
+        Lifecycle lifecycle = worlddimensions_b.lifecycle().add(iregistrycustom_dimension.allRegistriesLifecycle());
+        PrimaryLevelData worlddataserver = PrimaryLevelData.parse(dynamic1, worldsettings, worlddimensions_b.specialWorldProperty(), generatorsettings.options(), lifecycle);
+        worlddataserver.pdc = ((Dynamic<Tag>) dynamic1).getElement("BukkitValues", null); // CraftBukkit - Add PDC to world
+
+        return new LevelDataAndDimensions(worlddataserver, worlddimensions_b);
     }
 
-    private static <T> Dynamic<T> wrapWithRegistryOps(Dynamic<T> dynamic, RegistryAccess.Frozen frozen) {
-        RegistryOps<T> registryOps = RegistryOps.create(dynamic.getOps(), frozen);
-        return new Dynamic<>(registryOps, dynamic.getValue());
+    private static <T> Dynamic<T> wrapWithRegistryOps(Dynamic<T> dynamic, RegistryAccess.Dimension iregistrycustom_dimension) {
+        RegistryOps<T> registryops = RegistryOps.create(dynamic.getOps(), (HolderLookup.Provider) iregistrycustom_dimension);
+
+        return new Dynamic(registryops, dynamic.getValue());
     }
 
     public String getName() {
         return "Anvil";
     }
 
-    public LevelStorageSource.LevelCandidates findLevelCandidates() throws LevelStorageException {
-        if (!Files.isDirectory(this.baseDir)) {
+    public LevelStorageSource.a findLevelCandidates() throws LevelStorageException {
+        if (!Files.isDirectory(this.baseDir, new LinkOption[0])) {
             throw new LevelStorageException(Component.translatable("selectWorld.load_folder_access"));
         } else {
             try {
-                LevelStorageSource.LevelCandidates var3;
-                try (Stream<Path> stream = Files.list(this.baseDir)) {
-                    List<LevelStorageSource.LevelDirectory> list = stream.filter(path -> Files.isDirectory(path))
-                        .map(LevelStorageSource.LevelDirectory::new)
-                        .filter(levelDirectory -> Files.isRegularFile(levelDirectory.dataFile()) || Files.isRegularFile(levelDirectory.oldDataFile()))
-                        .toList();
-                    var3 = new LevelStorageSource.LevelCandidates(list);
+                Stream<Path> stream = Files.list(this.baseDir); // CraftBukkit - decompile error
+
+                LevelStorageSource.a convertable_a;
+
+                try {
+                    List<LevelStorageSource.LevelDirectory> list = stream.filter((path) -> {
+                        return Files.isDirectory(path, new LinkOption[0]);
+                    }).map(LevelStorageSource.LevelDirectory::new).filter((convertable_b) -> {
+                        return Files.isRegularFile(convertable_b.dataFile(), new LinkOption[0]) || Files.isRegularFile(convertable_b.oldDataFile(), new LinkOption[0]);
+                    }).toList();
+
+                    convertable_a = new LevelStorageSource.a(list);
+                } catch (Throwable throwable) {
+                    if (stream != null) {
+                        try {
+                            stream.close();
+                        } catch (Throwable throwable1) {
+                            throwable.addSuppressed(throwable1);
+                        }
+                    }
+
+                    throw throwable;
                 }
 
-                return var3;
-            } catch (IOException var6) {
+                if (stream != null) {
+                    stream.close();
+                }
+
+                return convertable_a;
+            } catch (IOException ioexception) {
                 throw new LevelStorageException(Component.translatable("selectWorld.load_folder_access"));
             }
         }
     }
 
-    public CompletableFuture<List<LevelSummary>> loadLevelSummaries(LevelStorageSource.LevelCandidates candidates) {
-        List<CompletableFuture<LevelSummary>> list = new ArrayList<>(candidates.levels.size());
+    public CompletableFuture<List<LevelSummary>> loadLevelSummaries(LevelStorageSource.a candidates) {
+        List<CompletableFuture<LevelSummary>> list = new ArrayList(candidates.levels.size());
+        Iterator iterator = candidates.levels.iterator();
 
-        for (LevelStorageSource.LevelDirectory levelDirectory : candidates.levels) {
+        while (iterator.hasNext()) {
+            LevelStorageSource.LevelDirectory convertable_b = (LevelStorageSource.LevelDirectory) iterator.next();
+
             list.add(CompletableFuture.supplyAsync(() -> {
-                boolean isLocked;
+                boolean flag;
+
                 try {
-                    isLocked = DirectoryLock.isLocked(levelDirectory.path());
-                } catch (Exception var13) {
-                    LOGGER.warn("Failed to read {} lock", levelDirectory.path(), var13);
+                    flag = DirectoryLock.isLocked(convertable_b.path());
+                } catch (Exception exception) {
+                    LevelStorageSource.LOGGER.warn("Failed to read {} lock", convertable_b.path(), exception);
                     return null;
                 }
 
                 try {
-                    return this.readLevelSummary(levelDirectory, isLocked);
-                } catch (OutOfMemoryError var12) {
+                    return this.readLevelSummary(convertable_b, flag);
+                } catch (OutOfMemoryError outofmemoryerror) {
                     MemoryReserve.release();
                     System.gc();
-                    String string = "Ran out of memory trying to read summary of world folder \"" + levelDirectory.directoryName() + "\"";
-                    LOGGER.error(LogUtils.FATAL_MARKER, string);
-                    OutOfMemoryError outOfMemoryError1 = new OutOfMemoryError("Ran out of memory reading level data");
-                    outOfMemoryError1.initCause(var12);
-                    CrashReport crashReport = CrashReport.forThrowable(outOfMemoryError1, string);
-                    CrashReportCategory crashReportCategory = crashReport.addCategory("World details");
-                    crashReportCategory.setDetail("Folder Name", levelDirectory.directoryName());
+                    String s = "Ran out of memory trying to read summary of world folder \"" + convertable_b.directoryName() + "\"";
 
+                    LevelStorageSource.LOGGER.error(LogUtils.FATAL_MARKER, s);
+                    OutOfMemoryError outofmemoryerror1 = new OutOfMemoryError("Ran out of memory reading level data");
+
+                    outofmemoryerror1.initCause(outofmemoryerror);
+                    CrashReport crashreport = CrashReport.forThrowable(outofmemoryerror1, s);
+                    CrashReportCategory crashreportsystemdetails = crashreport.addCategory("World details");
+
+                    crashreportsystemdetails.setDetail("Folder Name", (Object) convertable_b.directoryName());
+
                     try {
-                        long size = Files.size(levelDirectory.dataFile());
-                        crashReportCategory.setDetail("level.dat size", size);
-                    } catch (IOException var11) {
-                        crashReportCategory.setDetailError("level.dat size", var11);
+                        long i = Files.size(convertable_b.dataFile());
+
+                        crashreportsystemdetails.setDetail("level.dat size", (Object) i);
+                    } catch (IOException ioexception) {
+                        crashreportsystemdetails.setDetailError("level.dat size", ioexception);
                     }
 
-                    throw new ReportedException(crashReport);
+                    throw new ReportedException(crashreport);
                 }
             }, Util.backgroundExecutor()));
         }
 
-        return Util.sequenceFailFastAndCancel(list).thenApply(list1 -> list1.stream().filter(Objects::nonNull).sorted().toList());
+        return Util.sequenceFailFastAndCancel(list).thenApply((list1) -> {
+            return list1.stream().filter(Objects::nonNull).sorted().toList();
+        });
     }
 
     private int getStorageVersion() {
@@ -240,114 +287,126 @@
         return NbtIo.readCompressed(path, NbtAccounter.create(104857600L));
     }
 
-    static Dynamic<?> readLevelDataTagFixed(Path path, DataFixer dataFixer) throws IOException {
-        CompoundTag levelDataTagRaw = readLevelDataTagRaw(path);
-        CompoundTag compound = levelDataTagRaw.getCompound("Data");
-        int dataVersion = NbtUtils.getDataVersion(compound, -1);
-        Dynamic<?> dynamic = DataFixTypes.LEVEL.updateToCurrentVersion(dataFixer, new Dynamic<>(NbtOps.INSTANCE, compound), dataVersion);
+    static Dynamic<?> readLevelDataTagFixed(Path path, DataFixer datafixer) throws IOException {
+        CompoundTag nbttagcompound = readLevelDataTagRaw(path);
+        CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
+        int i = NbtUtils.getDataVersion(nbttagcompound1, -1);
+        Dynamic<?> dynamic = DataFixTypes.LEVEL.updateToCurrentVersion(datafixer, new Dynamic(NbtOps.INSTANCE, nbttagcompound1), i);
         Dynamic<?> dynamic1 = dynamic.get("Player").orElseEmptyMap();
-        Dynamic<?> dynamic2 = DataFixTypes.PLAYER.updateToCurrentVersion(dataFixer, dynamic1, dataVersion);
+        Dynamic<?> dynamic2 = DataFixTypes.PLAYER.updateToCurrentVersion(datafixer, dynamic1, i);
+
         dynamic = dynamic.set("Player", dynamic2);
         Dynamic<?> dynamic3 = dynamic.get("WorldGenSettings").orElseEmptyMap();
-        Dynamic<?> dynamic4 = DataFixTypes.WORLD_GEN_SETTINGS.updateToCurrentVersion(dataFixer, dynamic3, dataVersion);
-        return dynamic.set("WorldGenSettings", dynamic4);
+        Dynamic<?> dynamic4 = DataFixTypes.WORLD_GEN_SETTINGS.updateToCurrentVersion(datafixer, dynamic3, i);
+
+        dynamic = dynamic.set("WorldGenSettings", dynamic4);
+        return dynamic;
     }
 
-    private LevelSummary readLevelSummary(LevelStorageSource.LevelDirectory levelDirectory, boolean flag) {
-        Path path = levelDirectory.dataFile();
-        if (Files.exists(path)) {
+    private LevelSummary readLevelSummary(LevelStorageSource.LevelDirectory convertable_b, boolean flag) {
+        Path path = convertable_b.dataFile();
+
+        if (Files.exists(path, new LinkOption[0])) {
             try {
                 if (Files.isSymbolicLink(path)) {
                     List<ForbiddenSymlinkInfo> list = this.worldDirValidator.validateSymlink(path);
+
                     if (!list.isEmpty()) {
-                        LOGGER.warn("{}", ContentValidationException.getMessage(path, list));
-                        return new LevelSummary.SymlinkLevelSummary(levelDirectory.directoryName(), levelDirectory.iconFile());
+                        LevelStorageSource.LOGGER.warn("{}", ContentValidationException.getMessage(path, list));
+                        return new LevelSummary.SymlinkLevelSummary(convertable_b.directoryName(), convertable_b.iconFile());
                     }
                 }
 
-                if (readLightweightData(path) instanceof CompoundTag compoundTag) {
-                    CompoundTag compound = compoundTag.getCompound("Data");
-                    int dataVersion = NbtUtils.getDataVersion(compound, -1);
-                    Dynamic<?> dynamic = DataFixTypes.LEVEL.updateToCurrentVersion(this.fixerUpper, new Dynamic<>(NbtOps.INSTANCE, compound), dataVersion);
-                    return this.makeLevelSummary(dynamic, levelDirectory, flag);
+                Tag nbtbase = readLightweightData(path);
+
+                if (nbtbase instanceof CompoundTag) {
+                    CompoundTag nbttagcompound = (CompoundTag) nbtbase;
+                    CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
+                    int i = NbtUtils.getDataVersion(nbttagcompound1, -1);
+                    Dynamic<?> dynamic = DataFixTypes.LEVEL.updateToCurrentVersion(this.fixerUpper, new Dynamic(NbtOps.INSTANCE, nbttagcompound1), i);
+
+                    return this.makeLevelSummary(dynamic, convertable_b, flag);
                 }
 
-                LOGGER.warn("Invalid root tag in {}", path);
-            } catch (Exception var9) {
-                LOGGER.error("Exception reading {}", path, var9);
+                LevelStorageSource.LOGGER.warn("Invalid root tag in {}", path);
+            } catch (Exception exception) {
+                LevelStorageSource.LOGGER.error("Exception reading {}", path, exception);
             }
         }
 
-        return new LevelSummary.CorruptedLevelSummary(levelDirectory.directoryName(), levelDirectory.iconFile(), getFileModificationTime(levelDirectory));
+        return new LevelSummary.b(convertable_b.directoryName(), convertable_b.iconFile(), getFileModificationTime(convertable_b));
     }
 
-    private static long getFileModificationTime(LevelStorageSource.LevelDirectory levelDirectory) {
-        Instant fileModificationTime = getFileModificationTime(levelDirectory.dataFile());
-        if (fileModificationTime == null) {
-            fileModificationTime = getFileModificationTime(levelDirectory.oldDataFile());
+    private static long getFileModificationTime(LevelStorageSource.LevelDirectory convertable_b) {
+        Instant instant = getFileModificationTime(convertable_b.dataFile());
+
+        if (instant == null) {
+            instant = getFileModificationTime(convertable_b.oldDataFile());
         }
 
-        return fileModificationTime == null ? -1L : fileModificationTime.toEpochMilli();
+        return instant == null ? -1L : instant.toEpochMilli();
     }
 
     @Nullable
     static Instant getFileModificationTime(Path path) {
         try {
             return Files.getLastModifiedTime(path).toInstant();
-        } catch (IOException var2) {
+        } catch (IOException ioexception) {
             return null;
         }
     }
 
-    LevelSummary makeLevelSummary(Dynamic<?> dynamic, LevelStorageSource.LevelDirectory levelDirectory, boolean flag) {
-        LevelVersion levelVersion = LevelVersion.parse(dynamic);
-        int i = levelVersion.levelDataVersion();
+    LevelSummary makeLevelSummary(Dynamic<?> dynamic, LevelStorageSource.LevelDirectory convertable_b, boolean flag) {
+        LevelVersion levelversion = LevelVersion.parse(dynamic);
+        int i = levelversion.levelDataVersion();
+
         if (i != 19132 && i != 19133) {
             throw new NbtFormatException("Unknown data version: " + Integer.toHexString(i));
         } else {
             boolean flag1 = i != this.getStorageVersion();
-            Path path = levelDirectory.iconFile();
-            WorldDataConfiguration dataConfig = readDataConfig(dynamic);
-            LevelSettings levelSettings = LevelSettings.parse(dynamic, dataConfig);
-            FeatureFlagSet featureFlagSet = parseFeatureFlagsFromSummary(dynamic);
-            boolean isExperimental = FeatureFlags.isExperimental(featureFlagSet);
-            return new LevelSummary(levelSettings, levelVersion, levelDirectory.directoryName(), flag1, flag, isExperimental, path);
+            Path path = convertable_b.iconFile();
+            WorldDataConfiguration worlddataconfiguration = readDataConfig(dynamic);
+            LevelSettings worldsettings = LevelSettings.parse(dynamic, worlddataconfiguration);
+            FeatureFlagSet featureflagset = parseFeatureFlagsFromSummary(dynamic);
+            boolean flag2 = FeatureFlags.isExperimental(featureflagset);
+
+            return new LevelSummary(worldsettings, levelversion, convertable_b.directoryName(), flag1, flag, flag2, path);
         }
     }
 
     private static FeatureFlagSet parseFeatureFlagsFromSummary(Dynamic<?> dataDynamic) {
-        Set<ResourceLocation> set = dataDynamic.get("enabled_features")
-            .asStream()
-            .flatMap(dynamic -> dynamic.asString().result().map(ResourceLocation::tryParse).stream())
-            .collect(Collectors.toSet());
-        return FeatureFlags.REGISTRY.fromNames(set, resourceLocation -> {
+        Set<ResourceLocation> set = (Set) dataDynamic.get("enabled_features").asStream().flatMap((dynamic1) -> {
+            return dynamic1.asString().result().map(ResourceLocation::tryParse).stream();
+        }).collect(Collectors.toSet());
+
+        return FeatureFlags.REGISTRY.fromNames(set, (minecraftkey) -> {
         });
     }
 
     @Nullable
     private static Tag readLightweightData(Path file) throws IOException {
-        SkipFields skipFields = new SkipFields(
-            new FieldSelector("Data", CompoundTag.TYPE, "Player"), new FieldSelector("Data", CompoundTag.TYPE, "WorldGenSettings")
-        );
-        NbtIo.parseCompressed(file, skipFields, NbtAccounter.create(104857600L));
-        return skipFields.getResult();
+        SkipFields skipfields = new SkipFields(new FieldSelector[]{new FieldSelector("Data", CompoundTag.TYPE, "Player"), new FieldSelector("Data", CompoundTag.TYPE, "WorldGenSettings")});
+
+        NbtIo.parseCompressed(file, skipfields, NbtAccounter.create(104857600L));
+        return skipfields.getResult();
     }
 
     public boolean isNewLevelIdAcceptable(String saveName) {
         try {
-            Path levelPath = this.getLevelPath(saveName);
-            Files.createDirectory(levelPath);
-            Files.deleteIfExists(levelPath);
+            Path path = this.getLevelPath(saveName);
+
+            Files.createDirectory(path);
+            Files.deleteIfExists(path);
             return true;
-        } catch (IOException var3) {
+        } catch (IOException ioexception) {
             return false;
         }
     }
 
     public boolean levelExists(String saveName) {
         try {
-            return Files.isDirectory(this.getLevelPath(saveName));
-        } catch (InvalidPathException var3) {
+            return Files.isDirectory(this.getLevelPath(saveName), new LinkOption[0]);
+        } catch (InvalidPathException invalidpathexception) {
             return false;
         }
     }
@@ -364,37 +423,54 @@
         return this.backupDir;
     }
 
-    public LevelStorageSource.LevelStorageAccess validateAndCreateAccess(String saveName) throws IOException, ContentValidationException {
-        Path levelPath = this.getLevelPath(saveName);
-        List<ForbiddenSymlinkInfo> list = this.worldDirValidator.validateDirectory(levelPath, true);
+    public LevelStorageSource.LevelStorageAccess validateAndCreateAccess(String s, ResourceKey<LevelStem> dimensionType) throws IOException, ContentValidationException { // CraftBukkit
+        Path path = this.getLevelPath(s);
+        List<ForbiddenSymlinkInfo> list = this.worldDirValidator.validateDirectory(path, true);
+
         if (!list.isEmpty()) {
-            throw new ContentValidationException(levelPath, list);
+            throw new ContentValidationException(path, list);
         } else {
-            return new LevelStorageSource.LevelStorageAccess(saveName, levelPath);
+            return new LevelStorageSource.LevelStorageAccess(s, path, dimensionType); // CraftBukkit
         }
     }
 
-    public LevelStorageSource.LevelStorageAccess createAccess(String saveName) throws IOException {
-        Path levelPath = this.getLevelPath(saveName);
-        return new LevelStorageSource.LevelStorageAccess(saveName, levelPath);
+    public LevelStorageSource.LevelStorageAccess createAccess(String s, ResourceKey<LevelStem> dimensionType) throws IOException { // CraftBukkit
+        Path path = this.getLevelPath(s);
+
+        return new LevelStorageSource.LevelStorageAccess(s, path, dimensionType); // CraftBukkit
     }
 
     public DirectoryValidator getWorldDirValidator() {
         return this.worldDirValidator;
     }
 
-    public static record LevelCandidates(List<LevelStorageSource.LevelDirectory> levels) implements Iterable<LevelStorageSource.LevelDirectory> {
+    // CraftBukkit start
+    public static Path getStorageFolder(Path path, ResourceKey<LevelStem> dimensionType) {
+        if (dimensionType == LevelStem.OVERWORLD) {
+            return path;
+        } else if (dimensionType == LevelStem.NETHER) {
+            return path.resolve("DIM-1");
+        } else if (dimensionType == LevelStem.END) {
+            return path.resolve("DIM1");
+        } else {
+            return path.resolve("dimensions").resolve(dimensionType.location().getNamespace()).resolve(dimensionType.location().getPath());
+        }
+    }
+    // CraftBukkit end
+
+    public static record a(List<LevelStorageSource.LevelDirectory> levels) implements Iterable<LevelStorageSource.LevelDirectory> {
+
         public boolean isEmpty() {
             return this.levels.isEmpty();
         }
 
-        @Override
         public Iterator<LevelStorageSource.LevelDirectory> iterator() {
             return this.levels.iterator();
         }
     }
 
     public static record LevelDirectory(Path path) {
+
         public String directoryName() {
             return this.path.getFileName().toString();
         }
@@ -408,11 +484,17 @@
         }
 
         public Path corruptedDataFile(LocalDateTime dateTime) {
-            return this.path.resolve(LevelResource.LEVEL_DATA_FILE.getId() + "_corrupted_" + dateTime.format(LevelStorageSource.FORMATTER));
+            Path path = this.path;
+            String s = LevelResource.LEVEL_DATA_FILE.getId();
+
+            return path.resolve(s + "_corrupted_" + dateTime.format(LevelStorageSource.FORMATTER));
         }
 
-        public Path rawDataFile(LocalDateTime localDateTime) {
-            return this.path.resolve(LevelResource.LEVEL_DATA_FILE.getId() + "_raw_" + localDateTime.format(LevelStorageSource.FORMATTER));
+        public Path rawDataFile(LocalDateTime localdatetime) {
+            Path path = this.path;
+            String s = LevelResource.LEVEL_DATA_FILE.getId();
+
+            return path.resolve(s + "_raw_" + localdatetime.format(LevelStorageSource.FORMATTER));
         }
 
         public Path iconFile() {
@@ -429,23 +511,29 @@
     }
 
     public class LevelStorageAccess implements AutoCloseable {
+
         final DirectoryLock lock;
-        final LevelStorageSource.LevelDirectory levelDirectory;
+        public final LevelStorageSource.LevelDirectory levelDirectory;
         private final String levelId;
         private final Map<LevelResource, Path> resources = Maps.newHashMap();
+        // CraftBukkit start
+        public final ResourceKey<LevelStem> dimensionType;
 
-        LevelStorageAccess(String levelId, Path levelDir) throws IOException {
-            this.levelId = levelId;
-            this.levelDirectory = new LevelStorageSource.LevelDirectory(levelDir);
-            this.lock = DirectoryLock.create(levelDir);
+        LevelStorageAccess(String s, Path path, ResourceKey<LevelStem> dimensionType) throws IOException {
+            this.dimensionType = dimensionType;
+            // CraftBukkit end
+            this.levelId = s;
+            this.levelDirectory = new LevelStorageSource.LevelDirectory(path);
+            this.lock = DirectoryLock.create(path);
         }
 
         public void safeClose() {
             try {
                 this.close();
-            } catch (IOException var2) {
-                LevelStorageSource.LOGGER.warn("Failed to unlock access to level {}", this.getLevelId(), var2);
+            } catch (IOException ioexception) {
+                LevelStorageSource.LOGGER.warn("Failed to unlock access to level {}", this.getLevelId(), ioexception);
             }
+
         }
 
         public LevelStorageSource parent() {
@@ -461,11 +549,15 @@
         }
 
         public Path getLevelPath(LevelResource folderName) {
-            return this.resources.computeIfAbsent(folderName, this.levelDirectory::resourcePath);
+            Map<LevelResource, Path> map = this.resources; // CraftBukkit - decompile error
+            LevelStorageSource.LevelDirectory convertable_b = this.levelDirectory;
+
+            Objects.requireNonNull(this.levelDirectory);
+            return (Path) map.computeIfAbsent(folderName, convertable_b::resourcePath);
         }
 
         public Path getDimensionPath(ResourceKey<Level> dimensionPath) {
-            return DimensionType.getStorageFolder(dimensionPath, this.levelDirectory.path());
+            return getStorageFolder(this.levelDirectory.path(), this.dimensionType); // CraftBukkit
         }
 
         private void checkLock() {
@@ -494,34 +586,36 @@
 
         private Dynamic<?> getDataTag(boolean flag) throws IOException {
             this.checkLock();
-            return LevelStorageSource.readLevelDataTagFixed(
-                flag ? this.levelDirectory.oldDataFile() : this.levelDirectory.dataFile(), LevelStorageSource.this.fixerUpper
-            );
+            return LevelStorageSource.readLevelDataTagFixed(flag ? this.levelDirectory.oldDataFile() : this.levelDirectory.dataFile(), LevelStorageSource.this.fixerUpper);
         }
 
         public void saveDataTag(RegistryAccess registries, WorldData serverConfiguration) {
-            this.saveDataTag(registries, serverConfiguration, null);
+            this.saveDataTag(registries, serverConfiguration, (CompoundTag) null);
         }
 
         public void saveDataTag(RegistryAccess registries, WorldData serverConfiguration, @Nullable CompoundTag hostPlayerNBT) {
-            CompoundTag compoundTag = serverConfiguration.createTag(registries, hostPlayerNBT);
-            CompoundTag compoundTag1 = new CompoundTag();
-            compoundTag1.put("Data", compoundTag);
-            this.saveLevelData(compoundTag1);
+            CompoundTag nbttagcompound1 = serverConfiguration.createTag(registries, hostPlayerNBT);
+            CompoundTag nbttagcompound2 = new CompoundTag();
+
+            nbttagcompound2.put("Data", nbttagcompound1);
+            this.saveLevelData(nbttagcompound2);
         }
 
-        private void saveLevelData(CompoundTag compoundTag) {
+        private void saveLevelData(CompoundTag nbttagcompound) {
             Path path = this.levelDirectory.path();
 
             try {
                 Path path1 = Files.createTempFile(path, "level", ".dat");
-                NbtIo.writeCompressed(compoundTag, path1);
+
+                NbtIo.writeCompressed(nbttagcompound, path1);
                 Path path2 = this.levelDirectory.oldDataFile();
                 Path path3 = this.levelDirectory.dataFile();
+
                 Util.safeReplaceFile(path3, path1, path2);
-            } catch (Exception var6) {
-                LevelStorageSource.LOGGER.error("Failed to save level {}", path, var6);
+            } catch (Exception exception) {
+                LevelStorageSource.LOGGER.error("Failed to save level {}", path, exception);
             }
+
         }
 
         public Optional<Path> getIconFile() {
@@ -531,120 +625,136 @@
         public void deleteLevel() throws IOException {
             this.checkLock();
             final Path path = this.levelDirectory.lockFile();
+
             LevelStorageSource.LOGGER.info("Deleting level {}", this.levelId);
+            int i = 1;
 
-            for (int i = 1; i <= 5; i++) {
+            while (i <= 5) {
                 LevelStorageSource.LOGGER.info("Attempt {}...", i);
 
                 try {
                     Files.walkFileTree(this.levelDirectory.path(), new SimpleFileVisitor<Path>() {
-                        @Override
-                        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
-                            if (!file.equals(path)) {
-                                LevelStorageSource.LOGGER.debug("Deleting {}", file);
-                                Files.delete(file);
+                        public FileVisitResult visitFile(Path path1, BasicFileAttributes basicfileattributes) throws IOException {
+                            if (!path1.equals(path)) {
+                                LevelStorageSource.LOGGER.debug("Deleting {}", path1);
+                                Files.delete(path1);
                             }
 
                             return FileVisitResult.CONTINUE;
                         }
 
-                        @Override
-                        public FileVisitResult postVisitDirectory(Path dir, @Nullable IOException exception) throws IOException {
-                            if (exception != null) {
-                                throw exception;
+                        public FileVisitResult postVisitDirectory(Path path1, @Nullable IOException ioexception) throws IOException {
+                            if (ioexception != null) {
+                                throw ioexception;
                             } else {
-                                if (dir.equals(LevelStorageAccess.this.levelDirectory.path())) {
+                                if (path1.equals(LevelStorageAccess.this.levelDirectory.path())) {
                                     LevelStorageAccess.this.lock.close();
                                     Files.deleteIfExists(path);
                                 }
 
-                                Files.delete(dir);
+                                Files.delete(path1);
                                 return FileVisitResult.CONTINUE;
                             }
                         }
                     });
                     break;
-                } catch (IOException var6) {
+                } catch (IOException ioexception) {
                     if (i >= 5) {
-                        throw var6;
+                        throw ioexception;
                     }
 
-                    LevelStorageSource.LOGGER.warn("Failed to delete {}", this.levelDirectory.path(), var6);
+                    LevelStorageSource.LOGGER.warn("Failed to delete {}", this.levelDirectory.path(), ioexception);
 
                     try {
                         Thread.sleep(500L);
-                    } catch (InterruptedException var5) {
+                    } catch (InterruptedException interruptedexception) {
+                        ;
                     }
+
+                    ++i;
                 }
             }
+
         }
 
         public void renameLevel(String saveName) throws IOException {
-            this.modifyLevelDataWithoutDatafix(compoundTag -> compoundTag.putString("LevelName", saveName.trim()));
+            this.modifyLevelDataWithoutDatafix((nbttagcompound) -> {
+                nbttagcompound.putString("LevelName", saveName.trim());
+            });
         }
 
-        public void renameAndDropPlayer(String string) throws IOException {
-            this.modifyLevelDataWithoutDatafix(compoundTag -> {
-                compoundTag.putString("LevelName", string.trim());
-                compoundTag.remove("Player");
+        public void renameAndDropPlayer(String s) throws IOException {
+            this.modifyLevelDataWithoutDatafix((nbttagcompound) -> {
+                nbttagcompound.putString("LevelName", s.trim());
+                nbttagcompound.remove("Player");
             });
         }
 
         private void modifyLevelDataWithoutDatafix(Consumer<CompoundTag> consumer) throws IOException {
             this.checkLock();
-            CompoundTag levelDataTagRaw = LevelStorageSource.readLevelDataTagRaw(this.levelDirectory.dataFile());
-            consumer.accept(levelDataTagRaw.getCompound("Data"));
-            this.saveLevelData(levelDataTagRaw);
+            CompoundTag nbttagcompound = LevelStorageSource.readLevelDataTagRaw(this.levelDirectory.dataFile());
+
+            consumer.accept(nbttagcompound.getCompound("Data"));
+            this.saveLevelData(nbttagcompound);
         }
 
         public long makeWorldBackup() throws IOException {
             this.checkLock();
-            String string = LocalDateTime.now().format(LevelStorageSource.FORMATTER) + "_" + this.levelId;
-            Path backupPath = LevelStorageSource.this.getBackupPath();
+            String s = LocalDateTime.now().format(LevelStorageSource.FORMATTER);
+            String s1 = s + "_" + this.levelId;
+            Path path = LevelStorageSource.this.getBackupPath();
 
             try {
-                FileUtil.createDirectoriesSafe(backupPath);
-            } catch (IOException var9) {
-                throw new RuntimeException(var9);
+                FileUtil.createDirectoriesSafe(path);
+            } catch (IOException ioexception) {
+                throw new RuntimeException(ioexception);
             }
 
-            Path path = backupPath.resolve(FileUtil.findAvailableName(backupPath, string, ".zip"));
+            Path path1 = path.resolve(FileUtil.findAvailableName(path, s1, ".zip"));
+            final ZipOutputStream zipoutputstream = new ZipOutputStream(new BufferedOutputStream(Files.newOutputStream(path1)));
 
-            try (final ZipOutputStream zipOutputStream = new ZipOutputStream(new BufferedOutputStream(Files.newOutputStream(path)))) {
-                final Path path1 = Paths.get(this.levelId);
+            try {
+                final Path path2 = Paths.get(this.levelId);
+
                 Files.walkFileTree(this.levelDirectory.path(), new SimpleFileVisitor<Path>() {
-                    @Override
-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
-                        if (file.endsWith("session.lock")) {
+                    public FileVisitResult visitFile(Path path3, BasicFileAttributes basicfileattributes) throws IOException {
+                        if (path3.endsWith("session.lock")) {
                             return FileVisitResult.CONTINUE;
                         } else {
-                            String string1 = path1.resolve(LevelStorageAccess.this.levelDirectory.path().relativize(file)).toString().replace('\\', '/');
-                            ZipEntry zipEntry = new ZipEntry(string1);
-                            zipOutputStream.putNextEntry(zipEntry);
-                            com.google.common.io.Files.asByteSource(file.toFile()).copyTo(zipOutputStream);
-                            zipOutputStream.closeEntry();
+                            String s2 = path2.resolve(LevelStorageAccess.this.levelDirectory.path().relativize(path3)).toString().replace('\\', '/');
+                            ZipEntry zipentry = new ZipEntry(s2);
+
+                            zipoutputstream.putNextEntry(zipentry);
+                            com.google.common.io.Files.asByteSource(path3.toFile()).copyTo(zipoutputstream);
+                            zipoutputstream.closeEntry();
                             return FileVisitResult.CONTINUE;
                         }
                     }
                 });
+            } catch (Throwable throwable) {
+                try {
+                    zipoutputstream.close();
+                } catch (Throwable throwable1) {
+                    throwable.addSuppressed(throwable1);
+                }
+
+                throw throwable;
             }
 
-            return Files.size(path);
+            zipoutputstream.close();
+            return Files.size(path1);
         }
 
         public boolean hasWorldData() {
-            return Files.exists(this.levelDirectory.dataFile()) || Files.exists(this.levelDirectory.oldDataFile());
+            return Files.exists(this.levelDirectory.dataFile(), new LinkOption[0]) || Files.exists(this.levelDirectory.oldDataFile(), new LinkOption[0]);
         }
 
-        @Override
         public void close() throws IOException {
             this.lock.close();
         }
 
         public boolean restoreLevelDataFromOld() {
-            return Util.safeReplaceOrMoveFile(
-                this.levelDirectory.dataFile(), this.levelDirectory.oldDataFile(), this.levelDirectory.corruptedDataFile(LocalDateTime.now()), true
-            );
+            return Util.safeReplaceOrMoveFile(this.levelDirectory.dataFile(), this.levelDirectory.oldDataFile(), this.levelDirectory.corruptedDataFile(LocalDateTime.now()), true);
         }
 
         @Nullable
