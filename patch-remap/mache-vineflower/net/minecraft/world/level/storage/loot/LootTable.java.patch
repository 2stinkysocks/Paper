--- a/net/minecraft/world/level/storage/loot/LootTable.java
+++ b/net/minecraft/world/level/storage/loot/LootTable.java
@@ -1,14 +1,16 @@
 package net.minecraft.world.level.storage.loot;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectListIterator;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
@@ -27,27 +29,38 @@
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
 import org.slf4j.Logger;
 
+// CraftBukkit start
+import org.bukkit.craftbukkit.CraftLootTable;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.world.LootGenerateEvent;
+// CraftBukkit end
+
 public class LootTable {
+
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final LootTable EMPTY = new LootTable(LootContextParamSets.EMPTY, Optional.empty(), List.of(), List.of());
     public static final LootContextParamSet DEFAULT_PARAM_SET = LootContextParamSets.ALL_PARAMS;
-    public static final Codec<LootTable> CODEC = RecordCodecBuilder.create(
-        instance -> instance.group(
-                    LootContextParamSets.CODEC.optionalFieldOf("type", DEFAULT_PARAM_SET).forGetter(lootTable -> lootTable.paramSet),
-                    ExtraCodecs.strictOptionalField(ResourceLocation.CODEC, "random_sequence").forGetter(lootTable -> lootTable.randomSequence),
-                    ExtraCodecs.strictOptionalField(LootPool.CODEC.listOf(), "pools", List.of()).forGetter(lootTable -> lootTable.pools),
-                    ExtraCodecs.strictOptionalField(LootItemFunctions.CODEC.listOf(), "functions", List.of()).forGetter(lootTable -> lootTable.functions)
-                )
-                .apply(instance, LootTable::new)
-    );
+    public static final Codec<LootTable> CODEC = RecordCodecBuilder.create((instance) -> {
+        return instance.group(LootContextParamSets.CODEC.optionalFieldOf("type", LootTable.DEFAULT_PARAM_SET).forGetter((loottable) -> {
+            return loottable.paramSet;
+        }), ExtraCodecs.strictOptionalField(ResourceLocation.CODEC, "random_sequence").forGetter((loottable) -> {
+            return loottable.randomSequence;
+        }), ExtraCodecs.strictOptionalField(LootPool.CODEC.listOf(), "pools", List.of()).forGetter((loottable) -> {
+            return loottable.pools;
+        }), ExtraCodecs.strictOptionalField(LootItemFunctions.CODEC.listOf(), "functions", List.of()).forGetter((loottable) -> {
+            return loottable.functions;
+        })).apply(instance, LootTable::new);
+    });
     private final LootContextParamSet paramSet;
     private final Optional<ResourceLocation> randomSequence;
     private final List<LootPool> pools;
     private final List<LootItemFunction> functions;
     private final BiFunction<ItemStack, LootContext, ItemStack> compositeFunction;
+    public CraftLootTable craftLootTable; // CraftBukkit
 
-    LootTable(LootContextParamSet lootContextParamSet, Optional<ResourceLocation> optional, List<LootPool> list, List<LootItemFunction> list1) {
-        this.paramSet = lootContextParamSet;
+    LootTable(LootContextParamSet lootcontextparameterset, Optional<ResourceLocation> optional, List<LootPool> list, List<LootItemFunction> list1) {
+        this.paramSet = lootcontextparameterset;
         this.randomSequence = optional;
         this.pools = list;
         this.functions = list1;
@@ -55,46 +68,51 @@
     }
 
     public static Consumer<ItemStack> createStackSplitter(ServerLevel level, Consumer<ItemStack> output) {
-        return itemStack -> {
-            if (itemStack.isItemEnabled(level.enabledFeatures())) {
-                if (itemStack.getCount() < itemStack.getMaxStackSize()) {
-                    output.accept(itemStack);
+        return (itemstack) -> {
+            if (itemstack.isItemEnabled(level.enabledFeatures())) {
+                if (itemstack.getCount() < itemstack.getMaxStackSize()) {
+                    output.accept(itemstack);
                 } else {
-                    int count = itemStack.getCount();
+                    int i = itemstack.getCount();
 
-                    while (count > 0) {
-                        ItemStack itemStack1 = itemStack.copyWithCount(Math.min(itemStack.getMaxStackSize(), count));
-                        count -= itemStack1.getCount();
-                        output.accept(itemStack1);
+                    while (i > 0) {
+                        ItemStack itemstack1 = itemstack.copyWithCount(Math.min(itemstack.getMaxStackSize(), i));
+
+                        i -= itemstack1.getCount();
+                        output.accept(itemstack1);
                     }
                 }
+
             }
         };
     }
 
     public void getRandomItemsRaw(LootParams params, Consumer<ItemStack> output) {
-        this.getRandomItemsRaw(new LootContext.Builder(params).create(this.randomSequence), output);
+        this.getRandomItemsRaw((new LootContext.Builder(params)).create(this.randomSequence), output);
     }
 
     public void getRandomItemsRaw(LootContext context, Consumer<ItemStack> output) {
-        LootContext.VisitedEntry<?> visitedEntry = LootContext.createVisitedEntry(this);
-        if (context.pushVisitedElement(visitedEntry)) {
-            Consumer<ItemStack> consumer = LootItemFunction.decorate(this.compositeFunction, output, context);
+        LootContext.c<?> loottableinfo_c = LootContext.createVisitedEntry(this);
 
-            for (LootPool lootPool : this.pools) {
-                lootPool.addRandomItems(consumer, context);
+        if (context.pushVisitedElement(loottableinfo_c)) {
+            Consumer<ItemStack> consumer1 = LootItemFunction.decorate(this.compositeFunction, output, context);
+            Iterator iterator = this.pools.iterator();
+
+            while (iterator.hasNext()) {
+                LootPool lootselector = (LootPool) iterator.next();
+
+                lootselector.addRandomItems(consumer1, context);
             }
 
-            context.popVisitedElement(visitedEntry);
+            context.popVisitedElement(loottableinfo_c);
         } else {
-            LOGGER.warn("Detected infinite loop in loot tables");
+            LootTable.LOGGER.warn("Detected infinite loop in loot tables");
         }
+
     }
 
-    public void getRandomItems(LootParams params, long seed, Consumer<ItemStack> output) {
-        this.getRandomItemsRaw(
-            new LootContext.Builder(params).withOptionalRandomSeed(seed).create(this.randomSequence), createStackSplitter(params.getLevel(), output)
-        );
+    public void getRandomItems(LootParams params, long seed, Consumer<ItemStack> consumer) {
+        this.getRandomItemsRaw((new LootContext.Builder(params)).withOptionalRandomSeed(seed).create(this.randomSequence), createStackSplitter(params.getLevel(), consumer));
     }
 
     public void getRandomItems(LootParams params, Consumer<ItemStack> output) {
@@ -106,17 +124,19 @@
     }
 
     public ObjectArrayList<ItemStack> getRandomItems(LootParams params, long seed) {
-        return this.getRandomItems(new LootContext.Builder(params).withOptionalRandomSeed(seed).create(this.randomSequence));
+        return this.getRandomItems((new LootContext.Builder(params)).withOptionalRandomSeed(seed).create(this.randomSequence));
     }
 
     public ObjectArrayList<ItemStack> getRandomItems(LootParams params) {
-        return this.getRandomItems(new LootContext.Builder(params).create(this.randomSequence));
+        return this.getRandomItems((new LootContext.Builder(params)).create(this.randomSequence));
     }
 
     private ObjectArrayList<ItemStack> getRandomItems(LootContext context) {
-        ObjectArrayList<ItemStack> list = new ObjectArrayList<>();
-        this.getRandomItems(context, list::add);
-        return list;
+        ObjectArrayList<ItemStack> objectarraylist = new ObjectArrayList();
+
+        Objects.requireNonNull(objectarraylist);
+        this.getRandomItems(context, objectarraylist::add);
+        return objectarraylist;
     }
 
     public LootContextParamSet getParamSet() {
@@ -124,64 +144,87 @@
     }
 
     public void validate(ValidationContext validator) {
-        for (int i = 0; i < this.pools.size(); i++) {
-            this.pools.get(i).validate(validator.forChild(".pools[" + i + "]"));
+        int i;
+
+        for (i = 0; i < this.pools.size(); ++i) {
+            ((LootPool) this.pools.get(i)).validate(validator.forChild(".pools[" + i + "]"));
         }
 
-        for (int i = 0; i < this.functions.size(); i++) {
-            this.functions.get(i).validate(validator.forChild(".functions[" + i + "]"));
+        for (i = 0; i < this.functions.size(); ++i) {
+            ((LootItemFunction) this.functions.get(i)).validate(validator.forChild(".functions[" + i + "]"));
         }
+
     }
 
     public void fill(Container container, LootParams params, long seed) {
-        LootContext lootContext = new LootContext.Builder(params).withOptionalRandomSeed(seed).create(this.randomSequence);
-        ObjectArrayList<ItemStack> randomItems = this.getRandomItems(lootContext);
-        RandomSource random = lootContext.getRandom();
-        List<Integer> availableSlots = this.getAvailableSlots(container, random);
-        this.shuffleAndSplitItems(randomItems, availableSlots.size(), random);
+        // CraftBukkit start
+        this.fillInventory(container, params, seed, false);
+    }
 
-        for (ItemStack itemStack : randomItems) {
-            if (availableSlots.isEmpty()) {
-                LOGGER.warn("Tried to over-fill a container");
+    public void fillInventory(Container iinventory, LootParams lootparams, long i, boolean plugin) {
+        // CraftBukkit end
+        LootContext loottableinfo = (new LootContext.Builder(lootparams)).withOptionalRandomSeed(i).create(this.randomSequence);
+        ObjectArrayList<ItemStack> objectarraylist = this.getRandomItems(loottableinfo);
+        RandomSource randomsource = loottableinfo.getRandom();
+        // CraftBukkit start
+        LootGenerateEvent event = CraftEventFactory.callLootGenerateEvent(iinventory, this, loottableinfo, objectarraylist, plugin);
+        if (event.isCancelled()) {
+            return;
+        }
+        objectarraylist = event.getLoot().stream().map(CraftItemStack::asNMSCopy).collect(ObjectArrayList.toList());
+        // CraftBukkit end
+        List<Integer> list = this.getAvailableSlots(iinventory, randomsource);
+
+        this.shuffleAndSplitItems(objectarraylist, list.size(), randomsource);
+        ObjectListIterator objectlistiterator = objectarraylist.iterator();
+
+        while (objectlistiterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) objectlistiterator.next();
+
+            if (list.isEmpty()) {
+                LootTable.LOGGER.warn("Tried to over-fill a container");
                 return;
             }
 
-            if (itemStack.isEmpty()) {
-                container.setItem(availableSlots.remove(availableSlots.size() - 1), ItemStack.EMPTY);
+            if (itemstack.isEmpty()) {
+                iinventory.setItem((Integer) list.remove(list.size() - 1), ItemStack.EMPTY);
             } else {
-                container.setItem(availableSlots.remove(availableSlots.size() - 1), itemStack);
+                iinventory.setItem((Integer) list.remove(list.size() - 1), itemstack);
             }
         }
+
     }
 
     private void shuffleAndSplitItems(ObjectArrayList<ItemStack> stacks, int emptySlotsCount, RandomSource random) {
         List<ItemStack> list = Lists.newArrayList();
-        Iterator<ItemStack> iterator = stacks.iterator();
+        ObjectListIterator objectlistiterator = stacks.iterator();
 
-        while (iterator.hasNext()) {
-            ItemStack itemStack = iterator.next();
-            if (itemStack.isEmpty()) {
-                iterator.remove();
-            } else if (itemStack.getCount() > 1) {
-                list.add(itemStack);
-                iterator.remove();
+        while (objectlistiterator.hasNext()) {
+            ItemStack itemstack = (ItemStack) objectlistiterator.next();
+
+            if (itemstack.isEmpty()) {
+                objectlistiterator.remove();
+            } else if (itemstack.getCount() > 1) {
+                list.add(itemstack);
+                objectlistiterator.remove();
             }
         }
 
         while (emptySlotsCount - stacks.size() - list.size() > 0 && !list.isEmpty()) {
-            ItemStack itemStack1 = list.remove(Mth.nextInt(random, 0, list.size() - 1));
-            int randomInt = Mth.nextInt(random, 1, itemStack1.getCount() / 2);
-            ItemStack itemStack2 = itemStack1.split(randomInt);
-            if (itemStack1.getCount() > 1 && random.nextBoolean()) {
-                list.add(itemStack1);
+            ItemStack itemstack1 = (ItemStack) list.remove(Mth.nextInt(random, 0, list.size() - 1));
+            int j = Mth.nextInt(random, 1, itemstack1.getCount() / 2);
+            ItemStack itemstack2 = itemstack1.split(j);
+
+            if (itemstack1.getCount() > 1 && random.nextBoolean()) {
+                list.add(itemstack1);
             } else {
-                stacks.add(itemStack1);
+                stacks.add(itemstack1);
             }
 
-            if (itemStack2.getCount() > 1 && random.nextBoolean()) {
-                list.add(itemStack2);
+            if (itemstack2.getCount() > 1 && random.nextBoolean()) {
+                list.add(itemstack2);
             } else {
-                stacks.add(itemStack2);
+                stacks.add(itemstack2);
             }
         }
 
@@ -190,16 +233,16 @@
     }
 
     private List<Integer> getAvailableSlots(Container inventory, RandomSource random) {
-        ObjectArrayList<Integer> list = new ObjectArrayList<>();
+        ObjectArrayList<Integer> objectarraylist = new ObjectArrayList();
 
-        for (int i = 0; i < inventory.getContainerSize(); i++) {
+        for (int i = 0; i < inventory.getContainerSize(); ++i) {
             if (inventory.getItem(i).isEmpty()) {
-                list.add(i);
+                objectarraylist.add(i);
             }
         }
 
-        Util.shuffle(list, random);
-        return list;
+        Util.shuffle(objectarraylist, random);
+        return objectarraylist;
     }
 
     public static LootTable.Builder lootTable() {
@@ -207,11 +250,17 @@
     }
 
     public static class Builder implements FunctionUserBuilder<LootTable.Builder> {
-        private final ImmutableList.Builder<LootPool> pools = ImmutableList.builder();
-        private final ImmutableList.Builder<LootItemFunction> functions = ImmutableList.builder();
-        private LootContextParamSet paramSet = LootTable.DEFAULT_PARAM_SET;
-        private Optional<ResourceLocation> randomSequence = Optional.empty();
 
+        private final Builder<LootPool> pools = ImmutableList.builder();
+        private final Builder<LootItemFunction> functions = ImmutableList.builder();
+        private LootContextParamSet paramSet;
+        private Optional<ResourceLocation> randomSequence;
+
+        public Builder() {
+            this.paramSet = LootTable.DEFAULT_PARAM_SET;
+            this.randomSequence = Optional.empty();
+        }
+
         public LootTable.Builder withPool(LootPool.Builder lootPool) {
             this.pools.add(lootPool.build());
             return this;
@@ -228,7 +277,7 @@
         }
 
         @Override
-        public LootTable.Builder apply(LootItemFunction.Builder functionBuilder) {
+        public LootTable.Builder apply(LootItemFunction.a functionBuilder) {
             this.functions.add(functionBuilder.build());
             return this;
         }
