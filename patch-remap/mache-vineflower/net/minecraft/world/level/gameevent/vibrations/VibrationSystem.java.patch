--- a/net/minecraft/world/level/gameevent/vibrations/VibrationSystem.java
+++ b/net/minecraft/world/level/gameevent/vibrations/VibrationSystem.java
@@ -2,7 +2,6 @@
 
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.util.Optional;
 import java.util.function.ToIntFunction;
@@ -23,77 +22,67 @@
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.ClipBlockStateContext;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventListener;
 import net.minecraft.world.level.gameevent.PositionSource;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+// CraftBukkit start
+import org.bukkit.craftbukkit.CraftGameEvent;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.event.block.BlockReceiveGameEvent;
+// CraftBukkit end
 
 public interface VibrationSystem {
-    GameEvent[] RESONANCE_EVENTS = new GameEvent[]{
-        GameEvent.RESONATE_1,
-        GameEvent.RESONATE_2,
-        GameEvent.RESONATE_3,
-        GameEvent.RESONATE_4,
-        GameEvent.RESONATE_5,
-        GameEvent.RESONATE_6,
-        GameEvent.RESONATE_7,
-        GameEvent.RESONATE_8,
-        GameEvent.RESONATE_9,
-        GameEvent.RESONATE_10,
-        GameEvent.RESONATE_11,
-        GameEvent.RESONATE_12,
-        GameEvent.RESONATE_13,
-        GameEvent.RESONATE_14,
-        GameEvent.RESONATE_15
-    };
-    ToIntFunction<GameEvent> VIBRATION_FREQUENCY_FOR_EVENT = Util.make(new Object2IntOpenHashMap<>(), map -> {
-        map.defaultReturnValue(0);
-        map.put(GameEvent.STEP, 1);
-        map.put(GameEvent.SWIM, 1);
-        map.put(GameEvent.FLAP, 1);
-        map.put(GameEvent.PROJECTILE_LAND, 2);
-        map.put(GameEvent.HIT_GROUND, 2);
-        map.put(GameEvent.SPLASH, 2);
-        map.put(GameEvent.ITEM_INTERACT_FINISH, 3);
-        map.put(GameEvent.PROJECTILE_SHOOT, 3);
-        map.put(GameEvent.INSTRUMENT_PLAY, 3);
-        map.put(GameEvent.ENTITY_ACTION, 4);
-        map.put(GameEvent.ELYTRA_GLIDE, 4);
-        map.put(GameEvent.UNEQUIP, 4);
-        map.put(GameEvent.ENTITY_DISMOUNT, 5);
-        map.put(GameEvent.EQUIP, 5);
-        map.put(GameEvent.ENTITY_INTERACT, 6);
-        map.put(GameEvent.SHEAR, 6);
-        map.put(GameEvent.ENTITY_MOUNT, 6);
-        map.put(GameEvent.ENTITY_DAMAGE, 7);
-        map.put(GameEvent.DRINK, 8);
-        map.put(GameEvent.EAT, 8);
-        map.put(GameEvent.CONTAINER_CLOSE, 9);
-        map.put(GameEvent.BLOCK_CLOSE, 9);
-        map.put(GameEvent.BLOCK_DEACTIVATE, 9);
-        map.put(GameEvent.BLOCK_DETACH, 9);
-        map.put(GameEvent.CONTAINER_OPEN, 10);
-        map.put(GameEvent.BLOCK_OPEN, 10);
-        map.put(GameEvent.BLOCK_ACTIVATE, 10);
-        map.put(GameEvent.BLOCK_ATTACH, 10);
-        map.put(GameEvent.PRIME_FUSE, 10);
-        map.put(GameEvent.NOTE_BLOCK_PLAY, 10);
-        map.put(GameEvent.BLOCK_CHANGE, 11);
-        map.put(GameEvent.BLOCK_DESTROY, 12);
-        map.put(GameEvent.FLUID_PICKUP, 12);
-        map.put(GameEvent.BLOCK_PLACE, 13);
-        map.put(GameEvent.FLUID_PLACE, 13);
-        map.put(GameEvent.ENTITY_PLACE, 14);
-        map.put(GameEvent.LIGHTNING_STRIKE, 14);
-        map.put(GameEvent.TELEPORT, 14);
-        map.put(GameEvent.ENTITY_DIE, 15);
-        map.put(GameEvent.EXPLODE, 15);
 
-        for (int i = 1; i <= 15; i++) {
-            map.put(getResonanceEventByFrequency(i), i);
+    GameEvent[] RESONANCE_EVENTS = new GameEvent[]{GameEvent.RESONATE_1, GameEvent.RESONATE_2, GameEvent.RESONATE_3, GameEvent.RESONATE_4, GameEvent.RESONATE_5, GameEvent.RESONATE_6, GameEvent.RESONATE_7, GameEvent.RESONATE_8, GameEvent.RESONATE_9, GameEvent.RESONATE_10, GameEvent.RESONATE_11, GameEvent.RESONATE_12, GameEvent.RESONATE_13, GameEvent.RESONATE_14, GameEvent.RESONATE_15};
+    ToIntFunction<GameEvent> VIBRATION_FREQUENCY_FOR_EVENT = (ToIntFunction) Util.make(new Object2IntOpenHashMap(), (object2intopenhashmap) -> {
+        object2intopenhashmap.defaultReturnValue(0);
+        object2intopenhashmap.put(GameEvent.STEP, 1);
+        object2intopenhashmap.put(GameEvent.SWIM, 1);
+        object2intopenhashmap.put(GameEvent.FLAP, 1);
+        object2intopenhashmap.put(GameEvent.PROJECTILE_LAND, 2);
+        object2intopenhashmap.put(GameEvent.HIT_GROUND, 2);
+        object2intopenhashmap.put(GameEvent.SPLASH, 2);
+        object2intopenhashmap.put(GameEvent.ITEM_INTERACT_FINISH, 3);
+        object2intopenhashmap.put(GameEvent.PROJECTILE_SHOOT, 3);
+        object2intopenhashmap.put(GameEvent.INSTRUMENT_PLAY, 3);
+        object2intopenhashmap.put(GameEvent.ENTITY_ACTION, 4);
+        object2intopenhashmap.put(GameEvent.ELYTRA_GLIDE, 4);
+        object2intopenhashmap.put(GameEvent.UNEQUIP, 4);
+        object2intopenhashmap.put(GameEvent.ENTITY_DISMOUNT, 5);
+        object2intopenhashmap.put(GameEvent.EQUIP, 5);
+        object2intopenhashmap.put(GameEvent.ENTITY_INTERACT, 6);
+        object2intopenhashmap.put(GameEvent.SHEAR, 6);
+        object2intopenhashmap.put(GameEvent.ENTITY_MOUNT, 6);
+        object2intopenhashmap.put(GameEvent.ENTITY_DAMAGE, 7);
+        object2intopenhashmap.put(GameEvent.DRINK, 8);
+        object2intopenhashmap.put(GameEvent.EAT, 8);
+        object2intopenhashmap.put(GameEvent.CONTAINER_CLOSE, 9);
+        object2intopenhashmap.put(GameEvent.BLOCK_CLOSE, 9);
+        object2intopenhashmap.put(GameEvent.BLOCK_DEACTIVATE, 9);
+        object2intopenhashmap.put(GameEvent.BLOCK_DETACH, 9);
+        object2intopenhashmap.put(GameEvent.CONTAINER_OPEN, 10);
+        object2intopenhashmap.put(GameEvent.BLOCK_OPEN, 10);
+        object2intopenhashmap.put(GameEvent.BLOCK_ACTIVATE, 10);
+        object2intopenhashmap.put(GameEvent.BLOCK_ATTACH, 10);
+        object2intopenhashmap.put(GameEvent.PRIME_FUSE, 10);
+        object2intopenhashmap.put(GameEvent.NOTE_BLOCK_PLAY, 10);
+        object2intopenhashmap.put(GameEvent.BLOCK_CHANGE, 11);
+        object2intopenhashmap.put(GameEvent.BLOCK_DESTROY, 12);
+        object2intopenhashmap.put(GameEvent.FLUID_PICKUP, 12);
+        object2intopenhashmap.put(GameEvent.BLOCK_PLACE, 13);
+        object2intopenhashmap.put(GameEvent.FLUID_PLACE, 13);
+        object2intopenhashmap.put(GameEvent.ENTITY_PLACE, 14);
+        object2intopenhashmap.put(GameEvent.LIGHTNING_STRIKE, 14);
+        object2intopenhashmap.put(GameEvent.TELEPORT, 14);
+        object2intopenhashmap.put(GameEvent.ENTITY_DIE, 15);
+        object2intopenhashmap.put(GameEvent.EXPLODE, 15);
+
+        for (int i = 1; i <= 15; ++i) {
+            object2intopenhashmap.put(getResonanceEventByFrequency(i), i);
         }
+
     });
 
     VibrationSystem.Data getVibrationData();
@@ -101,201 +90,115 @@
     VibrationSystem.User getVibrationUser();
 
     static int getGameEventFrequency(GameEvent gameEvent) {
-        return VIBRATION_FREQUENCY_FOR_EVENT.applyAsInt(gameEvent);
+        return VibrationSystem.VIBRATION_FREQUENCY_FOR_EVENT.applyAsInt(gameEvent);
     }
 
     static GameEvent getResonanceEventByFrequency(int frequency) {
-        return RESONANCE_EVENTS[frequency - 1];
+        return VibrationSystem.RESONANCE_EVENTS[frequency - 1];
     }
 
     static int getRedstoneStrengthForDistance(float distance, int maxDistance) {
-        double d = 15.0 / (double)maxDistance;
-        return Math.max(1, 15 - Mth.floor(d * (double)distance));
+        double d0 = 15.0D / (double) maxDistance;
+
+        return Math.max(1, 15 - Mth.floor(d0 * (double) distance));
     }
 
-    public static final class Data {
-        public static Codec<VibrationSystem.Data> CODEC = RecordCodecBuilder.create(
-            instance -> instance.group(
-                        VibrationInfo.CODEC.optionalFieldOf("event").forGetter(data -> Optional.ofNullable(data.currentVibration)),
-                        VibrationSelector.CODEC.fieldOf("selector").forGetter(VibrationSystem.Data::getSelectionStrategy),
-                        ExtraCodecs.NON_NEGATIVE_INT.fieldOf("event_delay").orElse(0).forGetter(VibrationSystem.Data::getTravelTimeInTicks)
-                    )
-                    .apply(
-                        instance,
-                        (vibrationInfo, vibrationSelector, eventDelay) -> new VibrationSystem.Data(
-                                vibrationInfo.orElse(null), vibrationSelector, eventDelay, true
-                            )
-                    )
-        );
-        public static final String NBT_TAG_KEY = "listener";
-        @Nullable
-        VibrationInfo currentVibration;
-        private int travelTimeInTicks;
-        final VibrationSelector selectionStrategy;
-        private boolean reloadVibrationParticle;
+    public interface User {
 
-        private Data(@Nullable VibrationInfo currentVibration, VibrationSelector selectionStrategy, int travelTimeInTicks, boolean reloadVibrationParticle) {
-            this.currentVibration = currentVibration;
-            this.travelTimeInTicks = travelTimeInTicks;
-            this.selectionStrategy = selectionStrategy;
-            this.reloadVibrationParticle = reloadVibrationParticle;
-        }
+        int getListenerRadius();
 
-        public Data() {
-            this(null, new VibrationSelector(), 0, false);
-        }
+        PositionSource getPositionSource();
 
-        public VibrationSelector getSelectionStrategy() {
-            return this.selectionStrategy;
-        }
+        boolean canReceiveVibration(ServerLevel level, BlockPos pos, GameEvent gameEvent, GameEvent.Context context);
 
-        @Nullable
-        public VibrationInfo getCurrentVibration() {
-            return this.currentVibration;
-        }
+        void onReceiveVibration(ServerLevel level, BlockPos pos, GameEvent gameEvent, @Nullable Entity entity, @Nullable Entity playerEntity, float distance);
 
-        public void setCurrentVibration(@Nullable VibrationInfo currentVibration) {
-            this.currentVibration = currentVibration;
+        default TagKey<GameEvent> getListenableEvents() {
+            return GameEventTags.VIBRATIONS;
         }
 
-        public int getTravelTimeInTicks() {
-            return this.travelTimeInTicks;
+        default boolean canTriggerAvoidVibration() {
+            return false;
         }
 
-        public void setTravelTimeInTicks(int travelTimeInTicks) {
-            this.travelTimeInTicks = travelTimeInTicks;
+        default boolean requiresAdjacentChunksToBeTicking() {
+            return false;
         }
 
-        public void decrementTravelTime() {
-            this.travelTimeInTicks = Math.max(0, this.travelTimeInTicks - 1);
+        default int calculateTravelTimeInTicks(float distance) {
+            return Mth.floor(distance);
         }
 
-        public boolean shouldReloadVibrationParticle() {
-            return this.reloadVibrationParticle;
-        }
-
-        public void setReloadVibrationParticle(boolean reloadVibrationParticle) {
-            this.reloadVibrationParticle = reloadVibrationParticle;
-        }
-    }
-
-    public static class Listener implements GameEventListener {
-        private final VibrationSystem system;
-
-        public Listener(VibrationSystem system) {
-            this.system = system;
-        }
-
-        @Override
-        public PositionSource getListenerSource() {
-            return this.system.getVibrationUser().getPositionSource();
-        }
-
-        @Override
-        public int getListenerRadius() {
-            return this.system.getVibrationUser().getListenerRadius();
-        }
-
-        @Override
-        public boolean handleGameEvent(ServerLevel level, GameEvent gameEvent, GameEvent.Context context, Vec3 pos) {
-            VibrationSystem.Data vibrationData = this.system.getVibrationData();
-            VibrationSystem.User vibrationUser = this.system.getVibrationUser();
-            if (vibrationData.getCurrentVibration() != null) {
+        default boolean isValidVibration(GameEvent gameEvent, GameEvent.Context context) {
+            if (!gameEvent.is(this.getListenableEvents())) {
                 return false;
-            } else if (!vibrationUser.isValidVibration(gameEvent, context)) {
-                return false;
             } else {
-                Optional<Vec3> position = vibrationUser.getPositionSource().getPosition(level);
-                if (position.isEmpty()) {
-                    return false;
-                } else {
-                    Vec3 vec3 = position.get();
-                    if (!vibrationUser.canReceiveVibration(level, BlockPos.containing(pos), gameEvent, context)) {
+                Entity entity = context.sourceEntity();
+
+                if (entity != null) {
+                    if (entity.isSpectator()) {
                         return false;
-                    } else if (isOccluded(level, pos, vec3)) {
-                        return false;
-                    } else {
-                        this.scheduleVibration(level, vibrationData, gameEvent, context, pos, vec3);
-                        return true;
                     }
-                }
-            }
-        }
 
-        public void forceScheduleVibration(ServerLevel level, GameEvent gameEvent, GameEvent.Context context, Vec3 eventPos) {
-            this.system
-                .getVibrationUser()
-                .getPositionSource()
-                .getPosition(level)
-                .ifPresent(vibrationUserPos -> this.scheduleVibration(level, this.system.getVibrationData(), gameEvent, context, eventPos, vibrationUserPos));
-        }
+                    if (entity.isSteppingCarefully() && gameEvent.is(GameEventTags.IGNORE_VIBRATIONS_SNEAKING)) {
+                        if (this.canTriggerAvoidVibration() && entity instanceof ServerPlayer) {
+                            ServerPlayer entityplayer = (ServerPlayer) entity;
 
-        private void scheduleVibration(
-            ServerLevel level, VibrationSystem.Data data, GameEvent gameEvent, GameEvent.Context context, Vec3 pos, Vec3 vibrationUserPos
-        ) {
-            data.selectionStrategy
-                .addCandidate(new VibrationInfo(gameEvent, (float)pos.distanceTo(vibrationUserPos), pos, context.sourceEntity()), level.getGameTime());
-        }
+                            CriteriaTriggers.AVOID_VIBRATION.trigger(entityplayer);
+                        }
 
-        public static float distanceBetweenInBlocks(BlockPos pos1, BlockPos pos2) {
-            return (float)Math.sqrt(pos1.distSqr(pos2));
-        }
+                        return false;
+                    }
 
-        private static boolean isOccluded(Level level, Vec3 eventPos, Vec3 vibrationUserPos) {
-            Vec3 vec3 = new Vec3((double)Mth.floor(eventPos.x) + 0.5, (double)Mth.floor(eventPos.y) + 0.5, (double)Mth.floor(eventPos.z) + 0.5);
-            Vec3 vec31 = new Vec3(
-                (double)Mth.floor(vibrationUserPos.x) + 0.5, (double)Mth.floor(vibrationUserPos.y) + 0.5, (double)Mth.floor(vibrationUserPos.z) + 0.5
-            );
-
-            for (Direction direction : Direction.values()) {
-                Vec3 vec32 = vec3.relative(direction, 1.0E-5F);
-                if (level.isBlockInLine(new ClipBlockStateContext(vec32, vec31, state -> state.is(BlockTags.OCCLUDES_VIBRATION_SIGNALS))).getType()
-                    != HitResult.Type.BLOCK) {
-                    return false;
+                    if (entity.dampensVibrations()) {
+                        return false;
+                    }
                 }
-            }
 
-            return true;
+                return context.affectedState() != null ? !context.affectedState().is(BlockTags.DAMPENS_VIBRATIONS) : true;
+            }
         }
+
+        default void onDataChanged() {}
     }
 
     public interface Ticker {
+
         static void tick(Level level, VibrationSystem.Data data, VibrationSystem.User user) {
-            if (level instanceof ServerLevel serverLevel) {
+            if (level instanceof ServerLevel) {
+                ServerLevel worldserver = (ServerLevel) level;
+
                 if (data.currentVibration == null) {
-                    trySelectAndScheduleVibration(serverLevel, data, user);
+                    trySelectAndScheduleVibration(worldserver, data, user);
                 }
 
                 if (data.currentVibration != null) {
                     boolean flag = data.getTravelTimeInTicks() > 0;
-                    tryReloadVibrationParticle(serverLevel, data, user);
+
+                    tryReloadVibrationParticle(worldserver, data, user);
                     data.decrementTravelTime();
                     if (data.getTravelTimeInTicks() <= 0) {
-                        flag = receiveVibration(serverLevel, data, user, data.currentVibration);
+                        flag = receiveVibration(worldserver, data, user, data.currentVibration);
                     }
 
                     if (flag) {
                         user.onDataChanged();
                     }
+
                 }
             }
         }
 
         private static void trySelectAndScheduleVibration(ServerLevel level, VibrationSystem.Data data, VibrationSystem.User user) {
-            data.getSelectionStrategy()
-                .chosenCandidate(level.getGameTime())
-                .ifPresent(
-                    vibrationInfo -> {
-                        data.setCurrentVibration(vibrationInfo);
-                        Vec3 vec3 = vibrationInfo.pos();
-                        data.setTravelTimeInTicks(user.calculateTravelTimeInTicks(vibrationInfo.distance()));
-                        level.sendParticles(
-                            new VibrationParticleOption(user.getPositionSource(), data.getTravelTimeInTicks()), vec3.x, vec3.y, vec3.z, 1, 0.0, 0.0, 0.0, 0.0
-                        );
-                        user.onDataChanged();
-                        data.getSelectionStrategy().startOver();
-                    }
-                );
+            data.getSelectionStrategy().chosenCandidate(level.getGameTime()).ifPresent((vibrationinfo) -> {
+                data.setCurrentVibration(vibrationinfo);
+                Vec3 vec3d = vibrationinfo.pos();
+
+                data.setTravelTimeInTicks(user.calculateTravelTimeInTicks(vibrationinfo.distance()));
+                level.sendParticles(new VibrationParticleOption(user.getPositionSource(), data.getTravelTimeInTicks()), vec3d.x, vec3d.y, vec3d.z, 1, 0.0D, 0.0D, 0.0D, 0.0D);
+                user.onDataChanged();
+                data.getSelectionStrategy().startOver();
+            });
         }
 
         private static void tryReloadVibrationParticle(ServerLevel level, VibrationSystem.Data data, VibrationSystem.User user) {
@@ -303,48 +206,45 @@
                 if (data.currentVibration == null) {
                     data.setReloadVibrationParticle(false);
                 } else {
-                    Vec3 vec3 = data.currentVibration.pos();
-                    PositionSource positionSource = user.getPositionSource();
-                    Vec3 vec31 = positionSource.getPosition(level).orElse(vec3);
-                    int travelTimeInTicks = data.getTravelTimeInTicks();
-                    int i = user.calculateTravelTimeInTicks(data.currentVibration.distance());
-                    double d = 1.0 - (double)travelTimeInTicks / (double)i;
-                    double d1 = Mth.lerp(d, vec3.x, vec31.x);
-                    double d2 = Mth.lerp(d, vec3.y, vec31.y);
-                    double d3 = Mth.lerp(d, vec3.z, vec31.z);
-                    boolean flag = level.sendParticles(new VibrationParticleOption(positionSource, travelTimeInTicks), d1, d2, d3, 1, 0.0, 0.0, 0.0, 0.0) > 0;
+                    Vec3 vec3d = data.currentVibration.pos();
+                    PositionSource positionsource = user.getPositionSource();
+                    Vec3 vec3d1 = (Vec3) positionsource.getPosition(level).orElse(vec3d);
+                    int i = data.getTravelTimeInTicks();
+                    int j = user.calculateTravelTimeInTicks(data.currentVibration.distance());
+                    double d0 = 1.0D - (double) i / (double) j;
+                    double d1 = Mth.lerp(d0, vec3d.x, vec3d1.x);
+                    double d2 = Mth.lerp(d0, vec3d.y, vec3d1.y);
+                    double d3 = Mth.lerp(d0, vec3d.z, vec3d1.z);
+                    boolean flag = level.sendParticles(new VibrationParticleOption(positionsource, i), d1, d2, d3, 1, 0.0D, 0.0D, 0.0D, 0.0D) > 0;
+
                     if (flag) {
                         data.setReloadVibrationParticle(false);
                     }
+
                 }
             }
         }
 
         private static boolean receiveVibration(ServerLevel level, VibrationSystem.Data data, VibrationSystem.User user, VibrationInfo vibrationInfo) {
-            BlockPos blockPos = BlockPos.containing(vibrationInfo.pos());
-            BlockPos blockPos1 = user.getPositionSource().getPosition(level).map(BlockPos::containing).orElse(blockPos);
-            if (user.requiresAdjacentChunksToBeTicking() && !areAdjacentChunksTicking(level, blockPos1)) {
+            BlockPos blockposition = BlockPos.containing(vibrationInfo.pos());
+            BlockPos blockposition1 = (BlockPos) user.getPositionSource().getPosition(level).map(BlockPos::containing).orElse(blockposition);
+
+            if (user.requiresAdjacentChunksToBeTicking() && !areAdjacentChunksTicking(level, blockposition1)) {
                 return false;
             } else {
-                user.onReceiveVibration(
-                    level,
-                    blockPos,
-                    vibrationInfo.gameEvent(),
-                    vibrationInfo.getEntity(level).orElse(null),
-                    vibrationInfo.getProjectileOwner(level).orElse(null),
-                    VibrationSystem.Listener.distanceBetweenInBlocks(blockPos, blockPos1)
-                );
-                data.setCurrentVibration(null);
+                // CraftBukkit - decompile error
+                user.onReceiveVibration(level, blockposition, vibrationInfo.gameEvent(), (Entity) vibrationInfo.getEntity(level).orElse(null), (Entity) vibrationInfo.getProjectileOwner(level).orElse(null), VibrationSystem.Listener.distanceBetweenInBlocks(blockposition, blockposition1));
+                data.setCurrentVibration((VibrationInfo) null);
                 return true;
             }
         }
 
         private static boolean areAdjacentChunksTicking(Level level, BlockPos pos) {
-            ChunkPos chunkPos = new ChunkPos(pos);
+            ChunkPos chunkcoordintpair = new ChunkPos(pos);
 
-            for (int i = chunkPos.x - 1; i <= chunkPos.x + 1; i++) {
-                for (int i1 = chunkPos.z - 1; i1 <= chunkPos.z + 1; i1++) {
-                    if (!level.shouldTickBlocksAt(ChunkPos.asLong(i, i1)) || level.getChunkSource().getChunkNow(i, i1) == null) {
+            for (int i = chunkcoordintpair.x - 1; i <= chunkcoordintpair.x + 1; ++i) {
+                for (int j = chunkcoordintpair.z - 1; j <= chunkcoordintpair.z + 1; ++j) {
+                    if (!level.shouldTickBlocksAt(ChunkPos.asLong(i, j)) || level.getChunkSource().getChunkNow(i, j) == null) {
                         return false;
                     }
                 }
@@ -354,59 +254,152 @@
         }
     }
 
-    public interface User {
-        int getListenerRadius();
+    public static class Listener implements GameEventListener {
 
-        PositionSource getPositionSource();
+        private final VibrationSystem system;
 
-        boolean canReceiveVibration(ServerLevel level, BlockPos pos, GameEvent gameEvent, GameEvent.Context context);
-
-        void onReceiveVibration(ServerLevel level, BlockPos pos, GameEvent gameEvent, @Nullable Entity entity, @Nullable Entity playerEntity, float distance);
-
-        default TagKey<GameEvent> getListenableEvents() {
-            return GameEventTags.VIBRATIONS;
+        public Listener(VibrationSystem system) {
+            this.system = system;
         }
 
-        default boolean canTriggerAvoidVibration() {
-            return false;
+        @Override
+        public PositionSource getListenerSource() {
+            return this.system.getVibrationUser().getPositionSource();
         }
 
-        default boolean requiresAdjacentChunksToBeTicking() {
-            return false;
+        @Override
+        public int getListenerRadius() {
+            return this.system.getVibrationUser().getListenerRadius();
         }
 
-        default int calculateTravelTimeInTicks(float distance) {
-            return Mth.floor(distance);
-        }
+        @Override
+        public boolean handleGameEvent(ServerLevel level, GameEvent gameEvent, GameEvent.Context context, Vec3 pos) {
+            VibrationSystem.Data vibrationsystem_a = this.system.getVibrationData();
+            VibrationSystem.User vibrationsystem_d = this.system.getVibrationUser();
 
-        default boolean isValidVibration(GameEvent gameEvent, GameEvent.Context context) {
-            if (!gameEvent.is(this.getListenableEvents())) {
+            if (vibrationsystem_a.getCurrentVibration() != null) {
                 return false;
+            } else if (!vibrationsystem_d.isValidVibration(gameEvent, context)) {
+                return false;
             } else {
-                Entity entity = context.sourceEntity();
-                if (entity != null) {
-                    if (entity.isSpectator()) {
-                        return false;
-                    }
+                Optional<Vec3> optional = vibrationsystem_d.getPositionSource().getPosition(level);
 
-                    if (entity.isSteppingCarefully() && gameEvent.is(GameEventTags.IGNORE_VIBRATIONS_SNEAKING)) {
-                        if (this.canTriggerAvoidVibration() && entity instanceof ServerPlayer serverPlayer) {
-                            CriteriaTriggers.AVOID_VIBRATION.trigger(serverPlayer);
-                        }
-
+                if (optional.isEmpty()) {
+                    return false;
+                } else {
+                    Vec3 vec3d1 = (Vec3) optional.get();
+                    // CraftBukkit start
+                    boolean defaultCancel = !vibrationsystem_d.canReceiveVibration(level, BlockPos.containing(pos), gameEvent, context);
+                    Entity entity = context.sourceEntity();
+                    BlockReceiveGameEvent event = new BlockReceiveGameEvent(CraftGameEvent.minecraftToBukkit(gameEvent), CraftBlock.at(level, BlockPos.containing(vec3d1)), (entity == null) ? null : entity.getBukkitEntity());
+                    event.setCancelled(defaultCancel);
+                    level.getCraftServer().getPluginManager().callEvent(event);
+                    if (event.isCancelled()) {
+                        // CraftBukkit end
                         return false;
-                    }
-
-                    if (entity.dampensVibrations()) {
+                    } else if (isOccluded(level, pos, vec3d1)) {
                         return false;
+                    } else {
+                        this.scheduleVibration(level, vibrationsystem_a, gameEvent, context, pos, vec3d1);
+                        return true;
                     }
                 }
+            }
+        }
 
-                return context.affectedState() == null || !context.affectedState().is(BlockTags.DAMPENS_VIBRATIONS);
+        public void forceScheduleVibration(ServerLevel level, GameEvent gameEvent, GameEvent.Context context, Vec3 eventPos) {
+            this.system.getVibrationUser().getPositionSource().getPosition(level).ifPresent((vec3d1) -> {
+                this.scheduleVibration(level, this.system.getVibrationData(), gameEvent, context, eventPos, vec3d1);
+            });
+        }
+
+        private void scheduleVibration(ServerLevel level, VibrationSystem.Data data, GameEvent gameEvent, GameEvent.Context context, Vec3 pos, Vec3 vibrationUserPos) {
+            data.selectionStrategy.addCandidate(new VibrationInfo(gameEvent, (float) pos.distanceTo(vibrationUserPos), pos, context.sourceEntity()), level.getGameTime());
+        }
+
+        public static float distanceBetweenInBlocks(BlockPos pos1, BlockPos pos2) {
+            return (float) Math.sqrt(pos1.distSqr(pos2));
+        }
+
+        private static boolean isOccluded(Level level, Vec3 eventPos, Vec3 vibrationUserPos) {
+            Vec3 vec3d2 = new Vec3((double) Mth.floor(eventPos.x) + 0.5D, (double) Mth.floor(eventPos.y) + 0.5D, (double) Mth.floor(eventPos.z) + 0.5D);
+            Vec3 vec3d3 = new Vec3((double) Mth.floor(vibrationUserPos.x) + 0.5D, (double) Mth.floor(vibrationUserPos.y) + 0.5D, (double) Mth.floor(vibrationUserPos.z) + 0.5D);
+            Direction[] aenumdirection = Direction.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                Direction enumdirection = aenumdirection[j];
+                Vec3 vec3d4 = vec3d2.relative(enumdirection, 9.999999747378752E-6D);
+
+                if (level.isBlockInLine(new ClipBlockStateContext(vec3d4, vec3d3, (iblockdata) -> {
+                    return iblockdata.is(BlockTags.OCCLUDES_VIBRATION_SIGNALS);
+                })).getType() != HitResult.EnumMovingObjectType.BLOCK) {
+                    return false;
+                }
             }
+
+            return true;
         }
+    }
 
-        default void onDataChanged() {
+    public static final class Data {
+
+        public static Codec<VibrationSystem.Data> CODEC = RecordCodecBuilder.create((instance) -> {
+            return instance.group(VibrationInfo.CODEC.optionalFieldOf("event").forGetter((vibrationsystem_a) -> {
+                return Optional.ofNullable(vibrationsystem_a.currentVibration);
+            }), VibrationSelector.CODEC.fieldOf("selector").forGetter(VibrationSystem.Data::getSelectionStrategy), ExtraCodecs.NON_NEGATIVE_INT.fieldOf("event_delay").orElse(0).forGetter(VibrationSystem.Data::getTravelTimeInTicks)).apply(instance, (optional, vibrationselector, integer) -> {
+                return new VibrationSystem.Data((VibrationInfo) optional.orElse(null), vibrationselector, integer, true); // CraftBukkit - decompile error
+            });
+        });
+        public static final String NBT_TAG_KEY = "listener";
+        @Nullable
+        VibrationInfo currentVibration;
+        private int travelTimeInTicks;
+        final VibrationSelector selectionStrategy;
+        private boolean reloadVibrationParticle;
+
+        private Data(@Nullable VibrationInfo currentVibration, VibrationSelector selectionStrategy, int travelTimeInTicks, boolean reloadVibrationParticle) {
+            this.currentVibration = currentVibration;
+            this.travelTimeInTicks = travelTimeInTicks;
+            this.selectionStrategy = selectionStrategy;
+            this.reloadVibrationParticle = reloadVibrationParticle;
         }
+
+        public Data() {
+            this((VibrationInfo) null, new VibrationSelector(), 0, false);
+        }
+
+        public VibrationSelector getSelectionStrategy() {
+            return this.selectionStrategy;
+        }
+
+        @Nullable
+        public VibrationInfo getCurrentVibration() {
+            return this.currentVibration;
+        }
+
+        public void setCurrentVibration(@Nullable VibrationInfo currentVibration) {
+            this.currentVibration = currentVibration;
+        }
+
+        public int getTravelTimeInTicks() {
+            return this.travelTimeInTicks;
+        }
+
+        public void setTravelTimeInTicks(int travelTimeInTicks) {
+            this.travelTimeInTicks = travelTimeInTicks;
+        }
+
+        public void decrementTravelTime() {
+            this.travelTimeInTicks = Math.max(0, this.travelTimeInTicks - 1);
+        }
+
+        public boolean shouldReloadVibrationParticle() {
+            return this.reloadVibrationParticle;
+        }
+
+        public void setReloadVibrationParticle(boolean reloadVibrationParticle) {
+            this.reloadVibrationParticle = reloadVibrationParticle;
+        }
     }
 }
