--- a/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -1,3 +1,4 @@
+// keep
 package net.minecraft.world.level.levelgen;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -5,9 +6,10 @@
 import com.google.common.collect.Sets;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import java.text.DecimalFormat;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.OptionalInt;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
@@ -36,7 +38,7 @@
 import net.minecraft.world.level.biome.BiomeResolver;
 import net.minecraft.world.level.biome.BiomeSource;
 import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.chunk.CarvingMask;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
@@ -49,35 +51,39 @@
 import org.apache.commons.lang3.mutable.MutableObject;
 
 public final class NoiseBasedChunkGenerator extends ChunkGenerator {
-    public static final Codec<NoiseBasedChunkGenerator> CODEC = RecordCodecBuilder.create(
-        instance -> instance.group(
-                    BiomeSource.CODEC.fieldOf("biome_source").forGetter(generator -> generator.biomeSource),
-                    NoiseGeneratorSettings.CODEC.fieldOf("settings").forGetter(generator -> generator.settings)
-                )
-                .apply(instance, instance.stable(NoiseBasedChunkGenerator::new))
-    );
-    private static final BlockState AIR = Blocks.AIR.defaultBlockState();
-    private final Holder<NoiseGeneratorSettings> settings;
+
+    public static final Codec<NoiseBasedChunkGenerator> CODEC = RecordCodecBuilder.create((instance) -> {
+        return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.biomeSource;
+        }), NoiseGeneratorSettings.CODEC.fieldOf("settings").forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.settings;
+        })).apply(instance, instance.stable(NoiseBasedChunkGenerator::new));
+    });
+    private static final IBlockData AIR = Blocks.AIR.defaultBlockState();
+    public final Holder<NoiseGeneratorSettings> settings;
     private final Supplier<Aquifer.FluidPicker> globalFluidPicker;
 
     public NoiseBasedChunkGenerator(BiomeSource biomeSource, Holder<NoiseGeneratorSettings> settings) {
         super(biomeSource);
         this.settings = settings;
-        this.globalFluidPicker = Suppliers.memoize(() -> createFluidPicker(settings.value()));
+        this.globalFluidPicker = Suppliers.memoize(() -> {
+            return createFluidPicker((NoiseGeneratorSettings) settings.value());
+        });
     }
 
     private static Aquifer.FluidPicker createFluidPicker(NoiseGeneratorSettings settings) {
-        Aquifer.FluidStatus fluidStatus = new Aquifer.FluidStatus(-54, Blocks.LAVA.defaultBlockState());
+        Aquifer.FluidStatus aquifer_b = new Aquifer.FluidStatus(-54, Blocks.LAVA.defaultBlockState());
         int i = settings.seaLevel();
-        Aquifer.FluidStatus fluidStatus1 = new Aquifer.FluidStatus(i, settings.defaultFluid());
-        Aquifer.FluidStatus fluidStatus2 = new Aquifer.FluidStatus(DimensionType.MIN_Y * 2, Blocks.AIR.defaultBlockState());
-        return (x, y, z) -> y < Math.min(-54, i) ? fluidStatus : fluidStatus1;
+        Aquifer.FluidStatus aquifer_b1 = new Aquifer.FluidStatus(i, settings.defaultFluid());
+        Aquifer.FluidStatus aquifer_b2 = new Aquifer.FluidStatus(DimensionType.MIN_Y * 2, Blocks.AIR.defaultBlockState());
+
+        return (j, k, l) -> {
+            return k < Math.min(-54, i) ? aquifer_b : aquifer_b1;
+        };
     }
 
     @Override
-    public CompletableFuture<ChunkAccess> createBiomes(
-        Executor executor, RandomState randomState, Blender blender, StructureManager structureManager, ChunkAccess chunk
-    ) {
+    public CompletableFuture<ChunkAccess> createBiomes(Executor executor, RandomState randomState, Blender blender, StructureManager structureManager, ChunkAccess chunk) {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
             this.doCreateBiomes(blender, randomState, structureManager, chunk);
             return chunk;
@@ -85,20 +91,21 @@
     }
 
     private void doCreateBiomes(Blender blender, RandomState random, StructureManager structureManager, ChunkAccess chunk) {
-        NoiseChunk noiseChunk = chunk.getOrCreateNoiseChunk(chunkAccess -> this.createNoiseChunk(chunkAccess, structureManager, blender, random));
-        BiomeResolver biomeResolver = BelowZeroRetrogen.getBiomeResolver(blender.getBiomeResolver(this.biomeSource), chunk);
-        chunk.fillBiomesFromNoise(biomeResolver, noiseChunk.cachedClimateSampler(random.router(), this.settings.value().spawnTarget()));
+        NoiseChunk noisechunk = chunk.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, structureManager, blender, random);
+        });
+        BiomeResolver biomeresolver = BelowZeroRetrogen.getBiomeResolver(blender.getBiomeResolver(this.biomeSource), chunk);
+
+        chunk.fillBiomesFromNoise(biomeresolver, noisechunk.cachedClimateSampler(random.router(), ((NoiseGeneratorSettings) this.settings.value()).spawnTarget()));
     }
 
     private NoiseChunk createNoiseChunk(ChunkAccess chunk, StructureManager structureManager, Blender blender, RandomState random) {
-        return NoiseChunk.forChunk(
-            chunk, random, Beardifier.forStructuresInChunk(structureManager, chunk.getPos()), this.settings.value(), this.globalFluidPicker.get(), blender
-        );
+        return NoiseChunk.forChunk(chunk, random, Beardifier.forStructuresInChunk(structureManager, chunk.getPos()), (NoiseGeneratorSettings) this.settings.value(), (Aquifer.FluidPicker) this.globalFluidPicker.get(), blender);
     }
 
     @Override
     protected Codec<? extends ChunkGenerator> codec() {
-        return CODEC;
+        return NoiseBasedChunkGenerator.CODEC;
     }
 
     public Holder<NoiseGeneratorSettings> generatorSettings() {
@@ -111,110 +118,88 @@
 
     @Override
     public int getBaseHeight(int x, int z, Heightmap.Types type, LevelHeightAccessor level, RandomState random) {
-        return this.iterateNoiseColumn(level, random, x, z, null, type.isOpaque()).orElse(level.getMinBuildHeight());
+        return this.iterateNoiseColumn(level, random, x, z, (MutableObject) null, type.isOpaque()).orElse(level.getMinBuildHeight());
     }
 
     @Override
     public NoiseColumn getBaseColumn(int x, int z, LevelHeightAccessor height, RandomState random) {
-        MutableObject<NoiseColumn> mutableObject = new MutableObject<>();
-        this.iterateNoiseColumn(height, random, x, z, mutableObject, null);
-        return mutableObject.getValue();
+        MutableObject<NoiseColumn> mutableobject = new MutableObject();
+
+        this.iterateNoiseColumn(height, random, x, z, mutableobject, (Predicate) null);
+        return (NoiseColumn) mutableobject.getValue();
     }
 
     @Override
     public void addDebugScreenInfo(List<String> info, RandomState random, BlockPos pos) {
-        DecimalFormat decimalFormat = new DecimalFormat("0.000");
-        NoiseRouter noiseRouter = random.router();
-        DensityFunction.SinglePointContext singlePointContext = new DensityFunction.SinglePointContext(pos.getX(), pos.getY(), pos.getZ());
-        double d = noiseRouter.ridges().compute(singlePointContext);
-        info.add(
-            "NoiseRouter T: "
-                + decimalFormat.format(noiseRouter.temperature().compute(singlePointContext))
-                + " V: "
-                + decimalFormat.format(noiseRouter.vegetation().compute(singlePointContext))
-                + " C: "
-                + decimalFormat.format(noiseRouter.continents().compute(singlePointContext))
-                + " E: "
-                + decimalFormat.format(noiseRouter.erosion().compute(singlePointContext))
-                + " D: "
-                + decimalFormat.format(noiseRouter.depth().compute(singlePointContext))
-                + " W: "
-                + decimalFormat.format(d)
-                + " PV: "
-                + decimalFormat.format((double)NoiseRouterData.peaksAndValleys((float)d))
-                + " AS: "
-                + decimalFormat.format(noiseRouter.initialDensityWithoutJaggedness().compute(singlePointContext))
-                + " N: "
-                + decimalFormat.format(noiseRouter.finalDensity().compute(singlePointContext))
-        );
+        DecimalFormat decimalformat = new DecimalFormat("0.000");
+        NoiseRouter noiserouter = random.router();
+        DensityFunction.e densityfunction_e = new DensityFunction.e(pos.getX(), pos.getY(), pos.getZ());
+        double d0 = noiserouter.ridges().compute(densityfunction_e);
+        String s = decimalformat.format(noiserouter.temperature().compute(densityfunction_e));
+
+        info.add("NoiseRouter T: " + s + " V: " + decimalformat.format(noiserouter.vegetation().compute(densityfunction_e)) + " C: " + decimalformat.format(noiserouter.continents().compute(densityfunction_e)) + " E: " + decimalformat.format(noiserouter.erosion().compute(densityfunction_e)) + " D: " + decimalformat.format(noiserouter.depth().compute(densityfunction_e)) + " W: " + decimalformat.format(d0) + " PV: " + decimalformat.format((double) NoiseRouterData.peaksAndValleys((float) d0)) + " AS: " + decimalformat.format(noiserouter.initialDensityWithoutJaggedness().compute(densityfunction_e)) + " N: " + decimalformat.format(noiserouter.finalDensity().compute(densityfunction_e)));
     }
 
-    private OptionalInt iterateNoiseColumn(
-        LevelHeightAccessor level, RandomState random, int x, int z, @Nullable MutableObject<NoiseColumn> column, @Nullable Predicate<BlockState> stoppingState
-    ) {
-        NoiseSettings noiseSettings = this.settings.value().noiseSettings().clampToHeightAccessor(level);
-        int cellHeight = noiseSettings.getCellHeight();
-        int i = noiseSettings.minY();
-        int i1 = Mth.floorDiv(i, cellHeight);
-        int i2 = Mth.floorDiv(noiseSettings.height(), cellHeight);
-        if (i2 <= 0) {
+    private OptionalInt iterateNoiseColumn(LevelHeightAccessor level, RandomState random, int x, int z, @Nullable MutableObject<NoiseColumn> column, @Nullable Predicate<IBlockData> stoppingState) {
+        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().clampToHeightAccessor(level);
+        int k = noisesettings.getCellHeight();
+        int l = noisesettings.minY();
+        int i1 = Mth.floorDiv(l, k);
+        int j1 = Mth.floorDiv(noisesettings.height(), k);
+
+        if (j1 <= 0) {
             return OptionalInt.empty();
         } else {
-            BlockState[] blockStates;
+            IBlockData[] aiblockdata;
+
             if (column == null) {
-                blockStates = null;
+                aiblockdata = null;
             } else {
-                blockStates = new BlockState[noiseSettings.height()];
-                column.setValue(new NoiseColumn(i, blockStates));
+                aiblockdata = new IBlockData[noisesettings.height()];
+                column.setValue(new NoiseColumn(l, aiblockdata));
             }
 
-            int cellWidth = noiseSettings.getCellWidth();
-            int i3 = Math.floorDiv(x, cellWidth);
-            int i4 = Math.floorDiv(z, cellWidth);
-            int i5 = Math.floorMod(x, cellWidth);
-            int i6 = Math.floorMod(z, cellWidth);
-            int i7 = i3 * cellWidth;
-            int i8 = i4 * cellWidth;
-            double d = (double)i5 / (double)cellWidth;
-            double d1 = (double)i6 / (double)cellWidth;
-            NoiseChunk noiseChunk = new NoiseChunk(
-                1,
-                random,
-                i7,
-                i8,
-                noiseSettings,
-                DensityFunctions.BeardifierMarker.INSTANCE,
-                this.settings.value(),
-                this.globalFluidPicker.get(),
-                Blender.empty()
-            );
-            noiseChunk.initializeForFirstCellX();
-            noiseChunk.advanceCellX(0);
+            int k1 = noisesettings.getCellWidth();
+            int l1 = Math.floorDiv(x, k1);
+            int i2 = Math.floorDiv(z, k1);
+            int j2 = Math.floorMod(x, k1);
+            int k2 = Math.floorMod(z, k1);
+            int l2 = l1 * k1;
+            int i3 = i2 * k1;
+            double d0 = (double) j2 / (double) k1;
+            double d1 = (double) k2 / (double) k1;
+            NoiseChunk noisechunk = new NoiseChunk(1, random, l2, i3, noisesettings, DensityFunctions.b.INSTANCE, (NoiseGeneratorSettings) this.settings.value(), (Aquifer.FluidPicker) this.globalFluidPicker.get(), Blender.empty());
 
-            for (int i9 = i2 - 1; i9 >= 0; i9--) {
-                noiseChunk.selectCellYZ(i9, 0);
+            noisechunk.initializeForFirstCellX();
+            noisechunk.advanceCellX(0);
 
-                for (int i10 = cellHeight - 1; i10 >= 0; i10--) {
-                    int i11 = (i1 + i9) * cellHeight + i10;
-                    double d2 = (double)i10 / (double)cellHeight;
-                    noiseChunk.updateForY(i11, d2);
-                    noiseChunk.updateForX(x, d);
-                    noiseChunk.updateForZ(z, d1);
-                    BlockState interpolatedState = noiseChunk.getInterpolatedState();
-                    BlockState blockState = interpolatedState == null ? this.settings.value().defaultBlock() : interpolatedState;
-                    if (blockStates != null) {
-                        int i12 = i9 * cellHeight + i10;
-                        blockStates[i12] = blockState;
+            for (int j3 = j1 - 1; j3 >= 0; --j3) {
+                noisechunk.selectCellYZ(j3, 0);
+
+                for (int k3 = k - 1; k3 >= 0; --k3) {
+                    int l3 = (i1 + j3) * k + k3;
+                    double d2 = (double) k3 / (double) k;
+
+                    noisechunk.updateForY(l3, d2);
+                    noisechunk.updateForX(x, d0);
+                    noisechunk.updateForZ(z, d1);
+                    IBlockData iblockdata = noisechunk.getInterpolatedState();
+                    IBlockData iblockdata1 = iblockdata == null ? ((NoiseGeneratorSettings) this.settings.value()).defaultBlock() : iblockdata;
+
+                    if (aiblockdata != null) {
+                        int i4 = j3 * k + k3;
+
+                        aiblockdata[i4] = iblockdata1;
                     }
 
-                    if (stoppingState != null && stoppingState.test(blockState)) {
-                        noiseChunk.stopInterpolation();
-                        return OptionalInt.of(i11 + 1);
+                    if (stoppingState != null && stoppingState.test(iblockdata1)) {
+                        noisechunk.stopInterpolation();
+                        return OptionalInt.of(l3 + 1);
                     }
                 }
             }
 
-            noiseChunk.stopInterpolation();
+            noisechunk.stopInterpolation();
             return OptionalInt.empty();
         }
     }
@@ -222,178 +207,167 @@
     @Override
     public void buildSurface(WorldGenRegion level, StructureManager structureManager, RandomState random, ChunkAccess chunk) {
         if (!SharedConstants.debugVoidTerrain(chunk.getPos())) {
-            WorldGenerationContext worldGenerationContext = new WorldGenerationContext(this, level);
-            this.buildSurface(
-                chunk,
-                worldGenerationContext,
-                random,
-                structureManager,
-                level.getBiomeManager(),
-                level.registryAccess().registryOrThrow(Registries.BIOME),
-                Blender.of(level)
-            );
+            WorldGenerationContext worldgenerationcontext = new WorldGenerationContext(this, level);
+
+            this.buildSurface(chunk, worldgenerationcontext, random, structureManager, level.getBiomeManager(), level.registryAccess().registryOrThrow(Registries.BIOME), Blender.of(level));
         }
     }
 
     @VisibleForTesting
-    public void buildSurface(
-        ChunkAccess chunk,
-        WorldGenerationContext context,
-        RandomState random,
-        StructureManager structureManager,
-        BiomeManager biomeManager,
-        Registry<Biome> biomes,
-        Blender blender
-    ) {
-        NoiseChunk noiseChunk = chunk.getOrCreateNoiseChunk(chunkAccess -> this.createNoiseChunk(chunkAccess, structureManager, blender, random));
-        NoiseGeneratorSettings noiseGeneratorSettings = this.settings.value();
-        random.surfaceSystem()
-            .buildSurface(
-                random, biomeManager, biomes, noiseGeneratorSettings.useLegacyRandomSource(), context, chunk, noiseChunk, noiseGeneratorSettings.surfaceRule()
-            );
+    public void buildSurface(ChunkAccess chunk, WorldGenerationContext context, RandomState random, StructureManager structureManager, BiomeManager biomeManager, Registry<Biome> biomes, Blender blender) {
+        NoiseChunk noisechunk = chunk.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, structureManager, blender, random);
+        });
+        NoiseGeneratorSettings generatorsettingbase = (NoiseGeneratorSettings) this.settings.value();
+
+        random.surfaceSystem().buildSurface(random, biomeManager, biomes, generatorsettingbase.useLegacyRandomSource(), context, chunk, noisechunk, generatorsettingbase.surfaceRule());
     }
 
     @Override
-    public void applyCarvers(
-        WorldGenRegion level,
-        long seed,
-        RandomState random,
-        BiomeManager biomeManager,
-        StructureManager structureManager,
-        ChunkAccess chunk,
-        GenerationStep.Carving step
-    ) {
-        BiomeManager biomeManager1 = biomeManager.withDifferentSource((x, y, z) -> this.biomeSource.getNoiseBiome(x, y, z, random.sampler()));
-        WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
-        int i = 8;
-        ChunkPos pos = chunk.getPos();
-        NoiseChunk noiseChunk = chunk.getOrCreateNoiseChunk(chunkAccess -> this.createNoiseChunk(chunkAccess, structureManager, Blender.of(level), random));
-        Aquifer aquifer = noiseChunk.aquifer();
-        CarvingContext carvingContext = new CarvingContext(
-            this, level.registryAccess(), chunk.getHeightAccessorForGeneration(), noiseChunk, random, this.settings.value().surfaceRule()
-        );
-        CarvingMask carvingMask = ((ProtoChunk)chunk).getOrCreateCarvingMask(step);
+    public void applyCarvers(WorldGenRegion level, long seed, RandomState randomstate, BiomeManager random, StructureManager biomeManager, ChunkAccess structureManager, GenerationStep.Carving chunk) {
+        BiomeManager biomemanager1 = random.withDifferentSource((j, k, l) -> {
+            return this.biomeSource.getNoiseBiome(j, k, l, randomstate.sampler());
+        });
+        WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
+        boolean flag = true;
+        ChunkPos chunkcoordintpair = structureManager.getPos();
+        NoiseChunk noisechunk = structureManager.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, biomeManager, Blender.of(level), randomstate);
+        });
+        Aquifer aquifer = noisechunk.aquifer();
+        CarvingContext carvingcontext = new CarvingContext(this, level.registryAccess(), structureManager.getHeightAccessorForGeneration(), noisechunk, randomstate, ((NoiseGeneratorSettings) this.settings.value()).surfaceRule());
+        CarvingMask carvingmask = ((ProtoChunk) structureManager).getOrCreateCarvingMask(chunk);
 
-        for (int i1 = -8; i1 <= 8; i1++) {
-            for (int i2 = -8; i2 <= 8; i2++) {
-                ChunkPos chunkPos = new ChunkPos(pos.x + i1, pos.z + i2);
-                ChunkAccess chunk1 = level.getChunk(chunkPos.x, chunkPos.z);
-                BiomeGenerationSettings biomeGenerationSettings = chunk1.carverBiome(
-                    () -> this.getBiomeGenerationSettings(
-                            this.biomeSource
-                                .getNoiseBiome(QuartPos.fromBlock(chunkPos.getMinBlockX()), 0, QuartPos.fromBlock(chunkPos.getMinBlockZ()), random.sampler())
-                        )
-                );
-                Iterable<Holder<ConfiguredWorldCarver<?>>> carvers = biomeGenerationSettings.getCarvers(step);
-                int i3 = 0;
+        for (int j = -8; j <= 8; ++j) {
+            for (int k = -8; k <= 8; ++k) {
+                ChunkPos chunkcoordintpair1 = new ChunkPos(chunkcoordintpair.x + j, chunkcoordintpair.z + k);
+                ChunkAccess ichunkaccess1 = level.getChunk(chunkcoordintpair1.x, chunkcoordintpair1.z);
+                BiomeGenerationSettings biomesettingsgeneration = ichunkaccess1.carverBiome(() -> {
+                    return this.getBiomeGenerationSettings(this.biomeSource.getNoiseBiome(QuartPos.fromBlock(chunkcoordintpair1.getMinBlockX()), 0, QuartPos.fromBlock(chunkcoordintpair1.getMinBlockZ()), randomstate.sampler()));
+                });
+                Iterable<Holder<ConfiguredWorldCarver<?>>> iterable = biomesettingsgeneration.getCarvers(chunk);
+                int l = 0;
 
-                for (Holder<ConfiguredWorldCarver<?>> holder : carvers) {
-                    ConfiguredWorldCarver<?> configuredWorldCarver = holder.value();
-                    worldgenRandom.setLargeFeatureSeed(seed + (long)i3, chunkPos.x, chunkPos.z);
-                    if (configuredWorldCarver.isStartChunk(worldgenRandom)) {
-                        configuredWorldCarver.carve(carvingContext, chunk, biomeManager1::getBiome, worldgenRandom, aquifer, chunkPos, carvingMask);
-                    }
+                for (Iterator iterator = iterable.iterator(); iterator.hasNext(); ++l) {
+                    Holder<ConfiguredWorldCarver<?>> holder = (Holder) iterator.next();
+                    ConfiguredWorldCarver<?> worldgencarverwrapper = (ConfiguredWorldCarver) holder.value();
 
-                    i3++;
+                    seededrandom.setLargeFeatureSeed(seed + (long) l, chunkcoordintpair1.x, chunkcoordintpair1.z);
+                    if (worldgencarverwrapper.isStartChunk(seededrandom)) {
+                        Objects.requireNonNull(biomemanager1);
+                        worldgencarverwrapper.carve(carvingcontext, structureManager, biomemanager1::getBiome, seededrandom, aquifer, chunkcoordintpair1, carvingmask);
+                    }
                 }
             }
         }
+
     }
 
     @Override
-    public CompletableFuture<ChunkAccess> fillFromNoise(
-        Executor executor, Blender blender, RandomState random, StructureManager structureManager, ChunkAccess chunk
-    ) {
-        NoiseSettings noiseSettings = this.settings.value().noiseSettings().clampToHeightAccessor(chunk.getHeightAccessorForGeneration());
-        int i = noiseSettings.minY();
-        int i1 = Mth.floorDiv(i, noiseSettings.getCellHeight());
-        int i2 = Mth.floorDiv(noiseSettings.height(), noiseSettings.getCellHeight());
-        if (i2 <= 0) {
+    public CompletableFuture<ChunkAccess> fillFromNoise(Executor executor, Blender blender, RandomState random, StructureManager structureManager, ChunkAccess chunk) {
+        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().clampToHeightAccessor(chunk.getHeightAccessorForGeneration());
+        int i = noisesettings.minY();
+        int j = Mth.floorDiv(i, noisesettings.getCellHeight());
+        int k = Mth.floorDiv(noisesettings.height(), noisesettings.getCellHeight());
+
+        if (k <= 0) {
             return CompletableFuture.completedFuture(chunk);
         } else {
-            int sectionIndex = chunk.getSectionIndex(i2 * noiseSettings.getCellHeight() - 1 + i);
-            int sectionIndex1 = chunk.getSectionIndex(i);
+            int l = chunk.getSectionIndex(k * noisesettings.getCellHeight() - 1 + i);
+            int i1 = chunk.getSectionIndex(i);
             Set<LevelChunkSection> set = Sets.newHashSet();
 
-            for (int i3 = sectionIndex; i3 >= sectionIndex1; i3--) {
-                LevelChunkSection section = chunk.getSection(i3);
-                section.acquire();
-                set.add(section);
+            for (int j1 = l; j1 >= i1; --j1) {
+                LevelChunkSection chunksection = chunk.getSection(j1);
+
+                chunksection.acquire();
+                set.add(chunksection);
             }
 
-            return CompletableFuture.supplyAsync(
-                    Util.wrapThreadWithTaskName("wgen_fill_noise", () -> this.doFill(blender, structureManager, random, chunk, i1, i2)),
-                    Util.backgroundExecutor()
-                )
-                .whenCompleteAsync((chunkAccess, throwable) -> {
-                    for (LevelChunkSection levelChunkSection : set) {
-                        levelChunkSection.release();
-                    }
-                }, executor);
+            return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("wgen_fill_noise", () -> {
+                return this.doFill(blender, structureManager, random, chunk, j, k);
+            }), Util.backgroundExecutor()).whenCompleteAsync((ichunkaccess1, throwable) -> {
+                Iterator iterator = set.iterator();
+
+                while (iterator.hasNext()) {
+                    LevelChunkSection chunksection1 = (LevelChunkSection) iterator.next();
+
+                    chunksection1.release();
+                }
+
+            }, executor);
         }
     }
 
     private ChunkAccess doFill(Blender blender, StructureManager structureManager, RandomState random, ChunkAccess chunk, int minCellY, int cellCountY) {
-        NoiseChunk noiseChunk = chunk.getOrCreateNoiseChunk(chunkAccess -> this.createNoiseChunk(chunkAccess, structureManager, blender, random));
-        Heightmap heightmapUnprimed = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
-        Heightmap heightmapUnprimed1 = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
-        ChunkPos pos = chunk.getPos();
-        int minBlockX = pos.getMinBlockX();
-        int minBlockZ = pos.getMinBlockZ();
-        Aquifer aquifer = noiseChunk.aquifer();
-        noiseChunk.initializeForFirstCellX();
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
-        int i = noiseChunk.cellWidth();
-        int i1 = noiseChunk.cellHeight();
-        int i2 = 16 / i;
-        int i3 = 16 / i;
+        NoiseChunk noisechunk = chunk.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, structureManager, blender, random);
+        });
+        Heightmap heightmap = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
+        Heightmap heightmap1 = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int k = chunkcoordintpair.getMinBlockX();
+        int l = chunkcoordintpair.getMinBlockZ();
+        Aquifer aquifer = noisechunk.aquifer();
 
-        for (int i4 = 0; i4 < i2; i4++) {
-            noiseChunk.advanceCellX(i4);
+        noisechunk.initializeForFirstCellX();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+        int i1 = noisechunk.cellWidth();
+        int j1 = noisechunk.cellHeight();
+        int k1 = 16 / i1;
+        int l1 = 16 / i1;
 
-            for (int i5 = 0; i5 < i3; i5++) {
-                int i6 = chunk.getSectionsCount() - 1;
-                LevelChunkSection section = chunk.getSection(i6);
+        for (int i2 = 0; i2 < k1; ++i2) {
+            noisechunk.advanceCellX(i2);
 
-                for (int i7 = cellCountY - 1; i7 >= 0; i7--) {
-                    noiseChunk.selectCellYZ(i7, i5);
+            for (int j2 = 0; j2 < l1; ++j2) {
+                int k2 = chunk.getSectionsCount() - 1;
+                LevelChunkSection chunksection = chunk.getSection(k2);
 
-                    for (int i8 = i1 - 1; i8 >= 0; i8--) {
-                        int i9 = (minCellY + i7) * i1 + i8;
-                        int i10 = i9 & 15;
-                        int sectionIndex = chunk.getSectionIndex(i9);
-                        if (i6 != sectionIndex) {
-                            i6 = sectionIndex;
-                            section = chunk.getSection(sectionIndex);
+                for (int l2 = cellCountY - 1; l2 >= 0; --l2) {
+                    noisechunk.selectCellYZ(l2, j2);
+
+                    for (int i3 = j1 - 1; i3 >= 0; --i3) {
+                        int j3 = (minCellY + l2) * j1 + i3;
+                        int k3 = j3 & 15;
+                        int l3 = chunk.getSectionIndex(j3);
+
+                        if (k2 != l3) {
+                            k2 = l3;
+                            chunksection = chunk.getSection(l3);
                         }
 
-                        double d = (double)i8 / (double)i1;
-                        noiseChunk.updateForY(i9, d);
+                        double d0 = (double) i3 / (double) j1;
 
-                        for (int i11 = 0; i11 < i; i11++) {
-                            int i12 = minBlockX + i4 * i + i11;
-                            int i13 = i12 & 15;
-                            double d1 = (double)i11 / (double)i;
-                            noiseChunk.updateForX(i12, d1);
+                        noisechunk.updateForY(j3, d0);
 
-                            for (int i14 = 0; i14 < i; i14++) {
-                                int i15 = minBlockZ + i5 * i + i14;
-                                int i16 = i15 & 15;
-                                double d2 = (double)i14 / (double)i;
-                                noiseChunk.updateForZ(i15, d2);
-                                BlockState interpolatedState = noiseChunk.getInterpolatedState();
-                                if (interpolatedState == null) {
-                                    interpolatedState = this.settings.value().defaultBlock();
+                        for (int i4 = 0; i4 < i1; ++i4) {
+                            int j4 = k + i2 * i1 + i4;
+                            int k4 = j4 & 15;
+                            double d1 = (double) i4 / (double) i1;
+
+                            noisechunk.updateForX(j4, d1);
+
+                            for (int l4 = 0; l4 < i1; ++l4) {
+                                int i5 = l + j2 * i1 + l4;
+                                int j5 = i5 & 15;
+                                double d2 = (double) l4 / (double) i1;
+
+                                noisechunk.updateForZ(i5, d2);
+                                IBlockData iblockdata = noisechunk.getInterpolatedState();
+
+                                if (iblockdata == null) {
+                                    iblockdata = ((NoiseGeneratorSettings) this.settings.value()).defaultBlock();
                                 }
 
-                                BlockState var41 = this.debugPreliminarySurfaceLevel(noiseChunk, i12, i9, i15, interpolatedState);
-                                if (var41 != AIR && !SharedConstants.debugVoidTerrain(chunk.getPos())) {
-                                    section.setBlockState(i13, i10, i16, var41, false);
-                                    heightmapUnprimed.update(i13, i9, i16, var41);
-                                    heightmapUnprimed1.update(i13, i9, i16, var41);
-                                    if (aquifer.shouldScheduleFluidUpdate() && !var41.getFluidState().isEmpty()) {
-                                        mutableBlockPos.set(i12, i9, i15);
-                                        chunk.markPosForPostprocessing(mutableBlockPos);
+                                iblockdata = this.debugPreliminarySurfaceLevel(noisechunk, j4, j3, i5, iblockdata);
+                                if (iblockdata != NoiseBasedChunkGenerator.AIR && !SharedConstants.debugVoidTerrain(chunk.getPos())) {
+                                    chunksection.setBlockState(k4, k3, j5, iblockdata, false);
+                                    heightmap.update(k4, j3, j5, iblockdata);
+                                    heightmap1.update(k4, j3, j5, iblockdata);
+                                    if (aquifer.shouldScheduleFluidUpdate() && !iblockdata.getFluidState().isEmpty()) {
+                                        blockposition_mutableblockposition.set(j4, j3, i5);
+                                        chunk.markPosForPostprocessing(blockposition_mutableblockposition);
                                     }
                                 }
                             }
@@ -402,40 +376,41 @@
                 }
             }
 
-            noiseChunk.swapSlices();
+            noisechunk.swapSlices();
         }
 
-        noiseChunk.stopInterpolation();
+        noisechunk.stopInterpolation();
         return chunk;
     }
 
-    private BlockState debugPreliminarySurfaceLevel(NoiseChunk chunk, int x, int y, int z, BlockState state) {
+    private IBlockData debugPreliminarySurfaceLevel(NoiseChunk chunk, int x, int y, int z, IBlockData state) {
         return state;
     }
 
     @Override
     public int getGenDepth() {
-        return this.settings.value().noiseSettings().height();
+        return ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().height();
     }
 
     @Override
     public int getSeaLevel() {
-        return this.settings.value().seaLevel();
+        return ((NoiseGeneratorSettings) this.settings.value()).seaLevel();
     }
 
     @Override
     public int getMinY() {
-        return this.settings.value().noiseSettings().minY();
+        return ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().minY();
     }
 
     @Override
     public void spawnOriginalMobs(WorldGenRegion level) {
-        if (!this.settings.value().disableMobGeneration()) {
-            ChunkPos center = level.getCenter();
-            Holder<Biome> biome = level.getBiome(center.getWorldPosition().atY(level.getMaxBuildHeight() - 1));
-            WorldgenRandom worldgenRandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
-            worldgenRandom.setDecorationSeed(level.getSeed(), center.getMinBlockX(), center.getMinBlockZ());
-            NaturalSpawner.spawnMobsForChunkGeneration(level, biome, center, worldgenRandom);
+        if (!((NoiseGeneratorSettings) this.settings.value()).disableMobGeneration()) {
+            ChunkPos chunkcoordintpair = level.getCenter();
+            Holder<Biome> holder = level.getBiome(chunkcoordintpair.getWorldPosition().atY(level.getMaxBuildHeight() - 1));
+            WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
+
+            seededrandom.setDecorationSeed(level.getSeed(), chunkcoordintpair.getMinBlockX(), chunkcoordintpair.getMinBlockZ());
+            NaturalSpawner.spawnMobsForChunkGeneration(level, holder, chunkcoordintpair, seededrandom);
         }
     }
 }
