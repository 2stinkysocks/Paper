--- a/net/minecraft/world/level/levelgen/structure/structures/MineshaftPieces.java
+++ b/net/minecraft/world/level/levelgen/structure/structures/MineshaftPieces.java
@@ -2,7 +2,11 @@
 
 import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.DataResult;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -12,7 +16,6 @@
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.tags.BiomeTags;
 import net.minecraft.util.RandomSource;
-import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.vehicle.MinecartChest;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.ChunkPos;
@@ -26,8 +29,7 @@
 import net.minecraft.world.level.block.FenceBlock;
 import net.minecraft.world.level.block.RailBlock;
 import net.minecraft.world.level.block.WallTorchBlock;
-import net.minecraft.world.level.block.entity.SpawnerBlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.RailShape;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -39,6 +41,7 @@
 import org.slf4j.Logger;
 
 public class MineshaftPieces {
+
     static final Logger LOGGER = LogUtils.getLogger();
     private static final int DEFAULT_SHAFT_WIDTH = 3;
     private static final int DEFAULT_SHAFT_HEIGHT = 3;
@@ -48,50 +51,265 @@
     private static final int MAX_DEPTH = 8;
     public static final int MAGIC_START_Y = 50;
 
-    private static MineshaftPieces.MineShaftPiece createRandomShaftPiece(
-        StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int genDepth, MineshaftStructure.Type type
-    ) {
-        int randomInt = random.nextInt(100);
-        if (randomInt >= 80) {
-            BoundingBox boundingBox = MineshaftPieces.MineShaftCrossing.findCrossing(pieces, random, x, y, z, orientation);
-            if (boundingBox != null) {
-                return new MineshaftPieces.MineShaftCrossing(genDepth, boundingBox, orientation, type);
+    public MineshaftPieces() {}
+
+    private static MineshaftPieces.MineShaftPiece createRandomShaftPiece(StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int genDepth, MineshaftStructure.Type type) {
+        int i1 = random.nextInt(100);
+        BoundingBox structureboundingbox;
+
+        if (i1 >= 80) {
+            structureboundingbox = MineshaftPieces.MineShaftCrossing.findCrossing(pieces, random, x, y, z, orientation);
+            if (structureboundingbox != null) {
+                return new MineshaftPieces.MineShaftCrossing(genDepth, structureboundingbox, orientation, type);
             }
-        } else if (randomInt >= 70) {
-            BoundingBox boundingBox = MineshaftPieces.MineShaftStairs.findStairs(pieces, random, x, y, z, orientation);
-            if (boundingBox != null) {
-                return new MineshaftPieces.MineShaftStairs(genDepth, boundingBox, orientation, type);
+        } else if (i1 >= 70) {
+            structureboundingbox = MineshaftPieces.MineShaftStairs.findStairs(pieces, random, x, y, z, orientation);
+            if (structureboundingbox != null) {
+                return new MineshaftPieces.MineShaftStairs(genDepth, structureboundingbox, orientation, type);
             }
         } else {
-            BoundingBox boundingBox = MineshaftPieces.MineShaftCorridor.findCorridorSize(pieces, random, x, y, z, orientation);
-            if (boundingBox != null) {
-                return new MineshaftPieces.MineShaftCorridor(genDepth, random, boundingBox, orientation, type);
+            structureboundingbox = MineshaftPieces.MineShaftCorridor.findCorridorSize(pieces, random, x, y, z, orientation);
+            if (structureboundingbox != null) {
+                return new MineshaftPieces.MineShaftCorridor(genDepth, random, structureboundingbox, orientation, type);
             }
         }
 
         return null;
     }
 
-    static MineshaftPieces.MineShaftPiece generateAndAddPiece(
-        StructurePiece piece, StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction, int genDepth
-    ) {
+    static MineshaftPieces.MineShaftPiece generateAndAddPiece(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction, int genDepth) {
         if (genDepth > 8) {
             return null;
         } else if (Math.abs(x - piece.getBoundingBox().minX()) <= 80 && Math.abs(z - piece.getBoundingBox().minZ()) <= 80) {
-            MineshaftStructure.Type type = ((MineshaftPieces.MineShaftPiece)piece).type;
-            MineshaftPieces.MineShaftPiece mineShaftPiece = createRandomShaftPiece(pieces, random, x, y, z, direction, genDepth + 1, type);
-            if (mineShaftPiece != null) {
-                pieces.addPiece(mineShaftPiece);
-                mineShaftPiece.addChildren(piece, pieces, random);
+            MineshaftStructure.Type mineshaftstructure_a = ((MineshaftPieces.MineShaftPiece) piece).type;
+            MineshaftPieces.MineShaftPiece mineshaftpieces_c = createRandomShaftPiece(pieces, random, x, y, z, direction, genDepth + 1, mineshaftstructure_a);
+
+            if (mineshaftpieces_c != null) {
+                pieces.addPiece(mineshaftpieces_c);
+                mineshaftpieces_c.addChildren(piece, pieces, random);
             }
 
-            return mineShaftPiece;
+            return mineshaftpieces_c;
         } else {
             return null;
         }
     }
 
+    public static class MineShaftCrossing extends MineshaftPieces.MineShaftPiece {
+
+        private final Direction direction;
+        private final boolean isTwoFloored;
+
+        public MineShaftCrossing(CompoundTag tag) {
+            super(StructurePieceType.MINE_SHAFT_CROSSING, tag);
+            this.isTwoFloored = tag.getBoolean("tf");
+            this.direction = Direction.from2DDataValue(tag.getInt("D"));
+        }
+
+        @Override
+        protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag tag) {
+            super.addAdditionalSaveData(context, tag);
+            tag.putBoolean("tf", this.isTwoFloored);
+            tag.putInt("D", this.direction.get2DDataValue());
+        }
+
+        public MineShaftCrossing(int genDepth, BoundingBox boundingBox, @Nullable Direction direction, MineshaftStructure.Type type) {
+            super(StructurePieceType.MINE_SHAFT_CROSSING, genDepth, type, boundingBox);
+            this.direction = direction;
+            this.isTwoFloored = boundingBox.getYSpan() > 3;
+        }
+
+        @Nullable
+        public static BoundingBox findCrossing(StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction) {
+            byte b0;
+
+            if (random.nextInt(4) == 0) {
+                b0 = 6;
+            } else {
+                b0 = 2;
+            }
+
+            BoundingBox structureboundingbox;
+
+            switch (direction) {
+                case NORTH:
+                default:
+                    structureboundingbox = new BoundingBox(-1, 0, -4, 3, b0, 0);
+                    break;
+                case SOUTH:
+                    structureboundingbox = new BoundingBox(-1, 0, 0, 3, b0, 4);
+                    break;
+                case WEST:
+                    structureboundingbox = new BoundingBox(-4, 0, -1, 0, b0, 3);
+                    break;
+                case EAST:
+                    structureboundingbox = new BoundingBox(0, 0, -1, 4, b0, 3);
+            }
+
+            structureboundingbox.move(x, y, z);
+            return pieces.findCollisionPiece(structureboundingbox) != null ? null : structureboundingbox;
+        }
+
+        @Override
+        public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
+            int i = this.getGenDepth();
+
+            switch (this.direction) {
+                case NORTH:
+                default:
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.WEST, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.EAST, i);
+                    break;
+                case SOUTH:
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.WEST, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.EAST, i);
+                    break;
+                case WEST:
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.WEST, i);
+                    break;
+                case EAST:
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.EAST, i);
+            }
+
+            if (this.isTwoFloored) {
+                if (random.nextBoolean()) {
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY() + 3 + 1, this.boundingBox.minZ() - 1, Direction.NORTH, i);
+                }
+
+                if (random.nextBoolean()) {
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + 3 + 1, this.boundingBox.minZ() + 1, Direction.WEST, i);
+                }
+
+                if (random.nextBoolean()) {
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + 3 + 1, this.boundingBox.minZ() + 1, Direction.EAST, i);
+                }
+
+                if (random.nextBoolean()) {
+                    MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY() + 3 + 1, this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
+                }
+            }
+
+        }
+
+        @Override
+        public void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos) {
+            if (!this.isInInvalidLocation(level, box)) {
+                IBlockData iblockdata = this.type.getPlanksState();
+
+                if (this.isTwoFloored) {
+                    this.generateBox(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ(), this.boundingBox.maxX() - 1, this.boundingBox.minY() + 3 - 1, this.boundingBox.maxZ(), MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                    this.generateBox(level, box, this.boundingBox.minX(), this.boundingBox.minY(), this.boundingBox.minZ() + 1, this.boundingBox.maxX(), this.boundingBox.minY() + 3 - 1, this.boundingBox.maxZ() - 1, MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                    this.generateBox(level, box, this.boundingBox.minX() + 1, this.boundingBox.maxY() - 2, this.boundingBox.minZ(), this.boundingBox.maxX() - 1, this.boundingBox.maxY(), this.boundingBox.maxZ(), MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                    this.generateBox(level, box, this.boundingBox.minX(), this.boundingBox.maxY() - 2, this.boundingBox.minZ() + 1, this.boundingBox.maxX(), this.boundingBox.maxY(), this.boundingBox.maxZ() - 1, MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                    this.generateBox(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY() + 3, this.boundingBox.minZ() + 1, this.boundingBox.maxX() - 1, this.boundingBox.minY() + 3, this.boundingBox.maxZ() - 1, MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                } else {
+                    this.generateBox(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ(), this.boundingBox.maxX() - 1, this.boundingBox.maxY(), this.boundingBox.maxZ(), MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                    this.generateBox(level, box, this.boundingBox.minX(), this.boundingBox.minY(), this.boundingBox.minZ() + 1, this.boundingBox.maxX(), this.boundingBox.maxY(), this.boundingBox.maxZ() - 1, MineshaftPieces.MineShaftCrossing.CAVE_AIR, MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+                }
+
+                this.placeSupportPillar(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, this.boundingBox.maxY());
+                this.placeSupportPillar(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() - 1, this.boundingBox.maxY());
+                this.placeSupportPillar(level, box, this.boundingBox.maxX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, this.boundingBox.maxY());
+                this.placeSupportPillar(level, box, this.boundingBox.maxX() - 1, this.boundingBox.minY(), this.boundingBox.maxZ() - 1, this.boundingBox.maxY());
+                int i = this.boundingBox.minY() - 1;
+
+                for (int j = this.boundingBox.minX(); j <= this.boundingBox.maxX(); ++j) {
+                    for (int k = this.boundingBox.minZ(); k <= this.boundingBox.maxZ(); ++k) {
+                        this.setPlanksBlock(level, box, iblockdata, j, i, k);
+                    }
+                }
+
+            }
+        }
+
+        private void placeSupportPillar(WorldGenLevel level, BoundingBox box, int x, int y, int z, int maxY) {
+            if (!this.getBlock(level, x, maxY + 1, z, box).isAir()) {
+                this.generateBox(level, box, x, y, z, x, maxY, z, this.type.getPlanksState(), MineshaftPieces.MineShaftCrossing.CAVE_AIR, false);
+            }
+
+        }
+    }
+
+    public static class MineShaftStairs extends MineshaftPieces.MineShaftPiece {
+
+        public MineShaftStairs(int genDepth, BoundingBox boundingBox, Direction orientation, MineshaftStructure.Type type) {
+            super(StructurePieceType.MINE_SHAFT_STAIRS, genDepth, type, boundingBox);
+            this.setOrientation(orientation);
+        }
+
+        public MineShaftStairs(CompoundTag tag) {
+            super(StructurePieceType.MINE_SHAFT_STAIRS, tag);
+        }
+
+        @Nullable
+        public static BoundingBox findStairs(StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction) {
+            BoundingBox structureboundingbox;
+
+            switch (direction) {
+                case NORTH:
+                default:
+                    structureboundingbox = new BoundingBox(0, -5, -8, 2, 2, 0);
+                    break;
+                case SOUTH:
+                    structureboundingbox = new BoundingBox(0, -5, 0, 2, 2, 8);
+                    break;
+                case WEST:
+                    structureboundingbox = new BoundingBox(-8, -5, 0, 0, 2, 2);
+                    break;
+                case EAST:
+                    structureboundingbox = new BoundingBox(0, -5, 0, 8, 2, 2);
+            }
+
+            structureboundingbox.move(x, y, z);
+            return pieces.findCollisionPiece(structureboundingbox) != null ? null : structureboundingbox;
+        }
+
+        @Override
+        public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
+            int i = this.getGenDepth();
+            Direction enumdirection = this.getOrientation();
+
+            if (enumdirection != null) {
+                switch (enumdirection) {
+                    case NORTH:
+                    default:
+                        MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, i);
+                        break;
+                    case SOUTH:
+                        MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
+                        break;
+                    case WEST:
+                        MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ(), Direction.WEST, i);
+                        break;
+                    case EAST:
+                        MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ(), Direction.EAST, i);
+                }
+            }
+
+        }
+
+        @Override
+        public void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos) {
+            if (!this.isInInvalidLocation(level, box)) {
+                this.generateBox(level, box, 0, 5, 0, 2, 7, 1, MineshaftPieces.MineShaftStairs.CAVE_AIR, MineshaftPieces.MineShaftStairs.CAVE_AIR, false);
+                this.generateBox(level, box, 0, 0, 7, 2, 2, 8, MineshaftPieces.MineShaftStairs.CAVE_AIR, MineshaftPieces.MineShaftStairs.CAVE_AIR, false);
+
+                for (int i = 0; i < 5; ++i) {
+                    this.generateBox(level, box, 0, 5 - i - (i < 4 ? 1 : 0), 2 + i, 2, 7 - i, 2 + i, MineshaftPieces.MineShaftStairs.CAVE_AIR, MineshaftPieces.MineShaftStairs.CAVE_AIR, false);
+                }
+
+            }
+        }
+    }
+
     public static class MineShaftCorridor extends MineshaftPieces.MineShaftPiece {
+
         private final boolean hasRails;
         private final boolean spiderCorridor;
         private boolean hasPlacedSpider;
@@ -124,23 +342,34 @@
             } else {
                 this.numSections = boundingBox.getXSpan() / 5;
             }
+
         }
 
         @Nullable
         public static BoundingBox findCorridorSize(StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction) {
-            for (int i = random.nextInt(3) + 2; i > 0; i--) {
-                int i1 = i * 5;
+            for (int l = random.nextInt(3) + 2; l > 0; --l) {
+                int i1 = l * 5;
+                BoundingBox structureboundingbox;
 
-                BoundingBox boundingBox = switch (direction) {
-                    default -> new BoundingBox(0, 0, -(i1 - 1), 2, 2, 0);
-                    case SOUTH -> new BoundingBox(0, 0, 0, 2, 2, i1 - 1);
-                    case WEST -> new BoundingBox(-(i1 - 1), 0, 0, 0, 2, 2);
-                    case EAST -> new BoundingBox(0, 0, 0, i1 - 1, 2, 2);
-                };
-                boundingBox.move(x, y, z);
-                if (pieces.findCollisionPiece(boundingBox) == null) {
-                    return boundingBox;
+                switch (direction) {
+                    case NORTH:
+                    default:
+                        structureboundingbox = new BoundingBox(0, 0, -(i1 - 1), 2, 2, 0);
+                        break;
+                    case SOUTH:
+                        structureboundingbox = new BoundingBox(0, 0, 0, 2, 2, i1 - 1);
+                        break;
+                    case WEST:
+                        structureboundingbox = new BoundingBox(-(i1 - 1), 0, 0, 0, 2, 2);
+                        break;
+                    case EAST:
+                        structureboundingbox = new BoundingBox(0, 0, 0, i1 - 1, 2, 2);
                 }
+
+                structureboundingbox.move(x, y, z);
+                if (pieces.findCollisionPiece(structureboundingbox) == null) {
+                    return structureboundingbox;
+                }
             }
 
             return null;
@@ -148,202 +377,90 @@
 
         @Override
         public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
-            int genDepth = this.getGenDepth();
-            int randomInt = random.nextInt(4);
-            Direction orientation = this.getOrientation();
-            if (orientation != null) {
-                switch (orientation) {
+            int i = this.getGenDepth();
+            int j = random.nextInt(4);
+            Direction enumdirection = this.getOrientation();
+
+            if (enumdirection != null) {
+                switch (enumdirection) {
                     case NORTH:
                     default:
-                        if (randomInt <= 1) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX(),
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ() - 1,
-                                orientation,
-                                genDepth
-                            );
-                        } else if (randomInt == 2) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX() - 1,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ(),
-                                Direction.WEST,
-                                genDepth
-                            );
+                        if (j <= 1) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ() - 1, enumdirection, i);
+                        } else if (j == 2) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ(), Direction.WEST, i);
                         } else {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.maxX() + 1,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ(),
-                                Direction.EAST,
-                                genDepth
-                            );
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ(), Direction.EAST, i);
                         }
                         break;
                     case SOUTH:
-                        if (randomInt <= 1) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX(),
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.maxZ() + 1,
-                                orientation,
-                                genDepth
-                            );
-                        } else if (randomInt == 2) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX() - 1,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.maxZ() - 3,
-                                Direction.WEST,
-                                genDepth
-                            );
+                        if (j <= 1) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.maxZ() + 1, enumdirection, i);
+                        } else if (j == 2) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.maxZ() - 3, Direction.WEST, i);
                         } else {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.maxX() + 1,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.maxZ() - 3,
-                                Direction.EAST,
-                                genDepth
-                            );
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.maxZ() - 3, Direction.EAST, i);
                         }
                         break;
                     case WEST:
-                        if (randomInt <= 1) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX() - 1,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ(),
-                                orientation,
-                                genDepth
-                            );
-                        } else if (randomInt == 2) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX(),
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ() - 1,
-                                Direction.NORTH,
-                                genDepth
-                            );
+                        if (j <= 1) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ(), enumdirection, i);
+                        } else if (j == 2) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ() - 1, Direction.NORTH, i);
                         } else {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.minX(),
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.maxZ() + 1,
-                                Direction.SOUTH,
-                                genDepth
-                            );
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
                         }
                         break;
                     case EAST:
-                        if (randomInt <= 1) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.maxX() + 1,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ(),
-                                orientation,
-                                genDepth
-                            );
-                        } else if (randomInt == 2) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.maxX() - 3,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.minZ() - 1,
-                                Direction.NORTH,
-                                genDepth
-                            );
+                        if (j <= 1) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ(), enumdirection, i);
+                        } else if (j == 2) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() - 3, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.minZ() - 1, Direction.NORTH, i);
                         } else {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece,
-                                pieces,
-                                random,
-                                this.boundingBox.maxX() - 3,
-                                this.boundingBox.minY() - 1 + random.nextInt(3),
-                                this.boundingBox.maxZ() + 1,
-                                Direction.SOUTH,
-                                genDepth
-                            );
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() - 3, this.boundingBox.minY() - 1 + random.nextInt(3), this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
                         }
                 }
             }
 
-            if (genDepth < 8) {
-                if (orientation != Direction.NORTH && orientation != Direction.SOUTH) {
-                    for (int i = this.boundingBox.minX() + 3; i + 3 <= this.boundingBox.maxX(); i += 5) {
-                        int randomInt1 = random.nextInt(5);
-                        if (randomInt1 == 0) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece, pieces, random, i, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, genDepth + 1
-                            );
-                        } else if (randomInt1 == 1) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece, pieces, random, i, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, genDepth + 1
-                            );
+            if (i < 8) {
+                int k;
+                int l;
+
+                if (enumdirection != Direction.NORTH && enumdirection != Direction.SOUTH) {
+                    for (l = this.boundingBox.minX() + 3; l + 3 <= this.boundingBox.maxX(); l += 5) {
+                        k = random.nextInt(5);
+                        if (k == 0) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, l, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, i + 1);
+                        } else if (k == 1) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, l, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, i + 1);
                         }
                     }
                 } else {
-                    for (int ix = this.boundingBox.minZ() + 3; ix + 3 <= this.boundingBox.maxZ(); ix += 5) {
-                        int randomInt1 = random.nextInt(5);
-                        if (randomInt1 == 0) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), ix, Direction.WEST, genDepth + 1
-                            );
-                        } else if (randomInt1 == 1) {
-                            MineshaftPieces.generateAndAddPiece(
-                                piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), ix, Direction.EAST, genDepth + 1
-                            );
+                    for (l = this.boundingBox.minZ() + 3; l + 3 <= this.boundingBox.maxZ(); l += 5) {
+                        k = random.nextInt(5);
+                        if (k == 0) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), l, Direction.WEST, i + 1);
+                        } else if (k == 1) {
+                            MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), l, Direction.EAST, i + 1);
                         }
                     }
                 }
             }
+
         }
 
         @Override
         protected boolean createChest(WorldGenLevel level, BoundingBox box, RandomSource random, int x, int y, int z, ResourceLocation lootTable) {
-            BlockPos worldPos = this.getWorldPos(x, y, z);
-            if (box.isInside(worldPos) && level.getBlockState(worldPos).isAir() && !level.getBlockState(worldPos.below()).isAir()) {
-                BlockState blockState = Blocks.RAIL
-                    .defaultBlockState()
-                    .setValue(RailBlock.SHAPE, random.nextBoolean() ? RailShape.NORTH_SOUTH : RailShape.EAST_WEST);
-                this.placeBlock(level, blockState, x, y, z, box);
-                MinecartChest minecartChest = new MinecartChest(
-                    level.getLevel(), (double)worldPos.getX() + 0.5, (double)worldPos.getY() + 0.5, (double)worldPos.getZ() + 0.5
-                );
-                minecartChest.setLootTable(lootTable, random.nextLong());
-                level.addFreshEntity(minecartChest);
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+
+            if (box.isInside(blockposition_mutableblockposition) && level.getBlockState(blockposition_mutableblockposition).isAir() && !level.getBlockState(blockposition_mutableblockposition.below()).isAir()) {
+                IBlockData iblockdata = (IBlockData) Blocks.RAIL.defaultBlockState().setValue(RailBlock.SHAPE, random.nextBoolean() ? RailShape.NORTH_SOUTH : RailShape.EAST_WEST);
+
+                this.placeBlock(level, iblockdata, x, y, z, box);
+                MinecartChest entityminecartchest = new MinecartChest(level.getLevel(), (double) blockposition_mutableblockposition.getX() + 0.5D, (double) blockposition_mutableblockposition.getY() + 0.5D, (double) blockposition_mutableblockposition.getZ() + 0.5D);
+
+                entityminecartchest.setLootTable(lootTable, random.nextLong());
+                level.addFreshEntity(entityminecartchest);
                 return true;
             } else {
                 return false;
@@ -351,201 +468,205 @@
         }
 
         @Override
-        public void postProcess(
-            WorldGenLevel level,
-            StructureManager structureManager,
-            ChunkGenerator generator,
-            RandomSource random,
-            BoundingBox box,
-            ChunkPos chunkPos,
-            BlockPos pos
-        ) {
+        public void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos) {
             if (!this.isInInvalidLocation(level, box)) {
-                int i = 0;
-                int i1 = 2;
-                int i2 = 0;
-                int i3 = 2;
-                int i4 = this.numSections * 5 - 1;
-                BlockState planksState = this.type.getPlanksState();
-                this.generateBox(level, box, 0, 0, 0, 2, 1, i4, CAVE_AIR, CAVE_AIR, false);
-                this.generateMaybeBox(level, box, random, 0.8F, 0, 2, 0, 2, 2, i4, CAVE_AIR, CAVE_AIR, false, false);
+                boolean flag = false;
+                boolean flag1 = true;
+                boolean flag2 = false;
+                boolean flag3 = true;
+                int i = this.numSections * 5 - 1;
+                IBlockData iblockdata = this.type.getPlanksState();
+
+                this.generateBox(level, box, 0, 0, 0, 2, 1, i, MineshaftPieces.MineShaftCorridor.CAVE_AIR, MineshaftPieces.MineShaftCorridor.CAVE_AIR, false);
+                this.generateMaybeBox(level, box, random, 0.8F, 0, 2, 0, 2, 2, i, MineshaftPieces.MineShaftCorridor.CAVE_AIR, MineshaftPieces.MineShaftCorridor.CAVE_AIR, false, false);
                 if (this.spiderCorridor) {
-                    this.generateMaybeBox(level, box, random, 0.6F, 0, 0, 0, 2, 1, i4, Blocks.COBWEB.defaultBlockState(), CAVE_AIR, false, true);
+                    this.generateMaybeBox(level, box, random, 0.6F, 0, 0, 0, 2, 1, i, Blocks.COBWEB.defaultBlockState(), MineshaftPieces.MineShaftCorridor.CAVE_AIR, false, true);
                 }
 
-                for (int i5 = 0; i5 < this.numSections; i5++) {
-                    int i6 = 2 + i5 * 5;
-                    this.placeSupport(level, box, 0, 0, i6, 2, 2, random);
-                    this.maybePlaceCobWeb(level, box, random, 0.1F, 0, 2, i6 - 1);
-                    this.maybePlaceCobWeb(level, box, random, 0.1F, 2, 2, i6 - 1);
-                    this.maybePlaceCobWeb(level, box, random, 0.1F, 0, 2, i6 + 1);
-                    this.maybePlaceCobWeb(level, box, random, 0.1F, 2, 2, i6 + 1);
-                    this.maybePlaceCobWeb(level, box, random, 0.05F, 0, 2, i6 - 2);
-                    this.maybePlaceCobWeb(level, box, random, 0.05F, 2, 2, i6 - 2);
-                    this.maybePlaceCobWeb(level, box, random, 0.05F, 0, 2, i6 + 2);
-                    this.maybePlaceCobWeb(level, box, random, 0.05F, 2, 2, i6 + 2);
+                int j;
+                int k;
+
+                for (k = 0; k < this.numSections; ++k) {
+                    j = 2 + k * 5;
+                    this.placeSupport(level, box, 0, 0, j, 2, 2, random);
+                    this.maybePlaceCobWeb(level, box, random, 0.1F, 0, 2, j - 1);
+                    this.maybePlaceCobWeb(level, box, random, 0.1F, 2, 2, j - 1);
+                    this.maybePlaceCobWeb(level, box, random, 0.1F, 0, 2, j + 1);
+                    this.maybePlaceCobWeb(level, box, random, 0.1F, 2, 2, j + 1);
+                    this.maybePlaceCobWeb(level, box, random, 0.05F, 0, 2, j - 2);
+                    this.maybePlaceCobWeb(level, box, random, 0.05F, 2, 2, j - 2);
+                    this.maybePlaceCobWeb(level, box, random, 0.05F, 0, 2, j + 2);
+                    this.maybePlaceCobWeb(level, box, random, 0.05F, 2, 2, j + 2);
                     if (random.nextInt(100) == 0) {
-                        this.createChest(level, box, random, 2, 0, i6 - 1, BuiltInLootTables.ABANDONED_MINESHAFT);
+                        this.createChest(level, box, random, 2, 0, j - 1, BuiltInLootTables.ABANDONED_MINESHAFT);
                     }
 
                     if (random.nextInt(100) == 0) {
-                        this.createChest(level, box, random, 0, 0, i6 + 1, BuiltInLootTables.ABANDONED_MINESHAFT);
+                        this.createChest(level, box, random, 0, 0, j + 1, BuiltInLootTables.ABANDONED_MINESHAFT);
                     }
 
                     if (this.spiderCorridor && !this.hasPlacedSpider) {
-                        int i7 = 1;
-                        int i8 = i6 - 1 + random.nextInt(3);
-                        BlockPos worldPos = this.getWorldPos(1, 0, i8);
-                        if (box.isInside(worldPos) && this.isInterior(level, 1, 0, i8, box)) {
+                        boolean flag4 = true;
+                        int l = j - 1 + random.nextInt(3);
+                        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(1, 0, l);
+
+                        if (box.isInside(blockposition_mutableblockposition) && this.isInterior(level, 1, 0, l, box)) {
                             this.hasPlacedSpider = true;
-                            level.setBlock(worldPos, Blocks.SPAWNER.defaultBlockState(), 2);
-                            if (level.getBlockEntity(worldPos) instanceof SpawnerBlockEntity spawnerBlockEntity) {
-                                spawnerBlockEntity.setEntityId(EntityType.CAVE_SPIDER, random);
+                            // CraftBukkit start
+                            /*
+                            generatoraccessseed.setBlock(blockposition_mutableblockposition, Blocks.SPAWNER.defaultBlockState(), 2);
+                            TileEntity tileentity = generatoraccessseed.getBlockEntity(blockposition_mutableblockposition);
+
+                            if (tileentity instanceof TileEntityMobSpawner) {
+                                TileEntityMobSpawner tileentitymobspawner = (TileEntityMobSpawner) tileentity;
+
+                                tileentitymobspawner.setEntityId(EntityTypes.CAVE_SPIDER, randomsource);
                             }
+                            */
+                            placeCraftSpawner(level, blockposition_mutableblockposition, org.bukkit.entity.EntityType.CAVE_SPIDER, 2);
+                            // CraftBukkit end
                         }
                     }
                 }
 
-                for (int i5 = 0; i5 <= 2; i5++) {
-                    for (int i6x = 0; i6x <= i4; i6x++) {
-                        this.setPlanksBlock(level, box, planksState, i5, -1, i6x);
+                for (k = 0; k <= 2; ++k) {
+                    for (j = 0; j <= i; ++j) {
+                        this.setPlanksBlock(level, box, iblockdata, k, -1, j);
                     }
                 }
 
-                int i5 = 2;
+                boolean flag5 = true;
+
                 this.placeDoubleLowerOrUpperSupport(level, box, 0, -1, 2);
                 if (this.numSections > 1) {
-                    int i6x = i4 - 2;
-                    this.placeDoubleLowerOrUpperSupport(level, box, 0, -1, i6x);
+                    j = i - 2;
+                    this.placeDoubleLowerOrUpperSupport(level, box, 0, -1, j);
                 }
 
                 if (this.hasRails) {
-                    BlockState blockState = Blocks.RAIL.defaultBlockState().setValue(RailBlock.SHAPE, RailShape.NORTH_SOUTH);
+                    IBlockData iblockdata1 = (IBlockData) Blocks.RAIL.defaultBlockState().setValue(RailBlock.SHAPE, RailShape.NORTH_SOUTH);
 
-                    for (int i7 = 0; i7 <= i4; i7++) {
-                        BlockState block = this.getBlock(level, 1, -1, i7, box);
-                        if (!block.isAir() && block.isSolidRender(level, this.getWorldPos(1, -1, i7))) {
-                            float f = this.isInterior(level, 1, 0, i7, box) ? 0.7F : 0.9F;
-                            this.maybeGenerateBlock(level, box, random, f, 1, 0, i7, blockState);
+                    for (int i1 = 0; i1 <= i; ++i1) {
+                        IBlockData iblockdata2 = this.getBlock(level, 1, -1, i1, box);
+
+                        if (!iblockdata2.isAir() && iblockdata2.isSolidRender(level, this.getWorldPos(1, -1, i1))) {
+                            float f = this.isInterior(level, 1, 0, i1, box) ? 0.7F : 0.9F;
+
+                            this.maybeGenerateBlock(level, box, random, f, 1, 0, i1, iblockdata1);
                         }
                     }
                 }
+
             }
         }
 
         private void placeDoubleLowerOrUpperSupport(WorldGenLevel level, BoundingBox box, int x, int y, int z) {
-            BlockState woodState = this.type.getWoodState();
-            BlockState planksState = this.type.getPlanksState();
-            if (this.getBlock(level, x, y, z, box).is(planksState.getBlock())) {
-                this.fillPillarDownOrChainUp(level, woodState, x, y, z, box);
+            IBlockData iblockdata = this.type.getWoodState();
+            IBlockData iblockdata1 = this.type.getPlanksState();
+
+            if (this.getBlock(level, x, y, z, box).is(iblockdata1.getBlock())) {
+                this.fillPillarDownOrChainUp(level, iblockdata, x, y, z, box);
             }
 
-            if (this.getBlock(level, x + 2, y, z, box).is(planksState.getBlock())) {
-                this.fillPillarDownOrChainUp(level, woodState, x + 2, y, z, box);
+            if (this.getBlock(level, x + 2, y, z, box).is(iblockdata1.getBlock())) {
+                this.fillPillarDownOrChainUp(level, iblockdata, x + 2, y, z, box);
             }
+
         }
 
         @Override
-        protected void fillColumnDown(WorldGenLevel level, BlockState state, int x, int y, int z, BoundingBox box) {
-            BlockPos.MutableBlockPos worldPos = this.getWorldPos(x, y, z);
-            if (box.isInside(worldPos)) {
-                int y1 = worldPos.getY();
+        protected void fillColumnDown(WorldGenLevel level, IBlockData state, int x, int y, int z, BoundingBox box) {
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
 
-                while (this.isReplaceableByStructures(level.getBlockState(worldPos)) && worldPos.getY() > level.getMinBuildHeight() + 1) {
-                    worldPos.move(Direction.DOWN);
+            if (box.isInside(blockposition_mutableblockposition)) {
+                int l = blockposition_mutableblockposition.getY();
+
+                while (this.isReplaceableByStructures(level.getBlockState(blockposition_mutableblockposition)) && blockposition_mutableblockposition.getY() > level.getMinBuildHeight() + 1) {
+                    blockposition_mutableblockposition.move(Direction.DOWN);
                 }
 
-                if (this.canPlaceColumnOnTopOf(level, worldPos, level.getBlockState(worldPos))) {
-                    while (worldPos.getY() < y1) {
-                        worldPos.move(Direction.UP);
-                        level.setBlock(worldPos, state, 2);
+                if (this.canPlaceColumnOnTopOf(level, blockposition_mutableblockposition, level.getBlockState(blockposition_mutableblockposition))) {
+                    while (blockposition_mutableblockposition.getY() < l) {
+                        blockposition_mutableblockposition.move(Direction.UP);
+                        level.setBlock(blockposition_mutableblockposition, state, 2);
                     }
+
                 }
             }
         }
 
-        protected void fillPillarDownOrChainUp(WorldGenLevel level, BlockState state, int x, int y, int z, BoundingBox box) {
-            BlockPos.MutableBlockPos worldPos = this.getWorldPos(x, y, z);
-            if (box.isInside(worldPos)) {
-                int y1 = worldPos.getY();
-                int i = 1;
+        protected void fillPillarDownOrChainUp(WorldGenLevel level, IBlockData state, int x, int y, int z, BoundingBox box) {
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+
+            if (box.isInside(blockposition_mutableblockposition)) {
+                int l = blockposition_mutableblockposition.getY();
+                int i1 = 1;
                 boolean flag = true;
 
-                for (boolean flag1 = true; flag || flag1; i++) {
+                for (boolean flag1 = true; flag || flag1; ++i1) {
+                    IBlockData iblockdata1;
+                    boolean flag2;
+
                     if (flag) {
-                        worldPos.setY(y1 - i);
-                        BlockState blockState = level.getBlockState(worldPos);
-                        boolean flag2 = this.isReplaceableByStructures(blockState) && !blockState.is(Blocks.LAVA);
-                        if (!flag2 && this.canPlaceColumnOnTopOf(level, worldPos, blockState)) {
-                            fillColumnBetween(level, state, worldPos, y1 - i + 1, y1);
+                        blockposition_mutableblockposition.setY(l - i1);
+                        iblockdata1 = level.getBlockState(blockposition_mutableblockposition);
+                        flag2 = this.isReplaceableByStructures(iblockdata1) && !iblockdata1.is(Blocks.LAVA);
+                        if (!flag2 && this.canPlaceColumnOnTopOf(level, blockposition_mutableblockposition, iblockdata1)) {
+                            fillColumnBetween(level, state, blockposition_mutableblockposition, l - i1 + 1, l);
                             return;
                         }
 
-                        flag = i <= 20 && flag2 && worldPos.getY() > level.getMinBuildHeight() + 1;
+                        flag = i1 <= 20 && flag2 && blockposition_mutableblockposition.getY() > level.getMinBuildHeight() + 1;
                     }
 
                     if (flag1) {
-                        worldPos.setY(y1 + i);
-                        BlockState blockState = level.getBlockState(worldPos);
-                        boolean flag2 = this.isReplaceableByStructures(blockState);
-                        if (!flag2 && this.canHangChainBelow(level, worldPos, blockState)) {
-                            level.setBlock(worldPos.setY(y1 + 1), this.type.getFenceState(), 2);
-                            fillColumnBetween(level, Blocks.CHAIN.defaultBlockState(), worldPos, y1 + 2, y1 + i);
+                        blockposition_mutableblockposition.setY(l + i1);
+                        iblockdata1 = level.getBlockState(blockposition_mutableblockposition);
+                        flag2 = this.isReplaceableByStructures(iblockdata1);
+                        if (!flag2 && this.canHangChainBelow(level, blockposition_mutableblockposition, iblockdata1)) {
+                            level.setBlock(blockposition_mutableblockposition.setY(l + 1), this.type.getFenceState(), 2);
+                            fillColumnBetween(level, Blocks.CHAIN.defaultBlockState(), blockposition_mutableblockposition, l + 2, l + i1);
                             return;
                         }
 
-                        flag1 = i <= 50 && flag2 && worldPos.getY() < level.getMaxBuildHeight() - 1;
+                        flag1 = i1 <= 50 && flag2 && blockposition_mutableblockposition.getY() < level.getMaxBuildHeight() - 1;
                     }
                 }
+
             }
         }
 
-        private static void fillColumnBetween(WorldGenLevel level, BlockState state, BlockPos.MutableBlockPos pos, int minY, int maxY) {
-            for (int i = minY; i < maxY; i++) {
-                level.setBlock(pos.setY(i), state, 2);
+        private static void fillColumnBetween(WorldGenLevel level, IBlockData state, BlockPos.MutableBlockPos pos, int minY, int maxY) {
+            for (int k = minY; k < maxY; ++k) {
+                level.setBlock(pos.setY(k), state, 2);
             }
+
         }
 
-        private boolean canPlaceColumnOnTopOf(LevelReader level, BlockPos pos, BlockState state) {
+        private boolean canPlaceColumnOnTopOf(LevelReader level, BlockPos pos, IBlockData state) {
             return state.isFaceSturdy(level, pos, Direction.UP);
         }
 
-        private boolean canHangChainBelow(LevelReader level, BlockPos pos, BlockState state) {
+        private boolean canHangChainBelow(LevelReader level, BlockPos pos, IBlockData state) {
             return Block.canSupportCenter(level, pos, Direction.DOWN) && !(state.getBlock() instanceof FallingBlock);
         }
 
         private void placeSupport(WorldGenLevel level, BoundingBox box, int minX, int minY, int z, int maxY, int maxX, RandomSource random) {
             if (this.isSupportingBox(level, box, minX, maxX, maxY, z)) {
-                BlockState planksState = this.type.getPlanksState();
-                BlockState fenceState = this.type.getFenceState();
-                this.generateBox(level, box, minX, minY, z, minX, maxY - 1, z, fenceState.setValue(FenceBlock.WEST, Boolean.valueOf(true)), CAVE_AIR, false);
-                this.generateBox(level, box, maxX, minY, z, maxX, maxY - 1, z, fenceState.setValue(FenceBlock.EAST, Boolean.valueOf(true)), CAVE_AIR, false);
+                IBlockData iblockdata = this.type.getPlanksState();
+                IBlockData iblockdata1 = this.type.getFenceState();
+
+                this.generateBox(level, box, minX, minY, z, minX, maxY - 1, z, (IBlockData) iblockdata1.setValue(FenceBlock.WEST, true), MineshaftPieces.MineShaftCorridor.CAVE_AIR, false);
+                this.generateBox(level, box, maxX, minY, z, maxX, maxY - 1, z, (IBlockData) iblockdata1.setValue(FenceBlock.EAST, true), MineshaftPieces.MineShaftCorridor.CAVE_AIR, false);
                 if (random.nextInt(4) == 0) {
-                    this.generateBox(level, box, minX, maxY, z, minX, maxY, z, planksState, CAVE_AIR, false);
-                    this.generateBox(level, box, maxX, maxY, z, maxX, maxY, z, planksState, CAVE_AIR, false);
+                    this.generateBox(level, box, minX, maxY, z, minX, maxY, z, iblockdata, MineshaftPieces.MineShaftCorridor.CAVE_AIR, false);
+                    this.generateBox(level, box, maxX, maxY, z, maxX, maxY, z, iblockdata, MineshaftPieces.MineShaftCorridor.CAVE_AIR, false);
                 } else {
-                    this.generateBox(level, box, minX, maxY, z, maxX, maxY, z, planksState, CAVE_AIR, false);
-                    this.maybeGenerateBlock(
-                        level,
-                        box,
-                        random,
-                        0.05F,
-                        minX + 1,
-                        maxY,
-                        z - 1,
-                        Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.SOUTH)
-                    );
-                    this.maybeGenerateBlock(
-                        level,
-                        box,
-                        random,
-                        0.05F,
-                        minX + 1,
-                        maxY,
-                        z + 1,
-                        Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.NORTH)
-                    );
+                    this.generateBox(level, box, minX, maxY, z, maxX, maxY, z, iblockdata, MineshaftPieces.MineShaftCorridor.CAVE_AIR, false);
+                    this.maybeGenerateBlock(level, box, random, 0.05F, minX + 1, maxY, z - 1, (IBlockData) Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.SOUTH));
+                    this.maybeGenerateBlock(level, box, random, 0.05F, minX + 1, maxY, z + 1, (IBlockData) Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.NORTH));
                 }
+
             }
         }
 
@@ -553,302 +674,35 @@
             if (this.isInterior(level, x, y, z, box) && random.nextFloat() < chance && this.hasSturdyNeighbours(level, box, x, y, z, 2)) {
                 this.placeBlock(level, Blocks.COBWEB.defaultBlockState(), x, y, z, box);
             }
+
         }
 
         private boolean hasSturdyNeighbours(WorldGenLevel level, BoundingBox box, int x, int y, int z, int required) {
-            BlockPos.MutableBlockPos worldPos = this.getWorldPos(x, y, z);
-            int i = 0;
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+            int i1 = 0;
+            Direction[] aenumdirection = Direction.values();
+            int j1 = aenumdirection.length;
 
-            for (Direction direction : Direction.values()) {
-                worldPos.move(direction);
-                if (box.isInside(worldPos) && level.getBlockState(worldPos).isFaceSturdy(level, worldPos, direction.getOpposite())) {
-                    if (++i >= required) {
+            for (int k1 = 0; k1 < j1; ++k1) {
+                Direction enumdirection = aenumdirection[k1];
+
+                blockposition_mutableblockposition.move(enumdirection);
+                if (box.isInside(blockposition_mutableblockposition) && level.getBlockState(blockposition_mutableblockposition).isFaceSturdy(level, blockposition_mutableblockposition, enumdirection.getOpposite())) {
+                    ++i1;
+                    if (i1 >= required) {
                         return true;
                     }
                 }
 
-                worldPos.move(direction.getOpposite());
+                blockposition_mutableblockposition.move(enumdirection.getOpposite());
             }
 
             return false;
         }
     }
 
-    public static class MineShaftCrossing extends MineshaftPieces.MineShaftPiece {
-        private final Direction direction;
-        private final boolean isTwoFloored;
+    private abstract static class MineShaftPiece extends StructurePiece {
 
-        public MineShaftCrossing(CompoundTag tag) {
-            super(StructurePieceType.MINE_SHAFT_CROSSING, tag);
-            this.isTwoFloored = tag.getBoolean("tf");
-            this.direction = Direction.from2DDataValue(tag.getInt("D"));
-        }
-
-        @Override
-        protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag tag) {
-            super.addAdditionalSaveData(context, tag);
-            tag.putBoolean("tf", this.isTwoFloored);
-            tag.putInt("D", this.direction.get2DDataValue());
-        }
-
-        public MineShaftCrossing(int genDepth, BoundingBox boundingBox, @Nullable Direction direction, MineshaftStructure.Type type) {
-            super(StructurePieceType.MINE_SHAFT_CROSSING, genDepth, type, boundingBox);
-            this.direction = direction;
-            this.isTwoFloored = boundingBox.getYSpan() > 3;
-        }
-
-        @Nullable
-        public static BoundingBox findCrossing(StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction) {
-            int i;
-            if (random.nextInt(4) == 0) {
-                i = 6;
-            } else {
-                i = 2;
-            }
-            BoundingBox boundingBox = switch (direction) {
-                default -> new BoundingBox(-1, 0, -4, 3, i, 0);
-                case SOUTH -> new BoundingBox(-1, 0, 0, 3, i, 4);
-                case WEST -> new BoundingBox(-4, 0, -1, 0, i, 3);
-                case EAST -> new BoundingBox(0, 0, -1, 4, i, 3);
-            };
-            boundingBox.move(x, y, z);
-            return pieces.findCollisionPiece(boundingBox) != null ? null : boundingBox;
-        }
-
-        @Override
-        public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
-            int genDepth = this.getGenDepth();
-            switch (this.direction) {
-                case NORTH:
-                default:
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.WEST, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.EAST, genDepth
-                    );
-                    break;
-                case SOUTH:
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.WEST, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.EAST, genDepth
-                    );
-                    break;
-                case WEST:
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.WEST, genDepth
-                    );
-                    break;
-                case EAST:
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, genDepth
-                    );
-                    MineshaftPieces.generateAndAddPiece(
-                        piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, Direction.EAST, genDepth
-                    );
-            }
-
-            if (this.isTwoFloored) {
-                if (random.nextBoolean()) {
-                    MineshaftPieces.generateAndAddPiece(
-                        piece,
-                        pieces,
-                        random,
-                        this.boundingBox.minX() + 1,
-                        this.boundingBox.minY() + 3 + 1,
-                        this.boundingBox.minZ() - 1,
-                        Direction.NORTH,
-                        genDepth
-                    );
-                }
-
-                if (random.nextBoolean()) {
-                    MineshaftPieces.generateAndAddPiece(
-                        piece,
-                        pieces,
-                        random,
-                        this.boundingBox.minX() - 1,
-                        this.boundingBox.minY() + 3 + 1,
-                        this.boundingBox.minZ() + 1,
-                        Direction.WEST,
-                        genDepth
-                    );
-                }
-
-                if (random.nextBoolean()) {
-                    MineshaftPieces.generateAndAddPiece(
-                        piece,
-                        pieces,
-                        random,
-                        this.boundingBox.maxX() + 1,
-                        this.boundingBox.minY() + 3 + 1,
-                        this.boundingBox.minZ() + 1,
-                        Direction.EAST,
-                        genDepth
-                    );
-                }
-
-                if (random.nextBoolean()) {
-                    MineshaftPieces.generateAndAddPiece(
-                        piece,
-                        pieces,
-                        random,
-                        this.boundingBox.minX() + 1,
-                        this.boundingBox.minY() + 3 + 1,
-                        this.boundingBox.maxZ() + 1,
-                        Direction.SOUTH,
-                        genDepth
-                    );
-                }
-            }
-        }
-
-        @Override
-        public void postProcess(
-            WorldGenLevel level,
-            StructureManager structureManager,
-            ChunkGenerator generator,
-            RandomSource random,
-            BoundingBox box,
-            ChunkPos chunkPos,
-            BlockPos pos
-        ) {
-            if (!this.isInInvalidLocation(level, box)) {
-                BlockState planksState = this.type.getPlanksState();
-                if (this.isTwoFloored) {
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX() + 1,
-                        this.boundingBox.minY(),
-                        this.boundingBox.minZ(),
-                        this.boundingBox.maxX() - 1,
-                        this.boundingBox.minY() + 3 - 1,
-                        this.boundingBox.maxZ(),
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX(),
-                        this.boundingBox.minY(),
-                        this.boundingBox.minZ() + 1,
-                        this.boundingBox.maxX(),
-                        this.boundingBox.minY() + 3 - 1,
-                        this.boundingBox.maxZ() - 1,
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX() + 1,
-                        this.boundingBox.maxY() - 2,
-                        this.boundingBox.minZ(),
-                        this.boundingBox.maxX() - 1,
-                        this.boundingBox.maxY(),
-                        this.boundingBox.maxZ(),
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX(),
-                        this.boundingBox.maxY() - 2,
-                        this.boundingBox.minZ() + 1,
-                        this.boundingBox.maxX(),
-                        this.boundingBox.maxY(),
-                        this.boundingBox.maxZ() - 1,
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX() + 1,
-                        this.boundingBox.minY() + 3,
-                        this.boundingBox.minZ() + 1,
-                        this.boundingBox.maxX() - 1,
-                        this.boundingBox.minY() + 3,
-                        this.boundingBox.maxZ() - 1,
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                } else {
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX() + 1,
-                        this.boundingBox.minY(),
-                        this.boundingBox.minZ(),
-                        this.boundingBox.maxX() - 1,
-                        this.boundingBox.maxY(),
-                        this.boundingBox.maxZ(),
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                    this.generateBox(
-                        level,
-                        box,
-                        this.boundingBox.minX(),
-                        this.boundingBox.minY(),
-                        this.boundingBox.minZ() + 1,
-                        this.boundingBox.maxX(),
-                        this.boundingBox.maxY(),
-                        this.boundingBox.maxZ() - 1,
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
-                }
-
-                this.placeSupportPillar(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, this.boundingBox.maxY());
-                this.placeSupportPillar(level, box, this.boundingBox.minX() + 1, this.boundingBox.minY(), this.boundingBox.maxZ() - 1, this.boundingBox.maxY());
-                this.placeSupportPillar(level, box, this.boundingBox.maxX() - 1, this.boundingBox.minY(), this.boundingBox.minZ() + 1, this.boundingBox.maxY());
-                this.placeSupportPillar(level, box, this.boundingBox.maxX() - 1, this.boundingBox.minY(), this.boundingBox.maxZ() - 1, this.boundingBox.maxY());
-                int i = this.boundingBox.minY() - 1;
-
-                for (int i1 = this.boundingBox.minX(); i1 <= this.boundingBox.maxX(); i1++) {
-                    for (int i2 = this.boundingBox.minZ(); i2 <= this.boundingBox.maxZ(); i2++) {
-                        this.setPlanksBlock(level, box, planksState, i1, i, i2);
-                    }
-                }
-            }
-        }
-
-        private void placeSupportPillar(WorldGenLevel level, BoundingBox box, int x, int y, int z, int maxY) {
-            if (!this.getBlock(level, x, maxY + 1, z, box).isAir()) {
-                this.generateBox(level, box, x, y, z, x, maxY, z, this.type.getPlanksState(), CAVE_AIR, false);
-            }
-        }
-    }
-
-    abstract static class MineShaftPiece extends StructurePiece {
         protected MineshaftStructure.Type type;
 
         public MineShaftPiece(StructurePieceType structurePieceType, int genDepth, MineshaftStructure.Type type, BoundingBox boundingBox) {
@@ -863,11 +717,9 @@
 
         @Override
         protected boolean canBeReplaced(LevelReader level, int x, int y, int z, BoundingBox box) {
-            BlockState block = this.getBlock(level, x, y, z, box);
-            return !block.is(this.type.getPlanksState().getBlock())
-                && !block.is(this.type.getWoodState().getBlock())
-                && !block.is(this.type.getFenceState().getBlock())
-                && !block.is(Blocks.CHAIN);
+            IBlockData iblockdata = this.getBlock(level, x, y, z, box);
+
+            return !iblockdata.is(this.type.getPlanksState().getBlock()) && !iblockdata.is(this.type.getWoodState().getBlock()) && !iblockdata.is(this.type.getFenceState().getBlock()) && !iblockdata.is(Blocks.CHAIN);
         }
 
         @Override
@@ -876,8 +728,8 @@
         }
 
         protected boolean isSupportingBox(BlockGetter level, BoundingBox box, int xStart, int xEnd, int y, int z) {
-            for (int i = xStart; i <= xEnd; i++) {
-                if (this.getBlock(level, i, y + 1, z, box).isAir()) {
+            for (int i1 = xStart; i1 <= xEnd; ++i1) {
+                if (this.getBlock(level, i1, y + 1, z, box).isAir()) {
                     return false;
                 }
             }
@@ -886,47 +738,51 @@
         }
 
         protected boolean isInInvalidLocation(LevelAccessor level, BoundingBox boundingBox) {
-            int max = Math.max(this.boundingBox.minX() - 1, boundingBox.minX());
-            int max1 = Math.max(this.boundingBox.minY() - 1, boundingBox.minY());
-            int max2 = Math.max(this.boundingBox.minZ() - 1, boundingBox.minZ());
-            int min = Math.min(this.boundingBox.maxX() + 1, boundingBox.maxX());
-            int min1 = Math.min(this.boundingBox.maxY() + 1, boundingBox.maxY());
-            int min2 = Math.min(this.boundingBox.maxZ() + 1, boundingBox.maxZ());
-            BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos((max + min) / 2, (max1 + min1) / 2, (max2 + min2) / 2);
-            if (level.getBiome(mutableBlockPos).is(BiomeTags.MINESHAFT_BLOCKING)) {
+            int i = Math.max(this.boundingBox.minX() - 1, boundingBox.minX());
+            int j = Math.max(this.boundingBox.minY() - 1, boundingBox.minY());
+            int k = Math.max(this.boundingBox.minZ() - 1, boundingBox.minZ());
+            int l = Math.min(this.boundingBox.maxX() + 1, boundingBox.maxX());
+            int i1 = Math.min(this.boundingBox.maxY() + 1, boundingBox.maxY());
+            int j1 = Math.min(this.boundingBox.maxZ() + 1, boundingBox.maxZ());
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos((i + l) / 2, (j + i1) / 2, (k + j1) / 2);
+
+            if (level.getBiome(blockposition_mutableblockposition).is(BiomeTags.MINESHAFT_BLOCKING)) {
                 return true;
             } else {
-                for (int i = max; i <= min; i++) {
-                    for (int i1 = max2; i1 <= min2; i1++) {
-                        if (level.getBlockState(mutableBlockPos.set(i, max1, i1)).liquid()) {
+                int k1;
+                int l1;
+
+                for (k1 = i; k1 <= l; ++k1) {
+                    for (l1 = k; l1 <= j1; ++l1) {
+                        if (level.getBlockState(blockposition_mutableblockposition.set(k1, j, l1)).liquid()) {
                             return true;
                         }
 
-                        if (level.getBlockState(mutableBlockPos.set(i, min1, i1)).liquid()) {
+                        if (level.getBlockState(blockposition_mutableblockposition.set(k1, i1, l1)).liquid()) {
                             return true;
                         }
                     }
                 }
 
-                for (int i = max; i <= min; i++) {
-                    for (int i1 = max1; i1 <= min1; i1++) {
-                        if (level.getBlockState(mutableBlockPos.set(i, i1, max2)).liquid()) {
+                for (k1 = i; k1 <= l; ++k1) {
+                    for (l1 = j; l1 <= i1; ++l1) {
+                        if (level.getBlockState(blockposition_mutableblockposition.set(k1, l1, k)).liquid()) {
                             return true;
                         }
 
-                        if (level.getBlockState(mutableBlockPos.set(i, i1, min2)).liquid()) {
+                        if (level.getBlockState(blockposition_mutableblockposition.set(k1, l1, j1)).liquid()) {
                             return true;
                         }
                     }
                 }
 
-                for (int i = max2; i <= min2; i++) {
-                    for (int i1 = max1; i1 <= min1; i1++) {
-                        if (level.getBlockState(mutableBlockPos.set(max, i1, i)).liquid()) {
+                for (k1 = k; k1 <= j1; ++k1) {
+                    for (l1 = j; l1 <= i1; ++l1) {
+                        if (level.getBlockState(blockposition_mutableblockposition.set(i, l1, k1)).liquid()) {
                             return true;
                         }
 
-                        if (level.getBlockState(mutableBlockPos.set(min, i1, i)).liquid()) {
+                        if (level.getBlockState(blockposition_mutableblockposition.set(l, l1, k1)).liquid()) {
                             return true;
                         }
                     }
@@ -936,338 +792,147 @@
             }
         }
 
-        protected void setPlanksBlock(WorldGenLevel level, BoundingBox box, BlockState plankState, int x, int y, int z) {
+        protected void setPlanksBlock(WorldGenLevel level, BoundingBox box, IBlockData plankState, int x, int y, int z) {
             if (this.isInterior(level, x, y, z, box)) {
-                BlockPos worldPos = this.getWorldPos(x, y, z);
-                BlockState blockState = level.getBlockState(worldPos);
-                if (!blockState.isFaceSturdy(level, worldPos, Direction.UP)) {
-                    level.setBlock(worldPos, plankState, 2);
+                BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+                IBlockData iblockdata1 = level.getBlockState(blockposition_mutableblockposition);
+
+                if (!iblockdata1.isFaceSturdy(level, blockposition_mutableblockposition, Direction.UP)) {
+                    level.setBlock(blockposition_mutableblockposition, plankState, 2);
                 }
+
             }
         }
     }
 
     public static class MineShaftRoom extends MineshaftPieces.MineShaftPiece {
+
         private final List<BoundingBox> childEntranceBoxes = Lists.newLinkedList();
 
         public MineShaftRoom(int genDepth, RandomSource random, int x, int z, MineshaftStructure.Type type) {
-            super(
-                StructurePieceType.MINE_SHAFT_ROOM,
-                genDepth,
-                type,
-                new BoundingBox(x, 50, z, x + 7 + random.nextInt(6), 54 + random.nextInt(6), z + 7 + random.nextInt(6))
-            );
+            super(StructurePieceType.MINE_SHAFT_ROOM, genDepth, type, new BoundingBox(x, 50, z, x + 7 + random.nextInt(6), 54 + random.nextInt(6), z + 7 + random.nextInt(6)));
             this.type = type;
         }
 
         public MineShaftRoom(CompoundTag tag) {
             super(StructurePieceType.MINE_SHAFT_ROOM, tag);
-            BoundingBox.CODEC
-                .listOf()
-                .parse(NbtOps.INSTANCE, tag.getList("Entrances", 11))
-                .resultOrPartial(MineshaftPieces.LOGGER::error)
-                .ifPresent(this.childEntranceBoxes::addAll);
+            DataResult<List<BoundingBox>> dataresult = BoundingBox.CODEC.listOf().parse(NbtOps.INSTANCE, tag.getList("Entrances", 11)); // CraftBukkit - decompile error
+            Logger logger = MineshaftPieces.LOGGER;
+
+            Objects.requireNonNull(logger);
+            Optional<List<BoundingBox>> optional = dataresult.resultOrPartial(logger::error); // CraftBukkit - decompile error
+            List list = this.childEntranceBoxes;
+
+            Objects.requireNonNull(this.childEntranceBoxes);
+            optional.ifPresent(list::addAll);
         }
 
         @Override
         public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
-            int genDepth = this.getGenDepth();
-            int i = this.boundingBox.getYSpan() - 3 - 1;
-            if (i <= 0) {
-                i = 1;
+            int i = this.getGenDepth();
+            int j = this.boundingBox.getYSpan() - 3 - 1;
+
+            if (j <= 0) {
+                j = 1;
             }
 
-            int i1 = 0;
+            int k;
+            MineshaftPieces.MineShaftPiece mineshaftpieces_c;
+            BoundingBox structureboundingbox;
 
-            while (i1 < this.boundingBox.getXSpan()) {
-                int var9 = i1 + random.nextInt(this.boundingBox.getXSpan());
-                if (var9 + 3 > this.boundingBox.getXSpan()) {
+            for (k = 0; k < this.boundingBox.getXSpan(); k += 4) {
+                k += random.nextInt(this.boundingBox.getXSpan());
+                if (k + 3 > this.boundingBox.getXSpan()) {
                     break;
                 }
 
-                MineshaftPieces.MineShaftPiece mineShaftPiece = MineshaftPieces.generateAndAddPiece(
-                    piece,
-                    pieces,
-                    random,
-                    this.boundingBox.minX() + var9,
-                    this.boundingBox.minY() + random.nextInt(i) + 1,
-                    this.boundingBox.minZ() - 1,
-                    Direction.NORTH,
-                    genDepth
-                );
-                if (mineShaftPiece != null) {
-                    BoundingBox boundingBox = mineShaftPiece.getBoundingBox();
-                    this.childEntranceBoxes
-                        .add(
-                            new BoundingBox(
-                                boundingBox.minX(),
-                                boundingBox.minY(),
-                                this.boundingBox.minZ(),
-                                boundingBox.maxX(),
-                                boundingBox.maxY(),
-                                this.boundingBox.minZ() + 1
-                            )
-                        );
+                mineshaftpieces_c = MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + k, this.boundingBox.minY() + random.nextInt(j) + 1, this.boundingBox.minZ() - 1, Direction.NORTH, i);
+                if (mineshaftpieces_c != null) {
+                    structureboundingbox = mineshaftpieces_c.getBoundingBox();
+                    this.childEntranceBoxes.add(new BoundingBox(structureboundingbox.minX(), structureboundingbox.minY(), this.boundingBox.minZ(), structureboundingbox.maxX(), structureboundingbox.maxY(), this.boundingBox.minZ() + 1));
                 }
-
-                i1 = var9 + 4;
             }
 
-            int var10 = 0;
-
-            while (var10 < this.boundingBox.getXSpan()) {
-                i1 = var10 + random.nextInt(this.boundingBox.getXSpan());
-                if (i1 + 3 > this.boundingBox.getXSpan()) {
+            for (k = 0; k < this.boundingBox.getXSpan(); k += 4) {
+                k += random.nextInt(this.boundingBox.getXSpan());
+                if (k + 3 > this.boundingBox.getXSpan()) {
                     break;
                 }
 
-                MineshaftPieces.MineShaftPiece mineShaftPiece = MineshaftPieces.generateAndAddPiece(
-                    piece,
-                    pieces,
-                    random,
-                    this.boundingBox.minX() + i1,
-                    this.boundingBox.minY() + random.nextInt(i) + 1,
-                    this.boundingBox.maxZ() + 1,
-                    Direction.SOUTH,
-                    genDepth
-                );
-                if (mineShaftPiece != null) {
-                    BoundingBox boundingBox = mineShaftPiece.getBoundingBox();
-                    this.childEntranceBoxes
-                        .add(
-                            new BoundingBox(
-                                boundingBox.minX(),
-                                boundingBox.minY(),
-                                this.boundingBox.maxZ() - 1,
-                                boundingBox.maxX(),
-                                boundingBox.maxY(),
-                                this.boundingBox.maxZ()
-                            )
-                        );
+                mineshaftpieces_c = MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() + k, this.boundingBox.minY() + random.nextInt(j) + 1, this.boundingBox.maxZ() + 1, Direction.SOUTH, i);
+                if (mineshaftpieces_c != null) {
+                    structureboundingbox = mineshaftpieces_c.getBoundingBox();
+                    this.childEntranceBoxes.add(new BoundingBox(structureboundingbox.minX(), structureboundingbox.minY(), this.boundingBox.maxZ() - 1, structureboundingbox.maxX(), structureboundingbox.maxY(), this.boundingBox.maxZ()));
                 }
-
-                var10 = i1 + 4;
             }
 
-            int var12 = 0;
-
-            while (var12 < this.boundingBox.getZSpan()) {
-                i1 = var12 + random.nextInt(this.boundingBox.getZSpan());
-                if (i1 + 3 > this.boundingBox.getZSpan()) {
+            for (k = 0; k < this.boundingBox.getZSpan(); k += 4) {
+                k += random.nextInt(this.boundingBox.getZSpan());
+                if (k + 3 > this.boundingBox.getZSpan()) {
                     break;
                 }
 
-                MineshaftPieces.MineShaftPiece mineShaftPiece = MineshaftPieces.generateAndAddPiece(
-                    piece,
-                    pieces,
-                    random,
-                    this.boundingBox.minX() - 1,
-                    this.boundingBox.minY() + random.nextInt(i) + 1,
-                    this.boundingBox.minZ() + i1,
-                    Direction.WEST,
-                    genDepth
-                );
-                if (mineShaftPiece != null) {
-                    BoundingBox boundingBox = mineShaftPiece.getBoundingBox();
-                    this.childEntranceBoxes
-                        .add(
-                            new BoundingBox(
-                                this.boundingBox.minX(),
-                                boundingBox.minY(),
-                                boundingBox.minZ(),
-                                this.boundingBox.minX() + 1,
-                                boundingBox.maxY(),
-                                boundingBox.maxZ()
-                            )
-                        );
+                mineshaftpieces_c = MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + random.nextInt(j) + 1, this.boundingBox.minZ() + k, Direction.WEST, i);
+                if (mineshaftpieces_c != null) {
+                    structureboundingbox = mineshaftpieces_c.getBoundingBox();
+                    this.childEntranceBoxes.add(new BoundingBox(this.boundingBox.minX(), structureboundingbox.minY(), structureboundingbox.minZ(), this.boundingBox.minX() + 1, structureboundingbox.maxY(), structureboundingbox.maxZ()));
                 }
-
-                var12 = i1 + 4;
             }
 
-            int var14 = 0;
-
-            while (var14 < this.boundingBox.getZSpan()) {
-                i1 = var14 + random.nextInt(this.boundingBox.getZSpan());
-                if (i1 + 3 > this.boundingBox.getZSpan()) {
+            for (k = 0; k < this.boundingBox.getZSpan(); k += 4) {
+                k += random.nextInt(this.boundingBox.getZSpan());
+                if (k + 3 > this.boundingBox.getZSpan()) {
                     break;
                 }
 
-                StructurePiece structurePiece = MineshaftPieces.generateAndAddPiece(
-                    piece,
-                    pieces,
-                    random,
-                    this.boundingBox.maxX() + 1,
-                    this.boundingBox.minY() + random.nextInt(i) + 1,
-                    this.boundingBox.minZ() + i1,
-                    Direction.EAST,
-                    genDepth
-                );
-                if (structurePiece != null) {
-                    BoundingBox boundingBox = structurePiece.getBoundingBox();
-                    this.childEntranceBoxes
-                        .add(
-                            new BoundingBox(
-                                this.boundingBox.maxX() - 1,
-                                boundingBox.minY(),
-                                boundingBox.minZ(),
-                                this.boundingBox.maxX(),
-                                boundingBox.maxY(),
-                                boundingBox.maxZ()
-                            )
-                        );
+                mineshaftpieces_c = MineshaftPieces.generateAndAddPiece(piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + random.nextInt(j) + 1, this.boundingBox.minZ() + k, Direction.EAST, i);
+                if (mineshaftpieces_c != null) {
+                    structureboundingbox = mineshaftpieces_c.getBoundingBox();
+                    this.childEntranceBoxes.add(new BoundingBox(this.boundingBox.maxX() - 1, structureboundingbox.minY(), structureboundingbox.minZ(), this.boundingBox.maxX(), structureboundingbox.maxY(), structureboundingbox.maxZ()));
                 }
-
-                var14 = i1 + 4;
             }
+
         }
 
         @Override
-        public void postProcess(
-            WorldGenLevel level,
-            StructureManager structureManager,
-            ChunkGenerator generator,
-            RandomSource random,
-            BoundingBox box,
-            ChunkPos chunkPos,
-            BlockPos pos
-        ) {
+        public void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos) {
             if (!this.isInInvalidLocation(level, box)) {
-                this.generateBox(
-                    level,
-                    box,
-                    this.boundingBox.minX(),
-                    this.boundingBox.minY() + 1,
-                    this.boundingBox.minZ(),
-                    this.boundingBox.maxX(),
-                    Math.min(this.boundingBox.minY() + 3, this.boundingBox.maxY()),
-                    this.boundingBox.maxZ(),
-                    CAVE_AIR,
-                    CAVE_AIR,
-                    false
-                );
+                this.generateBox(level, box, this.boundingBox.minX(), this.boundingBox.minY() + 1, this.boundingBox.minZ(), this.boundingBox.maxX(), Math.min(this.boundingBox.minY() + 3, this.boundingBox.maxY()), this.boundingBox.maxZ(), MineshaftPieces.MineShaftRoom.CAVE_AIR, MineshaftPieces.MineShaftRoom.CAVE_AIR, false);
+                Iterator iterator = this.childEntranceBoxes.iterator();
 
-                for (BoundingBox boundingBox : this.childEntranceBoxes) {
-                    this.generateBox(
-                        level,
-                        box,
-                        boundingBox.minX(),
-                        boundingBox.maxY() - 2,
-                        boundingBox.minZ(),
-                        boundingBox.maxX(),
-                        boundingBox.maxY(),
-                        boundingBox.maxZ(),
-                        CAVE_AIR,
-                        CAVE_AIR,
-                        false
-                    );
+                while (iterator.hasNext()) {
+                    BoundingBox structureboundingbox1 = (BoundingBox) iterator.next();
+
+                    this.generateBox(level, box, structureboundingbox1.minX(), structureboundingbox1.maxY() - 2, structureboundingbox1.minZ(), structureboundingbox1.maxX(), structureboundingbox1.maxY(), structureboundingbox1.maxZ(), MineshaftPieces.MineShaftRoom.CAVE_AIR, MineshaftPieces.MineShaftRoom.CAVE_AIR, false);
                 }
 
-                this.generateUpperHalfSphere(
-                    level,
-                    box,
-                    this.boundingBox.minX(),
-                    this.boundingBox.minY() + 4,
-                    this.boundingBox.minZ(),
-                    this.boundingBox.maxX(),
-                    this.boundingBox.maxY(),
-                    this.boundingBox.maxZ(),
-                    CAVE_AIR,
-                    false
-                );
+                this.generateUpperHalfSphere(level, box, this.boundingBox.minX(), this.boundingBox.minY() + 4, this.boundingBox.minZ(), this.boundingBox.maxX(), this.boundingBox.maxY(), this.boundingBox.maxZ(), MineshaftPieces.MineShaftRoom.CAVE_AIR, false);
             }
         }
 
         @Override
         public void move(int x, int y, int z) {
             super.move(x, y, z);
+            Iterator iterator = this.childEntranceBoxes.iterator();
 
-            for (BoundingBox boundingBox : this.childEntranceBoxes) {
-                boundingBox.move(x, y, z);
+            while (iterator.hasNext()) {
+                BoundingBox structureboundingbox = (BoundingBox) iterator.next();
+
+                structureboundingbox.move(x, y, z);
             }
+
         }
 
         @Override
         protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag tag) {
             super.addAdditionalSaveData(context, tag);
-            BoundingBox.CODEC
-                .listOf()
-                .encodeStart(NbtOps.INSTANCE, this.childEntranceBoxes)
-                .resultOrPartial(MineshaftPieces.LOGGER::error)
-                .ifPresent(tag1 -> tag.put("Entrances", tag1));
-        }
-    }
+            DataResult<Tag> dataresult = BoundingBox.CODEC.listOf().encodeStart(NbtOps.INSTANCE, this.childEntranceBoxes); // CraftBukkit - decompile error
+            Logger logger = MineshaftPieces.LOGGER;
 
-    public static class MineShaftStairs extends MineshaftPieces.MineShaftPiece {
-        public MineShaftStairs(int genDepth, BoundingBox boundingBox, Direction orientation, MineshaftStructure.Type type) {
-            super(StructurePieceType.MINE_SHAFT_STAIRS, genDepth, type, boundingBox);
-            this.setOrientation(orientation);
+            Objects.requireNonNull(logger);
+            dataresult.resultOrPartial(logger::error).ifPresent((nbtbase) -> {
+                tag.put("Entrances", nbtbase);
+            });
         }
-
-        public MineShaftStairs(CompoundTag tag) {
-            super(StructurePieceType.MINE_SHAFT_STAIRS, tag);
-        }
-
-        @Nullable
-        public static BoundingBox findStairs(StructurePieceAccessor pieces, RandomSource random, int x, int y, int z, Direction direction) {
-            BoundingBox boundingBox = switch (direction) {
-                default -> new BoundingBox(0, -5, -8, 2, 2, 0);
-                case SOUTH -> new BoundingBox(0, -5, 0, 2, 2, 8);
-                case WEST -> new BoundingBox(-8, -5, 0, 0, 2, 2);
-                case EAST -> new BoundingBox(0, -5, 0, 8, 2, 2);
-            };
-            boundingBox.move(x, y, z);
-            return pieces.findCollisionPiece(boundingBox) != null ? null : boundingBox;
-        }
-
-        @Override
-        public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
-            int genDepth = this.getGenDepth();
-            Direction orientation = this.getOrientation();
-            if (orientation != null) {
-                switch (orientation) {
-                    case NORTH:
-                    default:
-                        MineshaftPieces.generateAndAddPiece(
-                            piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY(), this.boundingBox.minZ() - 1, Direction.NORTH, genDepth
-                        );
-                        break;
-                    case SOUTH:
-                        MineshaftPieces.generateAndAddPiece(
-                            piece, pieces, random, this.boundingBox.minX(), this.boundingBox.minY(), this.boundingBox.maxZ() + 1, Direction.SOUTH, genDepth
-                        );
-                        break;
-                    case WEST:
-                        MineshaftPieces.generateAndAddPiece(
-                            piece, pieces, random, this.boundingBox.minX() - 1, this.boundingBox.minY(), this.boundingBox.minZ(), Direction.WEST, genDepth
-                        );
-                        break;
-                    case EAST:
-                        MineshaftPieces.generateAndAddPiece(
-                            piece, pieces, random, this.boundingBox.maxX() + 1, this.boundingBox.minY(), this.boundingBox.minZ(), Direction.EAST, genDepth
-                        );
-                }
-            }
-        }
-
-        @Override
-        public void postProcess(
-            WorldGenLevel level,
-            StructureManager structureManager,
-            ChunkGenerator generator,
-            RandomSource random,
-            BoundingBox box,
-            ChunkPos chunkPos,
-            BlockPos pos
-        ) {
-            if (!this.isInInvalidLocation(level, box)) {
-                this.generateBox(level, box, 0, 5, 0, 2, 7, 1, CAVE_AIR, CAVE_AIR, false);
-                this.generateBox(level, box, 0, 0, 7, 2, 2, 8, CAVE_AIR, CAVE_AIR, false);
-
-                for (int i = 0; i < 5; i++) {
-                    this.generateBox(level, box, 0, 5 - i - (i < 4 ? 1 : 0), 2 + i, 2, 7 - i, 2 + i, CAVE_AIR, CAVE_AIR, false);
-                }
-            }
-        }
     }
 }
