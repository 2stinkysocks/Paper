--- a/net/minecraft/world/level/levelgen/structure/StructurePiece.java
+++ b/net/minecraft/world/level/levelgen/structure/StructurePiece.java
@@ -2,7 +2,10 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.DataResult;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -11,7 +14,6 @@
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
-import net.minecraft.nbt.Tag;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
@@ -27,9 +29,7 @@
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.entity.ChestBlockEntity;
-import net.minecraft.world.level.block.entity.DispenserBlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
@@ -38,8 +38,9 @@
 import org.slf4j.Logger;
 
 public abstract class StructurePiece {
+
     private static final Logger LOGGER = LogUtils.getLogger();
-    protected static final BlockState CAVE_AIR = Blocks.CAVE_AIR.defaultBlockState();
+    protected static final IBlockData CAVE_AIR = Blocks.CAVE_AIR.defaultBlockState();
     protected BoundingBox boundingBox;
     @Nullable
     private Direction orientation;
@@ -47,19 +48,7 @@
     private Rotation rotation;
     protected int genDepth;
     private final StructurePieceType type;
-    private static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder()
-        .add(Blocks.NETHER_BRICK_FENCE)
-        .add(Blocks.TORCH)
-        .add(Blocks.WALL_TORCH)
-        .add(Blocks.OAK_FENCE)
-        .add(Blocks.SPRUCE_FENCE)
-        .add(Blocks.DARK_OAK_FENCE)
-        .add(Blocks.ACACIA_FENCE)
-        .add(Blocks.BIRCH_FENCE)
-        .add(Blocks.JUNGLE_FENCE)
-        .add(Blocks.LADDER)
-        .add(Blocks.IRON_BARS)
-        .build();
+    public static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build();  // CraftBukkit - decompile error / PAIL private -> public
 
     protected StructurePiece(StructurePieceType type, int genDepth, BoundingBox boundingBox) {
         this.type = type;
@@ -68,22 +57,18 @@
     }
 
     public StructurePiece(StructurePieceType type, CompoundTag tag) {
-        this(
-            type,
-            tag.getInt("GD"),
-            BoundingBox.CODEC
-                .parse(NbtOps.INSTANCE, tag.get("BB"))
-                .resultOrPartial(LOGGER::error)
-                .orElseThrow(() -> new IllegalArgumentException("Invalid boundingbox"))
-        );
-        int _int = tag.getInt("O");
-        this.setOrientation(_int == -1 ? null : Direction.from2DDataValue(_int));
+        // CraftBukkit start - decompile error
+        this(type, tag.getInt("GD"), (BoundingBox) BoundingBox.CODEC.parse(NbtOps.INSTANCE, tag.get("BB")).resultOrPartial(Objects.requireNonNull(StructurePiece.LOGGER)::error).orElseThrow(() -> {
+            return new IllegalArgumentException("Invalid boundingbox");
+        }));
+        // CraftBukkit end
+        int j = tag.getInt("O");
+
+        this.setOrientation(j == -1 ? null : Direction.from2DDataValue(j));
     }
 
     protected static BoundingBox makeBoundingBox(int x, int y, int z, Direction direction, int offsetX, int offsetY, int offsetZ) {
-        return direction.getAxis() == Direction.Axis.Z
-            ? new BoundingBox(x, y, z, x + offsetX - 1, y + offsetY - 1, z + offsetZ - 1)
-            : new BoundingBox(x, y, z, x + offsetZ - 1, y + offsetY - 1, z + offsetX - 1);
+        return direction.getAxis() == Direction.Axis.Z ? new BoundingBox(x, y, z, x + offsetX - 1, y + offsetY - 1, z + offsetZ - 1) : new BoundingBox(x, y, z, x + offsetZ - 1, y + offsetY - 1, z + offsetX - 1);
     }
 
     protected static Direction getRandomHorizontalDirection(RandomSource random) {
@@ -91,24 +76,27 @@
     }
 
     public final CompoundTag createTag(StructurePieceSerializationContext context) {
-        CompoundTag compoundTag = new CompoundTag();
-        compoundTag.putString("id", BuiltInRegistries.STRUCTURE_PIECE.getKey(this.getType()).toString());
-        BoundingBox.CODEC.encodeStart(NbtOps.INSTANCE, this.boundingBox).resultOrPartial(LOGGER::error).ifPresent(tag -> compoundTag.put("BB", tag));
-        Direction orientation = this.getOrientation();
-        compoundTag.putInt("O", orientation == null ? -1 : orientation.get2DDataValue());
-        compoundTag.putInt("GD", this.genDepth);
-        this.addAdditionalSaveData(context, compoundTag);
-        return compoundTag;
+        CompoundTag nbttagcompound = new CompoundTag();
+
+        nbttagcompound.putString("id", BuiltInRegistries.STRUCTURE_PIECE.getKey(this.getType()).toString());
+        // CraftBukkit start - decompile error
+        BoundingBox.CODEC.encodeStart(NbtOps.INSTANCE, this.boundingBox).resultOrPartial(Objects.requireNonNull(StructurePiece.LOGGER)::error).ifPresent((nbtbase) -> {
+             nbttagcompound.put("BB", nbtbase);
+        });
+        // CraftBukkit end
+        Direction enumdirection = this.getOrientation();
+
+        nbttagcompound.putInt("O", enumdirection == null ? -1 : enumdirection.get2DDataValue());
+        nbttagcompound.putInt("GD", this.genDepth);
+        this.addAdditionalSaveData(context, nbttagcompound);
+        return nbttagcompound;
     }
 
     protected abstract void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag tag);
 
-    public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {
-    }
+    public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {}
 
-    public abstract void postProcess(
-        WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos
-    );
+    public abstract void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos);
 
     public BoundingBox getBoundingBox() {
         return this.boundingBox;
@@ -123,9 +111,10 @@
     }
 
     public boolean isCloseToChunk(ChunkPos chunkPos, int distance) {
-        int minBlockX = chunkPos.getMinBlockX();
-        int minBlockZ = chunkPos.getMinBlockZ();
-        return this.boundingBox.intersects(minBlockX - distance, minBlockZ - distance, minBlockX + 15 + distance, minBlockZ + 15 + distance);
+        int j = chunkPos.getMinBlockX();
+        int k = chunkPos.getMinBlockZ();
+
+        return this.boundingBox.intersects(j - distance, k - distance, j + 15 + distance, k + 15 + distance);
     }
 
     public BlockPos getLocatorPosition() {
@@ -137,11 +126,12 @@
     }
 
     protected int getWorldX(int x, int z) {
-        Direction orientation = this.getOrientation();
-        if (orientation == null) {
+        Direction enumdirection = this.getOrientation();
+
+        if (enumdirection == null) {
             return x;
         } else {
-            switch (orientation) {
+            switch (enumdirection) {
                 case NORTH:
                 case SOUTH:
                     return this.boundingBox.minX() + x;
@@ -160,11 +150,12 @@
     }
 
     protected int getWorldZ(int x, int z) {
-        Direction orientation = this.getOrientation();
-        if (orientation == null) {
+        Direction enumdirection = this.getOrientation();
+
+        if (enumdirection == null) {
             return z;
         } else {
-            switch (orientation) {
+            switch (enumdirection) {
                 case NORTH:
                     return this.boundingBox.maxZ() - z;
                 case SOUTH:
@@ -178,9 +169,10 @@
         }
     }
 
-    protected void placeBlock(WorldGenLevel level, BlockState blockstate, int x, int y, int z, BoundingBox boundingbox) {
-        BlockPos worldPos = this.getWorldPos(x, y, z);
-        if (boundingbox.isInside(worldPos)) {
+    protected void placeBlock(WorldGenLevel level, IBlockData blockstate, int x, int y, int z, BoundingBox boundingbox) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+
+        if (boundingbox.isInside(blockposition_mutableblockposition)) {
             if (this.canBeReplaced(level, x, y, z, boundingbox)) {
                 if (this.mirror != Mirror.NONE) {
                     blockstate = blockstate.mirror(this.mirror);
@@ -190,252 +182,265 @@
                     blockstate = blockstate.rotate(this.rotation);
                 }
 
-                level.setBlock(worldPos, blockstate, 2);
-                FluidState fluidState = level.getFluidState(worldPos);
-                if (!fluidState.isEmpty()) {
-                    level.scheduleTick(worldPos, fluidState.getType(), 0);
+                level.setBlock(blockposition_mutableblockposition, blockstate, 2);
+                // CraftBukkit start - fluid handling is already done if we have a transformer generator access
+                if (level instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess) {
+                    return;
                 }
+                // CraftBukkit end
+                FluidState fluid = level.getFluidState(blockposition_mutableblockposition);
 
-                if (SHAPE_CHECK_BLOCKS.contains(blockstate.getBlock())) {
-                    level.getChunk(worldPos).markPosForPostprocessing(worldPos);
+                if (!fluid.isEmpty()) {
+                    level.scheduleTick(blockposition_mutableblockposition, fluid.getType(), 0);
                 }
+
+                if (StructurePiece.SHAPE_CHECK_BLOCKS.contains(blockstate.getBlock())) {
+                    level.getChunk(blockposition_mutableblockposition).markPosForPostprocessing(blockposition_mutableblockposition);
+                }
+
             }
         }
     }
 
+    // CraftBukkit start
+    protected boolean placeCraftBlockEntity(ServerLevelAccessor worldAccess, BlockPos position, org.bukkit.craftbukkit.block.CraftBlockEntityState<?> craftBlockEntityState, int i) {
+        if (worldAccess instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess transformerAccess) {
+            return transformerAccess.setCraftBlock(position, craftBlockEntityState, i);
+        }
+        boolean result = worldAccess.setBlock(position, craftBlockEntityState.getHandle(), i);
+        BlockEntity tileEntity = worldAccess.getBlockEntity(position);
+        if (tileEntity != null) {
+            tileEntity.load(craftBlockEntityState.getSnapshotNBT());
+        }
+        return result;
+    }
+
+    protected void placeCraftSpawner(ServerLevelAccessor worldAccess, BlockPos position, org.bukkit.entity.EntityType entityType, int i) {
+        // This method is used in structures that are generated by code and place spawners as they set the entity after the block was placed making it impossible for plugins to access that information
+        org.bukkit.craftbukkit.block.CraftCreatureSpawner spawner = (org.bukkit.craftbukkit.block.CraftCreatureSpawner) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(position, Blocks.SPAWNER.defaultBlockState(), null);
+        spawner.setSpawnedType(entityType);
+        placeCraftBlockEntity(worldAccess, position, spawner, i);
+    }
+
+    protected void setCraftLootTable(ServerLevelAccessor worldAccess, BlockPos position, RandomSource randomSource, net.minecraft.resources.ResourceLocation loottableKey) {
+        // This method is used in structures that use data markers to a loot table to loot containers as otherwise plugins won't have access to that information.
+        net.minecraft.world.level.block.entity.BlockEntity tileEntity = worldAccess.getBlockEntity(position);
+        if (tileEntity instanceof net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity tileEntityLootable) {
+            tileEntityLootable.setLootTable(loottableKey, randomSource.nextLong());
+            if (worldAccess instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess transformerAccess) {
+                transformerAccess.setCraftBlock(position, (org.bukkit.craftbukkit.block.CraftBlockState) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(position, tileEntity.getBlockState(), tileEntityLootable.saveWithFullMetadata()), 3);
+            }
+        }
+    }
+    // CraftBukkit end
+
     protected boolean canBeReplaced(LevelReader level, int x, int y, int z, BoundingBox box) {
         return true;
     }
 
-    protected BlockState getBlock(BlockGetter level, int x, int y, int z, BoundingBox box) {
-        BlockPos worldPos = this.getWorldPos(x, y, z);
-        return !box.isInside(worldPos) ? Blocks.AIR.defaultBlockState() : level.getBlockState(worldPos);
+    protected IBlockData getBlock(BlockGetter level, int x, int y, int z, BoundingBox box) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+
+        return !box.isInside(blockposition_mutableblockposition) ? Blocks.AIR.defaultBlockState() : level.getBlockState(blockposition_mutableblockposition);
     }
 
     protected boolean isInterior(LevelReader level, int x, int y, int z, BoundingBox box) {
-        BlockPos worldPos = this.getWorldPos(x, y + 1, z);
-        return box.isInside(worldPos) && worldPos.getY() < level.getHeight(Heightmap.Types.OCEAN_FLOOR_WG, worldPos.getX(), worldPos.getZ());
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y + 1, z);
+
+        return !box.isInside(blockposition_mutableblockposition) ? false : blockposition_mutableblockposition.getY() < level.getHeight(Heightmap.Types.OCEAN_FLOOR_WG, blockposition_mutableblockposition.getX(), blockposition_mutableblockposition.getZ());
     }
 
     protected void generateAirBox(WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
-        for (int i = minY; i <= maxY; i++) {
-            for (int i1 = minX; i1 <= maxX; i1++) {
-                for (int i2 = minZ; i2 <= maxZ; i2++) {
-                    this.placeBlock(level, Blocks.AIR.defaultBlockState(), i1, i, i2, box);
+        for (int k1 = minY; k1 <= maxY; ++k1) {
+            for (int l1 = minX; l1 <= maxX; ++l1) {
+                for (int i2 = minZ; i2 <= maxZ; ++i2) {
+                    this.placeBlock(level, Blocks.AIR.defaultBlockState(), l1, k1, i2, box);
                 }
             }
         }
+
     }
 
-    protected void generateBox(
-        WorldGenLevel level,
-        BoundingBox box,
-        int xMin,
-        int yMin,
-        int zMin,
-        int xMax,
-        int yMax,
-        int zMax,
-        BlockState boundaryBlockState,
-        BlockState insideBlockState,
-        boolean existingOnly
-    ) {
-        for (int i = yMin; i <= yMax; i++) {
-            for (int i1 = xMin; i1 <= xMax; i1++) {
-                for (int i2 = zMin; i2 <= zMax; i2++) {
-                    if (!existingOnly || !this.getBlock(level, i1, i, i2, box).isAir()) {
-                        if (i != yMin && i != yMax && i1 != xMin && i1 != xMax && i2 != zMin && i2 != zMax) {
-                            this.placeBlock(level, insideBlockState, i1, i, i2, box);
+    protected void generateBox(WorldGenLevel level, BoundingBox box, int xMin, int yMin, int zMin, int xMax, int yMax, int zMax, IBlockData boundaryBlockState, IBlockData insideBlockState, boolean existingOnly) {
+        for (int k1 = yMin; k1 <= yMax; ++k1) {
+            for (int l1 = xMin; l1 <= xMax; ++l1) {
+                for (int i2 = zMin; i2 <= zMax; ++i2) {
+                    if (!existingOnly || !this.getBlock(level, l1, k1, i2, box).isAir()) {
+                        if (k1 != yMin && k1 != yMax && l1 != xMin && l1 != xMax && i2 != zMin && i2 != zMax) {
+                            this.placeBlock(level, insideBlockState, l1, k1, i2, box);
                         } else {
-                            this.placeBlock(level, boundaryBlockState, i1, i, i2, box);
+                            this.placeBlock(level, boundaryBlockState, l1, k1, i2, box);
                         }
                     }
                 }
             }
         }
+
     }
 
-    protected void generateBox(
-        WorldGenLevel level, BoundingBox boundingBox, BoundingBox box, BlockState boundaryBlockState, BlockState insideBlockState, boolean existingOnly
-    ) {
-        this.generateBox(
-            level, boundingBox, box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ(), boundaryBlockState, insideBlockState, existingOnly
-        );
+    protected void generateBox(WorldGenLevel level, BoundingBox boundingBox, BoundingBox box, IBlockData boundaryBlockState, IBlockData insideBlockState, boolean existingOnly) {
+        this.generateBox(level, boundingBox, box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ(), boundaryBlockState, insideBlockState, existingOnly);
     }
 
-    protected void generateBox(
-        WorldGenLevel level,
-        BoundingBox box,
-        int minX,
-        int minY,
-        int minZ,
-        int maxX,
-        int maxY,
-        int maxZ,
-        boolean alwaysReplace,
-        RandomSource random,
-        StructurePiece.BlockSelector blockSelector
-    ) {
-        for (int i = minY; i <= maxY; i++) {
-            for (int i1 = minX; i1 <= maxX; i1++) {
-                for (int i2 = minZ; i2 <= maxZ; i2++) {
-                    if (!alwaysReplace || !this.getBlock(level, i1, i, i2, box).isAir()) {
-                        blockSelector.next(random, i1, i, i2, i == minY || i == maxY || i1 == minX || i1 == maxX || i2 == minZ || i2 == maxZ);
-                        this.placeBlock(level, blockSelector.getNext(), i1, i, i2, box);
+    protected void generateBox(WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean alwaysReplace, RandomSource random, StructurePiece.BlockSelector blockSelector) {
+        for (int k1 = minY; k1 <= maxY; ++k1) {
+            for (int l1 = minX; l1 <= maxX; ++l1) {
+                for (int i2 = minZ; i2 <= maxZ; ++i2) {
+                    if (!alwaysReplace || !this.getBlock(level, l1, k1, i2, box).isAir()) {
+                        blockSelector.next(random, l1, k1, i2, k1 == minY || k1 == maxY || l1 == minX || l1 == maxX || i2 == minZ || i2 == maxZ);
+                        this.placeBlock(level, blockSelector.getNext(), l1, k1, i2, box);
                     }
                 }
             }
         }
+
     }
 
-    protected void generateBox(
-        WorldGenLevel level, BoundingBox boundingBox, BoundingBox box, boolean alwaysReplace, RandomSource random, StructurePiece.BlockSelector blockSelector
-    ) {
+    protected void generateBox(WorldGenLevel level, BoundingBox boundingBox, BoundingBox box, boolean alwaysReplace, RandomSource random, StructurePiece.BlockSelector blockSelector) {
         this.generateBox(level, boundingBox, box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ(), alwaysReplace, random, blockSelector);
     }
 
-    protected void generateMaybeBox(
-        WorldGenLevel level,
-        BoundingBox box,
-        RandomSource random,
-        float chance,
-        int x1,
-        int y1,
-        int z1,
-        int x2,
-        int y2,
-        int z2,
-        BlockState edgeState,
-        BlockState state,
-        boolean requireNonAir,
-        boolean requireSkylight
-    ) {
-        for (int i = y1; i <= y2; i++) {
-            for (int i1 = x1; i1 <= x2; i1++) {
-                for (int i2 = z1; i2 <= z2; i2++) {
-                    if (!(random.nextFloat() > chance)
-                        && (!requireNonAir || !this.getBlock(level, i1, i, i2, box).isAir())
-                        && (!requireSkylight || this.isInterior(level, i1, i, i2, box))) {
-                        if (i != y1 && i != y2 && i1 != x1 && i1 != x2 && i2 != z1 && i2 != z2) {
-                            this.placeBlock(level, state, i1, i, i2, box);
+    protected void generateMaybeBox(WorldGenLevel level, BoundingBox box, RandomSource random, float chance, int x1, int y1, int z1, int x2, int y2, int z2, IBlockData edgeState, IBlockData state, boolean requireNonAir, boolean requireSkylight) {
+        for (int k1 = y1; k1 <= y2; ++k1) {
+            for (int l1 = x1; l1 <= x2; ++l1) {
+                for (int i2 = z1; i2 <= z2; ++i2) {
+                    if (random.nextFloat() <= chance && (!requireNonAir || !this.getBlock(level, l1, k1, i2, box).isAir()) && (!requireSkylight || this.isInterior(level, l1, k1, i2, box))) {
+                        if (k1 != y1 && k1 != y2 && l1 != x1 && l1 != x2 && i2 != z1 && i2 != z2) {
+                            this.placeBlock(level, state, l1, k1, i2, box);
                         } else {
-                            this.placeBlock(level, edgeState, i1, i, i2, box);
+                            this.placeBlock(level, edgeState, l1, k1, i2, box);
                         }
                     }
                 }
             }
         }
+
     }
 
-    protected void maybeGenerateBlock(WorldGenLevel level, BoundingBox box, RandomSource random, float chance, int x, int y, int z, BlockState state) {
+    protected void maybeGenerateBlock(WorldGenLevel level, BoundingBox box, RandomSource random, float chance, int x, int y, int z, IBlockData state) {
         if (random.nextFloat() < chance) {
             this.placeBlock(level, state, x, y, z, box);
         }
+
     }
 
-    protected void generateUpperHalfSphere(
-        WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState state, boolean excludeAir
-    ) {
-        float f = (float)(maxX - minX + 1);
-        float f1 = (float)(maxY - minY + 1);
-        float f2 = (float)(maxZ - minZ + 1);
-        float f3 = (float)minX + f / 2.0F;
-        float f4 = (float)minZ + f2 / 2.0F;
+    protected void generateUpperHalfSphere(WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, IBlockData state, boolean excludeAir) {
+        float f = (float) (maxX - minX + 1);
+        float f1 = (float) (maxY - minY + 1);
+        float f2 = (float) (maxZ - minZ + 1);
+        float f3 = (float) minX + f / 2.0F;
+        float f4 = (float) minZ + f2 / 2.0F;
 
-        for (int i = minY; i <= maxY; i++) {
-            float f5 = (float)(i - minY) / f1;
+        for (int k1 = minY; k1 <= maxY; ++k1) {
+            float f5 = (float) (k1 - minY) / f1;
 
-            for (int i1 = minX; i1 <= maxX; i1++) {
-                float f6 = ((float)i1 - f3) / (f * 0.5F);
+            for (int l1 = minX; l1 <= maxX; ++l1) {
+                float f6 = ((float) l1 - f3) / (f * 0.5F);
 
-                for (int i2 = minZ; i2 <= maxZ; i2++) {
-                    float f7 = ((float)i2 - f4) / (f2 * 0.5F);
-                    if (!excludeAir || !this.getBlock(level, i1, i, i2, box).isAir()) {
+                for (int i2 = minZ; i2 <= maxZ; ++i2) {
+                    float f7 = ((float) i2 - f4) / (f2 * 0.5F);
+
+                    if (!excludeAir || !this.getBlock(level, l1, k1, i2, box).isAir()) {
                         float f8 = f6 * f6 + f5 * f5 + f7 * f7;
+
                         if (f8 <= 1.05F) {
-                            this.placeBlock(level, state, i1, i, i2, box);
+                            this.placeBlock(level, state, l1, k1, i2, box);
                         }
                     }
                 }
             }
         }
+
     }
 
-    protected void fillColumnDown(WorldGenLevel level, BlockState state, int x, int y, int z, BoundingBox box) {
-        BlockPos.MutableBlockPos worldPos = this.getWorldPos(x, y, z);
-        if (box.isInside(worldPos)) {
-            while (this.isReplaceableByStructures(level.getBlockState(worldPos)) && worldPos.getY() > level.getMinBuildHeight() + 1) {
-                level.setBlock(worldPos, state, 2);
-                worldPos.move(Direction.DOWN);
+    protected void fillColumnDown(WorldGenLevel level, IBlockData state, int x, int y, int z, BoundingBox box) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+
+        if (box.isInside(blockposition_mutableblockposition)) {
+            while (this.isReplaceableByStructures(level.getBlockState(blockposition_mutableblockposition)) && blockposition_mutableblockposition.getY() > level.getMinBuildHeight() + 1) {
+                level.setBlock(blockposition_mutableblockposition, state, 2);
+                blockposition_mutableblockposition.move(Direction.DOWN);
             }
+
         }
     }
 
-    protected boolean isReplaceableByStructures(BlockState state) {
+    protected boolean isReplaceableByStructures(IBlockData state) {
         return state.isAir() || state.liquid() || state.is(Blocks.GLOW_LICHEN) || state.is(Blocks.SEAGRASS) || state.is(Blocks.TALL_SEAGRASS);
     }
 
     protected boolean createChest(WorldGenLevel level, BoundingBox box, RandomSource random, int x, int y, int z, ResourceLocation lootTable) {
-        return this.createChest(level, box, random, this.getWorldPos(x, y, z), lootTable, null);
+        return this.createChest(level, box, random, this.getWorldPos(x, y, z), lootTable, (IBlockData) null);
     }
 
-    public static BlockState reorient(BlockGetter level, BlockPos pos, BlockState state) {
-        Direction direction = null;
+    public static IBlockData reorient(BlockGetter level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = null;
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
-        for (Direction direction1 : Direction.Plane.HORIZONTAL) {
-            BlockPos blockPos = pos.relative(direction1);
-            BlockState blockState = level.getBlockState(blockPos);
-            if (blockState.is(Blocks.CHEST)) {
+        while (iterator.hasNext()) {
+            Direction enumdirection1 = (Direction) iterator.next();
+            BlockPos blockposition1 = pos.relative(enumdirection1);
+            IBlockData iblockdata1 = level.getBlockState(blockposition1);
+
+            if (iblockdata1.is(Blocks.CHEST)) {
                 return state;
             }
 
-            if (blockState.isSolidRender(level, blockPos)) {
-                if (direction != null) {
-                    direction = null;
+            if (iblockdata1.isSolidRender(level, blockposition1)) {
+                if (enumdirection != null) {
+                    enumdirection = null;
                     break;
                 }
 
-                direction = direction1;
+                enumdirection = enumdirection1;
             }
         }
 
-        if (direction != null) {
-            return state.setValue(HorizontalDirectionalBlock.FACING, direction.getOpposite());
+        if (enumdirection != null) {
+            return (IBlockData) state.setValue(HorizontalDirectionalBlock.FACING, enumdirection.getOpposite());
         } else {
-            Direction direction2 = state.getValue(HorizontalDirectionalBlock.FACING);
-            BlockPos blockPos1 = pos.relative(direction2);
-            if (level.getBlockState(blockPos1).isSolidRender(level, blockPos1)) {
-                direction2 = direction2.getOpposite();
-                blockPos1 = pos.relative(direction2);
+            Direction enumdirection2 = (Direction) state.getValue(HorizontalDirectionalBlock.FACING);
+            BlockPos blockposition2 = pos.relative(enumdirection2);
+
+            if (level.getBlockState(blockposition2).isSolidRender(level, blockposition2)) {
+                enumdirection2 = enumdirection2.getOpposite();
+                blockposition2 = pos.relative(enumdirection2);
             }
 
-            if (level.getBlockState(blockPos1).isSolidRender(level, blockPos1)) {
-                direction2 = direction2.getClockWise();
-                blockPos1 = pos.relative(direction2);
+            if (level.getBlockState(blockposition2).isSolidRender(level, blockposition2)) {
+                enumdirection2 = enumdirection2.getClockWise();
+                blockposition2 = pos.relative(enumdirection2);
             }
 
-            if (level.getBlockState(blockPos1).isSolidRender(level, blockPos1)) {
-                direction2 = direction2.getOpposite();
-                blockPos1 = pos.relative(direction2);
+            if (level.getBlockState(blockposition2).isSolidRender(level, blockposition2)) {
+                enumdirection2 = enumdirection2.getOpposite();
+                pos.relative(enumdirection2);
             }
 
-            return state.setValue(HorizontalDirectionalBlock.FACING, direction2);
+            return (IBlockData) state.setValue(HorizontalDirectionalBlock.FACING, enumdirection2);
         }
     }
 
-    protected boolean createChest(
-        ServerLevelAccessor level, BoundingBox box, RandomSource random, BlockPos pos, ResourceLocation lootTable, @Nullable BlockState state
-    ) {
+    protected boolean createChest(ServerLevelAccessor level, BoundingBox box, RandomSource random, BlockPos pos, ResourceLocation lootTable, @Nullable IBlockData state) {
         if (box.isInside(pos) && !level.getBlockState(pos).is(Blocks.CHEST)) {
             if (state == null) {
                 state = reorient(level, pos, Blocks.CHEST.defaultBlockState());
             }
 
-            level.setBlock(pos, state, 2);
-            BlockEntity blockEntity = level.getBlockEntity(pos);
-            if (blockEntity instanceof ChestBlockEntity) {
-                ((ChestBlockEntity)blockEntity).setLootTable(lootTable, random.nextLong());
+            // CraftBukkit start
+            /*
+            worldaccess.setBlock(blockposition, iblockdata, 2);
+            TileEntity tileentity = worldaccess.getBlockEntity(blockposition);
+
+            if (tileentity instanceof TileEntityChest) {
+                ((TileEntityChest) tileentity).setLootTable(minecraftkey, randomsource.nextLong());
             }
+            */
+            org.bukkit.craftbukkit.block.CraftChest chestState = (org.bukkit.craftbukkit.block.CraftChest) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(pos, state, null);
+            chestState.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(lootTable)));
+            chestState.setSeed(random.nextLong());
+            placeCraftBlockEntity(level, pos, chestState, 2);
+            // CraftBukkit end
 
             return true;
         } else {
@@ -443,17 +448,36 @@
         }
     }
 
-    protected boolean createDispenser(
-        WorldGenLevel level, BoundingBox box, RandomSource random, int x, int y, int z, Direction facing, ResourceLocation lootTable
-    ) {
-        BlockPos worldPos = this.getWorldPos(x, y, z);
-        if (box.isInside(worldPos) && !level.getBlockState(worldPos).is(Blocks.DISPENSER)) {
-            this.placeBlock(level, Blocks.DISPENSER.defaultBlockState().setValue(DispenserBlock.FACING, facing), x, y, z, box);
-            BlockEntity blockEntity = level.getBlockEntity(worldPos);
-            if (blockEntity instanceof DispenserBlockEntity) {
-                ((DispenserBlockEntity)blockEntity).setLootTable(lootTable, random.nextLong());
+    protected boolean createDispenser(WorldGenLevel level, BoundingBox box, RandomSource random, int x, int y, int z, Direction facing, ResourceLocation lootTable) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
+
+        if (box.isInside(blockposition_mutableblockposition) && !level.getBlockState(blockposition_mutableblockposition).is(Blocks.DISPENSER)) {
+            // CraftBukkit start
+            /*
+            this.placeBlock(generatoraccessseed, (IBlockData) Blocks.DISPENSER.defaultBlockState().setValue(BlockDispenser.FACING, enumdirection), i, j, k, structureboundingbox);
+            TileEntity tileentity = generatoraccessseed.getBlockEntity(blockposition_mutableblockposition);
+
+            if (tileentity instanceof TileEntityDispenser) {
+                ((TileEntityDispenser) tileentity).setLootTable(minecraftkey, randomsource.nextLong());
             }
+            */
+            if (!this.canBeReplaced(level, x, y, z, box)) {
+                return true;
+            }
+            IBlockData iblockdata = Blocks.DISPENSER.defaultBlockState().setValue(DispenserBlock.FACING, facing);
+            if (this.mirror != Mirror.NONE) {
+                iblockdata = iblockdata.mirror(this.mirror);
+            }
+            if (this.rotation != Rotation.NONE) {
+                iblockdata = iblockdata.rotate(this.rotation);
+            }
 
+            org.bukkit.craftbukkit.block.CraftDispenser dispenserState = (org.bukkit.craftbukkit.block.CraftDispenser) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(blockposition_mutableblockposition, iblockdata, null);
+            dispenserState.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(lootTable)));
+            dispenserState.setSeed(random.nextLong());
+            placeCraftBlockEntity(level, blockposition_mutableblockposition, dispenserState, 2);
+            // CraftBukkit end
+
             return true;
         } else {
             return false;
@@ -465,19 +489,29 @@
     }
 
     public static BoundingBox createBoundingBox(Stream<StructurePiece> pieces) {
-        return BoundingBox.encapsulatingBoxes(pieces.map(StructurePiece::getBoundingBox)::iterator)
-            .orElseThrow(() -> new IllegalStateException("Unable to calculate boundingbox without pieces"));
+        Stream<BoundingBox> stream1 = pieces.map(StructurePiece::getBoundingBox); // CraftBukkit - decompile error
+
+        Objects.requireNonNull(stream1);
+        return (BoundingBox) BoundingBox.encapsulatingBoxes(stream1::iterator).orElseThrow(() -> {
+            return new IllegalStateException("Unable to calculate boundingbox without pieces");
+        });
     }
 
     @Nullable
     public static StructurePiece findCollisionPiece(List<StructurePiece> pieces, BoundingBox boundingBox) {
-        for (StructurePiece structurePiece : pieces) {
-            if (structurePiece.getBoundingBox().intersects(boundingBox)) {
-                return structurePiece;
+        Iterator iterator = pieces.iterator();
+
+        StructurePiece structurepiece;
+
+        do {
+            if (!iterator.hasNext()) {
+                return null;
             }
-        }
 
-        return null;
+            structurepiece = (StructurePiece) iterator.next();
+        } while (!structurepiece.getBoundingBox().intersects(boundingBox));
+
+        return structurepiece;
     }
 
     @Nullable
@@ -509,6 +543,7 @@
                     this.rotation = Rotation.NONE;
             }
         }
+
     }
 
     public Rotation getRotation() {
@@ -524,11 +559,16 @@
     }
 
     public abstract static class BlockSelector {
-        protected BlockState next = Blocks.AIR.defaultBlockState();
 
+        protected IBlockData next;
+
+        public BlockSelector() {
+            this.next = Blocks.AIR.defaultBlockState();
+        }
+
         public abstract void next(RandomSource random, int x, int y, int z, boolean wall);
 
-        public BlockState getNext() {
+        public IBlockData getNext() {
             return this.next;
         }
     }
