--- a/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -29,216 +29,113 @@
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 
 public class ChunkStatus {
+
     public static final int MAX_STRUCTURE_DISTANCE = 8;
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
-    public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(
-        Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES
-    );
-    private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (status, level, structureTemplateManager, lightEngine, task, chunk) -> CompletableFuture.completedFuture(
-            Either.left(chunk)
-        );
-    public static final ChunkStatus EMPTY = registerSimple(
-        "empty", null, -1, PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (status, level, chunkGenerator, neighboringChunks, loadingChunk) -> {
+    public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
+    private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+    };
+    public static final ChunkStatus EMPTY = registerSimple("empty", (ChunkStatus) null, -1, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    });
+    public static final ChunkStatus STRUCTURE_STARTS = register("structure_starts", ChunkStatus.EMPTY, 0, false, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        if (worldserver.serverLevelData.worldGenOptions().generateStructures()) { // CraftBukkit
+            chunkgenerator.createStructures(worldserver.registryAccess(), worldserver.getChunkSource().getGeneratorState(), worldserver.structureManager(), ichunkaccess, structuretemplatemanager);
         }
-    );
-    public static final ChunkStatus STRUCTURE_STARTS = register(
-        "structure_starts",
-        EMPTY,
-        0,
-        false,
-        PRE_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, executor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, loadingChunk) -> {
-            if (level.getServer().getWorldData().worldGenOptions().generateStructures()) {
-                chunkGenerator.createStructures(
-                    level.registryAccess(), level.getChunkSource().getGeneratorState(), level.structureManager(), loadingChunk, structureTemplateManager
-                );
-            }
-    
-            level.onStructureStartsAvailable(loadingChunk);
-            return CompletableFuture.completedFuture(Either.left(loadingChunk));
-        },
-        (status, level, structureTemplateManager, lightEngine, task, chunk) -> {
-            level.onStructureStartsAvailable(chunk);
-            return CompletableFuture.completedFuture(Either.left(chunk));
-        }
-    );
-    public static final ChunkStatus STRUCTURE_REFERENCES = registerSimple(
-        "structure_references",
-        STRUCTURE_STARTS,
-        8,
-        PRE_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, serverLevel, chunkGenerator, cache, loadingChunk) -> {
-            WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, cache, status, -1);
-            chunkGenerator.createReferences(worldGenRegion, serverLevel.structureManager().forWorldGenRegion(worldGenRegion), loadingChunk);
-        }
-    );
-    public static final ChunkStatus BIOMES = register(
-        "biomes",
-        STRUCTURE_REFERENCES,
-        8,
-        PRE_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, executor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, loadingChunk) -> {
-            WorldGenRegion worldGenRegion = new WorldGenRegion(level, cache, status, -1);
-            return chunkGenerator.createBiomes(
-                    executor,
-                    level.getChunkSource().randomState(),
-                    Blender.of(worldGenRegion),
-                    level.structureManager().forWorldGenRegion(worldGenRegion),
-                    loadingChunk
-                )
-                .thenApply(chunk -> Either.left(chunk));
-        }
-    );
-    public static final ChunkStatus NOISE = register(
-        "noise",
-        BIOMES,
-        8,
-        PRE_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, executor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, loadingChunk) -> {
-            WorldGenRegion worldGenRegion = new WorldGenRegion(level, cache, status, 0);
-            return chunkGenerator.fillFromNoise(
-                    executor,
-                    Blender.of(worldGenRegion),
-                    level.getChunkSource().randomState(),
-                    level.structureManager().forWorldGenRegion(worldGenRegion),
-                    loadingChunk
-                )
-                .thenApply(chunk -> {
-                    if (chunk instanceof ProtoChunk protoChunk) {
-                        BelowZeroRetrogen belowZeroRetrogen = protoChunk.getBelowZeroRetrogen();
-                        if (belowZeroRetrogen != null) {
-                            BelowZeroRetrogen.replaceOldBedrock(protoChunk);
-                            if (belowZeroRetrogen.hasBedrockHoles()) {
-                                belowZeroRetrogen.applyBedrockMask(protoChunk);
-                            }
-                        }
+
+        worldserver.onStructureStartsAvailable(ichunkaccess);
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        worldserver.onStructureStartsAvailable(ichunkaccess);
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+    });
+    public static final ChunkStatus STRUCTURE_REFERENCES = registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
+
+        chunkgenerator.createReferences(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess);
+    });
+    public static final ChunkStatus BIOMES = register("biomes", ChunkStatus.STRUCTURE_REFERENCES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
+
+        return chunkgenerator.createBiomes(executor, worldserver.getChunkSource().randomState(), Blender.of(regionlimitedworldaccess), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess).thenApply((ichunkaccess1) -> {
+            return Either.left(ichunkaccess1);
+        });
+    });
+    public static final ChunkStatus NOISE = register("noise", ChunkStatus.BIOMES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
+
+        return chunkgenerator.fillFromNoise(executor, Blender.of(regionlimitedworldaccess), worldserver.getChunkSource().randomState(), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess).thenApply((ichunkaccess1) -> {
+            if (ichunkaccess1 instanceof ProtoChunk) {
+                ProtoChunk protochunk = (ProtoChunk) ichunkaccess1;
+                BelowZeroRetrogen belowzeroretrogen = protochunk.getBelowZeroRetrogen();
+
+                if (belowzeroretrogen != null) {
+                    BelowZeroRetrogen.replaceOldBedrock(protochunk);
+                    if (belowzeroretrogen.hasBedrockHoles()) {
+                        belowzeroretrogen.applyBedrockMask(protochunk);
                     }
-        
-                    return Either.left(chunk);
-                });
-        }
-    );
-    public static final ChunkStatus SURFACE = registerSimple(
-        "surface",
-        NOISE,
-        8,
-        PRE_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, serverLevel, chunkGenerator, cache, loadingChunk) -> {
-            WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, cache, status, 0);
-            chunkGenerator.buildSurface(
-                worldGenRegion, serverLevel.structureManager().forWorldGenRegion(worldGenRegion), serverLevel.getChunkSource().randomState(), loadingChunk
-            );
-        }
-    );
-    public static final ChunkStatus CARVERS = registerSimple(
-        "carvers",
-        SURFACE,
-        8,
-        POST_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, serverLevel, chunkGenerator, cache, loadingChunk) -> {
-            WorldGenRegion worldGenRegion = new WorldGenRegion(serverLevel, cache, status, 0);
-            if (loadingChunk instanceof ProtoChunk protoChunk) {
-                Blender.addAroundOldChunksCarvingMaskFilter(worldGenRegion, protoChunk);
+                }
             }
-    
-            chunkGenerator.applyCarvers(
-                worldGenRegion,
-                serverLevel.getSeed(),
-                serverLevel.getChunkSource().randomState(),
-                serverLevel.getBiomeManager(),
-                serverLevel.structureManager().forWorldGenRegion(worldGenRegion),
-                loadingChunk,
-                GenerationStep.Carving.AIR
-            );
+
+            return Either.left(ichunkaccess1);
+        });
+    });
+    public static final ChunkStatus SURFACE = registerSimple("surface", ChunkStatus.NOISE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
+
+        chunkgenerator.buildSurface(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), worldserver.getChunkSource().randomState(), ichunkaccess);
+    });
+    public static final ChunkStatus CARVERS = registerSimple("carvers", ChunkStatus.SURFACE, 8, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
+
+        if (ichunkaccess instanceof ProtoChunk) {
+            ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
+
+            Blender.addAroundOldChunksCarvingMaskFilter(regionlimitedworldaccess, protochunk);
         }
-    );
-    public static final ChunkStatus FEATURES = registerSimple(
-        "features",
-        CARVERS,
-        8,
-        POST_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, level, chunkGenerator, neighbouringChunks, loadingChunk) -> {
-            Heightmap.primeHeightmaps(
-                loadingChunk,
-                EnumSet.of(
-                    Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE
-                )
-            );
-            WorldGenRegion worldGenRegion = new WorldGenRegion(level, neighbouringChunks, status, 1);
-            chunkGenerator.applyBiomeDecoration(worldGenRegion, loadingChunk, level.structureManager().forWorldGenRegion(worldGenRegion));
-            Blender.generateBorderTicks(worldGenRegion, loadingChunk);
+
+        chunkgenerator.applyCarvers(regionlimitedworldaccess, worldserver.getSeed(), worldserver.getChunkSource().randomState(), worldserver.getBiomeManager(), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess, GenerationStep.Carving.AIR);
+    });
+    public static final ChunkStatus FEATURES = registerSimple("features", ChunkStatus.CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        Heightmap.primeHeightmaps(ichunkaccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1);
+
+        chunkgenerator.applyBiomeDecoration(regionlimitedworldaccess, ichunkaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess));
+        Blender.generateBorderTicks(regionlimitedworldaccess, ichunkaccess);
+    });
+    public static final ChunkStatus INITIALIZE_LIGHT = register("initialize_light", ChunkStatus.FEATURES, 0, false, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return initializeLight(lightenginethreaded, ichunkaccess);
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return initializeLight(lightenginethreaded, ichunkaccess);
+    });
+    public static final ChunkStatus LIGHT = register("light", ChunkStatus.INITIALIZE_LIGHT, 1, true, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return lightChunk(lightenginethreaded, ichunkaccess);
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return lightChunk(lightenginethreaded, ichunkaccess);
+    });
+    public static final ChunkStatus SPAWN = registerSimple("spawn", ChunkStatus.LIGHT, 0, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        if (!ichunkaccess.isUpgrading()) {
+            chunkgenerator.spawnOriginalMobs(new WorldGenRegion(worldserver, list, chunkstatus, -1));
         }
-    );
-    public static final ChunkStatus INITIALIZE_LIGHT = register(
-        "initialize_light",
-        FEATURES,
-        0,
-        false,
-        POST_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, executor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, loadingChunk) -> initializeLight(
-                lightEngine, loadingChunk
-            ),
-        (status, level, structureTemplateManager, lightEngine, task, chunk) -> initializeLight(lightEngine, chunk)
-    );
-    public static final ChunkStatus LIGHT = register(
-        "light",
-        INITIALIZE_LIGHT,
-        1,
-        true,
-        POST_FEATURES,
-        ChunkStatus.ChunkType.PROTOCHUNK,
-        (status, executor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, loadingChunk) -> lightChunk(lightEngine, loadingChunk),
-        (status, level, structureTemplateManager, lightEngine, task, chunk) -> lightChunk(lightEngine, chunk)
-    );
-    public static final ChunkStatus SPAWN = registerSimple(
-        "spawn", LIGHT, 0, POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (status, serverLevel, generator, cache, loadingChunk) -> {
-            if (!loadingChunk.isUpgrading()) {
-                generator.spawnOriginalMobs(new WorldGenRegion(serverLevel, cache, status, -1));
-            }
-        }
-    );
-    public static final ChunkStatus FULL = register(
-        "full",
-        SPAWN,
-        0,
-        false,
-        POST_FEATURES,
-        ChunkStatus.ChunkType.LEVELCHUNK,
-        (status, executor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, loadingChunk) -> task.apply(loadingChunk),
-        (status, level, structureTemplateManager, lightEngine, task, chunk) -> task.apply(chunk)
-    );
-    private static final List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(
-        FULL,
-        INITIALIZE_LIGHT,
-        CARVERS,
-        BIOMES,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS,
-        STRUCTURE_STARTS
-    );
-    private static final IntList RANGE_BY_STATUS = Util.make(new IntArrayList(getStatusList().size()), list -> {
+
+    });
+    public static final ChunkStatus FULL = register("full", ChunkStatus.SPAWN, 0, false, ChunkStatus.POST_FEATURES, ChunkStatus.Type.LEVELCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return (CompletableFuture) function.apply(ichunkaccess);
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return (CompletableFuture) function.apply(ichunkaccess);
+    });
+    private static final List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(ChunkStatus.FULL, ChunkStatus.INITIALIZE_LIGHT, ChunkStatus.CARVERS, ChunkStatus.BIOMES, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, new ChunkStatus[0]);
+    private static final IntList RANGE_BY_STATUS = (IntList) Util.make(new IntArrayList(getStatusList().size()), (intarraylist) -> {
         int i = 0;
 
-        for (int i1 = getStatusList().size() - 1; i1 >= 0; i1--) {
-            while (i + 1 < STATUS_BY_RANGE.size() && i1 <= STATUS_BY_RANGE.get(i + 1).getIndex()) {
-                i++;
+        for (int j = getStatusList().size() - 1; j >= 0; --j) {
+            while (i + 1 < ChunkStatus.STATUS_BY_RANGE.size() && j <= ((ChunkStatus) ChunkStatus.STATUS_BY_RANGE.get(i + 1)).getIndex()) {
+                ++i;
             }
 
-            list.add(0, i);
+            intarraylist.add(0, i);
         }
+
     });
     private final int index;
     private final ChunkStatus parent;
@@ -246,102 +143,66 @@
     private final ChunkStatus.LoadingTask loadingTask;
     private final int range;
     private final boolean hasLoadDependencies;
-    private final ChunkStatus.ChunkType chunkType;
+    private final ChunkStatus.Type chunkType;
     private final EnumSet<Heightmap.Types> heightmapsAfter;
 
-    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> initializeLight(
-        ThreadedLevelLightEngine lightEngine, ChunkAccess chunk
-    ) {
+    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> initializeLight(ThreadedLevelLightEngine lightEngine, ChunkAccess chunk) {
         chunk.initializeLightSources();
-        ((ProtoChunk)chunk).setLightEngine(lightEngine);
-        boolean isLighted = isLighted(chunk);
-        return lightEngine.initializeLight(chunk, isLighted).thenApply(Either::left);
+        ((ProtoChunk) chunk).setLightEngine(lightEngine);
+        boolean flag = isLighted(chunk);
+
+        return lightEngine.initializeLight(chunk, flag).thenApply(Either::left);
     }
 
-    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> lightChunk(ThreadedLevelLightEngine lightEngine, ChunkAccess chunk) {
-        boolean isLighted = isLighted(chunk);
-        return lightEngine.lightChunk(chunk, isLighted).thenApply(Either::left);
+    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> lightChunk(ThreadedLevelLightEngine lightEngine, ChunkAccess chunk) {
+        boolean flag = isLighted(chunk);
+
+        return lightEngine.lightChunk(chunk, flag).thenApply(Either::left);
     }
 
-    private static ChunkStatus registerSimple(
-        String key,
-        @Nullable ChunkStatus parent,
-        int taskRange,
-        EnumSet<Heightmap.Types> heightmaps,
-        ChunkStatus.ChunkType type,
-        ChunkStatus.SimpleGenerationTask generationTask
-    ) {
+    private static ChunkStatus registerSimple(String key, @Nullable ChunkStatus parent, int taskRange, EnumSet<Heightmap.Types> heightmaps, ChunkStatus.Type type, ChunkStatus.SimpleGenerationTask generationTask) {
         return register(key, parent, taskRange, heightmaps, type, generationTask);
     }
 
-    private static ChunkStatus register(
-        String key,
-        @Nullable ChunkStatus parent,
-        int taskRange,
-        EnumSet<Heightmap.Types> heightmaps,
-        ChunkStatus.ChunkType type,
-        ChunkStatus.GenerationTask generationTask
-    ) {
-        return register(key, parent, taskRange, false, heightmaps, type, generationTask, PASSTHROUGH_LOAD_TASK);
+    private static ChunkStatus register(String key, @Nullable ChunkStatus parent, int taskRange, EnumSet<Heightmap.Types> heightmaps, ChunkStatus.Type type, ChunkStatus.GenerationTask generationTask) {
+        return register(key, parent, taskRange, false, heightmaps, type, generationTask, ChunkStatus.PASSTHROUGH_LOAD_TASK);
     }
 
-    private static ChunkStatus register(
-        String key,
-        @Nullable ChunkStatus parent,
-        int taskRange,
-        boolean hasLoadDependencies,
-        EnumSet<Heightmap.Types> heightmaps,
-        ChunkStatus.ChunkType type,
-        ChunkStatus.GenerationTask generationTask,
-        ChunkStatus.LoadingTask loadingTask
-    ) {
-        return Registry.register(
-            BuiltInRegistries.CHUNK_STATUS, key, new ChunkStatus(parent, taskRange, hasLoadDependencies, heightmaps, type, generationTask, loadingTask)
-        );
+    private static ChunkStatus register(String key, @Nullable ChunkStatus parent, int taskRange, boolean hasLoadDependencies, EnumSet<Heightmap.Types> heightmaps, ChunkStatus.Type type, ChunkStatus.GenerationTask generationTask, ChunkStatus.LoadingTask loadingTask) {
+        return (ChunkStatus) Registry.register(BuiltInRegistries.CHUNK_STATUS, key, new ChunkStatus(parent, taskRange, hasLoadDependencies, heightmaps, type, generationTask, loadingTask));
     }
 
     public static List<ChunkStatus> getStatusList() {
         List<ChunkStatus> list = Lists.newArrayList();
 
-        ChunkStatus chunkStatus;
-        for (chunkStatus = FULL; chunkStatus.getParent() != chunkStatus; chunkStatus = chunkStatus.getParent()) {
-            list.add(chunkStatus);
+        ChunkStatus chunkstatus;
+
+        for (chunkstatus = ChunkStatus.FULL; chunkstatus.getParent() != chunkstatus; chunkstatus = chunkstatus.getParent()) {
+            list.add(chunkstatus);
         }
 
-        list.add(chunkStatus);
+        list.add(chunkstatus);
         Collections.reverse(list);
         return list;
     }
 
     private static boolean isLighted(ChunkAccess chunk) {
-        return chunk.getStatus().isOrAfter(LIGHT) && chunk.isLightCorrect();
+        return chunk.getStatus().isOrAfter(ChunkStatus.LIGHT) && chunk.isLightCorrect();
     }
 
     public static ChunkStatus getStatusAroundFullChunk(int radius) {
-        if (radius >= STATUS_BY_RANGE.size()) {
-            return EMPTY;
-        } else {
-            return radius < 0 ? FULL : STATUS_BY_RANGE.get(radius);
-        }
+        return radius >= ChunkStatus.STATUS_BY_RANGE.size() ? ChunkStatus.EMPTY : (radius < 0 ? ChunkStatus.FULL : (ChunkStatus) ChunkStatus.STATUS_BY_RANGE.get(radius));
     }
 
     public static int maxDistance() {
-        return STATUS_BY_RANGE.size();
+        return ChunkStatus.STATUS_BY_RANGE.size();
     }
 
     public static int getDistance(ChunkStatus status) {
-        return RANGE_BY_STATUS.getInt(status.getIndex());
+        return ChunkStatus.RANGE_BY_STATUS.getInt(status.getIndex());
     }
 
-    ChunkStatus(
-        @Nullable ChunkStatus parent,
-        int range,
-        boolean hasLoadDependencies,
-        EnumSet<Heightmap.Types> heightmapsAfter,
-        ChunkStatus.ChunkType chunkType,
-        ChunkStatus.GenerationTask generationTask,
-        ChunkStatus.LoadingTask loadingTask
-    ) {
+    ChunkStatus(@Nullable ChunkStatus parent, int range, boolean hasLoadDependencies, EnumSet<Heightmap.Types> heightmapsAfter, ChunkStatus.Type chunkType, ChunkStatus.GenerationTask generationTask, ChunkStatus.LoadingTask loadingTask) {
         this.parent = parent == null ? this : parent;
         this.generationTask = generationTask;
         this.loadingTask = loadingTask;
@@ -360,40 +221,30 @@
         return this.parent;
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> generate(
-        Executor exectutor,
-        ServerLevel level,
-        ChunkGenerator chunkGenerator,
-        StructureTemplateManager structureTemplateManager,
-        ThreadedLevelLightEngine lightEngine,
-        Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task,
-        List<ChunkAccess> cache
-    ) {
-        ChunkAccess chunkAccess = cache.get(cache.size() / 2);
-        ProfiledDuration profiledDuration = JvmProfiler.INSTANCE.onChunkGenerate(chunkAccess.getPos(), level.dimension(), this.toString());
-        return this.generationTask
-            .doWork(this, exectutor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, chunkAccess)
-            .thenApply(generationResult -> {
-                generationResult.ifLeft(chunk -> {
-                    if (chunk instanceof ProtoChunk protoChunk && !protoChunk.getStatus().isOrAfter(this)) {
-                        protoChunk.setStatus(this);
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> generate(Executor exectutor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, List<ChunkAccess> cache) {
+        ChunkAccess ichunkaccess = (ChunkAccess) cache.get(cache.size() / 2);
+        ProfiledDuration profiledduration = JvmProfiler.INSTANCE.onChunkGenerate(ichunkaccess.getPos(), level.dimension(), this.toString());
+
+        return this.generationTask.doWork(this, exectutor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, ichunkaccess).thenApply((either) -> {
+            either.ifLeft((ichunkaccess1) -> {
+                if (ichunkaccess1 instanceof ProtoChunk) {
+                    ProtoChunk protochunk = (ProtoChunk) ichunkaccess1;
+
+                    if (!protochunk.getStatus().isOrAfter(this)) {
+                        protochunk.setStatus(this);
                     }
-                });
-                if (profiledDuration != null) {
-                    profiledDuration.finish();
                 }
-    
-                return generationResult;
+
             });
+            if (profiledduration != null) {
+                profiledduration.finish();
+            }
+
+            return either;
+        });
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> load(
-        ServerLevel level,
-        StructureTemplateManager structureTemplateManager,
-        ThreadedLevelLightEngine lightEngine,
-        Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task,
-        ChunkAccess loadingChunk
-    ) {
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> load(ServerLevel level, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, ChunkAccess loadingChunk) {
         return this.loadingTask.doWork(this, level, structureTemplateManager, lightEngine, task, loadingChunk);
     }
 
@@ -405,12 +256,12 @@
         return this.hasLoadDependencies;
     }
 
-    public ChunkStatus.ChunkType getChunkType() {
+    public ChunkStatus.Type getChunkType() {
         return this.chunkType;
     }
 
     public static ChunkStatus byName(String key) {
-        return BuiltInRegistries.CHUNK_STATUS.get(ResourceLocation.tryParse(key));
+        return (ChunkStatus) BuiltInRegistries.CHUNK_STATUS.get(ResourceLocation.tryParse(key));
     }
 
     public EnumSet<Heightmap.Types> heightmapsAfter() {
@@ -421,54 +272,31 @@
         return this.getIndex() >= status.getIndex();
     }
 
-    @Override
     public String toString() {
         return BuiltInRegistries.CHUNK_STATUS.getKey(this).toString();
     }
 
-    public static enum ChunkType {
-        PROTOCHUNK,
-        LEVELCHUNK;
+    public static enum Type {
+
+        PROTOCHUNK, LEVELCHUNK;
+
+        private Type() {}
     }
 
-    interface GenerationTask {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(
-            ChunkStatus status,
-            Executor executor,
-            ServerLevel level,
-            ChunkGenerator chunkGenerator,
-            StructureTemplateManager structureTemplateManager,
-            ThreadedLevelLightEngine lightEngine,
-            Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task,
-            List<ChunkAccess> cache,
-            ChunkAccess loadingChunk
-        );
+    private interface GenerationTask {
+
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> doWork(ChunkStatus status, Executor executor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, List<ChunkAccess> cache, ChunkAccess loadingChunk);
     }
 
-    interface LoadingTask {
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(
-            ChunkStatus status,
-            ServerLevel level,
-            StructureTemplateManager structureTemplateManager,
-            ThreadedLevelLightEngine lightEngine,
-            Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task,
-            ChunkAccess chunk
-        );
+    private interface LoadingTask {
+
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> doWork(ChunkStatus status, ServerLevel level, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, ChunkAccess chunk);
     }
 
-    interface SimpleGenerationTask extends ChunkStatus.GenerationTask {
+    private interface SimpleGenerationTask extends ChunkStatus.GenerationTask {
+
         @Override
-        default CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(
-            ChunkStatus status,
-            Executor executor,
-            ServerLevel level,
-            ChunkGenerator chunkGenerator,
-            StructureTemplateManager structureTemplateManager,
-            ThreadedLevelLightEngine lightEngine,
-            Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task,
-            List<ChunkAccess> cache,
-            ChunkAccess loadingChunk
-        ) {
+        default CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> doWork(ChunkStatus status, Executor executor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, List<ChunkAccess> cache, ChunkAccess loadingChunk) {
             this.doWork(status, level, chunkGenerator, cache, loadingChunk);
             return CompletableFuture.completedFuture(Either.left(loadingChunk));
         }
