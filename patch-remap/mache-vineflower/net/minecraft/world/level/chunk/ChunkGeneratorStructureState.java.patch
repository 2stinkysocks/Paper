--- a/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
+++ b/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
@@ -1,3 +1,4 @@
+// mc-dev import
 package net.minecraft.world.level.chunk;
 
 import com.google.common.base.Stopwatch;
@@ -6,8 +7,10 @@
 import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
@@ -32,48 +35,51 @@
 import org.slf4j.Logger;
 
 public class ChunkGeneratorStructureState {
+
     private static final Logger LOGGER = LogUtils.getLogger();
     private final RandomState randomState;
     private final BiomeSource biomeSource;
     private final long levelSeed;
     private final long concentricRingsSeed;
-    private final Map<Structure, List<StructurePlacement>> placementsForStructure = new Object2ObjectOpenHashMap<>();
-    private final Map<ConcentricRingsStructurePlacement, CompletableFuture<List<ChunkPos>>> ringPositions = new Object2ObjectArrayMap<>();
+    private final Map<Structure, List<StructurePlacement>> placementsForStructure = new Object2ObjectOpenHashMap();
+    private final Map<ConcentricRingsStructurePlacement, CompletableFuture<List<ChunkPos>>> ringPositions = new Object2ObjectArrayMap();
     private boolean hasGeneratedPositions;
     private final List<Holder<StructureSet>> possibleStructureSets;
 
-    public static ChunkGeneratorStructureState createForFlat(
-        RandomState randomState, long levelSeed, BiomeSource biomeSource, Stream<Holder<StructureSet>> structureSets
-    ) {
-        List<Holder<StructureSet>> list = structureSets.filter(structureSet -> hasBiomesForStructureSet(structureSet.value(), biomeSource)).toList();
-        return new ChunkGeneratorStructureState(randomState, biomeSource, levelSeed, 0L, list);
+    public static ChunkGeneratorStructureState createForFlat(RandomState randomState, long levelSeed, BiomeSource worldchunkmanager, Stream<Holder<StructureSet>> biomeSource) {
+        List<Holder<StructureSet>> list = biomeSource.filter((holder) -> {
+            return hasBiomesForStructureSet((StructureSet) holder.value(), worldchunkmanager);
+        }).toList();
+
+        return new ChunkGeneratorStructureState(randomState, worldchunkmanager, levelSeed, 0L, list);
     }
 
-    public static ChunkGeneratorStructureState createForNormal(
-        RandomState randomState, long seed, BiomeSource biomeSource, HolderLookup<StructureSet> structureSetLookup
-    ) {
-        List<Holder<StructureSet>> list = structureSetLookup.listElements()
-            .filter(structureSet -> hasBiomesForStructureSet(structureSet.value(), biomeSource))
-            .collect(Collectors.toUnmodifiableList());
-        return new ChunkGeneratorStructureState(randomState, biomeSource, seed, seed, list);
+    public static ChunkGeneratorStructureState createForNormal(RandomState randomState, long seed, BiomeSource worldchunkmanager, HolderLookup<StructureSet> biomeSource) {
+        List<Holder<StructureSet>> list = (List) biomeSource.listElements().filter((holder_c) -> {
+            return hasBiomesForStructureSet((StructureSet) holder_c.value(), worldchunkmanager);
+        }).collect(Collectors.toUnmodifiableList());
+
+        return new ChunkGeneratorStructureState(randomState, worldchunkmanager, seed, seed, list);
     }
 
     private static boolean hasBiomesForStructureSet(StructureSet structureSet, BiomeSource biomeSource) {
-        Stream<Holder<Biome>> stream = structureSet.structures().stream().flatMap(structureEntry -> {
-            Structure structure = structureEntry.structure().value();
+        Stream<Holder<Biome>> stream = structureSet.structures().stream().flatMap((structureset_a) -> {
+            Structure structure = (Structure) structureset_a.structure().value();
+
             return structure.biomes().stream();
         });
-        return stream.anyMatch(biomeSource.possibleBiomes()::contains);
+        Set set = biomeSource.possibleBiomes();
+
+        Objects.requireNonNull(set);
+        return stream.anyMatch(set::contains);
     }
 
-    private ChunkGeneratorStructureState(
-        RandomState randomState, BiomeSource biomeSource, long levelSeed, long cocentricRingsSeed, List<Holder<StructureSet>> possibleStructureSets
-    ) {
+    private ChunkGeneratorStructureState(RandomState randomState, BiomeSource biomeSource, long levelSeed, long j, List<Holder<StructureSet>> cocentricRingsSeed) {
         this.randomState = randomState;
         this.levelSeed = levelSeed;
         this.biomeSource = biomeSource;
-        this.concentricRingsSeed = cocentricRingsSeed;
-        this.possibleStructureSets = possibleStructureSets;
+        this.concentricRingsSeed = j;
+        this.possibleStructureSets = cocentricRingsSeed;
     }
 
     public List<Holder<StructureSet>> possibleStructureSets() {
@@ -82,29 +88,37 @@
 
     private void generatePositions() {
         Set<Holder<Biome>> set = this.biomeSource.possibleBiomes();
-        this.possibleStructureSets()
-            .forEach(
-                structureSetHolder -> {
-                    StructureSet structureSet = structureSetHolder.value();
-                    boolean flag = false;
-        
-                    for (StructureSet.StructureSelectionEntry structureSelectionEntry : structureSet.structures()) {
-                        Structure structure = structureSelectionEntry.structure().value();
-                        if (structure.biomes().stream().anyMatch(set::contains)) {
-                            this.placementsForStructure.computeIfAbsent(structure, key -> new ArrayList<>()).add(structureSet.placement());
-                            flag = true;
-                        }
-                    }
-        
-                    if (flag && structureSet.placement() instanceof ConcentricRingsStructurePlacement concentricRingsStructurePlacement) {
-                        this.ringPositions
-                            .put(
-                                concentricRingsStructurePlacement,
-                                this.generateRingPositions((Holder<StructureSet>)structureSetHolder, concentricRingsStructurePlacement)
-                            );
-                    }
+
+        this.possibleStructureSets().forEach((holder) -> {
+            StructureSet structureset = (StructureSet) holder.value();
+            boolean flag = false;
+            Iterator iterator = structureset.structures().iterator();
+
+            while (iterator.hasNext()) {
+                StructureSet.a structureset_a = (StructureSet.a) iterator.next();
+                Structure structure = (Structure) structureset_a.structure().value();
+                Stream stream = structure.biomes().stream();
+
+                Objects.requireNonNull(set);
+                if (stream.anyMatch(set::contains)) {
+                    ((List) this.placementsForStructure.computeIfAbsent(structure, (structure1) -> {
+                        return new ArrayList();
+                    })).add(structureset.placement());
+                    flag = true;
                 }
-            );
+            }
+
+            if (flag) {
+                StructurePlacement structureplacement = structureset.placement();
+
+                if (structureplacement instanceof ConcentricRingsStructurePlacement) {
+                    ConcentricRingsStructurePlacement concentricringsstructureplacement = (ConcentricRingsStructurePlacement) structureplacement;
+
+                    this.ringPositions.put(concentricringsstructureplacement, this.generateRingPositions(holder, concentricringsstructureplacement));
+                }
+            }
+
+        });
     }
 
     private CompletableFuture<List<ChunkPos>> generateRingPositions(Holder<StructureSet> structureSet, ConcentricRingsStructurePlacement placement) {
@@ -113,58 +127,55 @@
         } else {
             Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
             int i = placement.distance();
-            int i1 = placement.count();
-            List<CompletableFuture<ChunkPos>> list = new ArrayList<>(i1);
-            int i2 = placement.spread();
-            HolderSet<Biome> holderSet = placement.preferredBiomes();
-            RandomSource randomSource = RandomSource.create();
-            randomSource.setSeed(this.concentricRingsSeed);
-            double d = randomSource.nextDouble() * Math.PI * 2.0;
-            int i3 = 0;
-            int i4 = 0;
+            int j = placement.count();
+            List<CompletableFuture<ChunkPos>> list = new ArrayList(j);
+            int k = placement.spread();
+            HolderSet<Biome> holderset = placement.preferredBiomes();
+            RandomSource randomsource = RandomSource.create();
 
-            for (int i5 = 0; i5 < i1; i5++) {
-                double d1 = (double)(4 * i + i * i4 * 6) + (randomSource.nextDouble() - 0.5) * (double)i * 2.5;
-                int i6 = (int)Math.round(Math.cos(d) * d1);
-                int i7 = (int)Math.round(Math.sin(d) * d1);
-                RandomSource randomSource1 = randomSource.fork();
-                list.add(
-                    CompletableFuture.supplyAsync(
-                        () -> {
-                            Pair<BlockPos, Holder<Biome>> pair = this.biomeSource
-                                .findBiomeHorizontal(
-                                    SectionPos.sectionToBlockCoord(i6, 8),
-                                    0,
-                                    SectionPos.sectionToBlockCoord(i7, 8),
-                                    112,
-                                    holderSet::contains,
-                                    randomSource1,
-                                    this.randomState.sampler()
-                                );
-                            if (pair != null) {
-                                BlockPos blockPos = pair.getFirst();
-                                return new ChunkPos(SectionPos.blockToSectionCoord(blockPos.getX()), SectionPos.blockToSectionCoord(blockPos.getZ()));
-                            } else {
-                                return new ChunkPos(i6, i7);
-                            }
-                        },
-                        Util.backgroundExecutor()
-                    )
-                );
-                d += (Math.PI * 2) / (double)i2;
-                if (++i3 == i2) {
-                    i4++;
-                    i3 = 0;
-                    i2 += 2 * i2 / (i4 + 1);
-                    i2 = Math.min(i2, i1 - i5);
-                    d += randomSource.nextDouble() * Math.PI * 2.0;
+            randomsource.setSeed(this.concentricRingsSeed);
+            double d0 = randomsource.nextDouble() * 3.141592653589793D * 2.0D;
+            int l = 0;
+            int i1 = 0;
+
+            for (int j1 = 0; j1 < j; ++j1) {
+                double d1 = (double) (4 * i + i * i1 * 6) + (randomsource.nextDouble() - 0.5D) * (double) i * 2.5D;
+                int k1 = (int) Math.round(Math.cos(d0) * d1);
+                int l1 = (int) Math.round(Math.sin(d0) * d1);
+                RandomSource randomsource1 = randomsource.fork();
+
+                list.add(CompletableFuture.supplyAsync(() -> {
+                    BiomeSource worldchunkmanager = this.biomeSource;
+                    int i2 = SectionPos.sectionToBlockCoord(k1, 8);
+                    int j2 = SectionPos.sectionToBlockCoord(l1, 8);
+
+                    Objects.requireNonNull(holderset);
+                    Pair<BlockPos, Holder<Biome>> pair = worldchunkmanager.findBiomeHorizontal(i2, 0, j2, 112, holderset::contains, randomsource1, this.randomState.sampler());
+
+                    if (pair != null) {
+                        BlockPos blockposition = (BlockPos) pair.getFirst();
+
+                        return new ChunkPos(SectionPos.blockToSectionCoord(blockposition.getX()), SectionPos.blockToSectionCoord(blockposition.getZ()));
+                    } else {
+                        return new ChunkPos(k1, l1);
+                    }
+                }, Util.backgroundExecutor()));
+                d0 += 6.283185307179586D / (double) k;
+                ++l;
+                if (l == k) {
+                    ++i1;
+                    l = 0;
+                    k += 2 * k / (i1 + 1);
+                    k = Math.min(k, j - j1);
+                    d0 += randomsource.nextDouble() * 3.141592653589793D * 2.0D;
                 }
             }
 
-            return Util.sequence(list).thenApply(completed -> {
-                double d2 = (double)stopwatch.stop().elapsed(TimeUnit.MILLISECONDS) / 1000.0;
-                LOGGER.debug("Calculation for {} took {}s", structureSet, d2);
-                return completed;
+            return Util.sequence(list).thenApply((list1) -> {
+                double d2 = (double) stopwatch.stop().elapsed(TimeUnit.MILLISECONDS) / 1000.0D;
+
+                ChunkGeneratorStructureState.LOGGER.debug("Calculation for {} took {}s", structureSet, d2);
+                return list1;
             });
         }
     }
@@ -174,18 +185,20 @@
             this.generatePositions();
             this.hasGeneratedPositions = true;
         }
+
     }
 
     @Nullable
     public List<ChunkPos> getRingPositionsFor(ConcentricRingsStructurePlacement placement) {
         this.ensureStructuresGenerated();
-        CompletableFuture<List<ChunkPos>> completableFuture = this.ringPositions.get(placement);
-        return completableFuture != null ? completableFuture.join() : null;
+        CompletableFuture<List<ChunkPos>> completablefuture = (CompletableFuture) this.ringPositions.get(placement);
+
+        return completablefuture != null ? (List) completablefuture.join() : null;
     }
 
     public List<StructurePlacement> getPlacementsForStructure(Holder<Structure> structure) {
         this.ensureStructuresGenerated();
-        return this.placementsForStructure.getOrDefault(structure.value(), List.of());
+        return (List) this.placementsForStructure.getOrDefault(structure.value(), List.of());
     }
 
     public RandomState randomState() {
@@ -193,11 +206,11 @@
     }
 
     public boolean hasStructureChunkInRange(Holder<StructureSet> structureSet, int x, int z, int range) {
-        StructurePlacement structurePlacement = structureSet.value().placement();
+        StructurePlacement structureplacement = ((StructureSet) structureSet.value()).placement();
 
-        for (int i = x - range; i <= x + range; i++) {
-            for (int i1 = z - range; i1 <= z + range; i1++) {
-                if (structurePlacement.isStructureChunk(this, i, i1)) {
+        for (int l = x - range; l <= x + range; ++l) {
+            for (int i1 = z - range; i1 <= z + range; ++i1) {
+                if (structureplacement.isStructureChunk(this, l, i1)) {
                     return true;
                 }
             }
