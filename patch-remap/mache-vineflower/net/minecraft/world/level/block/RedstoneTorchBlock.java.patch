--- a/net/minecraft/world/level/block/RedstoneTorchBlock.java
+++ b/net/minecraft/world/level/block/RedstoneTorchBlock.java
@@ -2,26 +2,29 @@
 
 import com.google.common.collect.Lists;
 import com.mojang.serialization.MapCodec;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
-import net.minecraft.core.particles.DustParticleOptions;
+import net.minecraft.core.particles.ParticleParamRedstone;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
+import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
 public class RedstoneTorchBlock extends BaseTorchBlock {
+
     public static final MapCodec<RedstoneTorchBlock> CODEC = simpleCodec(RedstoneTorchBlock::new);
     public static final BooleanProperty LIT = BlockStateProperties.LIT;
-    private static final Map<BlockGetter, List<RedstoneTorchBlock.Toggle>> RECENT_TOGGLES = new WeakHashMap<>();
+    private static final Map<BlockGetter, List<RedstoneTorchBlock.Toggle>> RECENT_TOGGLES = new WeakHashMap();
     public static final int RECENT_TOGGLE_TIMER = 60;
     public static final int MAX_RECENT_TOGGLES = 8;
     public static final int RESTART_DELAY = 160;
@@ -29,104 +32,151 @@
 
     @Override
     public MapCodec<? extends RedstoneTorchBlock> codec() {
-        return CODEC;
+        return RedstoneTorchBlock.CODEC;
     }
 
     protected RedstoneTorchBlock(BlockBehaviour.Properties properties) {
         super(properties);
-        this.registerDefaultState(this.stateDefinition.any().setValue(LIT, Boolean.valueOf(true)));
+        this.registerDefaultState((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(RedstoneTorchBlock.LIT, true));
     }
 
     @Override
-    public void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean isMoving) {
-        for (Direction direction : Direction.values()) {
-            level.updateNeighborsAt(pos.relative(direction), this);
+    public void onPlace(IBlockData state, Level level, BlockPos pos, IBlockData oldState, boolean isMoving) {
+        Direction[] aenumdirection = Direction.values();
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            Direction enumdirection = aenumdirection[j];
+
+            level.updateNeighborsAt(pos.relative(enumdirection), this);
         }
+
     }
 
     @Override
-    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
+    public void onRemove(IBlockData state, Level level, BlockPos pos, IBlockData newState, boolean isMoving) {
         if (!isMoving) {
-            for (Direction direction : Direction.values()) {
-                level.updateNeighborsAt(pos.relative(direction), this);
+            Direction[] aenumdirection = Direction.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                Direction enumdirection = aenumdirection[j];
+
+                level.updateNeighborsAt(pos.relative(enumdirection), this);
             }
+
         }
     }
 
     @Override
-    public int getSignal(BlockState blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
-        return blockState.getValue(LIT) && Direction.UP != side ? 15 : 0;
+    public int getSignal(IBlockData blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
+        return (Boolean) blockState.getValue(RedstoneTorchBlock.LIT) && Direction.UP != side ? 15 : 0;
     }
 
-    protected boolean hasNeighborSignal(Level level, BlockPos pos, BlockState state) {
+    protected boolean hasNeighborSignal(Level level, BlockPos pos, IBlockData state) {
         return level.hasSignal(pos.below(), Direction.DOWN);
     }
 
     @Override
-    public void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
-        boolean hasNeighborSignal = this.hasNeighborSignal(level, pos, state);
-        List<RedstoneTorchBlock.Toggle> list = RECENT_TOGGLES.get(level);
+    public void tick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        boolean flag = this.hasNeighborSignal(level, pos, state);
+        List list = (List) RedstoneTorchBlock.RECENT_TOGGLES.get(level);
 
-        while (list != null && !list.isEmpty() && level.getGameTime() - list.get(0).when > 60L) {
+        while (list != null && !list.isEmpty() && level.getGameTime() - ((RedstoneTorchBlock.Toggle) list.get(0)).when > 60L) {
             list.remove(0);
         }
 
-        if (state.getValue(LIT)) {
-            if (hasNeighborSignal) {
-                level.setBlock(pos, state.setValue(LIT, Boolean.valueOf(false)), 3);
+        // CraftBukkit start
+        org.bukkit.plugin.PluginManager manager = level.getCraftServer().getPluginManager();
+        org.bukkit.block.Block block = level.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+        int oldCurrent = ((Boolean) state.getValue(RedstoneTorchBlock.LIT)).booleanValue() ? 15 : 0;
+
+        BlockRedstoneEvent event = new BlockRedstoneEvent(block, oldCurrent, oldCurrent);
+        // CraftBukkit end
+        if ((Boolean) state.getValue(RedstoneTorchBlock.LIT)) {
+            if (flag) {
+                // CraftBukkit start
+                if (oldCurrent != 0) {
+                    event.setNewCurrent(0);
+                    manager.callEvent(event);
+                    if (event.getNewCurrent() != 0) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                level.setBlock(pos, (IBlockData) state.setValue(RedstoneTorchBlock.LIT, false), 3);
                 if (isToggledTooFrequently(level, pos, true)) {
                     level.levelEvent(1502, pos, 0);
                     level.scheduleTick(pos, level.getBlockState(pos).getBlock(), 160);
                 }
             }
-        } else if (!hasNeighborSignal && !isToggledTooFrequently(level, pos, false)) {
-            level.setBlock(pos, state.setValue(LIT, Boolean.valueOf(true)), 3);
+        } else if (!flag && !isToggledTooFrequently(level, pos, false)) {
+            // CraftBukkit start
+            if (oldCurrent != 15) {
+                event.setNewCurrent(15);
+                manager.callEvent(event);
+                if (event.getNewCurrent() != 15) {
+                    return;
+                }
+            }
+            // CraftBukkit end
+            level.setBlock(pos, (IBlockData) state.setValue(RedstoneTorchBlock.LIT, true), 3);
         }
+
     }
 
     @Override
-    public void neighborChanged(BlockState state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
-        if (state.getValue(LIT) == this.hasNeighborSignal(level, pos, state) && !level.getBlockTicks().willTickThisTick(pos, this)) {
-            level.scheduleTick(pos, this, 2);
+    public void neighborChanged(IBlockData state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
+        if ((Boolean) state.getValue(RedstoneTorchBlock.LIT) == this.hasNeighborSignal(level, pos, state) && !level.getBlockTicks().willTickThisTick(pos, this)) {
+            level.scheduleTick(pos, (Block) this, 2);
         }
+
     }
 
     @Override
-    public int getDirectSignal(BlockState blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
+    public int getDirectSignal(IBlockData blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
         return side == Direction.DOWN ? blockState.getSignal(blockAccess, pos, side) : 0;
     }
 
     @Override
-    public boolean isSignalSource(BlockState state) {
+    public boolean isSignalSource(IBlockData state) {
         return true;
     }
 
     @Override
-    public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
-        if (state.getValue(LIT)) {
-            double d = (double)pos.getX() + 0.5 + (random.nextDouble() - 0.5) * 0.2;
-            double d1 = (double)pos.getY() + 0.7 + (random.nextDouble() - 0.5) * 0.2;
-            double d2 = (double)pos.getZ() + 0.5 + (random.nextDouble() - 0.5) * 0.2;
-            level.addParticle(DustParticleOptions.REDSTONE, d, d1, d2, 0.0, 0.0, 0.0);
+    public void animateTick(IBlockData state, Level level, BlockPos pos, RandomSource random) {
+        if ((Boolean) state.getValue(RedstoneTorchBlock.LIT)) {
+            double d0 = (double) pos.getX() + 0.5D + (random.nextDouble() - 0.5D) * 0.2D;
+            double d1 = (double) pos.getY() + 0.7D + (random.nextDouble() - 0.5D) * 0.2D;
+            double d2 = (double) pos.getZ() + 0.5D + (random.nextDouble() - 0.5D) * 0.2D;
+
+            level.addParticle(ParticleParamRedstone.REDSTONE, d0, d1, d2, 0.0D, 0.0D, 0.0D);
         }
     }
 
     @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
-        builder.add(LIT);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(RedstoneTorchBlock.LIT);
     }
 
     private static boolean isToggledTooFrequently(Level level, BlockPos pos, boolean logToggle) {
-        List<RedstoneTorchBlock.Toggle> list = RECENT_TOGGLES.computeIfAbsent(level, toggles -> Lists.newArrayList());
+        List<RedstoneTorchBlock.Toggle> list = (List) RedstoneTorchBlock.RECENT_TOGGLES.computeIfAbsent(level, (iblockaccess) -> {
+            return Lists.newArrayList();
+        });
+
         if (logToggle) {
             list.add(new RedstoneTorchBlock.Toggle(pos.immutable(), level.getGameTime()));
         }
 
         int i = 0;
+        Iterator iterator = list.iterator();
 
-        for (RedstoneTorchBlock.Toggle toggle : list) {
-            if (toggle.pos.equals(pos)) {
-                if (++i >= 8) {
+        while (iterator.hasNext()) {
+            RedstoneTorchBlock.Toggle blockredstonetorch_redstoneupdateinfo = (RedstoneTorchBlock.Toggle) iterator.next();
+
+            if (blockredstonetorch_redstoneupdateinfo.pos.equals(pos)) {
+                ++i;
+                if (i >= 8) {
                     return true;
                 }
             }
@@ -136,6 +186,7 @@
     }
 
     public static class Toggle {
+
         final BlockPos pos;
         final long when;
 
