--- a/net/minecraft/world/level/block/entity/SkullBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/SkullBlockEntity.java
@@ -23,61 +23,60 @@
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.SkullBlock;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 
 public class SkullBlockEntity extends BlockEntity {
+
     public static final String TAG_SKULL_OWNER = "SkullOwner";
     public static final String TAG_NOTE_BLOCK_SOUND = "note_block_sound";
     @Nullable
     private static Executor mainThreadExecutor;
     @Nullable
     private static LoadingCache<String, CompletableFuture<Optional<GameProfile>>> profileCache;
-    private static final Executor CHECKED_MAIN_THREAD_EXECUTOR = runnable -> {
-        Executor executor = mainThreadExecutor;
+    private static final Executor CHECKED_MAIN_THREAD_EXECUTOR = (runnable) -> {
+        Executor executor = SkullBlockEntity.mainThreadExecutor;
+
         if (executor != null) {
             executor.execute(runnable);
         }
+
     };
     @Nullable
-    private GameProfile owner;
+    public GameProfile owner;
     @Nullable
-    private ResourceLocation noteBlockSound;
+    public ResourceLocation noteBlockSound;
     private int animationTickCount;
     private boolean isAnimating;
 
-    public SkullBlockEntity(BlockPos pos, BlockState blockState) {
+    public SkullBlockEntity(BlockPos pos, IBlockData blockState) {
         super(BlockEntityType.SKULL, pos, blockState);
     }
 
     public static void setup(final Services services, Executor mainThreadExecutor) {
         SkullBlockEntity.mainThreadExecutor = mainThreadExecutor;
-        final BooleanSupplier booleanSupplier = () -> profileCache == null;
-        profileCache = CacheBuilder.newBuilder()
-            .expireAfterAccess(Duration.ofMinutes(10L))
-            .maximumSize(256L)
-            .build(
-                new CacheLoader<String, CompletableFuture<Optional<GameProfile>>>() {
-                    @Override
-                    public CompletableFuture<Optional<GameProfile>> load(String string) {
-                        return booleanSupplier.getAsBoolean()
-                            ? CompletableFuture.completedFuture(Optional.empty())
-                            : SkullBlockEntity.loadProfile(string, services, booleanSupplier);
-                    }
-                }
-            );
+        final BooleanSupplier booleansupplier = () -> {
+            return SkullBlockEntity.profileCache == null;
+        };
+
+        SkullBlockEntity.profileCache = CacheBuilder.newBuilder().expireAfterAccess(Duration.ofMinutes(10L)).maximumSize(256L).build(new CacheLoader<String, CompletableFuture<Optional<GameProfile>>>() {
+            public CompletableFuture<Optional<GameProfile>> load(String s) {
+                return booleansupplier.getAsBoolean() ? CompletableFuture.completedFuture(Optional.empty()) : SkullBlockEntity.loadProfile(s, services, booleansupplier);
+            }
+        });
     }
 
     public static void clear() {
-        mainThreadExecutor = null;
-        profileCache = null;
+        SkullBlockEntity.mainThreadExecutor = null;
+        SkullBlockEntity.profileCache = null;
     }
 
-    static CompletableFuture<Optional<GameProfile>> loadProfile(String string, Services services, BooleanSupplier booleanSupplier) {
-        return services.profileCache().getAsync(string).thenApplyAsync(optional -> {
-            if (optional.isPresent() && !booleanSupplier.getAsBoolean()) {
-                UUID id = optional.get().getId();
-                ProfileResult profileResult = services.sessionService().fetchProfile(id, true);
-                return profileResult != null ? Optional.ofNullable(profileResult.profile()) : optional;
+    static CompletableFuture<Optional<GameProfile>> loadProfile(String s, Services services, BooleanSupplier booleansupplier) {
+        return services.profileCache().getAsync(s).thenApplyAsync((optional) -> {
+            if (optional.isPresent() && !booleansupplier.getAsBoolean()) {
+                UUID uuid = ((GameProfile) optional.get()).getId();
+                ProfileResult profileresult = services.sessionService().fetchProfile(uuid, true);
+
+                return profileresult != null ? Optional.ofNullable(profileresult.profile()) : optional;
             } else {
                 return Optional.empty();
             }
@@ -88,14 +87,16 @@
     protected void saveAdditional(CompoundTag tag) {
         super.saveAdditional(tag);
         if (this.owner != null) {
-            CompoundTag compoundTag = new CompoundTag();
-            NbtUtils.writeGameProfile(compoundTag, this.owner);
-            tag.put("SkullOwner", compoundTag);
+            CompoundTag nbttagcompound1 = new CompoundTag();
+
+            NbtUtils.writeGameProfile(nbttagcompound1, this.owner);
+            tag.put("SkullOwner", nbttagcompound1);
         }
 
         if (this.noteBlockSound != null) {
             tag.putString("note_block_sound", this.noteBlockSound.toString());
         }
+
     }
 
     @Override
@@ -104,28 +105,31 @@
         if (tag.contains("SkullOwner", 10)) {
             this.setOwner(NbtUtils.readGameProfile(tag.getCompound("SkullOwner")));
         } else if (tag.contains("ExtraType", 8)) {
-            String string = tag.getString("ExtraType");
-            if (!StringUtil.isNullOrEmpty(string)) {
-                this.setOwner(new GameProfile(Util.NIL_UUID, string));
+            String s = tag.getString("ExtraType");
+
+            if (!StringUtil.isNullOrEmpty(s)) {
+                this.setOwner(new GameProfile(Util.NIL_UUID, s));
             }
         }
 
         if (tag.contains("note_block_sound", 8)) {
             this.noteBlockSound = ResourceLocation.tryParse(tag.getString("note_block_sound"));
         }
+
     }
 
-    public static void animation(Level level, BlockPos pos, BlockState state, SkullBlockEntity blockEntity) {
-        if (state.hasProperty(SkullBlock.POWERED) && state.getValue(SkullBlock.POWERED)) {
+    public static void animation(Level level, BlockPos pos, IBlockData state, SkullBlockEntity blockEntity) {
+        if (state.hasProperty(SkullBlock.POWERED) && (Boolean) state.getValue(SkullBlock.POWERED)) {
             blockEntity.isAnimating = true;
-            blockEntity.animationTickCount++;
+            ++blockEntity.animationTickCount;
         } else {
             blockEntity.isAnimating = false;
         }
+
     }
 
     public float getAnimation(float partialTick) {
-        return this.isAnimating ? (float)this.animationTickCount + partialTick : (float)this.animationTickCount;
+        return this.isAnimating ? (float) this.animationTickCount + partialTick : (float) this.animationTickCount;
     }
 
     @Nullable
@@ -158,25 +162,26 @@
 
     private void updateOwnerProfile() {
         if (this.owner != null && !Util.isBlank(this.owner.getName()) && !hasTextures(this.owner)) {
-            fetchGameProfile(this.owner.getName()).thenAcceptAsync(optional -> {
-                this.owner = optional.orElse(this.owner);
+            fetchGameProfile(this.owner.getName()).thenAcceptAsync((optional) -> {
+                this.owner = (GameProfile) optional.orElse(this.owner);
                 this.setChanged();
-            }, CHECKED_MAIN_THREAD_EXECUTOR);
+            }, SkullBlockEntity.CHECKED_MAIN_THREAD_EXECUTOR);
         } else {
             this.setChanged();
         }
     }
 
     @Nullable
-    public static GameProfile getOrResolveGameProfile(CompoundTag compoundTag) {
-        if (compoundTag.contains("SkullOwner", 10)) {
-            return NbtUtils.readGameProfile(compoundTag.getCompound("SkullOwner"));
+    public static GameProfile getOrResolveGameProfile(CompoundTag nbttagcompound) {
+        if (nbttagcompound.contains("SkullOwner", 10)) {
+            return NbtUtils.readGameProfile(nbttagcompound.getCompound("SkullOwner"));
         } else {
-            if (compoundTag.contains("SkullOwner", 8)) {
-                String string = compoundTag.getString("SkullOwner");
-                if (!Util.isBlank(string)) {
-                    compoundTag.remove("SkullOwner");
-                    resolveGameProfile(compoundTag, string);
+            if (nbttagcompound.contains("SkullOwner", 8)) {
+                String s = nbttagcompound.getString("SkullOwner");
+
+                if (!Util.isBlank(s)) {
+                    nbttagcompound.remove("SkullOwner");
+                    resolveGameProfile(nbttagcompound, s);
                 }
             }
 
@@ -184,26 +189,38 @@
         }
     }
 
-    public static void resolveGameProfile(CompoundTag compoundTag) {
-        String string = compoundTag.getString("SkullOwner");
-        if (!Util.isBlank(string)) {
-            resolveGameProfile(compoundTag, string);
+    public static void resolveGameProfile(CompoundTag nbttagcompound) {
+        String s = nbttagcompound.getString("SkullOwner");
+
+        if (!Util.isBlank(s)) {
+            resolveGameProfile(nbttagcompound, s);
+            // CraftBukkit start
+        } else {
+            net.minecraft.nbt.ListTag textures = nbttagcompound.getCompound("SkullOwner").getCompound("Properties").getList("textures", 10); // Safe due to method contracts
+            for (int i = 0; i < textures.size(); i++) {
+                if (textures.get(i) instanceof CompoundTag && !((CompoundTag) textures.get(i)).contains("Signature", 8) && ((CompoundTag) textures.get(i)).getString("Value").trim().isEmpty()) {
+                    nbttagcompound.remove("SkullOwner");
+                    break;
+                }
+            }
+            // CraftBukkit end
         }
+
     }
 
-    private static void resolveGameProfile(CompoundTag compoundTag, String string) {
-        fetchGameProfile(string)
-            .thenAccept(
-                optional -> compoundTag.put("SkullOwner", NbtUtils.writeGameProfile(new CompoundTag(), optional.orElse(new GameProfile(Util.NIL_UUID, string))))
-            );
+    private static void resolveGameProfile(CompoundTag nbttagcompound, String s) {
+        fetchGameProfile(s).thenAccept((optional) -> {
+            nbttagcompound.put("SkullOwner", NbtUtils.writeGameProfile(new CompoundTag(), (GameProfile) optional.orElse(new GameProfile(Util.NIL_UUID, s))));
+        });
     }
 
-    private static CompletableFuture<Optional<GameProfile>> fetchGameProfile(String string) {
-        LoadingCache<String, CompletableFuture<Optional<GameProfile>>> loadingCache = profileCache;
-        return loadingCache != null && Player.isValidUsername(string) ? loadingCache.getUnchecked(string) : CompletableFuture.completedFuture(Optional.empty());
+    private static CompletableFuture<Optional<GameProfile>> fetchGameProfile(String s) {
+        LoadingCache<String, CompletableFuture<Optional<GameProfile>>> loadingcache = SkullBlockEntity.profileCache;
+
+        return loadingcache != null && Player.isValidUsername(s) ? (CompletableFuture) loadingcache.getUnchecked(s) : CompletableFuture.completedFuture(Optional.empty());
     }
 
-    private static boolean hasTextures(GameProfile gameProfile) {
-        return gameProfile.getProperties().containsKey("textures");
+    private static boolean hasTextures(GameProfile gameprofile) {
+        return gameprofile.getProperties().containsKey("textures");
     }
 }
