--- a/net/minecraft/world/level/block/MultifaceSpreader.java
+++ b/net/minecraft/world/level/block/MultifaceSpreader.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.level.block;
 
 import com.google.common.annotations.VisibleForTesting;
+import java.util.Objects;
 import java.util.Optional;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
@@ -8,99 +9,98 @@
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.LevelAccessor;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 
 public class MultifaceSpreader {
-    public static final MultifaceSpreader.SpreadType[] DEFAULT_SPREAD_ORDER = new MultifaceSpreader.SpreadType[]{
-        MultifaceSpreader.SpreadType.SAME_POSITION, MultifaceSpreader.SpreadType.SAME_PLANE, MultifaceSpreader.SpreadType.WRAP_AROUND
-    };
+
+    public static final MultifaceSpreader.SpreadType[] DEFAULT_SPREAD_ORDER = new MultifaceSpreader.SpreadType[]{MultifaceSpreader.SpreadType.SAME_POSITION, MultifaceSpreader.SpreadType.SAME_PLANE, MultifaceSpreader.SpreadType.WRAP_AROUND};
     private final MultifaceSpreader.SpreadConfig config;
 
-    public MultifaceSpreader(MultifaceBlock config) {
-        this(new MultifaceSpreader.DefaultSpreaderConfig(config));
+    public MultifaceSpreader(MultifaceBlock block) {
+        this((MultifaceSpreader.SpreadConfig) (new MultifaceSpreader.DefaultSpreaderConfig(block)));
     }
 
     public MultifaceSpreader(MultifaceSpreader.SpreadConfig config) {
         this.config = config;
     }
 
-    public boolean canSpreadInAnyDirection(BlockState state, BlockGetter level, BlockPos pos, Direction spreadDirection) {
-        return Direction.stream()
-            .anyMatch(face -> this.getSpreadFromFaceTowardDirection(state, level, pos, spreadDirection, face, this.config::canSpreadInto).isPresent());
+    public boolean canSpreadInAnyDirection(IBlockData state, BlockGetter level, BlockPos pos, Direction spreadDirection) {
+        return Direction.stream().anyMatch((enumdirection1) -> {
+            MultifaceSpreader.SpreadConfig multifacespreader_b = this.config;
+
+            Objects.requireNonNull(this.config);
+            return this.getSpreadFromFaceTowardDirection(state, level, pos, spreadDirection, enumdirection1, multifacespreader_b::canSpreadInto).isPresent();
+        });
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> spreadFromRandomFaceTowardRandomDirection(
-        BlockState state, LevelAccessor level, BlockPos pos, RandomSource random
-    ) {
-        return Direction.allShuffled(random)
-            .stream()
-            .filter(direction -> this.config.canSpreadFrom(state, direction))
-            .map(spreadDirection -> this.spreadFromFaceTowardRandomDirection(state, level, pos, spreadDirection, random, false))
-            .filter(Optional::isPresent)
-            .findFirst()
-            .orElse(Optional.empty());
+    public Optional<MultifaceSpreader.c> spreadFromRandomFaceTowardRandomDirection(IBlockData state, LevelAccessor level, BlockPos pos, RandomSource random) {
+        return (Optional) Direction.allShuffled(random).stream().filter((enumdirection) -> {
+            return this.config.canSpreadFrom(state, enumdirection);
+        }).map((enumdirection) -> {
+            return this.spreadFromFaceTowardRandomDirection(state, level, pos, enumdirection, random, false);
+        }).filter(Optional::isPresent).findFirst().orElse(Optional.empty());
     }
 
-    public long spreadAll(BlockState state, LevelAccessor level, BlockPos pos, boolean markForPostprocessing) {
-        return Direction.stream()
-            .filter(direction -> this.config.canSpreadFrom(state, direction))
-            .map(spreadDirection -> this.spreadFromFaceTowardAllDirections(state, level, pos, spreadDirection, markForPostprocessing))
-            .reduce(0L, Long::sum);
+    public long spreadAll(IBlockData state, LevelAccessor level, BlockPos pos, boolean markForPostprocessing) {
+        return (Long) Direction.stream().filter((enumdirection) -> {
+            return this.config.canSpreadFrom(state, enumdirection);
+        }).map((enumdirection) -> {
+            return this.spreadFromFaceTowardAllDirections(state, level, pos, enumdirection, markForPostprocessing);
+        }).reduce(0L, Long::sum);
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> spreadFromFaceTowardRandomDirection(
-        BlockState state, LevelAccessor level, BlockPos pos, Direction spreadDirection, RandomSource random, boolean markForPostprocessing
-    ) {
-        return Direction.allShuffled(random)
-            .stream()
-            .map(face -> this.spreadFromFaceTowardDirection(state, level, pos, spreadDirection, face, markForPostprocessing))
-            .filter(Optional::isPresent)
-            .findFirst()
-            .orElse(Optional.empty());
+    public Optional<MultifaceSpreader.c> spreadFromFaceTowardRandomDirection(IBlockData state, LevelAccessor level, BlockPos pos, Direction spreadDirection, RandomSource random, boolean markForPostprocessing) {
+        return (Optional) Direction.allShuffled(random).stream().map((enumdirection1) -> {
+            return this.spreadFromFaceTowardDirection(state, level, pos, spreadDirection, enumdirection1, markForPostprocessing);
+        }).filter(Optional::isPresent).findFirst().orElse(Optional.empty());
     }
 
-    private long spreadFromFaceTowardAllDirections(
-        BlockState state, LevelAccessor level, BlockPos pos, Direction spreadDirection, boolean markForPostprocessing
-    ) {
-        return Direction.stream()
-            .map(face -> this.spreadFromFaceTowardDirection(state, level, pos, spreadDirection, face, markForPostprocessing))
-            .filter(Optional::isPresent)
-            .count();
+    private long spreadFromFaceTowardAllDirections(IBlockData state, LevelAccessor level, BlockPos pos, Direction spreadDirection, boolean markForPostprocessing) {
+        return Direction.stream().map((enumdirection1) -> {
+            return this.spreadFromFaceTowardDirection(state, level, pos, spreadDirection, enumdirection1, markForPostprocessing);
+        }).filter(Optional::isPresent).count();
     }
 
     @VisibleForTesting
-    public Optional<MultifaceSpreader.SpreadPos> spreadFromFaceTowardDirection(
-        BlockState state, LevelAccessor level, BlockPos pos, Direction spreadDirection, Direction face, boolean markForPostprocessing
-    ) {
-        return this.getSpreadFromFaceTowardDirection(state, level, pos, spreadDirection, face, this.config::canSpreadInto)
-            .flatMap(spreadPos -> this.spreadToFace(level, spreadPos, markForPostprocessing));
+    public Optional<MultifaceSpreader.c> spreadFromFaceTowardDirection(IBlockData state, LevelAccessor level, BlockPos pos, Direction spreadDirection, Direction face, boolean markForPostprocessing) {
+        MultifaceSpreader.SpreadConfig multifacespreader_b = this.config;
+
+        Objects.requireNonNull(this.config);
+        return this.getSpreadFromFaceTowardDirection(state, level, pos, spreadDirection, face, multifacespreader_b::canSpreadInto).flatMap((multifacespreader_c) -> {
+            return this.spreadToFace(level, multifacespreader_c, markForPostprocessing);
+        });
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> getSpreadFromFaceTowardDirection(
-        BlockState state, BlockGetter level, BlockPos pos, Direction spreadDirection, Direction face, MultifaceSpreader.SpreadPredicate predicate
-    ) {
+    public Optional<MultifaceSpreader.c> getSpreadFromFaceTowardDirection(IBlockData state, BlockGetter level, BlockPos pos, Direction spreadDirection, Direction face, MultifaceSpreader.SpreadPredicate predicate) {
         if (face.getAxis() == spreadDirection.getAxis()) {
             return Optional.empty();
-        } else if (this.config.isOtherBlockValidAsSource(state) || this.config.hasFace(state, spreadDirection) && !this.config.hasFace(state, face)) {
-            for (MultifaceSpreader.SpreadType spreadType : this.config.getSpreadTypes()) {
-                MultifaceSpreader.SpreadPos spreadPos = spreadType.getSpreadPos(pos, face, spreadDirection);
-                if (predicate.test(level, pos, spreadPos)) {
-                    return Optional.of(spreadPos);
+        } else if (!this.config.isOtherBlockValidAsSource(state) && (!this.config.hasFace(state, spreadDirection) || this.config.hasFace(state, face))) {
+            return Optional.empty();
+        } else {
+            MultifaceSpreader.SpreadType[] amultifacespreader_e = this.config.getSpreadTypes();
+            int i = amultifacespreader_e.length;
+
+            for (int j = 0; j < i; ++j) {
+                MultifaceSpreader.SpreadType multifacespreader_e = amultifacespreader_e[j];
+                MultifaceSpreader.c multifacespreader_c = multifacespreader_e.getSpreadPos(pos, face, spreadDirection);
+
+                if (predicate.test(level, pos, multifacespreader_c)) {
+                    return Optional.of(multifacespreader_c);
                 }
             }
 
             return Optional.empty();
-        } else {
-            return Optional.empty();
         }
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> spreadToFace(LevelAccessor level, MultifaceSpreader.SpreadPos pos, boolean markForPostprocessing) {
-        BlockState blockState = level.getBlockState(pos.pos());
-        return this.config.placeBlock(level, pos, blockState, markForPostprocessing) ? Optional.of(pos) : Optional.empty();
+    public Optional<MultifaceSpreader.c> spreadToFace(LevelAccessor level, MultifaceSpreader.c pos, boolean markForPostprocessing) {
+        IBlockData iblockdata = level.getBlockState(pos.pos());
+
+        return this.config.placeBlock(level, pos, iblockdata, markForPostprocessing) ? Optional.of(pos) : Optional.empty();
     }
 
     public static class DefaultSpreaderConfig implements MultifaceSpreader.SpreadConfig {
+
         protected MultifaceBlock block;
 
         public DefaultSpreaderConfig(MultifaceBlock block) {
@@ -109,86 +109,93 @@
 
         @Nullable
         @Override
-        public BlockState getStateForPlacement(BlockState currentState, BlockGetter level, BlockPos pos, Direction lookingDirection) {
+        public IBlockData getStateForPlacement(IBlockData currentState, BlockGetter level, BlockPos pos, Direction lookingDirection) {
             return this.block.getStateForPlacement(currentState, level, pos, lookingDirection);
         }
 
-        protected boolean stateCanBeReplaced(BlockGetter level, BlockPos pos, BlockPos spreadPos, Direction direction, BlockState state) {
-            return state.isAir() || state.is(this.block) || state.is(Blocks.WATER) && state.getFluidState().isSource();
+        protected boolean stateCanBeReplaced(BlockGetter level, BlockPos pos, BlockPos spreadPos, Direction direction, IBlockData state) {
+            return state.isAir() || state.is((Block) this.block) || state.is(Blocks.WATER) && state.getFluidState().isSource();
         }
 
         @Override
-        public boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.SpreadPos spreadPos) {
-            BlockState blockState = level.getBlockState(spreadPos.pos());
-            return this.stateCanBeReplaced(level, pos, spreadPos.pos(), spreadPos.face(), blockState)
-                && this.block.isValidStateForPlacement(level, blockState, spreadPos.pos(), spreadPos.face());
+        public boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.c spreadPos) {
+            IBlockData iblockdata = level.getBlockState(spreadPos.pos());
+
+            return this.stateCanBeReplaced(level, pos, spreadPos.pos(), spreadPos.face(), iblockdata) && this.block.isValidStateForPlacement(level, iblockdata, spreadPos.pos(), spreadPos.face());
         }
     }
 
     public interface SpreadConfig {
+
         @Nullable
-        BlockState getStateForPlacement(BlockState currentState, BlockGetter level, BlockPos pos, Direction lookingDirection);
+        IBlockData getStateForPlacement(IBlockData currentState, BlockGetter level, BlockPos pos, Direction lookingDirection);
 
-        boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.SpreadPos spreadPos);
+        boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.c spreadPos);
 
         default MultifaceSpreader.SpreadType[] getSpreadTypes() {
             return MultifaceSpreader.DEFAULT_SPREAD_ORDER;
         }
 
-        default boolean hasFace(BlockState state, Direction direction) {
+        default boolean hasFace(IBlockData state, Direction direction) {
             return MultifaceBlock.hasFace(state, direction);
         }
 
-        default boolean isOtherBlockValidAsSource(BlockState otherBlock) {
+        default boolean isOtherBlockValidAsSource(IBlockData otherBlock) {
             return false;
         }
 
-        default boolean canSpreadFrom(BlockState state, Direction direction) {
+        default boolean canSpreadFrom(IBlockData state, Direction direction) {
             return this.isOtherBlockValidAsSource(state) || this.hasFace(state, direction);
         }
 
-        default boolean placeBlock(LevelAccessor level, MultifaceSpreader.SpreadPos pos, BlockState state, boolean markForPostprocessing) {
-            BlockState stateForPlacement = this.getStateForPlacement(state, level, pos.pos(), pos.face());
-            if (stateForPlacement != null) {
+        default boolean placeBlock(LevelAccessor level, MultifaceSpreader.c pos, IBlockData state, boolean markForPostprocessing) {
+            IBlockData iblockdata1 = this.getStateForPlacement(state, level, pos.pos(), pos.face());
+
+            if (iblockdata1 != null) {
                 if (markForPostprocessing) {
                     level.getChunk(pos.pos()).markPosForPostprocessing(pos.pos());
                 }
 
-                return level.setBlock(pos.pos(), stateForPlacement, 2);
+                return org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockSpreadEvent(level, pos.source(), pos.pos(), iblockdata1, 2); // CraftBukkit
             } else {
                 return false;
             }
         }
     }
 
-    public static record SpreadPos(BlockPos pos, Direction face) {
-    }
-
     @FunctionalInterface
     public interface SpreadPredicate {
-        boolean test(BlockGetter level, BlockPos pos, MultifaceSpreader.SpreadPos spreadPos);
+
+        boolean test(BlockGetter level, BlockPos pos, MultifaceSpreader.c spreadPos);
     }
 
     public static enum SpreadType {
+
         SAME_POSITION {
             @Override
-            public MultifaceSpreader.SpreadPos getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
-                return new MultifaceSpreader.SpreadPos(pos, face);
+            public MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
+                return new MultifaceSpreader.c(pos, face, pos); // CraftBukkit
             }
         },
         SAME_PLANE {
             @Override
-            public MultifaceSpreader.SpreadPos getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
-                return new MultifaceSpreader.SpreadPos(pos.relative(face), spreadDirection);
+            public MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
+                return new MultifaceSpreader.c(pos.relative(face), spreadDirection, pos); // CraftBukkit
             }
         },
         WRAP_AROUND {
             @Override
-            public MultifaceSpreader.SpreadPos getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
-                return new MultifaceSpreader.SpreadPos(pos.relative(face).relative(spreadDirection), face.getOpposite());
+            public MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
+                return new MultifaceSpreader.c(pos.relative(face).relative(spreadDirection), face.getOpposite(), pos); // CraftBukkit
             }
         };
 
-        public abstract MultifaceSpreader.SpreadPos getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection);
+        SpreadType() {}
+
+        public abstract MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection);
     }
+
+    public static record c(BlockPos pos, Direction face, BlockPos source) { // CraftBukkit
+
+    }
 }
