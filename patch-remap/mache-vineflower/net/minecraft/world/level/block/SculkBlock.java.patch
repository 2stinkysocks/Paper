--- a/net/minecraft/world/level/block/SculkBlock.java
+++ b/net/minecraft/world/level/block/SculkBlock.java
@@ -1,23 +1,27 @@
 package net.minecraft.world.level.block;
 
 import com.mojang.serialization.MapCodec;
+import java.util.Iterator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.valueproviders.ConstantInt;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.Fluids;
 
 public class SculkBlock extends DropExperienceBlock implements SculkBehaviour {
+
     public static final MapCodec<SculkBlock> CODEC = simpleCodec(SculkBlock::new);
 
     @Override
     public MapCodec<SculkBlock> codec() {
-        return CODEC;
+        return SculkBlock.CODEC;
     }
 
     public SculkBlock(BlockBehaviour.Properties properties) {
@@ -25,70 +29,79 @@
     }
 
     @Override
-    public int attemptUseCharge(
-        SculkSpreader.ChargeCursor cursor, LevelAccessor level, BlockPos pos, RandomSource random, SculkSpreader spreader, boolean shouldConvertBlocks
-    ) {
-        int charge = cursor.getCharge();
-        if (charge != 0 && random.nextInt(spreader.chargeDecayRate()) == 0) {
-            BlockPos pos1 = cursor.getPos();
-            boolean flag = pos1.closerThan(pos, (double)spreader.noGrowthRadius());
-            if (!flag && canPlaceGrowth(level, pos1)) {
-                int i = spreader.growthSpawnCost();
-                if (random.nextInt(i) < charge) {
-                    BlockPos blockPos = pos1.above();
-                    BlockState randomGrowthState = this.getRandomGrowthState(level, blockPos, random, spreader.isWorldGeneration());
-                    level.setBlock(blockPos, randomGrowthState, 3);
-                    level.playSound(null, pos1, randomGrowthState.getSoundType().getPlaceSound(), SoundSource.BLOCKS, 1.0F, 1.0F);
+    public int attemptUseCharge(SculkSpreader.ChargeCursor cursor, LevelAccessor level, BlockPos pos, RandomSource random, SculkSpreader spreader, boolean shouldConvertBlocks) {
+        int i = cursor.getCharge();
+
+        if (i != 0 && random.nextInt(spreader.chargeDecayRate()) == 0) {
+            BlockPos blockposition1 = cursor.getPos();
+            boolean flag1 = blockposition1.closerThan(pos, (double) spreader.noGrowthRadius());
+
+            if (!flag1 && canPlaceGrowth(level, blockposition1)) {
+                int j = spreader.growthSpawnCost();
+
+                if (random.nextInt(j) < i) {
+                    BlockPos blockposition2 = blockposition1.above();
+                    IBlockData iblockdata = this.getRandomGrowthState(level, blockposition2, random, spreader.isWorldGeneration());
+
+                    // CraftBukkit start - Call BlockSpreadEvent
+                    if (org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition2, iblockdata, 3)) {
+                        level.playSound((Player) null, blockposition1, iblockdata.getSoundType().getPlaceSound(), SoundSource.BLOCKS, 1.0F, 1.0F);
+                    }
+                    // CraftBukkit end
                 }
 
-                return Math.max(0, charge - i);
+                return Math.max(0, i - j);
             } else {
-                return random.nextInt(spreader.additionalDecayRate()) != 0 ? charge : charge - (flag ? 1 : getDecayPenalty(spreader, pos1, pos, charge));
+                return random.nextInt(spreader.additionalDecayRate()) != 0 ? i : i - (flag1 ? 1 : getDecayPenalty(spreader, blockposition1, pos, i));
             }
         } else {
-            return charge;
+            return i;
         }
     }
 
     private static int getDecayPenalty(SculkSpreader spreader, BlockPos cursorPos, BlockPos rootPos, int charge) {
-        int i = spreader.noGrowthRadius();
-        float squared = Mth.square((float)Math.sqrt(cursorPos.distSqr(rootPos)) - (float)i);
-        int squared1 = Mth.square(24 - i);
-        float min = Math.min(1.0F, squared / (float)squared1);
-        return Math.max(1, (int)((float)charge * min * 0.5F));
+        int j = spreader.noGrowthRadius();
+        float f = Mth.square((float) Math.sqrt(cursorPos.distSqr(rootPos)) - (float) j);
+        int k = Mth.square(24 - j);
+        float f1 = Math.min(1.0F, f / (float) k);
+
+        return Math.max(1, (int) ((float) charge * f1 * 0.5F));
     }
 
-    private BlockState getRandomGrowthState(LevelAccessor level, BlockPos pos, RandomSource random, boolean isWorldGeneration) {
-        BlockState blockState;
+    private IBlockData getRandomGrowthState(LevelAccessor level, BlockPos pos, RandomSource random, boolean isWorldGeneration) {
+        IBlockData iblockdata;
+
         if (random.nextInt(11) == 0) {
-            blockState = Blocks.SCULK_SHRIEKER.defaultBlockState().setValue(SculkShriekerBlock.CAN_SUMMON, Boolean.valueOf(isWorldGeneration));
+            iblockdata = (IBlockData) Blocks.SCULK_SHRIEKER.defaultBlockState().setValue(SculkShriekerBlock.CAN_SUMMON, isWorldGeneration);
         } else {
-            blockState = Blocks.SCULK_SENSOR.defaultBlockState();
+            iblockdata = Blocks.SCULK_SENSOR.defaultBlockState();
         }
 
-        return blockState.hasProperty(BlockStateProperties.WATERLOGGED) && !level.getFluidState(pos).isEmpty()
-            ? blockState.setValue(BlockStateProperties.WATERLOGGED, Boolean.valueOf(true))
-            : blockState;
+        return iblockdata.hasProperty(BlockStateProperties.WATERLOGGED) && !level.getFluidState(pos).isEmpty() ? (IBlockData) iblockdata.setValue(BlockStateProperties.WATERLOGGED, true) : iblockdata;
     }
 
     private static boolean canPlaceGrowth(LevelAccessor level, BlockPos pos) {
-        BlockState blockState = level.getBlockState(pos.above());
-        if (blockState.isAir() || blockState.is(Blocks.WATER) && blockState.getFluidState().is(Fluids.WATER)) {
+        IBlockData iblockdata = level.getBlockState(pos.above());
+
+        if (!iblockdata.isAir() && (!iblockdata.is(Blocks.WATER) || !iblockdata.getFluidState().is((Fluid) Fluids.WATER))) {
+            return false;
+        } else {
             int i = 0;
+            Iterator iterator = BlockPos.betweenClosed(pos.offset(-4, 0, -4), pos.offset(4, 2, 4)).iterator();
 
-            for (BlockPos blockPos : BlockPos.betweenClosed(pos.offset(-4, 0, -4), pos.offset(4, 2, 4))) {
-                BlockState blockState1 = level.getBlockState(blockPos);
-                if (blockState1.is(Blocks.SCULK_SENSOR) || blockState1.is(Blocks.SCULK_SHRIEKER)) {
-                    i++;
+            do {
+                if (!iterator.hasNext()) {
+                    return true;
                 }
 
-                if (i > 2) {
-                    return false;
+                BlockPos blockposition1 = (BlockPos) iterator.next();
+                IBlockData iblockdata1 = level.getBlockState(blockposition1);
+
+                if (iblockdata1.is(Blocks.SCULK_SENSOR) || iblockdata1.is(Blocks.SCULK_SHRIEKER)) {
+                    ++i;
                 }
-            }
+            } while (i <= 2);
 
-            return true;
-        } else {
             return false;
         }
     }
