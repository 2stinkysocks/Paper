--- a/net/minecraft/world/level/block/CommandBlock.java
+++ b/net/minecraft/world/level/block/CommandBlock.java
@@ -4,13 +4,12 @@
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.StringUtil;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.player.Player;
@@ -23,7 +22,7 @@
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
@@ -31,96 +30,121 @@
 import net.minecraft.world.phys.BlockHitResult;
 import org.slf4j.Logger;
 
+import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
+
 public class CommandBlock extends BaseEntityBlock implements GameMasterBlock {
-    public static final MapCodec<CommandBlock> CODEC = RecordCodecBuilder.mapCodec(
-        instance -> instance.group(Codec.BOOL.fieldOf("automatic").forGetter(commandBlock -> commandBlock.automatic), propertiesCodec())
-                .apply(instance, CommandBlock::new)
-    );
+
+    public static final MapCodec<CommandBlock> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
+        return instance.group(Codec.BOOL.fieldOf("automatic").forGetter((blockcommand) -> {
+            return blockcommand.automatic;
+        }), propertiesCodec()).apply(instance, CommandBlock::new);
+    });
     private static final Logger LOGGER = LogUtils.getLogger();
-    public static final DirectionProperty FACING = DirectionalBlock.FACING;
+    public static final DirectionProperty FACING = BlockDirectional.FACING;
     public static final BooleanProperty CONDITIONAL = BlockStateProperties.CONDITIONAL;
     private final boolean automatic;
 
     @Override
     public MapCodec<CommandBlock> codec() {
-        return CODEC;
+        return CommandBlock.CODEC;
     }
 
-    public CommandBlock(boolean flag, BlockBehaviour.Properties properties) {
-        super(properties);
-        this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(CONDITIONAL, Boolean.valueOf(false)));
+    public CommandBlock(boolean flag, BlockBehaviour.Properties blockbase_info) {
+        super(blockbase_info);
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(CommandBlock.FACING, Direction.NORTH)).setValue(CommandBlock.CONDITIONAL, false));
         this.automatic = flag;
     }
 
     @Override
-    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
-        CommandBlockEntity commandBlockEntity = new CommandBlockEntity(pos, state);
-        commandBlockEntity.setAutomatic(this.automatic);
-        return commandBlockEntity;
+    public BlockEntity newBlockEntity(BlockPos pos, IBlockData state) {
+        CommandBlockEntity tileentitycommand = new CommandBlockEntity(pos, state);
+
+        tileentitycommand.setAutomatic(this.automatic);
+        return tileentitycommand;
     }
 
     @Override
-    public void neighborChanged(BlockState state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
+    public void neighborChanged(IBlockData state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
         if (!level.isClientSide) {
-            if (level.getBlockEntity(pos) instanceof CommandBlockEntity commandBlockEntity) {
-                boolean hasNeighborSignal = level.hasNeighborSignal(pos);
-                boolean isPowered = commandBlockEntity.isPowered();
-                commandBlockEntity.setPowered(hasNeighborSignal);
-                if (!isPowered && !commandBlockEntity.isAutomatic() && commandBlockEntity.getMode() != CommandBlockEntity.Mode.SEQUENCE) {
-                    if (hasNeighborSignal) {
-                        commandBlockEntity.markConditionMet();
-                        level.scheduleTick(pos, this, 1);
+            BlockEntity tileentity = level.getBlockEntity(pos);
+
+            if (tileentity instanceof CommandBlockEntity) {
+                CommandBlockEntity tileentitycommand = (CommandBlockEntity) tileentity;
+                boolean flag1 = level.hasNeighborSignal(pos);
+                boolean flag2 = tileentitycommand.isPowered();
+                // CraftBukkit start
+                org.bukkit.block.Block bukkitBlock = level.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+                int old = flag2 ? 15 : 0;
+                int current = flag1 ? 15 : 0;
+
+                BlockRedstoneEvent eventRedstone = new BlockRedstoneEvent(bukkitBlock, old, current);
+                level.getCraftServer().getPluginManager().callEvent(eventRedstone);
+                flag1 = eventRedstone.getNewCurrent() > 0;
+                // CraftBukkit end
+
+                tileentitycommand.setPowered(flag1);
+                if (!flag2 && !tileentitycommand.isAutomatic() && tileentitycommand.getMode() != CommandBlockEntity.Type.SEQUENCE) {
+                    if (flag1) {
+                        tileentitycommand.markConditionMet();
+                        level.scheduleTick(pos, (Block) this, 1);
                     }
+
                 }
             }
         }
     }
 
     @Override
-    public void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
-        if (level.getBlockEntity(pos) instanceof CommandBlockEntity commandBlockEntity) {
-            BaseCommandBlock commandBlock = commandBlockEntity.getCommandBlock();
-            boolean flag = !StringUtil.isNullOrEmpty(commandBlock.getCommand());
-            CommandBlockEntity.Mode mode = commandBlockEntity.getMode();
-            boolean flag1 = commandBlockEntity.wasConditionMet();
-            if (mode == CommandBlockEntity.Mode.AUTO) {
-                commandBlockEntity.markConditionMet();
+    public void tick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        BlockEntity tileentity = level.getBlockEntity(pos);
+
+        if (tileentity instanceof CommandBlockEntity) {
+            CommandBlockEntity tileentitycommand = (CommandBlockEntity) tileentity;
+            BaseCommandBlock commandblocklistenerabstract = tileentitycommand.getCommandBlock();
+            boolean flag = !StringUtil.isNullOrEmpty(commandblocklistenerabstract.getCommand());
+            CommandBlockEntity.Type tileentitycommand_type = tileentitycommand.getMode();
+            boolean flag1 = tileentitycommand.wasConditionMet();
+
+            if (tileentitycommand_type == CommandBlockEntity.Type.AUTO) {
+                tileentitycommand.markConditionMet();
                 if (flag1) {
-                    this.execute(state, level, pos, commandBlock, flag);
-                } else if (commandBlockEntity.isConditional()) {
-                    commandBlock.setSuccessCount(0);
+                    this.execute(state, level, pos, commandblocklistenerabstract, flag);
+                } else if (tileentitycommand.isConditional()) {
+                    commandblocklistenerabstract.setSuccessCount(0);
                 }
 
-                if (commandBlockEntity.isPowered() || commandBlockEntity.isAutomatic()) {
-                    level.scheduleTick(pos, this, 1);
+                if (tileentitycommand.isPowered() || tileentitycommand.isAutomatic()) {
+                    level.scheduleTick(pos, (Block) this, 1);
                 }
-            } else if (mode == CommandBlockEntity.Mode.REDSTONE) {
+            } else if (tileentitycommand_type == CommandBlockEntity.Type.REDSTONE) {
                 if (flag1) {
-                    this.execute(state, level, pos, commandBlock, flag);
-                } else if (commandBlockEntity.isConditional()) {
-                    commandBlock.setSuccessCount(0);
+                    this.execute(state, level, pos, commandblocklistenerabstract, flag);
+                } else if (tileentitycommand.isConditional()) {
+                    commandblocklistenerabstract.setSuccessCount(0);
                 }
             }
 
             level.updateNeighbourForOutputSignal(pos, this);
         }
+
     }
 
-    private void execute(BlockState state, Level level, BlockPos pos, BaseCommandBlock logic, boolean canTrigger) {
+    private void execute(IBlockData state, Level level, BlockPos pos, BaseCommandBlock logic, boolean canTrigger) {
         if (canTrigger) {
             logic.performCommand(level);
         } else {
             logic.setSuccessCount(0);
         }
 
-        executeChain(level, pos, state.getValue(FACING));
+        executeChain(level, pos, (Direction) state.getValue(CommandBlock.FACING));
     }
 
     @Override
-    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
-        BlockEntity blockEntity = level.getBlockEntity(pos);
-        if (blockEntity instanceof CommandBlockEntity && player.canUseGameMasterBlocks()) {
-            player.openCommandBlock((CommandBlockEntity)blockEntity);
+    public InteractionResult use(IBlockData state, Level level, BlockPos pos, Player player, EnumHand hand, BlockHitResult hit) {
+        BlockEntity tileentity = level.getBlockEntity(pos);
+
+        if (tileentity instanceof CommandBlockEntity && player.canUseGameMasterBlocks()) {
+            player.openCommandBlock((CommandBlockEntity) tileentity);
             return InteractionResult.sidedSuccess(level.isClientSide);
         } else {
             return InteractionResult.PASS;
@@ -128,97 +152,118 @@
     }
 
     @Override
-    public boolean hasAnalogOutputSignal(BlockState state) {
+    public boolean hasAnalogOutputSignal(IBlockData state) {
         return true;
     }
 
     @Override
-    public int getAnalogOutputSignal(BlockState blockState, Level level, BlockPos pos) {
-        BlockEntity blockEntity = level.getBlockEntity(pos);
-        return blockEntity instanceof CommandBlockEntity ? ((CommandBlockEntity)blockEntity).getCommandBlock().getSuccessCount() : 0;
+    public int getAnalogOutputSignal(IBlockData blockState, Level level, BlockPos pos) {
+        BlockEntity tileentity = level.getBlockEntity(pos);
+
+        return tileentity instanceof CommandBlockEntity ? ((CommandBlockEntity) tileentity).getCommandBlock().getSuccessCount() : 0;
     }
 
     @Override
-    public void setPlacedBy(Level level, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
-        if (level.getBlockEntity(pos) instanceof CommandBlockEntity commandBlockEntity) {
-            BaseCommandBlock commandBlock = commandBlockEntity.getCommandBlock();
+    public void setPlacedBy(Level level, BlockPos pos, IBlockData state, LivingEntity placer, ItemStack stack) {
+        BlockEntity tileentity = level.getBlockEntity(pos);
+
+        if (tileentity instanceof CommandBlockEntity) {
+            CommandBlockEntity tileentitycommand = (CommandBlockEntity) tileentity;
+            BaseCommandBlock commandblocklistenerabstract = tileentitycommand.getCommandBlock();
+
             if (stack.hasCustomHoverName()) {
-                commandBlock.setName(stack.getHoverName());
+                commandblocklistenerabstract.setName(stack.getHoverName());
             }
 
             if (!level.isClientSide) {
                 if (BlockItem.getBlockEntityData(stack) == null) {
-                    commandBlock.setTrackOutput(level.getGameRules().getBoolean(GameRules.RULE_SENDCOMMANDFEEDBACK));
-                    commandBlockEntity.setAutomatic(this.automatic);
+                    commandblocklistenerabstract.setTrackOutput(level.getGameRules().getBoolean(GameRules.RULE_SENDCOMMANDFEEDBACK));
+                    tileentitycommand.setAutomatic(this.automatic);
                 }
 
-                if (commandBlockEntity.getMode() == CommandBlockEntity.Mode.SEQUENCE) {
-                    boolean hasNeighborSignal = level.hasNeighborSignal(pos);
-                    commandBlockEntity.setPowered(hasNeighborSignal);
+                if (tileentitycommand.getMode() == CommandBlockEntity.Type.SEQUENCE) {
+                    boolean flag = level.hasNeighborSignal(pos);
+
+                    tileentitycommand.setPowered(flag);
                 }
             }
+
         }
     }
 
     @Override
-    public RenderShape getRenderShape(BlockState state) {
-        return RenderShape.MODEL;
+    public EnumRenderType getRenderShape(IBlockData state) {
+        return EnumRenderType.MODEL;
     }
 
     @Override
-    public BlockState rotate(BlockState state, Rotation rotation) {
-        return state.setValue(FACING, rotation.rotate(state.getValue(FACING)));
+    public IBlockData rotate(IBlockData state, Rotation rotation) {
+        return (IBlockData) state.setValue(CommandBlock.FACING, rotation.rotate((Direction) state.getValue(CommandBlock.FACING)));
     }
 
     @Override
-    public BlockState mirror(BlockState state, Mirror mirror) {
-        return state.rotate(mirror.getRotation(state.getValue(FACING)));
+    public IBlockData mirror(IBlockData state, Mirror mirror) {
+        return state.rotate(mirror.getRotation((Direction) state.getValue(CommandBlock.FACING)));
     }
 
     @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
-        builder.add(FACING, CONDITIONAL);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(CommandBlock.FACING, CommandBlock.CONDITIONAL);
     }
 
     @Override
-    public BlockState getStateForPlacement(BlockPlaceContext context) {
-        return this.defaultBlockState().setValue(FACING, context.getNearestLookingDirection().getOpposite());
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        return (IBlockData) this.defaultBlockState().setValue(CommandBlock.FACING, context.getNearestLookingDirection().getOpposite());
     }
 
     private static void executeChain(Level level, BlockPos pos, Direction direction) {
-        BlockPos.MutableBlockPos mutableBlockPos = pos.mutable();
-        GameRules gameRules = level.getGameRules();
-        int _int = gameRules.getInt(GameRules.RULE_MAX_COMMAND_CHAIN_LENGTH);
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = pos.mutable();
+        GameRules gamerules = level.getGameRules();
 
-        while (_int-- > 0) {
-            mutableBlockPos.move(direction);
-            BlockState blockState = level.getBlockState(mutableBlockPos);
-            Block block = blockState.getBlock();
-            if (!blockState.is(Blocks.CHAIN_COMMAND_BLOCK)
-                || !(level.getBlockEntity(mutableBlockPos) instanceof CommandBlockEntity commandBlockEntity)
-                || commandBlockEntity.getMode() != CommandBlockEntity.Mode.SEQUENCE) {
+        IBlockData iblockdata;
+        int i;
+
+        for (i = gamerules.getInt(GameRules.RULE_MAX_COMMAND_CHAIN_LENGTH); i-- > 0; direction = (Direction) iblockdata.getValue(CommandBlock.FACING)) {
+            blockposition_mutableblockposition.move(direction);
+            iblockdata = level.getBlockState(blockposition_mutableblockposition);
+            Block block = iblockdata.getBlock();
+
+            if (!iblockdata.is(Blocks.CHAIN_COMMAND_BLOCK)) {
                 break;
             }
 
-            if (commandBlockEntity.isPowered() || commandBlockEntity.isAutomatic()) {
-                BaseCommandBlock commandBlock = commandBlockEntity.getCommandBlock();
-                if (commandBlockEntity.markConditionMet()) {
-                    if (!commandBlock.performCommand(level)) {
+            BlockEntity tileentity = level.getBlockEntity(blockposition_mutableblockposition);
+
+            if (!(tileentity instanceof CommandBlockEntity)) {
+                break;
+            }
+
+            CommandBlockEntity tileentitycommand = (CommandBlockEntity) tileentity;
+
+            if (tileentitycommand.getMode() != CommandBlockEntity.Type.SEQUENCE) {
+                break;
+            }
+
+            if (tileentitycommand.isPowered() || tileentitycommand.isAutomatic()) {
+                BaseCommandBlock commandblocklistenerabstract = tileentitycommand.getCommandBlock();
+
+                if (tileentitycommand.markConditionMet()) {
+                    if (!commandblocklistenerabstract.performCommand(level)) {
                         break;
                     }
 
-                    level.updateNeighbourForOutputSignal(mutableBlockPos, block);
-                } else if (commandBlockEntity.isConditional()) {
-                    commandBlock.setSuccessCount(0);
+                    level.updateNeighbourForOutputSignal(blockposition_mutableblockposition, block);
+                } else if (tileentitycommand.isConditional()) {
+                    commandblocklistenerabstract.setSuccessCount(0);
                 }
             }
-
-            direction = blockState.getValue(FACING);
         }
 
-        if (_int <= 0) {
-            int max = Math.max(gameRules.getInt(GameRules.RULE_MAX_COMMAND_CHAIN_LENGTH), 0);
-            LOGGER.warn("Command Block chain tried to execute more than {} steps!", max);
+        if (i <= 0) {
+            int j = Math.max(gamerules.getInt(GameRules.RULE_MAX_COMMAND_CHAIN_LENGTH), 0);
+
+            CommandBlock.LOGGER.warn("Command Block chain tried to execute more than {} steps!", j);
         }
+
     }
 }
