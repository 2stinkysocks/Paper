--- a/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -5,7 +5,7 @@
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -16,76 +16,86 @@
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.SignalGetter;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BlockDirectional;
 import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.DirectionalBlock;
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.level.block.state.properties.PistonType;
 import net.minecraft.world.level.gameevent.GameEvent;
-import net.minecraft.world.level.material.PushReaction;
-import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.level.material.EnumPistonReaction;
+import net.minecraft.world.level.pathfinder.PathMode;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+// CraftBukkit start
+import com.google.common.collect.ImmutableList;
+import java.util.AbstractList;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.event.block.BlockPistonRetractEvent;
+import org.bukkit.event.block.BlockPistonExtendEvent;
+// CraftBukkit end
 
-public class PistonBaseBlock extends DirectionalBlock {
-    public static final MapCodec<PistonBaseBlock> CODEC = RecordCodecBuilder.mapCodec(
-        instance -> instance.group(Codec.BOOL.fieldOf("sticky").forGetter(pistonBaseBlock -> pistonBaseBlock.isSticky), propertiesCodec())
-                .apply(instance, PistonBaseBlock::new)
-    );
+public class PistonBaseBlock extends BlockDirectional {
+
+    public static final MapCodec<PistonBaseBlock> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
+        return instance.group(Codec.BOOL.fieldOf("sticky").forGetter((blockpiston) -> {
+            return blockpiston.isSticky;
+        }), propertiesCodec()).apply(instance, PistonBaseBlock::new);
+    });
     public static final BooleanProperty EXTENDED = BlockStateProperties.EXTENDED;
     public static final int TRIGGER_EXTEND = 0;
     public static final int TRIGGER_CONTRACT = 1;
     public static final int TRIGGER_DROP = 2;
     public static final float PLATFORM_THICKNESS = 4.0F;
-    protected static final VoxelShape EAST_AABB = Block.box(0.0, 0.0, 0.0, 12.0, 16.0, 16.0);
-    protected static final VoxelShape WEST_AABB = Block.box(4.0, 0.0, 0.0, 16.0, 16.0, 16.0);
-    protected static final VoxelShape SOUTH_AABB = Block.box(0.0, 0.0, 0.0, 16.0, 16.0, 12.0);
-    protected static final VoxelShape NORTH_AABB = Block.box(0.0, 0.0, 4.0, 16.0, 16.0, 16.0);
-    protected static final VoxelShape UP_AABB = Block.box(0.0, 0.0, 0.0, 16.0, 12.0, 16.0);
-    protected static final VoxelShape DOWN_AABB = Block.box(0.0, 4.0, 0.0, 16.0, 16.0, 16.0);
+    protected static final VoxelShape EAST_AABB = Block.box(0.0D, 0.0D, 0.0D, 12.0D, 16.0D, 16.0D);
+    protected static final VoxelShape WEST_AABB = Block.box(4.0D, 0.0D, 0.0D, 16.0D, 16.0D, 16.0D);
+    protected static final VoxelShape SOUTH_AABB = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 16.0D, 12.0D);
+    protected static final VoxelShape NORTH_AABB = Block.box(0.0D, 0.0D, 4.0D, 16.0D, 16.0D, 16.0D);
+    protected static final VoxelShape UP_AABB = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 12.0D, 16.0D);
+    protected static final VoxelShape DOWN_AABB = Block.box(0.0D, 4.0D, 0.0D, 16.0D, 16.0D, 16.0D);
     private final boolean isSticky;
 
     @Override
     public MapCodec<PistonBaseBlock> codec() {
-        return CODEC;
+        return PistonBaseBlock.CODEC;
     }
 
     public PistonBaseBlock(boolean isSticky, BlockBehaviour.Properties properties) {
         super(properties);
-        this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(EXTENDED, Boolean.valueOf(false)));
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(PistonBaseBlock.FACING, Direction.NORTH)).setValue(PistonBaseBlock.EXTENDED, false));
         this.isSticky = isSticky;
     }
 
     @Override
-    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
-        if (state.getValue(EXTENDED)) {
-            switch ((Direction)state.getValue(FACING)) {
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        if ((Boolean) state.getValue(PistonBaseBlock.EXTENDED)) {
+            switch ((Direction) state.getValue(PistonBaseBlock.FACING)) {
                 case DOWN:
-                    return DOWN_AABB;
+                    return PistonBaseBlock.DOWN_AABB;
                 case UP:
                 default:
-                    return UP_AABB;
+                    return PistonBaseBlock.UP_AABB;
                 case NORTH:
-                    return NORTH_AABB;
+                    return PistonBaseBlock.NORTH_AABB;
                 case SOUTH:
-                    return SOUTH_AABB;
+                    return PistonBaseBlock.SOUTH_AABB;
                 case WEST:
-                    return WEST_AABB;
+                    return PistonBaseBlock.WEST_AABB;
                 case EAST:
-                    return EAST_AABB;
+                    return PistonBaseBlock.EAST_AABB;
             }
         } else {
             return Shapes.block();
@@ -93,63 +103,88 @@
     }
 
     @Override
-    public void setPlacedBy(Level level, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
+    public void setPlacedBy(Level level, BlockPos pos, IBlockData state, LivingEntity placer, ItemStack stack) {
         if (!level.isClientSide) {
             this.checkIfExtend(level, pos, state);
         }
+
     }
 
     @Override
-    public void neighborChanged(BlockState state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
+    public void neighborChanged(IBlockData state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
         if (!level.isClientSide) {
             this.checkIfExtend(level, pos, state);
         }
+
     }
 
     @Override
-    public void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean isMoving) {
+    public void onPlace(IBlockData state, Level level, BlockPos pos, IBlockData oldState, boolean isMoving) {
         if (!oldState.is(state.getBlock())) {
             if (!level.isClientSide && level.getBlockEntity(pos) == null) {
                 this.checkIfExtend(level, pos, state);
             }
+
         }
     }
 
     @Override
-    public BlockState getStateForPlacement(BlockPlaceContext context) {
-        return this.defaultBlockState().setValue(FACING, context.getNearestLookingDirection().getOpposite()).setValue(EXTENDED, Boolean.valueOf(false));
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        return (IBlockData) ((IBlockData) this.defaultBlockState().setValue(PistonBaseBlock.FACING, context.getNearestLookingDirection().getOpposite())).setValue(PistonBaseBlock.EXTENDED, false);
     }
 
-    private void checkIfExtend(Level level, BlockPos pos, BlockState state) {
-        Direction direction = state.getValue(FACING);
-        boolean neighborSignal = this.getNeighborSignal(level, pos, direction);
-        if (neighborSignal && !state.getValue(EXTENDED)) {
-            if (new PistonStructureResolver(level, pos, direction, true).resolve()) {
-                level.blockEvent(pos, this, 0, direction.get3DDataValue());
+    private void checkIfExtend(Level level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = (Direction) state.getValue(PistonBaseBlock.FACING);
+        boolean flag = this.getNeighborSignal(level, pos, enumdirection);
+
+        if (flag && !(Boolean) state.getValue(PistonBaseBlock.EXTENDED)) {
+            if ((new PistonStructureResolver(level, pos, enumdirection, true)).resolve()) {
+                level.blockEvent(pos, this, 0, enumdirection.get3DDataValue());
             }
-        } else if (!neighborSignal && state.getValue(EXTENDED)) {
-            BlockPos blockPos = pos.relative(direction, 2);
-            BlockState blockState = level.getBlockState(blockPos);
-            int i = 1;
-            if (blockState.is(Blocks.MOVING_PISTON)
-                && blockState.getValue(FACING) == direction
-                && level.getBlockEntity(blockPos) instanceof PistonMovingBlockEntity pistonMovingBlockEntity
-                && pistonMovingBlockEntity.isExtending()
-                && (
-                    pistonMovingBlockEntity.getProgress(0.0F) < 0.5F
-                        || level.getGameTime() == pistonMovingBlockEntity.getLastTicked()
-                        || ((ServerLevel)level).isHandlingTick()
-                )) {
-                i = 2;
+        } else if (!flag && (Boolean) state.getValue(PistonBaseBlock.EXTENDED)) {
+            BlockPos blockposition1 = pos.relative(enumdirection, 2);
+            IBlockData iblockdata1 = level.getBlockState(blockposition1);
+            byte b0 = 1;
+
+            if (iblockdata1.is(Blocks.MOVING_PISTON) && iblockdata1.getValue(PistonBaseBlock.FACING) == enumdirection) {
+                BlockEntity tileentity = level.getBlockEntity(blockposition1);
+
+                if (tileentity instanceof PistonMovingBlockEntity) {
+                    PistonMovingBlockEntity tileentitypiston = (PistonMovingBlockEntity) tileentity;
+
+                    if (tileentitypiston.isExtending() && (tileentitypiston.getProgress(0.0F) < 0.5F || level.getGameTime() == tileentitypiston.getLastTicked() || ((ServerLevel) level).isHandlingTick())) {
+                        b0 = 2;
+                    }
+                }
             }
 
-            level.blockEvent(pos, this, i, direction.get3DDataValue());
+            // CraftBukkit start
+            if (!this.isSticky) {
+                org.bukkit.block.Block block = level.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+                BlockPistonRetractEvent event = new BlockPistonRetractEvent(block, ImmutableList.<org.bukkit.block.Block>of(), CraftBlock.notchToBlockFace(enumdirection));
+                level.getCraftServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+            }
+            // PAIL: checkME - what happened to setTypeAndData?
+            // CraftBukkit end
+            level.blockEvent(pos, this, b0, enumdirection.get3DDataValue());
         }
+
     }
 
     private boolean getNeighborSignal(SignalGetter signalGetter, BlockPos pos, Direction direction) {
-        for (Direction direction1 : Direction.values()) {
-            if (direction1 != direction && signalGetter.hasSignal(pos.relative(direction1), direction1)) {
+        Direction[] aenumdirection = Direction.values();
+        int i = aenumdirection.length;
+
+        int j;
+
+        for (j = 0; j < i; ++j) {
+            Direction enumdirection1 = aenumdirection[j];
+
+            if (enumdirection1 != direction && signalGetter.hasSignal(pos.relative(enumdirection1), enumdirection1)) {
                 return true;
             }
         }
@@ -157,10 +192,15 @@
         if (signalGetter.hasSignal(pos, Direction.DOWN)) {
             return true;
         } else {
-            BlockPos blockPos = pos.above();
+            BlockPos blockposition1 = pos.above();
+            Direction[] aenumdirection1 = Direction.values();
 
-            for (Direction direction2 : Direction.values()) {
-                if (direction2 != Direction.DOWN && signalGetter.hasSignal(blockPos.relative(direction2), direction2)) {
+            j = aenumdirection1.length;
+
+            for (int k = 0; k < j; ++k) {
+                Direction enumdirection2 = aenumdirection1[k];
+
+                if (enumdirection2 != Direction.DOWN && signalGetter.hasSignal(blockposition1.relative(enumdirection2), enumdirection2)) {
                     return true;
                 }
             }
@@ -170,209 +210,271 @@
     }
 
     @Override
-    public boolean triggerEvent(BlockState state, Level level, BlockPos pos, int id, int param) {
-        Direction direction = state.getValue(FACING);
-        BlockState blockState = state.setValue(EXTENDED, Boolean.valueOf(true));
+    public boolean triggerEvent(IBlockData state, Level level, BlockPos pos, int id, int param) {
+        Direction enumdirection = (Direction) state.getValue(PistonBaseBlock.FACING);
+        IBlockData iblockdata1 = (IBlockData) state.setValue(PistonBaseBlock.EXTENDED, true);
+
         if (!level.isClientSide) {
-            boolean neighborSignal = this.getNeighborSignal(level, pos, direction);
-            if (neighborSignal && (id == 1 || id == 2)) {
-                level.setBlock(pos, blockState, 2);
+            boolean flag = this.getNeighborSignal(level, pos, enumdirection);
+
+            if (flag && (id == 1 || id == 2)) {
+                level.setBlock(pos, iblockdata1, 2);
                 return false;
             }
 
-            if (!neighborSignal && id == 0) {
+            if (!flag && id == 0) {
                 return false;
             }
         }
 
         if (id == 0) {
-            if (!this.moveBlocks(level, pos, direction, true)) {
+            if (!this.moveBlocks(level, pos, enumdirection, true)) {
                 return false;
             }
 
-            level.setBlock(pos, blockState, 67);
-            level.playSound(null, pos, SoundEvents.PISTON_EXTEND, SoundSource.BLOCKS, 0.5F, level.random.nextFloat() * 0.25F + 0.6F);
-            level.gameEvent(GameEvent.BLOCK_ACTIVATE, pos, GameEvent.Context.of(blockState));
+            level.setBlock(pos, iblockdata1, 67);
+            level.playSound((Player) null, pos, SoundEvents.PISTON_EXTEND, SoundSource.BLOCKS, 0.5F, level.random.nextFloat() * 0.25F + 0.6F);
+            level.gameEvent(GameEvent.BLOCK_ACTIVATE, pos, GameEvent.Context.of(iblockdata1));
         } else if (id == 1 || id == 2) {
-            BlockEntity blockEntity = level.getBlockEntity(pos.relative(direction));
-            if (blockEntity instanceof PistonMovingBlockEntity) {
-                ((PistonMovingBlockEntity)blockEntity).finalTick();
+            BlockEntity tileentity = level.getBlockEntity(pos.relative(enumdirection));
+
+            if (tileentity instanceof PistonMovingBlockEntity) {
+                ((PistonMovingBlockEntity) tileentity).finalTick();
             }
 
-            BlockState blockState1 = Blocks.MOVING_PISTON
-                .defaultBlockState()
-                .setValue(MovingPistonBlock.FACING, direction)
-                .setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
-            level.setBlock(pos, blockState1, 20);
-            level.setBlockEntity(
-                MovingPistonBlock.newMovingBlockEntity(
-                    pos, blockState1, this.defaultBlockState().setValue(FACING, Direction.from3DDataValue(param & 7)), direction, false, true
-                )
-            );
-            level.blockUpdated(pos, blockState1.getBlock());
-            blockState1.updateNeighbourShapes(level, pos, 2);
+            IBlockData iblockdata2 = (IBlockData) ((IBlockData) Blocks.MOVING_PISTON.defaultBlockState().setValue(MovingPistonBlock.FACING, enumdirection)).setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
+
+            level.setBlock(pos, iblockdata2, 20);
+            level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(pos, iblockdata2, (IBlockData) this.defaultBlockState().setValue(PistonBaseBlock.FACING, Direction.from3DDataValue(param & 7)), enumdirection, false, true));
+            level.blockUpdated(pos, iblockdata2.getBlock());
+            iblockdata2.updateNeighbourShapes(level, pos, 2);
             if (this.isSticky) {
-                BlockPos blockPos = pos.offset(direction.getStepX() * 2, direction.getStepY() * 2, direction.getStepZ() * 2);
-                BlockState blockState2 = level.getBlockState(blockPos);
-                boolean flag = false;
-                if (blockState2.is(Blocks.MOVING_PISTON)
-                    && level.getBlockEntity(blockPos) instanceof PistonMovingBlockEntity pistonMovingBlockEntity
-                    && pistonMovingBlockEntity.getDirection() == direction
-                    && pistonMovingBlockEntity.isExtending()) {
-                    pistonMovingBlockEntity.finalTick();
-                    flag = true;
+                BlockPos blockposition1 = pos.offset(enumdirection.getStepX() * 2, enumdirection.getStepY() * 2, enumdirection.getStepZ() * 2);
+                IBlockData iblockdata3 = level.getBlockState(blockposition1);
+                boolean flag1 = false;
+
+                if (iblockdata3.is(Blocks.MOVING_PISTON)) {
+                    BlockEntity tileentity1 = level.getBlockEntity(blockposition1);
+
+                    if (tileentity1 instanceof PistonMovingBlockEntity) {
+                        PistonMovingBlockEntity tileentitypiston = (PistonMovingBlockEntity) tileentity1;
+
+                        if (tileentitypiston.getDirection() == enumdirection && tileentitypiston.isExtending()) {
+                            tileentitypiston.finalTick();
+                            flag1 = true;
+                        }
+                    }
                 }
 
-                if (!flag) {
-                    if (id != 1
-                        || blockState2.isAir()
-                        || !isPushable(blockState2, level, blockPos, direction.getOpposite(), false, direction)
-                        || blockState2.getPistonPushReaction() != PushReaction.NORMAL
-                            && !blockState2.is(Blocks.PISTON)
-                            && !blockState2.is(Blocks.STICKY_PISTON)) {
-                        level.removeBlock(pos.relative(direction), false);
+                if (!flag1) {
+                    if (id == 1 && !iblockdata3.isAir() && isPushable(iblockdata3, level, blockposition1, enumdirection.getOpposite(), false, enumdirection) && (iblockdata3.getPistonPushReaction() == EnumPistonReaction.NORMAL || iblockdata3.is(Blocks.PISTON) || iblockdata3.is(Blocks.STICKY_PISTON))) {
+                        this.moveBlocks(level, pos, enumdirection, false);
                     } else {
-                        this.moveBlocks(level, pos, direction, false);
+                        level.removeBlock(pos.relative(enumdirection), false);
                     }
                 }
             } else {
-                level.removeBlock(pos.relative(direction), false);
+                level.removeBlock(pos.relative(enumdirection), false);
             }
 
-            level.playSound(null, pos, SoundEvents.PISTON_CONTRACT, SoundSource.BLOCKS, 0.5F, level.random.nextFloat() * 0.15F + 0.6F);
-            level.gameEvent(GameEvent.BLOCK_DEACTIVATE, pos, GameEvent.Context.of(blockState1));
+            level.playSound((Player) null, pos, SoundEvents.PISTON_CONTRACT, SoundSource.BLOCKS, 0.5F, level.random.nextFloat() * 0.15F + 0.6F);
+            level.gameEvent(GameEvent.BLOCK_DEACTIVATE, pos, GameEvent.Context.of(iblockdata2));
         }
 
         return true;
     }
 
-    public static boolean isPushable(BlockState state, Level level, BlockPos pos, Direction movementDirection, boolean allowDestroy, Direction pistonFacing) {
-        if (pos.getY() < level.getMinBuildHeight() || pos.getY() > level.getMaxBuildHeight() - 1 || !level.getWorldBorder().isWithinBounds(pos)) {
-            return false;
-        } else if (state.isAir()) {
-            return true;
-        } else if (state.is(Blocks.OBSIDIAN) || state.is(Blocks.CRYING_OBSIDIAN) || state.is(Blocks.RESPAWN_ANCHOR) || state.is(Blocks.REINFORCED_DEEPSLATE)) {
-            return false;
-        } else if (movementDirection == Direction.DOWN && pos.getY() == level.getMinBuildHeight()) {
-            return false;
-        } else if (movementDirection == Direction.UP && pos.getY() == level.getMaxBuildHeight() - 1) {
-            return false;
-        } else {
-            if (!state.is(Blocks.PISTON) && !state.is(Blocks.STICKY_PISTON)) {
-                if (state.getDestroySpeed(level, pos) == -1.0F) {
+    public static boolean isPushable(IBlockData state, Level level, BlockPos pos, Direction movementDirection, boolean allowDestroy, Direction pistonFacing) {
+        if (pos.getY() >= level.getMinBuildHeight() && pos.getY() <= level.getMaxBuildHeight() - 1 && level.getWorldBorder().isWithinBounds(pos)) {
+            if (state.isAir()) {
+                return true;
+            } else if (!state.is(Blocks.OBSIDIAN) && !state.is(Blocks.CRYING_OBSIDIAN) && !state.is(Blocks.RESPAWN_ANCHOR) && !state.is(Blocks.REINFORCED_DEEPSLATE)) {
+                if (movementDirection == Direction.DOWN && pos.getY() == level.getMinBuildHeight()) {
                     return false;
-                }
+                } else if (movementDirection == Direction.UP && pos.getY() == level.getMaxBuildHeight() - 1) {
+                    return false;
+                } else {
+                    if (!state.is(Blocks.PISTON) && !state.is(Blocks.STICKY_PISTON)) {
+                        if (state.getDestroySpeed(level, pos) == -1.0F) {
+                            return false;
+                        }
 
-                switch (state.getPistonPushReaction()) {
-                    case BLOCK:
+                        switch (state.getPistonPushReaction()) {
+                            case BLOCK:
+                                return false;
+                            case DESTROY:
+                                return allowDestroy;
+                            case PUSH_ONLY:
+                                return movementDirection == pistonFacing;
+                        }
+                    } else if ((Boolean) state.getValue(PistonBaseBlock.EXTENDED)) {
                         return false;
-                    case DESTROY:
-                        return allowDestroy;
-                    case PUSH_ONLY:
-                        return movementDirection == pistonFacing;
+                    }
+
+                    return !state.hasBlockEntity();
                 }
-            } else if (state.getValue(EXTENDED)) {
+            } else {
                 return false;
             }
-
-            return !state.hasBlockEntity();
+        } else {
+            return false;
         }
     }
 
     private boolean moveBlocks(Level level, BlockPos pos, Direction facing, boolean extending) {
-        BlockPos blockPos = pos.relative(facing);
-        if (!extending && level.getBlockState(blockPos).is(Blocks.PISTON_HEAD)) {
-            level.setBlock(blockPos, Blocks.AIR.defaultBlockState(), 20);
+        BlockPos blockposition1 = pos.relative(facing);
+
+        if (!extending && level.getBlockState(blockposition1).is(Blocks.PISTON_HEAD)) {
+            level.setBlock(blockposition1, Blocks.AIR.defaultBlockState(), 20);
         }
 
-        PistonStructureResolver pistonStructureResolver = new PistonStructureResolver(level, pos, facing, extending);
-        if (!pistonStructureResolver.resolve()) {
+        PistonStructureResolver pistonextendschecker = new PistonStructureResolver(level, pos, facing, extending);
+
+        if (!pistonextendschecker.resolve()) {
             return false;
         } else {
-            Map<BlockPos, BlockState> map = Maps.newHashMap();
-            List<BlockPos> toPush = pistonStructureResolver.getToPush();
-            List<BlockState> list = Lists.newArrayList();
+            Map<BlockPos, IBlockData> map = Maps.newHashMap();
+            List<BlockPos> list = pistonextendschecker.getToPush();
+            List<IBlockData> list1 = Lists.newArrayList();
+            Iterator iterator = list.iterator();
 
-            for (BlockPos blockPos1 : toPush) {
-                BlockState blockState = level.getBlockState(blockPos1);
-                list.add(blockState);
-                map.put(blockPos1, blockState);
+            while (iterator.hasNext()) {
+                BlockPos blockposition2 = (BlockPos) iterator.next();
+                IBlockData iblockdata = level.getBlockState(blockposition2);
+
+                list1.add(iblockdata);
+                map.put(blockposition2, iblockdata);
             }
 
-            List<BlockPos> toDestroy = pistonStructureResolver.getToDestroy();
-            BlockState[] blockStates = new BlockState[toPush.size() + toDestroy.size()];
-            Direction direction = extending ? facing : facing.getOpposite();
+            List<BlockPos> list2 = pistonextendschecker.getToDestroy();
+            IBlockData[] aiblockdata = new IBlockData[list.size() + list2.size()];
+            Direction enumdirection1 = extending ? facing : facing.getOpposite();
             int i = 0;
+            // CraftBukkit start
+            final org.bukkit.block.Block bblock = level.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
 
-            for (int i1 = toDestroy.size() - 1; i1 >= 0; i1--) {
-                BlockPos blockPos2 = toDestroy.get(i1);
-                BlockState blockState1 = level.getBlockState(blockPos2);
-                BlockEntity blockEntity = blockState1.hasBlockEntity() ? level.getBlockEntity(blockPos2) : null;
-                dropResources(blockState1, level, blockPos2, blockEntity);
-                level.setBlock(blockPos2, Blocks.AIR.defaultBlockState(), 18);
-                level.gameEvent(GameEvent.BLOCK_DESTROY, blockPos2, GameEvent.Context.of(blockState1));
-                if (!blockState1.is(BlockTags.FIRE)) {
-                    level.addDestroyBlockEffect(blockPos2, blockState1);
+            final List<BlockPos> moved = pistonextendschecker.getToPush();
+            final List<BlockPos> broken = pistonextendschecker.getToDestroy();
+
+            List<org.bukkit.block.Block> blocks = new AbstractList<org.bukkit.block.Block>() {
+
+                @Override
+                public int size() {
+                    return moved.size() + broken.size();
                 }
 
-                blockStates[i++] = blockState1;
+                @Override
+                public org.bukkit.block.Block get(int index) {
+                    if (index >= size() || index < 0) {
+                        throw new ArrayIndexOutOfBoundsException(index);
+                    }
+                    BlockPos pos = (BlockPos) (index < moved.size() ? moved.get(index) : broken.get(index - moved.size()));
+                    return bblock.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+                }
+            };
+            org.bukkit.event.block.BlockPistonEvent event;
+            if (extending) {
+                event = new BlockPistonExtendEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1));
+            } else {
+                event = new BlockPistonRetractEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1));
             }
+            level.getCraftServer().getPluginManager().callEvent(event);
 
-            for (int i1 = toPush.size() - 1; i1 >= 0; i1--) {
-                BlockPos blockPos2 = toPush.get(i1);
-                BlockState blockState1 = level.getBlockState(blockPos2);
-                blockPos2 = blockPos2.relative(direction);
-                map.remove(blockPos2);
-                BlockState blockState2 = Blocks.MOVING_PISTON.defaultBlockState().setValue(FACING, facing);
-                level.setBlock(blockPos2, blockState2, 68);
-                level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockPos2, blockState2, list.get(i1), facing, extending, false));
-                blockStates[i++] = blockState1;
+            if (event.isCancelled()) {
+                for (BlockPos b : broken) {
+                    level.sendBlockUpdated(b, Blocks.AIR.defaultBlockState(), level.getBlockState(b), 3);
+                }
+                for (BlockPos b : moved) {
+                    level.sendBlockUpdated(b, Blocks.AIR.defaultBlockState(), level.getBlockState(b), 3);
+                    b = b.relative(enumdirection1);
+                    level.sendBlockUpdated(b, Blocks.AIR.defaultBlockState(), level.getBlockState(b), 3);
+                }
+                return false;
             }
+            // CraftBukkit end
 
+            BlockPos blockposition3;
+            int j;
+            IBlockData iblockdata1;
+
+            for (j = list2.size() - 1; j >= 0; --j) {
+                blockposition3 = (BlockPos) list2.get(j);
+                iblockdata1 = level.getBlockState(blockposition3);
+                BlockEntity tileentity = iblockdata1.hasBlockEntity() ? level.getBlockEntity(blockposition3) : null;
+
+                dropResources(iblockdata1, level, blockposition3, tileentity);
+                level.setBlock(blockposition3, Blocks.AIR.defaultBlockState(), 18);
+                level.gameEvent(GameEvent.BLOCK_DESTROY, blockposition3, GameEvent.Context.of(iblockdata1));
+                if (!iblockdata1.is(BlockTags.FIRE)) {
+                    level.addDestroyBlockEffect(blockposition3, iblockdata1);
+                }
+
+                aiblockdata[i++] = iblockdata1;
+            }
+
+            for (j = list.size() - 1; j >= 0; --j) {
+                blockposition3 = (BlockPos) list.get(j);
+                iblockdata1 = level.getBlockState(blockposition3);
+                blockposition3 = blockposition3.relative(enumdirection1);
+                map.remove(blockposition3);
+                IBlockData iblockdata2 = (IBlockData) Blocks.MOVING_PISTON.defaultBlockState().setValue(PistonBaseBlock.FACING, facing);
+
+                level.setBlock(blockposition3, iblockdata2, 68);
+                level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockposition3, iblockdata2, (IBlockData) list1.get(j), facing, extending, false));
+                aiblockdata[i++] = iblockdata1;
+            }
+
             if (extending) {
-                PistonType pistonType = this.isSticky ? PistonType.STICKY : PistonType.DEFAULT;
-                BlockState blockState3 = Blocks.PISTON_HEAD
-                    .defaultBlockState()
-                    .setValue(PistonHeadBlock.FACING, facing)
-                    .setValue(PistonHeadBlock.TYPE, pistonType);
-                BlockState blockState1 = Blocks.MOVING_PISTON
-                    .defaultBlockState()
-                    .setValue(MovingPistonBlock.FACING, facing)
-                    .setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
-                map.remove(blockPos);
-                level.setBlock(blockPos, blockState1, 68);
-                level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockPos, blockState1, blockState3, facing, true, true));
+                PistonType blockpropertypistontype = this.isSticky ? PistonType.STICKY : PistonType.DEFAULT;
+                IBlockData iblockdata3 = (IBlockData) ((IBlockData) Blocks.PISTON_HEAD.defaultBlockState().setValue(PistonHeadBlock.FACING, facing)).setValue(PistonHeadBlock.TYPE, blockpropertypistontype);
+
+                iblockdata1 = (IBlockData) ((IBlockData) Blocks.MOVING_PISTON.defaultBlockState().setValue(MovingPistonBlock.FACING, facing)).setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
+                map.remove(blockposition1);
+                level.setBlock(blockposition1, iblockdata1, 68);
+                level.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockposition1, iblockdata1, iblockdata3, facing, true, true));
             }
 
-            BlockState blockState4 = Blocks.AIR.defaultBlockState();
+            IBlockData iblockdata4 = Blocks.AIR.defaultBlockState();
+            Iterator iterator1 = map.keySet().iterator();
 
-            for (BlockPos blockPos3 : map.keySet()) {
-                level.setBlock(blockPos3, blockState4, 82);
+            while (iterator1.hasNext()) {
+                BlockPos blockposition4 = (BlockPos) iterator1.next();
+
+                level.setBlock(blockposition4, iblockdata4, 82);
             }
 
-            for (Entry<BlockPos, BlockState> entry : map.entrySet()) {
-                BlockPos blockPos4 = entry.getKey();
-                BlockState blockState5 = entry.getValue();
-                blockState5.updateIndirectNeighbourShapes(level, blockPos4, 2);
-                blockState4.updateNeighbourShapes(level, blockPos4, 2);
-                blockState4.updateIndirectNeighbourShapes(level, blockPos4, 2);
+            iterator1 = map.entrySet().iterator();
+
+            BlockPos blockposition5;
+
+            while (iterator1.hasNext()) {
+                Entry<BlockPos, IBlockData> entry = (Entry) iterator1.next();
+
+                blockposition5 = (BlockPos) entry.getKey();
+                IBlockData iblockdata5 = (IBlockData) entry.getValue();
+
+                iblockdata5.updateIndirectNeighbourShapes(level, blockposition5, 2);
+                iblockdata4.updateNeighbourShapes(level, blockposition5, 2);
+                iblockdata4.updateIndirectNeighbourShapes(level, blockposition5, 2);
             }
 
-            int var22 = 0;
+            i = 0;
 
-            for (int i2 = toDestroy.size() - 1; i2 >= 0; i2--) {
-                BlockState blockState1 = blockStates[var22++];
-                BlockPos blockPos4 = toDestroy.get(i2);
-                blockState1.updateIndirectNeighbourShapes(level, blockPos4, 2);
-                level.updateNeighborsAt(blockPos4, blockState1.getBlock());
+            int k;
+
+            for (k = list2.size() - 1; k >= 0; --k) {
+                iblockdata1 = aiblockdata[i++];
+                blockposition5 = (BlockPos) list2.get(k);
+                iblockdata1.updateIndirectNeighbourShapes(level, blockposition5, 2);
+                level.updateNeighborsAt(blockposition5, iblockdata1.getBlock());
             }
 
-            for (int i2 = toPush.size() - 1; i2 >= 0; i2--) {
-                level.updateNeighborsAt(toPush.get(i2), blockStates[var22++].getBlock());
+            for (k = list.size() - 1; k >= 0; --k) {
+                level.updateNeighborsAt((BlockPos) list.get(k), aiblockdata[i++].getBlock());
             }
 
             if (extending) {
-                level.updateNeighborsAt(blockPos, Blocks.PISTON_HEAD);
+                level.updateNeighborsAt(blockposition1, Blocks.PISTON_HEAD);
             }
 
             return true;
@@ -380,27 +482,27 @@
     }
 
     @Override
-    public BlockState rotate(BlockState state, Rotation rot) {
-        return state.setValue(FACING, rot.rotate(state.getValue(FACING)));
+    public IBlockData rotate(IBlockData state, Rotation rot) {
+        return (IBlockData) state.setValue(PistonBaseBlock.FACING, rot.rotate((Direction) state.getValue(PistonBaseBlock.FACING)));
     }
 
     @Override
-    public BlockState mirror(BlockState state, Mirror mirror) {
-        return state.rotate(mirror.getRotation(state.getValue(FACING)));
+    public IBlockData mirror(IBlockData state, Mirror mirror) {
+        return state.rotate(mirror.getRotation((Direction) state.getValue(PistonBaseBlock.FACING)));
     }
 
     @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
-        builder.add(FACING, EXTENDED);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(PistonBaseBlock.FACING, PistonBaseBlock.EXTENDED);
     }
 
     @Override
-    public boolean useShapeForLightOcclusion(BlockState state) {
-        return state.getValue(EXTENDED);
+    public boolean useShapeForLightOcclusion(IBlockData state) {
+        return (Boolean) state.getValue(PistonBaseBlock.EXTENDED);
     }
 
     @Override
-    public boolean isPathfindable(BlockState state, BlockGetter level, BlockPos pos, PathComputationType type) {
+    public boolean isPathfindable(IBlockData state, BlockGetter level, BlockPos pos, PathMode type) {
         return false;
     }
 }
