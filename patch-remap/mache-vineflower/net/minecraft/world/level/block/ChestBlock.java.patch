--- a/net/minecraft/world/level/block/ChestBlock.java
+++ b/net/minecraft/world/level/block/ChestBlock.java
@@ -2,7 +2,9 @@
 
 import com.mojang.serialization.MapCodec;
 import it.unimi.dsi.fastutil.floats.Float2FloatFunction;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.function.BiPredicate;
 import java.util.function.Supplier;
@@ -18,9 +20,9 @@
 import net.minecraft.world.CompoundContainer;
 import net.minecraft.world.Container;
 import net.minecraft.world.Containers;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.ITileInventory;
 import net.minecraft.world.InteractionResult;
-import net.minecraft.world.MenuProvider;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.animal.Cat;
 import net.minecraft.world.entity.monster.piglin.PiglinAi;
@@ -39,45 +41,47 @@
 import net.minecraft.world.level.block.entity.ChestBlockEntity;
 import net.minecraft.world.level.block.entity.LidBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.level.block.state.properties.ChestType;
 import net.minecraft.world.level.block.state.properties.DirectionProperty;
 import net.minecraft.world.level.block.state.properties.EnumProperty;
+import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
-import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.level.pathfinder.PathMode;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class ChestBlock extends AbstractChestBlock<ChestBlockEntity> implements SimpleWaterloggedBlock {
-    public static final MapCodec<ChestBlock> CODEC = simpleCodec(properties -> new ChestBlock(properties, () -> BlockEntityType.CHEST));
+
+    public static final MapCodec<ChestBlock> CODEC = simpleCodec((blockbase_info) -> {
+        return new ChestBlock(blockbase_info, () -> {
+            return BlockEntityType.CHEST;
+        });
+    });
     public static final DirectionProperty FACING = HorizontalDirectionalBlock.FACING;
     public static final EnumProperty<ChestType> TYPE = BlockStateProperties.CHEST_TYPE;
     public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
     public static final int EVENT_SET_OPEN_COUNT = 1;
     protected static final int AABB_OFFSET = 1;
     protected static final int AABB_HEIGHT = 14;
-    protected static final VoxelShape NORTH_AABB = Block.box(1.0, 0.0, 0.0, 15.0, 14.0, 15.0);
-    protected static final VoxelShape SOUTH_AABB = Block.box(1.0, 0.0, 1.0, 15.0, 14.0, 16.0);
-    protected static final VoxelShape WEST_AABB = Block.box(0.0, 0.0, 1.0, 15.0, 14.0, 15.0);
-    protected static final VoxelShape EAST_AABB = Block.box(1.0, 0.0, 1.0, 16.0, 14.0, 15.0);
-    protected static final VoxelShape AABB = Block.box(1.0, 0.0, 1.0, 15.0, 14.0, 15.0);
-    private static final DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<Container>> CHEST_COMBINER = new DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<Container>>(
-        
-    ) {
-        @Override
-        public Optional<Container> acceptDouble(ChestBlockEntity first, ChestBlockEntity second) {
-            return Optional.of(new CompoundContainer(first, second));
+    protected static final VoxelShape NORTH_AABB = Block.box(1.0D, 0.0D, 0.0D, 15.0D, 14.0D, 15.0D);
+    protected static final VoxelShape SOUTH_AABB = Block.box(1.0D, 0.0D, 1.0D, 15.0D, 14.0D, 16.0D);
+    protected static final VoxelShape WEST_AABB = Block.box(0.0D, 0.0D, 1.0D, 15.0D, 14.0D, 15.0D);
+    protected static final VoxelShape EAST_AABB = Block.box(1.0D, 0.0D, 1.0D, 16.0D, 14.0D, 15.0D);
+    protected static final VoxelShape AABB = Block.box(1.0D, 0.0D, 1.0D, 15.0D, 14.0D, 15.0D);
+    private static final DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<Container>> CHEST_COMBINER = new DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<Container>>() {
+        public Optional<Container> acceptDouble(ChestBlockEntity tileentitychest, ChestBlockEntity tileentitychest1) {
+            return Optional.of(new CompoundContainer(tileentitychest, tileentitychest1));
         }
 
-        @Override
-        public Optional<Container> acceptSingle(ChestBlockEntity single) {
-            return Optional.of(single);
+        public Optional<Container> acceptSingle(ChestBlockEntity tileentitychest) {
+            return Optional.of(tileentitychest);
         }
 
         @Override
@@ -85,182 +89,187 @@
             return Optional.empty();
         }
     };
-    private static final DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<MenuProvider>> MENU_PROVIDER_COMBINER = new DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<MenuProvider>>(
-        
-    ) {
+    private static final DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<ITileInventory>> MENU_PROVIDER_COMBINER = new DoubleBlockCombiner.Combiner<ChestBlockEntity, Optional<ITileInventory>>() {
+        public Optional<ITileInventory> acceptDouble(final ChestBlockEntity tileentitychest, final ChestBlockEntity tileentitychest1) {
+            final CompoundContainer inventorylargechest = new CompoundContainer(tileentitychest, tileentitychest1);
+
+            return Optional.of(new DoubleInventory(tileentitychest, tileentitychest1, inventorylargechest)); // CraftBukkit
+        }
+
+        public Optional<ITileInventory> acceptSingle(ChestBlockEntity tileentitychest) {
+            return Optional.of(tileentitychest);
+        }
+
         @Override
-        public Optional<MenuProvider> acceptDouble(final ChestBlockEntity first, final ChestBlockEntity second) {
-            final Container container = new CompoundContainer(first, second);
-            return Optional.of(new MenuProvider() {
-                @Nullable
-                @Override
-                public AbstractContainerMenu createMenu(int containerId, Inventory playerInventory, Player player) {
-                    if (first.canOpen(player) && second.canOpen(player)) {
-                        first.unpackLootTable(playerInventory.player);
-                        second.unpackLootTable(playerInventory.player);
-                        return ChestMenu.sixRows(containerId, playerInventory, container);
-                    } else {
-                        return null;
-                    }
-                }
+        public Optional<ITileInventory> acceptNone() {
+            return Optional.empty();
+        }
+    };
 
-                @Override
-                public Component getDisplayName() {
-                    if (first.hasCustomName()) {
-                        return first.getDisplayName();
-                    } else {
-                        return (Component)(second.hasCustomName() ? second.getDisplayName() : Component.translatable("container.chestDouble"));
-                    }
-                }
-            });
+    // CraftBukkit start
+    public static class DoubleInventory implements ITileInventory {
+
+        private final ChestBlockEntity tileentitychest;
+        private final ChestBlockEntity tileentitychest1;
+        public final CompoundContainer inventorylargechest;
+
+        public DoubleInventory(ChestBlockEntity tileentitychest, ChestBlockEntity tileentitychest1, CompoundContainer inventorylargechest) {
+            this.tileentitychest = tileentitychest;
+            this.tileentitychest1 = tileentitychest1;
+            this.inventorylargechest = inventorylargechest;
         }
 
+        @Nullable
         @Override
-        public Optional<MenuProvider> acceptSingle(ChestBlockEntity single) {
-            return Optional.of(single);
+        public AbstractContainerMenu createMenu(int containerId, Inventory playerInventory, Player player) {
+            if (tileentitychest.canOpen(player) && tileentitychest1.canOpen(player)) {
+                tileentitychest.unpackLootTable(playerInventory.player);
+                tileentitychest1.unpackLootTable(playerInventory.player);
+                return ChestMenu.sixRows(containerId, playerInventory, inventorylargechest);
+            } else {
+                return null;
+            }
         }
 
         @Override
-        public Optional<MenuProvider> acceptNone() {
-            return Optional.empty();
+        public Component getDisplayName() {
+            return (Component) (tileentitychest.hasCustomName() ? tileentitychest.getDisplayName() : (tileentitychest1.hasCustomName() ? tileentitychest1.getDisplayName() : Component.translatable("container.chestDouble")));
         }
     };
+    // CraftBukkit end
 
     @Override
     public MapCodec<? extends ChestBlock> codec() {
-        return CODEC;
+        return ChestBlock.CODEC;
     }
 
     protected ChestBlock(BlockBehaviour.Properties properties, Supplier<BlockEntityType<? extends ChestBlockEntity>> blockEntityType) {
         super(properties, blockEntityType);
-        this.registerDefaultState(
-            this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(TYPE, ChestType.SINGLE).setValue(WATERLOGGED, Boolean.valueOf(false))
-        );
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(ChestBlock.FACING, Direction.NORTH)).setValue(ChestBlock.TYPE, ChestType.SINGLE)).setValue(ChestBlock.WATERLOGGED, false));
     }
 
-    public static DoubleBlockCombiner.BlockType getBlockType(BlockState state) {
-        ChestType chestType = state.getValue(TYPE);
-        if (chestType == ChestType.SINGLE) {
-            return DoubleBlockCombiner.BlockType.SINGLE;
-        } else {
-            return chestType == ChestType.RIGHT ? DoubleBlockCombiner.BlockType.FIRST : DoubleBlockCombiner.BlockType.SECOND;
-        }
+    public static DoubleBlockCombiner.BlockType getBlockType(IBlockData state) {
+        ChestType blockpropertychesttype = (ChestType) state.getValue(ChestBlock.TYPE);
+
+        return blockpropertychesttype == ChestType.SINGLE ? DoubleBlockCombiner.BlockType.SINGLE : (blockpropertychesttype == ChestType.RIGHT ? DoubleBlockCombiner.BlockType.FIRST : DoubleBlockCombiner.BlockType.SECOND);
     }
 
     @Override
-    public RenderShape getRenderShape(BlockState state) {
-        return RenderShape.ENTITYBLOCK_ANIMATED;
+    public EnumRenderType getRenderShape(IBlockData state) {
+        return EnumRenderType.ENTITYBLOCK_ANIMATED;
     }
 
     @Override
-    public BlockState updateShape(BlockState state, Direction facing, BlockState facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
-        if (state.getValue(WATERLOGGED)) {
-            level.scheduleTick(currentPos, Fluids.WATER, Fluids.WATER.getTickDelay(level));
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        if ((Boolean) state.getValue(ChestBlock.WATERLOGGED)) {
+            level.scheduleTick(currentPos, (Fluid) Fluids.WATER, Fluids.WATER.getTickDelay(level));
         }
 
-        if (facingState.is(this) && facing.getAxis().isHorizontal()) {
-            ChestType chestType = facingState.getValue(TYPE);
-            if (state.getValue(TYPE) == ChestType.SINGLE
-                && chestType != ChestType.SINGLE
-                && state.getValue(FACING) == facingState.getValue(FACING)
-                && getConnectedDirection(facingState) == facing.getOpposite()) {
-                return state.setValue(TYPE, chestType.getOpposite());
+        if (facingState.is((Block) this) && facing.getAxis().isHorizontal()) {
+            ChestType blockpropertychesttype = (ChestType) facingState.getValue(ChestBlock.TYPE);
+
+            if (state.getValue(ChestBlock.TYPE) == ChestType.SINGLE && blockpropertychesttype != ChestType.SINGLE && state.getValue(ChestBlock.FACING) == facingState.getValue(ChestBlock.FACING) && getConnectedDirection(facingState) == facing.getOpposite()) {
+                return (IBlockData) state.setValue(ChestBlock.TYPE, blockpropertychesttype.getOpposite());
             }
         } else if (getConnectedDirection(state) == facing) {
-            return state.setValue(TYPE, ChestType.SINGLE);
+            return (IBlockData) state.setValue(ChestBlock.TYPE, ChestType.SINGLE);
         }
 
         return super.updateShape(state, facing, facingState, level, currentPos, facingPos);
     }
 
     @Override
-    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
-        if (state.getValue(TYPE) == ChestType.SINGLE) {
-            return AABB;
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        if (state.getValue(ChestBlock.TYPE) == ChestType.SINGLE) {
+            return ChestBlock.AABB;
         } else {
             switch (getConnectedDirection(state)) {
                 case NORTH:
                 default:
-                    return NORTH_AABB;
+                    return ChestBlock.NORTH_AABB;
                 case SOUTH:
-                    return SOUTH_AABB;
+                    return ChestBlock.SOUTH_AABB;
                 case WEST:
-                    return WEST_AABB;
+                    return ChestBlock.WEST_AABB;
                 case EAST:
-                    return EAST_AABB;
+                    return ChestBlock.EAST_AABB;
             }
         }
     }
 
-    public static Direction getConnectedDirection(BlockState state) {
-        Direction direction = state.getValue(FACING);
-        return state.getValue(TYPE) == ChestType.LEFT ? direction.getClockWise() : direction.getCounterClockWise();
+    public static Direction getConnectedDirection(IBlockData state) {
+        Direction enumdirection = (Direction) state.getValue(ChestBlock.FACING);
+
+        return state.getValue(ChestBlock.TYPE) == ChestType.LEFT ? enumdirection.getClockWise() : enumdirection.getCounterClockWise();
     }
 
     @Override
-    public BlockState getStateForPlacement(BlockPlaceContext context) {
-        ChestType chestType = ChestType.SINGLE;
-        Direction opposite = context.getHorizontalDirection().getOpposite();
-        FluidState fluidState = context.getLevel().getFluidState(context.getClickedPos());
-        boolean isSecondaryUseActive = context.isSecondaryUseActive();
-        Direction clickedFace = context.getClickedFace();
-        if (clickedFace.getAxis().isHorizontal() && isSecondaryUseActive) {
-            Direction direction = this.candidatePartnerFacing(context, clickedFace.getOpposite());
-            if (direction != null && direction.getAxis() != clickedFace.getAxis()) {
-                opposite = direction;
-                chestType = direction.getCounterClockWise() == clickedFace.getOpposite() ? ChestType.RIGHT : ChestType.LEFT;
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        ChestType blockpropertychesttype = ChestType.SINGLE;
+        Direction enumdirection = context.getHorizontalDirection().getOpposite();
+        FluidState fluid = context.getLevel().getFluidState(context.getClickedPos());
+        boolean flag = context.isSecondaryUseActive();
+        Direction enumdirection1 = context.getClickedFace();
+
+        if (enumdirection1.getAxis().isHorizontal() && flag) {
+            Direction enumdirection2 = this.candidatePartnerFacing(context, enumdirection1.getOpposite());
+
+            if (enumdirection2 != null && enumdirection2.getAxis() != enumdirection1.getAxis()) {
+                enumdirection = enumdirection2;
+                blockpropertychesttype = enumdirection2.getCounterClockWise() == enumdirection1.getOpposite() ? ChestType.RIGHT : ChestType.LEFT;
             }
         }
 
-        if (chestType == ChestType.SINGLE && !isSecondaryUseActive) {
-            if (opposite == this.candidatePartnerFacing(context, opposite.getClockWise())) {
-                chestType = ChestType.LEFT;
-            } else if (opposite == this.candidatePartnerFacing(context, opposite.getCounterClockWise())) {
-                chestType = ChestType.RIGHT;
+        if (blockpropertychesttype == ChestType.SINGLE && !flag) {
+            if (enumdirection == this.candidatePartnerFacing(context, enumdirection.getClockWise())) {
+                blockpropertychesttype = ChestType.LEFT;
+            } else if (enumdirection == this.candidatePartnerFacing(context, enumdirection.getCounterClockWise())) {
+                blockpropertychesttype = ChestType.RIGHT;
             }
         }
 
-        return this.defaultBlockState()
-            .setValue(FACING, opposite)
-            .setValue(TYPE, chestType)
-            .setValue(WATERLOGGED, Boolean.valueOf(fluidState.getType() == Fluids.WATER));
+        return (IBlockData) ((IBlockData) ((IBlockData) this.defaultBlockState().setValue(ChestBlock.FACING, enumdirection)).setValue(ChestBlock.TYPE, blockpropertychesttype)).setValue(ChestBlock.WATERLOGGED, fluid.getType() == Fluids.WATER);
     }
 
     @Override
-    public FluidState getFluidState(BlockState state) {
-        return state.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);
+    public FluidState getFluidState(IBlockData state) {
+        return (Boolean) state.getValue(ChestBlock.WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);
     }
 
     @Nullable
     private Direction candidatePartnerFacing(BlockPlaceContext context, Direction direction) {
-        BlockState blockState = context.getLevel().getBlockState(context.getClickedPos().relative(direction));
-        return blockState.is(this) && blockState.getValue(TYPE) == ChestType.SINGLE ? blockState.getValue(FACING) : null;
+        IBlockData iblockdata = context.getLevel().getBlockState(context.getClickedPos().relative(direction));
+
+        return iblockdata.is((Block) this) && iblockdata.getValue(ChestBlock.TYPE) == ChestType.SINGLE ? (Direction) iblockdata.getValue(ChestBlock.FACING) : null;
     }
 
     @Override
-    public void setPlacedBy(Level level, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
+    public void setPlacedBy(Level level, BlockPos pos, IBlockData state, LivingEntity placer, ItemStack stack) {
         if (stack.hasCustomHoverName()) {
-            BlockEntity blockEntity = level.getBlockEntity(pos);
-            if (blockEntity instanceof ChestBlockEntity) {
-                ((ChestBlockEntity)blockEntity).setCustomName(stack.getHoverName());
+            BlockEntity tileentity = level.getBlockEntity(pos);
+
+            if (tileentity instanceof ChestBlockEntity) {
+                ((ChestBlockEntity) tileentity).setCustomName(stack.getHoverName());
             }
         }
+
     }
 
     @Override
-    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
+    public void onRemove(IBlockData state, Level level, BlockPos pos, IBlockData newState, boolean isMoving) {
         Containers.dropContentsOnDestroy(state, newState, level, pos);
         super.onRemove(state, level, pos, newState, isMoving);
     }
 
     @Override
-    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
+    public InteractionResult use(IBlockData state, Level level, BlockPos pos, Player player, EnumHand hand, BlockHitResult hit) {
         if (level.isClientSide) {
             return InteractionResult.SUCCESS;
         } else {
-            MenuProvider menuProvider = this.getMenuProvider(state, level, pos);
-            if (menuProvider != null) {
-                player.openMenu(menuProvider);
+            ITileInventory itileinventory = this.getMenuProvider(state, level, pos);
+
+            if (itileinventory != null) {
+                player.openMenu(itileinventory);
                 player.awardStat(this.getOpenChestStat());
                 PiglinAi.angerNearbyPiglins(player, true);
             }
@@ -274,61 +283,73 @@
     }
 
     public BlockEntityType<? extends ChestBlockEntity> blockEntityType() {
-        return this.blockEntityType.get();
+        return (BlockEntityType) this.blockEntityType.get();
     }
 
     @Nullable
-    public static Container getContainer(ChestBlock chest, BlockState state, Level level, BlockPos pos, boolean override) {
-        return chest.combine(state, level, pos, override).apply(CHEST_COMBINER).orElse(null);
+    public static Container getContainer(ChestBlock chest, IBlockData state, Level level, BlockPos pos, boolean override) {
+        return (Container) ((Optional) chest.combine(state, level, pos, override).apply(ChestBlock.CHEST_COMBINER)).orElse((Object) null);
     }
 
     @Override
-    public DoubleBlockCombiner.NeighborCombineResult<? extends ChestBlockEntity> combine(BlockState state, Level level, BlockPos pos, boolean override) {
-        BiPredicate<LevelAccessor, BlockPos> biPredicate;
+    public DoubleBlockCombiner.NeighborCombineResult<? extends ChestBlockEntity> combine(IBlockData state, Level level, BlockPos pos, boolean override) {
+        BiPredicate<LevelAccessor, BlockPos> bipredicate; // CraftBukkit - decompile error
+
         if (override) {
-            biPredicate = (levelAccessor, blockPos) -> false;
+            bipredicate = (generatoraccess, blockposition1) -> {
+                return false;
+            };
         } else {
-            biPredicate = ChestBlock::isChestBlockedAt;
+            bipredicate = ChestBlock::isChestBlockedAt;
         }
 
-        return DoubleBlockCombiner.combineWithNeigbour(
-            this.blockEntityType.get(), ChestBlock::getBlockType, ChestBlock::getConnectedDirection, FACING, state, level, pos, biPredicate
-        );
+        return DoubleBlockCombiner.combineWithNeigbour((BlockEntityType) this.blockEntityType.get(), ChestBlock::getBlockType, ChestBlock::getConnectedDirection, ChestBlock.FACING, state, level, pos, bipredicate);
     }
 
     @Nullable
     @Override
-    public MenuProvider getMenuProvider(BlockState state, Level level, BlockPos pos) {
-        return this.combine(state, level, pos, false).apply(MENU_PROVIDER_COMBINER).orElse(null);
+    public ITileInventory getMenuProvider(IBlockData state, Level level, BlockPos pos) {
+        // CraftBukkit start
+        return getMenuProvider(state, level, pos, false);
     }
 
+    @Nullable
+    public ITileInventory getMenuProvider(IBlockData iblockdata, Level world, BlockPos blockposition, boolean ignoreObstructions) {
+        return (ITileInventory) ((Optional) this.combine(iblockdata, world, blockposition, ignoreObstructions).apply(ChestBlock.MENU_PROVIDER_COMBINER)).orElse((Object) null);
+        // CraftBukkit end
+    }
+
     public static DoubleBlockCombiner.Combiner<ChestBlockEntity, Float2FloatFunction> opennessCombiner(final LidBlockEntity lid) {
         return new DoubleBlockCombiner.Combiner<ChestBlockEntity, Float2FloatFunction>() {
-            @Override
             public Float2FloatFunction acceptDouble(ChestBlockEntity first, ChestBlockEntity second) {
-                return partialTicks -> Math.max(first.getOpenNess(partialTicks), second.getOpenNess(partialTicks));
+                return (f) -> {
+                    return Math.max(first.getOpenNess(f), second.getOpenNess(f));
+                };
             }
 
-            @Override
             public Float2FloatFunction acceptSingle(ChestBlockEntity single) {
+                Objects.requireNonNull(single);
                 return single::getOpenNess;
             }
 
             @Override
             public Float2FloatFunction acceptNone() {
-                return lid::getOpenNess;
+                LidBlockEntity lidblockentity1 = lid;
+
+                Objects.requireNonNull(lid);
+                return lidblockentity1::getOpenNess;
             }
         };
     }
 
     @Override
-    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
+    public BlockEntity newBlockEntity(BlockPos pos, IBlockData state) {
         return new ChestBlockEntity(pos, state);
     }
 
     @Nullable
     @Override
-    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> blockEntityType) {
+    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, IBlockData state, BlockEntityType<T> blockEntityType) {
         return level.isClientSide ? createTickerHelper(blockEntityType, this.blockEntityType(), ChestBlockEntity::lidAnimateTick) : null;
     }
 
@@ -337,20 +358,21 @@
     }
 
     private static boolean isBlockedChestByBlock(BlockGetter level, BlockPos pos) {
-        BlockPos blockPos = pos.above();
-        return level.getBlockState(blockPos).isRedstoneConductor(level, blockPos);
+        BlockPos blockposition1 = pos.above();
+
+        return level.getBlockState(blockposition1).isRedstoneConductor(level, blockposition1);
     }
 
     private static boolean isCatSittingOnChest(LevelAccessor level, BlockPos pos) {
-        List<Cat> entitiesOfClass = level.getEntitiesOfClass(
-            Cat.class,
-            new AABB(
-                (double)pos.getX(), (double)(pos.getY() + 1), (double)pos.getZ(), (double)(pos.getX() + 1), (double)(pos.getY() + 2), (double)(pos.getZ() + 1)
-            )
-        );
-        if (!entitiesOfClass.isEmpty()) {
-            for (Cat cat : entitiesOfClass) {
-                if (cat.isInSittingPose()) {
+        List<Cat> list = level.getEntitiesOfClass(Cat.class, new AABB((double) pos.getX(), (double) (pos.getY() + 1), (double) pos.getZ(), (double) (pos.getX() + 1), (double) (pos.getY() + 2), (double) (pos.getZ() + 1)));
+
+        if (!list.isEmpty()) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                Cat entitycat = (Cat) iterator.next();
+
+                if (entitycat.isInSittingPose()) {
                     return true;
                 }
             }
@@ -360,40 +382,42 @@
     }
 
     @Override
-    public boolean hasAnalogOutputSignal(BlockState state) {
+    public boolean hasAnalogOutputSignal(IBlockData state) {
         return true;
     }
 
     @Override
-    public int getAnalogOutputSignal(BlockState blockState, Level level, BlockPos pos) {
+    public int getAnalogOutputSignal(IBlockData blockState, Level level, BlockPos pos) {
         return AbstractContainerMenu.getRedstoneSignalFromContainer(getContainer(this, blockState, level, pos, false));
     }
 
     @Override
-    public BlockState rotate(BlockState state, Rotation rotation) {
-        return state.setValue(FACING, rotation.rotate(state.getValue(FACING)));
+    public IBlockData rotate(IBlockData state, Rotation rotation) {
+        return (IBlockData) state.setValue(ChestBlock.FACING, rotation.rotate((Direction) state.getValue(ChestBlock.FACING)));
     }
 
     @Override
-    public BlockState mirror(BlockState state, Mirror mirror) {
-        return state.rotate(mirror.getRotation(state.getValue(FACING)));
+    public IBlockData mirror(IBlockData state, Mirror mirror) {
+        return state.rotate(mirror.getRotation((Direction) state.getValue(ChestBlock.FACING)));
     }
 
     @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
-        builder.add(FACING, TYPE, WATERLOGGED);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(ChestBlock.FACING, ChestBlock.TYPE, ChestBlock.WATERLOGGED);
     }
 
     @Override
-    public boolean isPathfindable(BlockState state, BlockGetter level, BlockPos pos, PathComputationType type) {
+    public boolean isPathfindable(IBlockData state, BlockGetter level, BlockPos pos, PathMode type) {
         return false;
     }
 
     @Override
-    public void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
-        BlockEntity blockEntity = level.getBlockEntity(pos);
-        if (blockEntity instanceof ChestBlockEntity) {
-            ((ChestBlockEntity)blockEntity).recheckOpen();
+    public void tick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        BlockEntity tileentity = level.getBlockEntity(pos);
+
+        if (tileentity instanceof ChestBlockEntity) {
+            ((ChestBlockEntity) tileentity).recheckOpen();
         }
+
     }
 }
