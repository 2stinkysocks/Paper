--- a/net/minecraft/world/level/block/DiodeBlock.java
+++ b/net/minecraft/world/level/block/DiodeBlock.java
@@ -14,15 +14,17 @@
 import net.minecraft.world.level.SignalGetter;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.TickPriority;
+import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public abstract class DiodeBlock extends HorizontalDirectionalBlock {
-    protected static final VoxelShape SHAPE = Block.box(0.0, 0.0, 0.0, 16.0, 2.0, 16.0);
+
+    protected static final VoxelShape SHAPE = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 2.0D, 16.0D);
     public static final BooleanProperty POWERED = BlockStateProperties.POWERED;
 
     protected DiodeBlock(BlockBehaviour.Properties properties) {
@@ -33,167 +35,188 @@
     protected abstract MapCodec<? extends DiodeBlock> codec();
 
     @Override
-    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
-        return SHAPE;
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        return DiodeBlock.SHAPE;
     }
 
     @Override
-    public boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
-        BlockPos blockPos = pos.below();
-        return this.canSurviveOn(level, blockPos, level.getBlockState(blockPos));
+    public boolean canSurvive(IBlockData state, LevelReader level, BlockPos pos) {
+        BlockPos blockposition1 = pos.below();
+
+        return this.canSurviveOn(level, blockposition1, level.getBlockState(blockposition1));
     }
 
-    protected boolean canSurviveOn(LevelReader levelReader, BlockPos blockPos, BlockState blockState) {
-        return blockState.isFaceSturdy(levelReader, blockPos, Direction.UP, SupportType.RIGID);
+    protected boolean canSurviveOn(LevelReader iworldreader, BlockPos blockposition, IBlockData iblockdata) {
+        return iblockdata.isFaceSturdy(iworldreader, blockposition, Direction.UP, SupportType.RIGID);
     }
 
     @Override
-    public void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
+    public void tick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
         if (!this.isLocked(level, pos, state)) {
-            boolean flag = state.getValue(POWERED);
-            boolean shouldTurnOn = this.shouldTurnOn(level, pos, state);
-            if (flag && !shouldTurnOn) {
-                level.setBlock(pos, state.setValue(POWERED, Boolean.valueOf(false)), 2);
+            boolean flag = (Boolean) state.getValue(DiodeBlock.POWERED);
+            boolean flag1 = this.shouldTurnOn(level, pos, state);
+
+            if (flag && !flag1) {
+                // CraftBukkit start
+                if (CraftEventFactory.callRedstoneChange(level, pos, 15, 0).getNewCurrent() != 0) {
+                    return;
+                }
+                // CraftBukkit end
+                level.setBlock(pos, (IBlockData) state.setValue(DiodeBlock.POWERED, false), 2);
             } else if (!flag) {
-                level.setBlock(pos, state.setValue(POWERED, Boolean.valueOf(true)), 2);
-                if (!shouldTurnOn) {
-                    level.scheduleTick(pos, this, this.getDelay(state), TickPriority.VERY_HIGH);
+                // CraftBukkit start
+                if (CraftEventFactory.callRedstoneChange(level, pos, 0, 15).getNewCurrent() != 15) {
+                    return;
                 }
+                // CraftBukkit end
+                level.setBlock(pos, (IBlockData) state.setValue(DiodeBlock.POWERED, true), 2);
+                if (!flag1) {
+                    level.scheduleTick(pos, (Block) this, this.getDelay(state), TickPriority.VERY_HIGH);
+                }
             }
+
         }
     }
 
     @Override
-    public int getDirectSignal(BlockState blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
+    public int getDirectSignal(IBlockData blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
         return blockState.getSignal(blockAccess, pos, side);
     }
 
     @Override
-    public int getSignal(BlockState blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
-        if (!blockState.getValue(POWERED)) {
-            return 0;
-        } else {
-            return blockState.getValue(FACING) == side ? this.getOutputSignal(blockAccess, pos, blockState) : 0;
-        }
+    public int getSignal(IBlockData blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
+        return !(Boolean) blockState.getValue(DiodeBlock.POWERED) ? 0 : (blockState.getValue(DiodeBlock.FACING) == side ? this.getOutputSignal(blockAccess, pos, blockState) : 0);
     }
 
     @Override
-    public void neighborChanged(BlockState state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
+    public void neighborChanged(IBlockData state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
         if (state.canSurvive(level, pos)) {
             this.checkTickOnNeighbor(level, pos, state);
         } else {
-            BlockEntity blockEntity = state.hasBlockEntity() ? level.getBlockEntity(pos) : null;
-            dropResources(state, level, pos, blockEntity);
+            BlockEntity tileentity = state.hasBlockEntity() ? level.getBlockEntity(pos) : null;
+
+            dropResources(state, level, pos, tileentity);
             level.removeBlock(pos, false);
+            Direction[] aenumdirection = Direction.values();
+            int i = aenumdirection.length;
 
-            for (Direction direction : Direction.values()) {
-                level.updateNeighborsAt(pos.relative(direction), this);
+            for (int j = 0; j < i; ++j) {
+                Direction enumdirection = aenumdirection[j];
+
+                level.updateNeighborsAt(pos.relative(enumdirection), this);
             }
+
         }
     }
 
-    protected void checkTickOnNeighbor(Level level, BlockPos pos, BlockState state) {
+    protected void checkTickOnNeighbor(Level level, BlockPos pos, IBlockData state) {
         if (!this.isLocked(level, pos, state)) {
-            boolean flag = state.getValue(POWERED);
-            boolean shouldTurnOn = this.shouldTurnOn(level, pos, state);
-            if (flag != shouldTurnOn && !level.getBlockTicks().willTickThisTick(pos, this)) {
-                TickPriority tickPriority = TickPriority.HIGH;
+            boolean flag = (Boolean) state.getValue(DiodeBlock.POWERED);
+            boolean flag1 = this.shouldTurnOn(level, pos, state);
+
+            if (flag != flag1 && !level.getBlockTicks().willTickThisTick(pos, this)) {
+                TickPriority ticklistpriority = TickPriority.HIGH;
+
                 if (this.shouldPrioritize(level, pos, state)) {
-                    tickPriority = TickPriority.EXTREMELY_HIGH;
+                    ticklistpriority = TickPriority.EXTREMELY_HIGH;
                 } else if (flag) {
-                    tickPriority = TickPriority.VERY_HIGH;
+                    ticklistpriority = TickPriority.VERY_HIGH;
                 }
 
-                level.scheduleTick(pos, this, this.getDelay(state), tickPriority);
+                level.scheduleTick(pos, (Block) this, this.getDelay(state), ticklistpriority);
             }
+
         }
     }
 
-    public boolean isLocked(LevelReader level, BlockPos pos, BlockState state) {
+    public boolean isLocked(LevelReader level, BlockPos pos, IBlockData state) {
         return false;
     }
 
-    protected boolean shouldTurnOn(Level level, BlockPos pos, BlockState state) {
+    protected boolean shouldTurnOn(Level level, BlockPos pos, IBlockData state) {
         return this.getInputSignal(level, pos, state) > 0;
     }
 
-    protected int getInputSignal(Level level, BlockPos pos, BlockState state) {
-        Direction direction = state.getValue(FACING);
-        BlockPos blockPos = pos.relative(direction);
-        int signal = level.getSignal(blockPos, direction);
-        if (signal >= 15) {
-            return signal;
+    protected int getInputSignal(Level level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = (Direction) state.getValue(DiodeBlock.FACING);
+        BlockPos blockposition1 = pos.relative(enumdirection);
+        int i = level.getSignal(blockposition1, enumdirection);
+
+        if (i >= 15) {
+            return i;
         } else {
-            BlockState blockState = level.getBlockState(blockPos);
-            return Math.max(signal, blockState.is(Blocks.REDSTONE_WIRE) ? blockState.getValue(RedStoneWireBlock.POWER) : 0);
+            IBlockData iblockdata1 = level.getBlockState(blockposition1);
+
+            return Math.max(i, iblockdata1.is(Blocks.REDSTONE_WIRE) ? (Integer) iblockdata1.getValue(RedStoneWireBlock.POWER) : 0);
         }
     }
 
-    protected int getAlternateSignal(SignalGetter level, BlockPos pos, BlockState state) {
-        Direction direction = state.getValue(FACING);
-        Direction clockWise = direction.getClockWise();
-        Direction counterClockWise = direction.getCounterClockWise();
+    protected int getAlternateSignal(SignalGetter level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = (Direction) state.getValue(DiodeBlock.FACING);
+        Direction enumdirection1 = enumdirection.getClockWise();
+        Direction enumdirection2 = enumdirection.getCounterClockWise();
         boolean flag = this.sideInputDiodesOnly();
-        return Math.max(
-            level.getControlInputSignal(pos.relative(clockWise), clockWise, flag),
-            level.getControlInputSignal(pos.relative(counterClockWise), counterClockWise, flag)
-        );
+
+        return Math.max(level.getControlInputSignal(pos.relative(enumdirection1), enumdirection1, flag), level.getControlInputSignal(pos.relative(enumdirection2), enumdirection2, flag));
     }
 
     @Override
-    public boolean isSignalSource(BlockState state) {
+    public boolean isSignalSource(IBlockData state) {
         return true;
     }
 
     @Override
-    public BlockState getStateForPlacement(BlockPlaceContext context) {
-        return this.defaultBlockState().setValue(FACING, context.getHorizontalDirection().getOpposite());
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        return (IBlockData) this.defaultBlockState().setValue(DiodeBlock.FACING, context.getHorizontalDirection().getOpposite());
     }
 
     @Override
-    public void setPlacedBy(Level level, BlockPos pos, BlockState state, LivingEntity placer, ItemStack stack) {
+    public void setPlacedBy(Level level, BlockPos pos, IBlockData state, LivingEntity placer, ItemStack stack) {
         if (this.shouldTurnOn(level, pos, state)) {
-            level.scheduleTick(pos, this, 1);
+            level.scheduleTick(pos, (Block) this, 1);
         }
+
     }
 
     @Override
-    public void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean isMoving) {
+    public void onPlace(IBlockData state, Level level, BlockPos pos, IBlockData oldState, boolean isMoving) {
         this.updateNeighborsInFront(level, pos, state);
     }
 
     @Override
-    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
+    public void onRemove(IBlockData state, Level level, BlockPos pos, IBlockData newState, boolean isMoving) {
         if (!isMoving && !state.is(newState.getBlock())) {
             super.onRemove(state, level, pos, newState, isMoving);
             this.updateNeighborsInFront(level, pos, state);
         }
     }
 
-    protected void updateNeighborsInFront(Level level, BlockPos pos, BlockState state) {
-        Direction direction = state.getValue(FACING);
-        BlockPos blockPos = pos.relative(direction.getOpposite());
-        level.neighborChanged(blockPos, this, pos);
-        level.updateNeighborsAtExceptFromFacing(blockPos, this, direction);
+    protected void updateNeighborsInFront(Level level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = (Direction) state.getValue(DiodeBlock.FACING);
+        BlockPos blockposition1 = pos.relative(enumdirection.getOpposite());
+
+        level.neighborChanged(blockposition1, this, pos);
+        level.updateNeighborsAtExceptFromFacing(blockposition1, this, enumdirection);
     }
 
     protected boolean sideInputDiodesOnly() {
         return false;
     }
 
-    protected int getOutputSignal(BlockGetter level, BlockPos pos, BlockState state) {
+    protected int getOutputSignal(BlockGetter level, BlockPos pos, IBlockData state) {
         return 15;
     }
 
-    public static boolean isDiode(BlockState state) {
+    public static boolean isDiode(IBlockData state) {
         return state.getBlock() instanceof DiodeBlock;
     }
 
-    public boolean shouldPrioritize(BlockGetter level, BlockPos pos, BlockState state) {
-        Direction opposite = state.getValue(FACING).getOpposite();
-        BlockState blockState = level.getBlockState(pos.relative(opposite));
-        return isDiode(blockState) && blockState.getValue(FACING) != opposite;
+    public boolean shouldPrioritize(BlockGetter level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = ((Direction) state.getValue(DiodeBlock.FACING)).getOpposite();
+        IBlockData iblockdata1 = level.getBlockState(pos.relative(enumdirection));
+
+        return isDiode(iblockdata1) && iblockdata1.getValue(DiodeBlock.FACING) != enumdirection;
     }
 
-    protected abstract int getDelay(BlockState state);
+    protected abstract int getDelay(IBlockData state);
 }
