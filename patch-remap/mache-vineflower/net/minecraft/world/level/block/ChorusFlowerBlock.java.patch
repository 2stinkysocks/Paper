--- a/net/minecraft/world/level/block/ChorusFlowerBlock.java
+++ b/net/minecraft/world/level/block/ChorusFlowerBlock.java
@@ -2,7 +2,7 @@
 
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import com.mojang.serialization.codecs.RecordCodecBuilder.Instance;
+import java.util.Iterator;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -15,167 +15,201 @@
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+
 public class ChorusFlowerBlock extends Block {
-    public static final MapCodec<ChorusFlowerBlock> CODEC = RecordCodecBuilder.mapCodec(
-        instance -> instance.group(
-                    BuiltInRegistries.BLOCK.byNameCodec().fieldOf("plant").forGetter(chorusFlowerBlock -> chorusFlowerBlock.plant), propertiesCodec()
-                )
-                .apply(instance, ChorusFlowerBlock::new)
-    );
+
+    public static final MapCodec<ChorusFlowerBlock> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
+        return instance.group(BuiltInRegistries.BLOCK.byNameCodec().fieldOf("plant").forGetter((blockchorusflower) -> {
+            return blockchorusflower.plant;
+        }), propertiesCodec()).apply(instance, ChorusFlowerBlock::new);
+    });
     public static final int DEAD_AGE = 5;
     public static final IntegerProperty AGE = BlockStateProperties.AGE_5;
-    protected static final VoxelShape BLOCK_SUPPORT_SHAPE = Block.box(1.0, 0.0, 1.0, 15.0, 15.0, 15.0);
+    protected static final VoxelShape BLOCK_SUPPORT_SHAPE = Block.box(1.0D, 0.0D, 1.0D, 15.0D, 15.0D, 15.0D);
     private final Block plant;
 
     @Override
     public MapCodec<ChorusFlowerBlock> codec() {
-        return CODEC;
+        return ChorusFlowerBlock.CODEC;
     }
 
-    protected ChorusFlowerBlock(Block block, BlockBehaviour.Properties properties) {
-        super(properties);
+    protected ChorusFlowerBlock(Block block, BlockBehaviour.Properties blockbase_info) {
+        super(blockbase_info);
         this.plant = block;
-        this.registerDefaultState(this.stateDefinition.any().setValue(AGE, Integer.valueOf(0)));
+        this.registerDefaultState((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(ChorusFlowerBlock.AGE, 0));
     }
 
     @Override
-    public void tick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
+    public void tick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
         if (!state.canSurvive(level, pos)) {
             level.destroyBlock(pos, true);
         }
+
     }
 
     @Override
-    public boolean isRandomlyTicking(BlockState state) {
-        return state.getValue(AGE) < 5;
+    public boolean isRandomlyTicking(IBlockData state) {
+        return (Integer) state.getValue(ChorusFlowerBlock.AGE) < 5;
     }
 
     @Override
-    public VoxelShape getBlockSupportShape(BlockState state, BlockGetter level, BlockPos pos) {
-        return BLOCK_SUPPORT_SHAPE;
+    public VoxelShape getBlockSupportShape(IBlockData state, BlockGetter level, BlockPos pos) {
+        return ChorusFlowerBlock.BLOCK_SUPPORT_SHAPE;
     }
 
     @Override
-    public void randomTick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
-        BlockPos blockPos = pos.above();
-        if (level.isEmptyBlock(blockPos) && blockPos.getY() < level.getMaxBuildHeight()) {
-            int i = state.getValue(AGE);
+    public void randomTick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        BlockPos blockposition1 = pos.above();
+
+        if (level.isEmptyBlock(blockposition1) && blockposition1.getY() < level.getMaxBuildHeight()) {
+            int i = (Integer) state.getValue(ChorusFlowerBlock.AGE);
+
             if (i < 5) {
                 boolean flag = false;
                 boolean flag1 = false;
-                BlockState blockState = level.getBlockState(pos.below());
-                if (blockState.is(Blocks.END_STONE)) {
+                IBlockData iblockdata1 = level.getBlockState(pos.below());
+                int j;
+
+                if (iblockdata1.is(Blocks.END_STONE)) {
                     flag = true;
-                } else if (blockState.is(this.plant)) {
-                    int i1 = 1;
+                } else if (iblockdata1.is(this.plant)) {
+                    j = 1;
 
-                    for (int i2 = 0; i2 < 4; i2++) {
-                        BlockState blockState1 = level.getBlockState(pos.below(i1 + 1));
-                        if (!blockState1.is(this.plant)) {
-                            if (blockState1.is(Blocks.END_STONE)) {
+                    for (int k = 0; k < 4; ++k) {
+                        IBlockData iblockdata2 = level.getBlockState(pos.below(j + 1));
+
+                        if (!iblockdata2.is(this.plant)) {
+                            if (iblockdata2.is(Blocks.END_STONE)) {
                                 flag1 = true;
                             }
                             break;
                         }
 
-                        i1++;
+                        ++j;
                     }
 
-                    if (i1 < 2 || i1 <= random.nextInt(flag1 ? 5 : 4)) {
+                    if (j < 2 || j <= random.nextInt(flag1 ? 5 : 4)) {
                         flag = true;
                     }
-                } else if (blockState.isAir()) {
+                } else if (iblockdata1.isAir()) {
                     flag = true;
                 }
 
-                if (flag && allNeighborsEmpty(level, blockPos, null) && level.isEmptyBlock(pos.above(2))) {
-                    level.setBlock(pos, ChorusPlantBlock.getStateWithConnections(level, pos, this.plant.defaultBlockState()), 2);
-                    this.placeGrownFlower(level, blockPos, i);
+                if (flag && allNeighborsEmpty(level, blockposition1, (Direction) null) && level.isEmptyBlock(pos.above(2))) {
+                    // CraftBukkit start - add event
+                    if (CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition1, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(i)), 2)) {
+                        level.setBlock(pos, ChorusPlantBlock.getStateWithConnections(level, pos, this.plant.defaultBlockState()), 2);
+                        this.placeGrownFlower(level, blockposition1, i);
+                    }
+                    // CraftBukkit end
                 } else if (i < 4) {
-                    int i1 = random.nextInt(4);
+                    j = random.nextInt(4);
                     if (flag1) {
-                        i1++;
+                        ++j;
                     }
 
                     boolean flag2 = false;
 
-                    for (int i3 = 0; i3 < i1; i3++) {
-                        Direction randomDirection = Direction.Plane.HORIZONTAL.getRandomDirection(random);
-                        BlockPos blockPos1 = pos.relative(randomDirection);
-                        if (level.isEmptyBlock(blockPos1)
-                            && level.isEmptyBlock(blockPos1.below())
-                            && allNeighborsEmpty(level, blockPos1, randomDirection.getOpposite())) {
-                            this.placeGrownFlower(level, blockPos1, i + 1);
-                            flag2 = true;
+                    for (int l = 0; l < j; ++l) {
+                        Direction enumdirection = Direction.Plane.HORIZONTAL.getRandomDirection(random);
+                        BlockPos blockposition2 = pos.relative(enumdirection);
+
+                        if (level.isEmptyBlock(blockposition2) && level.isEmptyBlock(blockposition2.below()) && allNeighborsEmpty(level, blockposition2, enumdirection.getOpposite())) {
+                            // CraftBukkit start - add event
+                            if (CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition2, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(i + 1)), 2)) {
+                                this.placeGrownFlower(level, blockposition2, i + 1);
+                                flag2 = true;
+                            }
+                            // CraftBukkit end
                         }
                     }
 
                     if (flag2) {
                         level.setBlock(pos, ChorusPlantBlock.getStateWithConnections(level, pos, this.plant.defaultBlockState()), 2);
                     } else {
-                        this.placeDeadFlower(level, pos);
+                        // CraftBukkit start - add event
+                        if (CraftEventFactory.handleBlockGrowEvent(level, pos, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(5)), 2)) {
+                            this.placeDeadFlower(level, pos);
+                        }
+                        // CraftBukkit end
                     }
                 } else {
-                    this.placeDeadFlower(level, pos);
+                    // CraftBukkit start - add event
+                    if (CraftEventFactory.handleBlockGrowEvent(level, pos, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(5)), 2)) {
+                        this.placeDeadFlower(level, pos);
+                    }
+                    // CraftBukkit end
                 }
+
             }
         }
     }
 
     private void placeGrownFlower(Level level, BlockPos pos, int age) {
-        level.setBlock(pos, this.defaultBlockState().setValue(AGE, Integer.valueOf(age)), 2);
+        level.setBlock(pos, (IBlockData) this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, age), 2);
         level.levelEvent(1033, pos, 0);
     }
 
     private void placeDeadFlower(Level level, BlockPos pos) {
-        level.setBlock(pos, this.defaultBlockState().setValue(AGE, Integer.valueOf(5)), 2);
+        level.setBlock(pos, (IBlockData) this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, 5), 2);
         level.levelEvent(1034, pos, 0);
     }
 
     private static boolean allNeighborsEmpty(LevelReader level, BlockPos pos, @Nullable Direction excludingSide) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            if (direction != excludingSide && !level.isEmptyBlock(pos.relative(direction))) {
-                return false;
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
+
+        Direction enumdirection1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return true;
             }
-        }
 
-        return true;
+            enumdirection1 = (Direction) iterator.next();
+        } while (enumdirection1 == excludingSide || level.isEmptyBlock(pos.relative(enumdirection1)));
+
+        return false;
     }
 
     @Override
-    public BlockState updateShape(BlockState state, Direction facing, BlockState facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
         if (facing != Direction.UP && !state.canSurvive(level, currentPos)) {
-            level.scheduleTick(currentPos, this, 1);
+            level.scheduleTick(currentPos, (Block) this, 1);
         }
 
         return super.updateShape(state, facing, facingState, level, currentPos, facingPos);
     }
 
     @Override
-    public boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
-        BlockState blockState = level.getBlockState(pos.below());
-        if (!blockState.is(this.plant) && !blockState.is(Blocks.END_STONE)) {
-            if (!blockState.isAir()) {
+    public boolean canSurvive(IBlockData state, LevelReader level, BlockPos pos) {
+        IBlockData iblockdata1 = level.getBlockState(pos.below());
+
+        if (!iblockdata1.is(this.plant) && !iblockdata1.is(Blocks.END_STONE)) {
+            if (!iblockdata1.isAir()) {
                 return false;
             } else {
                 boolean flag = false;
+                Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
-                for (Direction direction : Direction.Plane.HORIZONTAL) {
-                    BlockState blockState1 = level.getBlockState(pos.relative(direction));
-                    if (blockState1.is(this.plant)) {
+                while (iterator.hasNext()) {
+                    Direction enumdirection = (Direction) iterator.next();
+                    IBlockData iblockdata2 = level.getBlockState(pos.relative(enumdirection));
+
+                    if (iblockdata2.is(this.plant)) {
                         if (flag) {
                             return false;
                         }
 
                         flag = true;
-                    } else if (!blockState1.isAir()) {
+                    } else if (!iblockdata2.isAir()) {
                         return false;
                     }
                 }
@@ -188,8 +222,8 @@
     }
 
     @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
-        builder.add(AGE);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(ChorusFlowerBlock.AGE);
     }
 
     public static void generatePlant(LevelAccessor level, BlockPos pos, RandomSource random, int maxHorizontalDistance) {
@@ -197,62 +231,65 @@
         growTreeRecursive(level, pos, random, pos, maxHorizontalDistance, 0);
     }
 
-    private static void growTreeRecursive(
-        LevelAccessor level, BlockPos branchPos, RandomSource random, BlockPos originalBranchPos, int maxHorizontalDistance, int iterations
-    ) {
+    private static void growTreeRecursive(LevelAccessor level, BlockPos branchPos, RandomSource random, BlockPos originalBranchPos, int maxHorizontalDistance, int iterations) {
         Block block = Blocks.CHORUS_PLANT;
-        int i = random.nextInt(4) + 1;
+        int k = random.nextInt(4) + 1;
+
         if (iterations == 0) {
-            i++;
+            ++k;
         }
 
-        for (int i1 = 0; i1 < i; i1++) {
-            BlockPos blockPos = branchPos.above(i1 + 1);
-            if (!allNeighborsEmpty(level, blockPos, null)) {
+        for (int l = 0; l < k; ++l) {
+            BlockPos blockposition2 = branchPos.above(l + 1);
+
+            if (!allNeighborsEmpty(level, blockposition2, (Direction) null)) {
                 return;
             }
 
-            level.setBlock(blockPos, ChorusPlantBlock.getStateWithConnections(level, blockPos, block.defaultBlockState()), 2);
-            level.setBlock(blockPos.below(), ChorusPlantBlock.getStateWithConnections(level, blockPos.below(), block.defaultBlockState()), 2);
+            level.setBlock(blockposition2, ChorusPlantBlock.getStateWithConnections(level, blockposition2, block.defaultBlockState()), 2);
+            level.setBlock(blockposition2.below(), ChorusPlantBlock.getStateWithConnections(level, blockposition2.below(), block.defaultBlockState()), 2);
         }
 
         boolean flag = false;
+
         if (iterations < 4) {
-            int randomInt = random.nextInt(4);
+            int i1 = random.nextInt(4);
+
             if (iterations == 0) {
-                randomInt++;
+                ++i1;
             }
 
-            for (int i2 = 0; i2 < randomInt; i2++) {
-                Direction randomDirection = Direction.Plane.HORIZONTAL.getRandomDirection(random);
-                BlockPos blockPos1 = branchPos.above(i).relative(randomDirection);
-                if (Math.abs(blockPos1.getX() - originalBranchPos.getX()) < maxHorizontalDistance
-                    && Math.abs(blockPos1.getZ() - originalBranchPos.getZ()) < maxHorizontalDistance
-                    && level.isEmptyBlock(blockPos1)
-                    && level.isEmptyBlock(blockPos1.below())
-                    && allNeighborsEmpty(level, blockPos1, randomDirection.getOpposite())) {
+            for (int j1 = 0; j1 < i1; ++j1) {
+                Direction enumdirection = Direction.Plane.HORIZONTAL.getRandomDirection(random);
+                BlockPos blockposition3 = branchPos.above(k).relative(enumdirection);
+
+                if (Math.abs(blockposition3.getX() - originalBranchPos.getX()) < maxHorizontalDistance && Math.abs(blockposition3.getZ() - originalBranchPos.getZ()) < maxHorizontalDistance && level.isEmptyBlock(blockposition3) && level.isEmptyBlock(blockposition3.below()) && allNeighborsEmpty(level, blockposition3, enumdirection.getOpposite())) {
                     flag = true;
-                    level.setBlock(blockPos1, ChorusPlantBlock.getStateWithConnections(level, blockPos1, block.defaultBlockState()), 2);
-                    level.setBlock(
-                        blockPos1.relative(randomDirection.getOpposite()),
-                        ChorusPlantBlock.getStateWithConnections(level, blockPos1.relative(randomDirection.getOpposite()), block.defaultBlockState()),
-                        2
-                    );
-                    growTreeRecursive(level, blockPos1, random, originalBranchPos, maxHorizontalDistance, iterations + 1);
+                    level.setBlock(blockposition3, ChorusPlantBlock.getStateWithConnections(level, blockposition3, block.defaultBlockState()), 2);
+                    level.setBlock(blockposition3.relative(enumdirection.getOpposite()), ChorusPlantBlock.getStateWithConnections(level, blockposition3.relative(enumdirection.getOpposite()), block.defaultBlockState()), 2);
+                    growTreeRecursive(level, blockposition3, random, originalBranchPos, maxHorizontalDistance, iterations + 1);
                 }
             }
         }
 
         if (!flag) {
-            level.setBlock(branchPos.above(i), Blocks.CHORUS_FLOWER.defaultBlockState().setValue(AGE, Integer.valueOf(5)), 2);
+            level.setBlock(branchPos.above(k), (IBlockData) Blocks.CHORUS_FLOWER.defaultBlockState().setValue(ChorusFlowerBlock.AGE, 5), 2);
         }
+
     }
 
     @Override
-    public void onProjectileHit(Level level, BlockState state, BlockHitResult hit, Projectile projectile) {
-        BlockPos blockPos = hit.getBlockPos();
-        if (!level.isClientSide && projectile.mayInteract(level, blockPos) && projectile.mayBreak(level)) {
-            level.destroyBlock(blockPos, true, projectile);
+    public void onProjectileHit(Level level, IBlockData state, BlockHitResult hit, Projectile projectile) {
+        BlockPos blockposition = hit.getBlockPos();
+
+        if (!level.isClientSide && projectile.mayInteract(level, blockposition) && projectile.mayBreak(level)) {
+            // CraftBukkit
+            if (!CraftEventFactory.callEntityChangeBlockEvent(projectile, blockposition, Blocks.AIR.defaultBlockState())) {
+                return;
+            }
+            // CraftBukkit end
+            level.destroyBlock(blockposition, true, projectile);
         }
+
     }
 }
