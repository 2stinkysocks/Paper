--- a/net/minecraft/world/level/block/SignBlock.java
+++ b/net/minecraft/world/level/block/SignBlock.java
@@ -7,11 +7,10 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.network.chat.CommonComponents;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.contents.PlainTextContents;
+import net.minecraft.network.chat.contents.LiteralContents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.stats.Stats;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.Item;
@@ -26,11 +25,12 @@
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.entity.SignText;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.level.block.state.properties.WoodType;
 import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.phys.BlockHitResult;
@@ -39,80 +39,92 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 
 public abstract class SignBlock extends BaseEntityBlock implements SimpleWaterloggedBlock {
+
     public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
     protected static final float AABB_OFFSET = 4.0F;
-    protected static final VoxelShape SHAPE = Block.box(4.0, 0.0, 4.0, 12.0, 16.0, 12.0);
+    protected static final VoxelShape SHAPE = Block.box(4.0D, 0.0D, 4.0D, 12.0D, 16.0D, 12.0D);
     private final WoodType type;
 
-    protected SignBlock(WoodType woodType, BlockBehaviour.Properties properties) {
-        super(properties);
-        this.type = woodType;
+    protected SignBlock(WoodType blockpropertywood, BlockBehaviour.Properties blockbase_info) {
+        super(blockbase_info);
+        this.type = blockpropertywood;
     }
 
     @Override
     protected abstract MapCodec<? extends SignBlock> codec();
 
     @Override
-    public BlockState updateShape(BlockState state, Direction facing, BlockState facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
-        if (state.getValue(WATERLOGGED)) {
-            level.scheduleTick(currentPos, Fluids.WATER, Fluids.WATER.getTickDelay(level));
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        if ((Boolean) state.getValue(SignBlock.WATERLOGGED)) {
+            level.scheduleTick(currentPos, (Fluid) Fluids.WATER, Fluids.WATER.getTickDelay(level));
         }
 
         return super.updateShape(state, facing, facingState, level, currentPos, facingPos);
     }
 
     @Override
-    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
-        return SHAPE;
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        return SignBlock.SHAPE;
     }
 
     @Override
-    public boolean isPossibleToRespawnInThis(BlockState state) {
+    public boolean isPossibleToRespawnInThis(IBlockData state) {
         return true;
     }
 
     @Override
-    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
+    public BlockEntity newBlockEntity(BlockPos pos, IBlockData state) {
         return new SignBlockEntity(pos, state);
     }
 
     @Override
-    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
-        ItemStack itemInHand = player.getItemInHand(hand);
-        Item item = itemInHand.getItem();
-        SignApplicator signApplicator1 = itemInHand.getItem() instanceof SignApplicator signApplicator ? signApplicator : null;
-        boolean flag = signApplicator1 != null && player.mayBuild();
-        if (level.getBlockEntity(pos) instanceof SignBlockEntity signBlockEntity) {
+    public InteractionResult use(IBlockData state, Level level, BlockPos pos, Player player, EnumHand hand, BlockHitResult hit) {
+        ItemStack itemstack = player.getItemInHand(hand);
+        Item item = itemstack.getItem();
+        Item item1 = itemstack.getItem();
+        SignApplicator signapplicator;
+
+        if (item1 instanceof SignApplicator) {
+            SignApplicator signapplicator1 = (SignApplicator) item1;
+
+            signapplicator = signapplicator1;
+        } else {
+            signapplicator = null;
+        }
+
+        SignApplicator signapplicator2 = signapplicator;
+        boolean flag = signapplicator2 != null && player.mayBuild();
+        BlockEntity tileentity = level.getBlockEntity(pos);
+
+        if (tileentity instanceof SignBlockEntity) {
+            SignBlockEntity tileentitysign = (SignBlockEntity) tileentity;
+
             if (!level.isClientSide) {
-                boolean isFacingFrontText = signBlockEntity.isFacingFrontText(player);
-                SignText text = signBlockEntity.getText(isFacingFrontText);
-                boolean flag1 = signBlockEntity.executeClickCommandsIfPresent(player, level, pos, isFacingFrontText);
-                if (signBlockEntity.isWaxed()) {
-                    level.playSound(null, signBlockEntity.getBlockPos(), signBlockEntity.getSignInteractionFailedSoundEvent(), SoundSource.BLOCKS);
+                boolean flag1 = tileentitysign.isFacingFrontText(player);
+                SignText signtext = tileentitysign.getText(flag1);
+                boolean flag2 = tileentitysign.executeClickCommandsIfPresent(player, level, pos, flag1);
+
+                if (tileentitysign.isWaxed()) {
+                    level.playSound((Player) null, tileentitysign.getBlockPos(), tileentitysign.getSignInteractionFailedSoundEvent(), SoundSource.BLOCKS);
                     return this.getInteractionResult(flag);
-                } else if (flag
-                    && !this.otherPlayerIsEditingSign(player, signBlockEntity)
-                    && signApplicator1.canApplyToSign(text, player)
-                    && signApplicator1.tryApplyToSign(level, signBlockEntity, isFacingFrontText, player)) {
+                } else if (flag && !this.otherPlayerIsEditingSign(player, tileentitysign) && signapplicator2.canApplyToSign(signtext, player) && signapplicator2.tryApplyToSign(level, tileentitysign, flag1, player)) {
                     if (!player.isCreative()) {
-                        itemInHand.shrink(1);
+                        itemstack.shrink(1);
                     }
 
-                    level.gameEvent(GameEvent.BLOCK_CHANGE, signBlockEntity.getBlockPos(), GameEvent.Context.of(player, signBlockEntity.getBlockState()));
+                    level.gameEvent(GameEvent.BLOCK_CHANGE, tileentitysign.getBlockPos(), GameEvent.Context.of(player, tileentitysign.getBlockState()));
                     player.awardStat(Stats.ITEM_USED.get(item));
                     return InteractionResult.SUCCESS;
-                } else if (flag1) {
+                } else if (flag2) {
                     return InteractionResult.SUCCESS;
-                } else if (!this.otherPlayerIsEditingSign(player, signBlockEntity)
-                    && player.mayBuild()
-                    && this.hasEditableText(player, signBlockEntity, isFacingFrontText)) {
-                    this.openTextEdit(player, signBlockEntity, isFacingFrontText);
+                } else if (!this.otherPlayerIsEditingSign(player, tileentitysign) && player.mayBuild() && this.hasEditableText(player, tileentitysign, flag1)) {
+                    this.openTextEdit(player, tileentitysign, flag1, org.bukkit.event.player.PlayerSignOpenEvent.Cause.INTERACT); // CraftBukkit
                     return this.getInteractionResult(flag);
                 } else {
                     return InteractionResult.PASS;
                 }
             } else {
-                return !flag && !signBlockEntity.isWaxed() ? InteractionResult.CONSUME : InteractionResult.SUCCESS;
+                return !flag && !tileentitysign.isWaxed() ? InteractionResult.CONSUME : InteractionResult.SUCCESS;
             }
         } else {
             return InteractionResult.PASS;
@@ -124,20 +136,22 @@
     }
 
     private boolean hasEditableText(Player player, SignBlockEntity signEntity, boolean isFrontText) {
-        SignText text = signEntity.getText(isFrontText);
-        return Arrays.stream(text.getMessages(player.isTextFilteringEnabled()))
-            .allMatch(line -> line.equals(CommonComponents.EMPTY) || line.getContents() instanceof PlainTextContents);
+        SignText signtext = signEntity.getText(isFrontText);
+
+        return Arrays.stream(signtext.getMessages(player.isTextFilteringEnabled())).allMatch((ichatbasecomponent) -> {
+            return ichatbasecomponent.equals(CommonComponents.EMPTY) || ichatbasecomponent.getContents() instanceof LiteralContents;
+        });
     }
 
-    public abstract float getYRotationDegrees(BlockState state);
+    public abstract float getYRotationDegrees(IBlockData state);
 
-    public Vec3 getSignHitboxCenterPosition(BlockState state) {
-        return new Vec3(0.5, 0.5, 0.5);
+    public Vec3 getSignHitboxCenterPosition(IBlockData state) {
+        return new Vec3(0.5D, 0.5D, 0.5D);
     }
 
     @Override
-    public FluidState getFluidState(BlockState state) {
-        return state.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);
+    public FluidState getFluidState(IBlockData state) {
+        return (Boolean) state.getValue(SignBlock.WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);
     }
 
     public WoodType type() {
@@ -145,29 +159,40 @@
     }
 
     public static WoodType getWoodType(Block block) {
-        WoodType woodType;
+        WoodType blockpropertywood;
+
         if (block instanceof SignBlock) {
-            woodType = ((SignBlock)block).type();
+            blockpropertywood = ((SignBlock) block).type();
         } else {
-            woodType = WoodType.OAK;
+            blockpropertywood = WoodType.OAK;
         }
 
-        return woodType;
+        return blockpropertywood;
     }
 
     public void openTextEdit(Player player, SignBlockEntity signEntity, boolean isFrontText) {
-        signEntity.setAllowedPlayerEditor(player.getUUID());
-        player.openTextEdit(signEntity, isFrontText);
+        // Craftbukkit start
+        openTextEdit(player, signEntity, isFrontText, org.bukkit.event.player.PlayerSignOpenEvent.Cause.UNKNOWN);
     }
 
+    public void openTextEdit(Player entityhuman, SignBlockEntity tileentitysign, boolean flag, org.bukkit.event.player.PlayerSignOpenEvent.Cause cause) {
+        if (!org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerSignOpenEvent(entityhuman, tileentitysign, flag, cause)) {
+            return;
+        }
+        // Craftbukkit end
+        tileentitysign.setAllowedPlayerEditor(entityhuman.getUUID());
+        entityhuman.openTextEdit(tileentitysign, flag);
+    }
+
     private boolean otherPlayerIsEditingSign(Player player, SignBlockEntity signEntity) {
-        UUID playerWhoMayEdit = signEntity.getPlayerWhoMayEdit();
-        return playerWhoMayEdit != null && !playerWhoMayEdit.equals(player.getUUID());
+        UUID uuid = signEntity.getPlayerWhoMayEdit();
+
+        return uuid != null && !uuid.equals(player.getUUID());
     }
 
     @Nullable
     @Override
-    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> blockEntityType) {
-        return createTickerHelper(blockEntityType, BlockEntityType.SIGN, SignBlockEntity::tick);
+    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, IBlockData state, BlockEntityType<T> blockEntityType) {
+        return null; // Craftbukkit - remove unnecessary sign ticking
     }
 }
