--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -3,17 +3,19 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.serialization.MapCodec;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
-import net.minecraft.core.particles.DustParticleOptions;
+import net.minecraft.core.particles.ParticleParamRedstone;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.context.BlockPlaceContext;
@@ -22,165 +24,147 @@
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.EnumProperty;
 import net.minecraft.world.level.block.state.properties.IntegerProperty;
+import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.block.state.properties.RedstoneSide;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
 public class RedStoneWireBlock extends Block {
+
     public static final MapCodec<RedStoneWireBlock> CODEC = simpleCodec(RedStoneWireBlock::new);
     public static final EnumProperty<RedstoneSide> NORTH = BlockStateProperties.NORTH_REDSTONE;
     public static final EnumProperty<RedstoneSide> EAST = BlockStateProperties.EAST_REDSTONE;
     public static final EnumProperty<RedstoneSide> SOUTH = BlockStateProperties.SOUTH_REDSTONE;
     public static final EnumProperty<RedstoneSide> WEST = BlockStateProperties.WEST_REDSTONE;
     public static final IntegerProperty POWER = BlockStateProperties.POWER;
-    public static final Map<Direction, EnumProperty<RedstoneSide>> PROPERTY_BY_DIRECTION = Maps.newEnumMap(
-        ImmutableMap.of(Direction.NORTH, NORTH, Direction.EAST, EAST, Direction.SOUTH, SOUTH, Direction.WEST, WEST)
-    );
+    public static final Map<Direction, EnumProperty<RedstoneSide>> PROPERTY_BY_DIRECTION = Maps.newEnumMap(ImmutableMap.of(Direction.NORTH, RedStoneWireBlock.NORTH, Direction.EAST, RedStoneWireBlock.EAST, Direction.SOUTH, RedStoneWireBlock.SOUTH, Direction.WEST, RedStoneWireBlock.WEST));
     protected static final int H = 1;
     protected static final int W = 3;
     protected static final int E = 13;
     protected static final int N = 3;
     protected static final int S = 13;
-    private static final VoxelShape SHAPE_DOT = Block.box(3.0, 0.0, 3.0, 13.0, 1.0, 13.0);
-    private static final Map<Direction, VoxelShape> SHAPES_FLOOR = Maps.newEnumMap(
-        ImmutableMap.of(
-            Direction.NORTH,
-            Block.box(3.0, 0.0, 0.0, 13.0, 1.0, 13.0),
-            Direction.SOUTH,
-            Block.box(3.0, 0.0, 3.0, 13.0, 1.0, 16.0),
-            Direction.EAST,
-            Block.box(3.0, 0.0, 3.0, 16.0, 1.0, 13.0),
-            Direction.WEST,
-            Block.box(0.0, 0.0, 3.0, 13.0, 1.0, 13.0)
-        )
-    );
-    private static final Map<Direction, VoxelShape> SHAPES_UP = Maps.newEnumMap(
-        ImmutableMap.of(
-            Direction.NORTH,
-            Shapes.or(SHAPES_FLOOR.get(Direction.NORTH), Block.box(3.0, 0.0, 0.0, 13.0, 16.0, 1.0)),
-            Direction.SOUTH,
-            Shapes.or(SHAPES_FLOOR.get(Direction.SOUTH), Block.box(3.0, 0.0, 15.0, 13.0, 16.0, 16.0)),
-            Direction.EAST,
-            Shapes.or(SHAPES_FLOOR.get(Direction.EAST), Block.box(15.0, 0.0, 3.0, 16.0, 16.0, 13.0)),
-            Direction.WEST,
-            Shapes.or(SHAPES_FLOOR.get(Direction.WEST), Block.box(0.0, 0.0, 3.0, 1.0, 16.0, 13.0))
-        )
-    );
-    private static final Map<BlockState, VoxelShape> SHAPES_CACHE = Maps.newHashMap();
-    private static final Vec3[] COLORS = Util.make(new Vec3[16], array -> {
-        for (int i = 0; i <= 15; i++) {
-            float f = (float)i / 15.0F;
+    private static final VoxelShape SHAPE_DOT = Block.box(3.0D, 0.0D, 3.0D, 13.0D, 1.0D, 13.0D);
+    private static final Map<Direction, VoxelShape> SHAPES_FLOOR = Maps.newEnumMap(ImmutableMap.of(Direction.NORTH, Block.box(3.0D, 0.0D, 0.0D, 13.0D, 1.0D, 13.0D), Direction.SOUTH, Block.box(3.0D, 0.0D, 3.0D, 13.0D, 1.0D, 16.0D), Direction.EAST, Block.box(3.0D, 0.0D, 3.0D, 16.0D, 1.0D, 13.0D), Direction.WEST, Block.box(0.0D, 0.0D, 3.0D, 13.0D, 1.0D, 13.0D)));
+    private static final Map<Direction, VoxelShape> SHAPES_UP = Maps.newEnumMap(ImmutableMap.of(Direction.NORTH, Shapes.or((VoxelShape) RedStoneWireBlock.SHAPES_FLOOR.get(Direction.NORTH), Block.box(3.0D, 0.0D, 0.0D, 13.0D, 16.0D, 1.0D)), Direction.SOUTH, Shapes.or((VoxelShape) RedStoneWireBlock.SHAPES_FLOOR.get(Direction.SOUTH), Block.box(3.0D, 0.0D, 15.0D, 13.0D, 16.0D, 16.0D)), Direction.EAST, Shapes.or((VoxelShape) RedStoneWireBlock.SHAPES_FLOOR.get(Direction.EAST), Block.box(15.0D, 0.0D, 3.0D, 16.0D, 16.0D, 13.0D)), Direction.WEST, Shapes.or((VoxelShape) RedStoneWireBlock.SHAPES_FLOOR.get(Direction.WEST), Block.box(0.0D, 0.0D, 3.0D, 1.0D, 16.0D, 13.0D))));
+    private static final Map<IBlockData, VoxelShape> SHAPES_CACHE = Maps.newHashMap();
+    private static final Vec3[] COLORS = (Vec3[]) Util.make(new Vec3[16], (avec3d) -> {
+        for (int i = 0; i <= 15; ++i) {
+            float f = (float) i / 15.0F;
             float f1 = f * 0.6F + (f > 0.0F ? 0.4F : 0.3F);
             float f2 = Mth.clamp(f * f * 0.7F - 0.5F, 0.0F, 1.0F);
             float f3 = Mth.clamp(f * f * 0.6F - 0.7F, 0.0F, 1.0F);
-            array[i] = new Vec3((double)f1, (double)f2, (double)f3);
+
+            avec3d[i] = new Vec3((double) f1, (double) f2, (double) f3);
         }
+
     });
     private static final float PARTICLE_DENSITY = 0.2F;
-    private final BlockState crossState;
+    private final IBlockData crossState;
     private boolean shouldSignal = true;
 
     @Override
     public MapCodec<RedStoneWireBlock> codec() {
-        return CODEC;
+        return RedStoneWireBlock.CODEC;
     }
 
     public RedStoneWireBlock(BlockBehaviour.Properties properties) {
         super(properties);
-        this.registerDefaultState(
-            this.stateDefinition
-                .any()
-                .setValue(NORTH, RedstoneSide.NONE)
-                .setValue(EAST, RedstoneSide.NONE)
-                .setValue(SOUTH, RedstoneSide.NONE)
-                .setValue(WEST, RedstoneSide.NONE)
-                .setValue(POWER, Integer.valueOf(0))
-        );
-        this.crossState = this.defaultBlockState()
-            .setValue(NORTH, RedstoneSide.SIDE)
-            .setValue(EAST, RedstoneSide.SIDE)
-            .setValue(SOUTH, RedstoneSide.SIDE)
-            .setValue(WEST, RedstoneSide.SIDE);
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(RedStoneWireBlock.NORTH, RedstoneSide.NONE)).setValue(RedStoneWireBlock.EAST, RedstoneSide.NONE)).setValue(RedStoneWireBlock.SOUTH, RedstoneSide.NONE)).setValue(RedStoneWireBlock.WEST, RedstoneSide.NONE)).setValue(RedStoneWireBlock.POWER, 0));
+        this.crossState = (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) this.defaultBlockState().setValue(RedStoneWireBlock.NORTH, RedstoneSide.SIDE)).setValue(RedStoneWireBlock.EAST, RedstoneSide.SIDE)).setValue(RedStoneWireBlock.SOUTH, RedstoneSide.SIDE)).setValue(RedStoneWireBlock.WEST, RedstoneSide.SIDE);
+        UnmodifiableIterator unmodifiableiterator = this.getStateDefinition().getPossibleStates().iterator();
 
-        for (BlockState blockState : this.getStateDefinition().getPossibleStates()) {
-            if (blockState.getValue(POWER) == 0) {
-                SHAPES_CACHE.put(blockState, this.calculateShape(blockState));
+        while (unmodifiableiterator.hasNext()) {
+            IBlockData iblockdata = (IBlockData) unmodifiableiterator.next();
+
+            if ((Integer) iblockdata.getValue(RedStoneWireBlock.POWER) == 0) {
+                RedStoneWireBlock.SHAPES_CACHE.put(iblockdata, this.calculateShape(iblockdata));
             }
         }
+
     }
 
-    private VoxelShape calculateShape(BlockState state) {
-        VoxelShape voxelShape = SHAPE_DOT;
+    private VoxelShape calculateShape(IBlockData state) {
+        VoxelShape voxelshape = RedStoneWireBlock.SHAPE_DOT;
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            RedstoneSide redstoneSide = state.getValue(PROPERTY_BY_DIRECTION.get(direction));
-            if (redstoneSide == RedstoneSide.SIDE) {
-                voxelShape = Shapes.or(voxelShape, SHAPES_FLOOR.get(direction));
-            } else if (redstoneSide == RedstoneSide.UP) {
-                voxelShape = Shapes.or(voxelShape, SHAPES_UP.get(direction));
+        while (iterator.hasNext()) {
+            Direction enumdirection = (Direction) iterator.next();
+            RedstoneSide blockpropertyredstoneside = (RedstoneSide) state.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection));
+
+            if (blockpropertyredstoneside == RedstoneSide.SIDE) {
+                voxelshape = Shapes.or(voxelshape, (VoxelShape) RedStoneWireBlock.SHAPES_FLOOR.get(enumdirection));
+            } else if (blockpropertyredstoneside == RedstoneSide.UP) {
+                voxelshape = Shapes.or(voxelshape, (VoxelShape) RedStoneWireBlock.SHAPES_UP.get(enumdirection));
             }
         }
 
-        return voxelShape;
+        return voxelshape;
     }
 
     @Override
-    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
-        return SHAPES_CACHE.get(state.setValue(POWER, Integer.valueOf(0)));
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        return (VoxelShape) RedStoneWireBlock.SHAPES_CACHE.get(state.setValue(RedStoneWireBlock.POWER, 0));
     }
 
     @Override
-    public BlockState getStateForPlacement(BlockPlaceContext context) {
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
         return this.getConnectionState(context.getLevel(), this.crossState, context.getClickedPos());
     }
 
-    private BlockState getConnectionState(BlockGetter level, BlockState state, BlockPos pos) {
-        boolean isDot = isDot(state);
-        BlockState var11 = this.getMissingConnections(level, this.defaultBlockState().setValue(POWER, state.getValue(POWER)), pos);
-        if (isDot && isDot(var11)) {
-            return var11;
+    private IBlockData getConnectionState(BlockGetter level, IBlockData state, BlockPos pos) {
+        boolean flag = isDot(state);
+
+        state = this.getMissingConnections(level, (IBlockData) this.defaultBlockState().setValue(RedStoneWireBlock.POWER, (Integer) state.getValue(RedStoneWireBlock.POWER)), pos);
+        if (flag && isDot(state)) {
+            return state;
         } else {
-            boolean isConnected = var11.getValue(NORTH).isConnected();
-            boolean isConnected1 = var11.getValue(SOUTH).isConnected();
-            boolean isConnected2 = var11.getValue(EAST).isConnected();
-            boolean isConnected3 = var11.getValue(WEST).isConnected();
-            boolean flag = !isConnected && !isConnected1;
-            boolean flag1 = !isConnected2 && !isConnected3;
-            if (!isConnected3 && flag) {
-                var11 = var11.setValue(WEST, RedstoneSide.SIDE);
+            boolean flag1 = ((RedstoneSide) state.getValue(RedStoneWireBlock.NORTH)).isConnected();
+            boolean flag2 = ((RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH)).isConnected();
+            boolean flag3 = ((RedstoneSide) state.getValue(RedStoneWireBlock.EAST)).isConnected();
+            boolean flag4 = ((RedstoneSide) state.getValue(RedStoneWireBlock.WEST)).isConnected();
+            boolean flag5 = !flag1 && !flag2;
+            boolean flag6 = !flag3 && !flag4;
+
+            if (!flag4 && flag5) {
+                state = (IBlockData) state.setValue(RedStoneWireBlock.WEST, RedstoneSide.SIDE);
             }
 
-            if (!isConnected2 && flag) {
-                var11 = var11.setValue(EAST, RedstoneSide.SIDE);
+            if (!flag3 && flag5) {
+                state = (IBlockData) state.setValue(RedStoneWireBlock.EAST, RedstoneSide.SIDE);
             }
 
-            if (!isConnected && flag1) {
-                var11 = var11.setValue(NORTH, RedstoneSide.SIDE);
+            if (!flag1 && flag6) {
+                state = (IBlockData) state.setValue(RedStoneWireBlock.NORTH, RedstoneSide.SIDE);
             }
 
-            if (!isConnected1 && flag1) {
-                var11 = var11.setValue(SOUTH, RedstoneSide.SIDE);
+            if (!flag2 && flag6) {
+                state = (IBlockData) state.setValue(RedStoneWireBlock.SOUTH, RedstoneSide.SIDE);
             }
 
-            return var11;
+            return state;
         }
     }
 
-    private BlockState getMissingConnections(BlockGetter level, BlockState state, BlockPos pos) {
+    private IBlockData getMissingConnections(BlockGetter level, IBlockData state, BlockPos pos) {
         boolean flag = !level.getBlockState(pos.above()).isRedstoneConductor(level, pos);
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            if (!state.getValue(PROPERTY_BY_DIRECTION.get(direction)).isConnected()) {
-                RedstoneSide connectingSide = this.getConnectingSide(level, pos, direction, flag);
-                state = state.setValue(PROPERTY_BY_DIRECTION.get(direction), connectingSide);
+        while (iterator.hasNext()) {
+            Direction enumdirection = (Direction) iterator.next();
+
+            if (!((RedstoneSide) state.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection))).isConnected()) {
+                RedstoneSide blockpropertyredstoneside = this.getConnectingSide(level, pos, enumdirection, flag);
+
+                state = (IBlockData) state.setValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection), blockpropertyredstoneside);
             }
         }
 
@@ -188,57 +172,56 @@
     }
 
     @Override
-    public BlockState updateShape(BlockState state, Direction facing, BlockState facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
         if (facing == Direction.DOWN) {
             return !this.canSurviveOn(level, facingPos, facingState) ? Blocks.AIR.defaultBlockState() : state;
         } else if (facing == Direction.UP) {
             return this.getConnectionState(level, state, currentPos);
         } else {
-            RedstoneSide connectingSide = this.getConnectingSide(level, currentPos, facing);
-            return connectingSide.isConnected() == state.getValue(PROPERTY_BY_DIRECTION.get(facing)).isConnected() && !isCross(state)
-                ? state.setValue(PROPERTY_BY_DIRECTION.get(facing), connectingSide)
-                : this.getConnectionState(
-                    level, this.crossState.setValue(POWER, state.getValue(POWER)).setValue(PROPERTY_BY_DIRECTION.get(facing), connectingSide), currentPos
-                );
+            RedstoneSide blockpropertyredstoneside = this.getConnectingSide(level, currentPos, facing);
+
+            return blockpropertyredstoneside.isConnected() == ((RedstoneSide) state.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(facing))).isConnected() && !isCross(state) ? (IBlockData) state.setValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(facing), blockpropertyredstoneside) : this.getConnectionState(level, (IBlockData) ((IBlockData) this.crossState.setValue(RedStoneWireBlock.POWER, (Integer) state.getValue(RedStoneWireBlock.POWER))).setValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(facing), blockpropertyredstoneside), currentPos);
         }
     }
 
-    private static boolean isCross(BlockState state) {
-        return state.getValue(NORTH).isConnected()
-            && state.getValue(SOUTH).isConnected()
-            && state.getValue(EAST).isConnected()
-            && state.getValue(WEST).isConnected();
+    private static boolean isCross(IBlockData state) {
+        return ((RedstoneSide) state.getValue(RedStoneWireBlock.NORTH)).isConnected() && ((RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH)).isConnected() && ((RedstoneSide) state.getValue(RedStoneWireBlock.EAST)).isConnected() && ((RedstoneSide) state.getValue(RedStoneWireBlock.WEST)).isConnected();
     }
 
-    private static boolean isDot(BlockState state) {
-        return !state.getValue(NORTH).isConnected()
-            && !state.getValue(SOUTH).isConnected()
-            && !state.getValue(EAST).isConnected()
-            && !state.getValue(WEST).isConnected();
+    private static boolean isDot(IBlockData state) {
+        return !((RedstoneSide) state.getValue(RedStoneWireBlock.NORTH)).isConnected() && !((RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH)).isConnected() && !((RedstoneSide) state.getValue(RedStoneWireBlock.EAST)).isConnected() && !((RedstoneSide) state.getValue(RedStoneWireBlock.WEST)).isConnected();
     }
 
     @Override
-    public void updateIndirectNeighbourShapes(BlockState state, LevelAccessor level, BlockPos pos, int flags, int recursionLeft) {
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
+    public void updateIndirectNeighbourShapes(IBlockData state, LevelAccessor level, BlockPos pos, int flags, int recursionLeft) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            RedstoneSide redstoneSide = state.getValue(PROPERTY_BY_DIRECTION.get(direction));
-            if (redstoneSide != RedstoneSide.NONE && !level.getBlockState(mutableBlockPos.setWithOffset(pos, direction)).is(this)) {
-                mutableBlockPos.move(Direction.DOWN);
-                BlockState blockState = level.getBlockState(mutableBlockPos);
-                if (blockState.is(this)) {
-                    BlockPos blockPos = mutableBlockPos.relative(direction.getOpposite());
-                    level.neighborShapeChanged(direction.getOpposite(), level.getBlockState(blockPos), mutableBlockPos, blockPos, flags, recursionLeft);
+        while (iterator.hasNext()) {
+            Direction enumdirection = (Direction) iterator.next();
+            RedstoneSide blockpropertyredstoneside = (RedstoneSide) state.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection));
+
+            if (blockpropertyredstoneside != RedstoneSide.NONE && !level.getBlockState(blockposition_mutableblockposition.setWithOffset(pos, enumdirection)).is((Block) this)) {
+                blockposition_mutableblockposition.move(Direction.DOWN);
+                IBlockData iblockdata1 = level.getBlockState(blockposition_mutableblockposition);
+
+                if (iblockdata1.is((Block) this)) {
+                    BlockPos blockposition1 = blockposition_mutableblockposition.relative(enumdirection.getOpposite());
+
+                    level.neighborShapeChanged(enumdirection.getOpposite(), level.getBlockState(blockposition1), blockposition_mutableblockposition, blockposition1, flags, recursionLeft);
                 }
 
-                mutableBlockPos.setWithOffset(pos, direction).move(Direction.UP);
-                BlockState blockState1 = level.getBlockState(mutableBlockPos);
-                if (blockState1.is(this)) {
-                    BlockPos blockPos1 = mutableBlockPos.relative(direction.getOpposite());
-                    level.neighborShapeChanged(direction.getOpposite(), level.getBlockState(blockPos1), mutableBlockPos, blockPos1, flags, recursionLeft);
+                blockposition_mutableblockposition.setWithOffset(pos, enumdirection).move(Direction.UP);
+                IBlockData iblockdata2 = level.getBlockState(blockposition_mutableblockposition);
+
+                if (iblockdata2.is((Block) this)) {
+                    BlockPos blockposition2 = blockposition_mutableblockposition.relative(enumdirection.getOpposite());
+
+                    level.neighborShapeChanged(enumdirection.getOpposite(), level.getBlockState(blockposition2), blockposition_mutableblockposition, blockposition2, flags, recursionLeft);
                 }
             }
         }
+
     }
 
     private RedstoneSide getConnectingSide(BlockGetter level, BlockPos pos, Direction face) {
@@ -246,12 +229,14 @@
     }
 
     private RedstoneSide getConnectingSide(BlockGetter level, BlockPos pos, Direction direction, boolean nonNormalCubeAbove) {
-        BlockPos blockPos = pos.relative(direction);
-        BlockState blockState = level.getBlockState(blockPos);
+        BlockPos blockposition1 = pos.relative(direction);
+        IBlockData iblockdata = level.getBlockState(blockposition1);
+
         if (nonNormalCubeAbove) {
-            boolean flag = blockState.getBlock() instanceof TrapDoorBlock || this.canSurviveOn(level, blockPos, blockState);
-            if (flag && shouldConnectTo(level.getBlockState(blockPos.above()))) {
-                if (blockState.isFaceSturdy(level, blockPos, direction.getOpposite())) {
+            boolean flag1 = iblockdata.getBlock() instanceof TrapDoorBlock || this.canSurviveOn(level, blockposition1, iblockdata);
+
+            if (flag1 && shouldConnectTo(level.getBlockState(blockposition1.above()))) {
+                if (iblockdata.isFaceSturdy(level, blockposition1, direction.getOpposite())) {
                     return RedstoneSide.UP;
                 }
 
@@ -259,86 +244,119 @@
             }
         }
 
-        return !shouldConnectTo(blockState, direction)
-                && (blockState.isRedstoneConductor(level, blockPos) || !shouldConnectTo(level.getBlockState(blockPos.below())))
-            ? RedstoneSide.NONE
-            : RedstoneSide.SIDE;
+        return !shouldConnectTo(iblockdata, direction) && (iblockdata.isRedstoneConductor(level, blockposition1) || !shouldConnectTo(level.getBlockState(blockposition1.below()))) ? RedstoneSide.NONE : RedstoneSide.SIDE;
     }
 
     @Override
-    public boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
-        BlockPos blockPos = pos.below();
-        BlockState blockState = level.getBlockState(blockPos);
-        return this.canSurviveOn(level, blockPos, blockState);
+    public boolean canSurvive(IBlockData state, LevelReader level, BlockPos pos) {
+        BlockPos blockposition1 = pos.below();
+        IBlockData iblockdata1 = level.getBlockState(blockposition1);
+
+        return this.canSurviveOn(level, blockposition1, iblockdata1);
     }
 
-    private boolean canSurviveOn(BlockGetter level, BlockPos pos, BlockState state) {
+    private boolean canSurviveOn(BlockGetter level, BlockPos pos, IBlockData state) {
         return state.isFaceSturdy(level, pos, Direction.UP) || state.is(Blocks.HOPPER);
     }
 
-    private void updatePowerStrength(Level level, BlockPos pos, BlockState state) {
+    private void updatePowerStrength(Level level, BlockPos pos, IBlockData state) {
         int i = this.calculateTargetStrength(level, pos);
-        if (state.getValue(POWER) != i) {
+
+        // CraftBukkit start
+        int oldPower = (Integer) state.getValue(RedStoneWireBlock.POWER);
+        if (oldPower != i) {
+            BlockRedstoneEvent event = new BlockRedstoneEvent(level.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()), oldPower, i);
+            level.getCraftServer().getPluginManager().callEvent(event);
+
+            i = event.getNewCurrent();
+        }
+        if (oldPower != i) {
+            // CraftBukkit end
             if (level.getBlockState(pos) == state) {
-                level.setBlock(pos, state.setValue(POWER, Integer.valueOf(i)), 2);
+                level.setBlock(pos, (IBlockData) state.setValue(RedStoneWireBlock.POWER, i), 2);
             }
 
             Set<BlockPos> set = Sets.newHashSet();
+
             set.add(pos);
+            Direction[] aenumdirection = Direction.values();
+            int j = aenumdirection.length;
 
-            for (Direction direction : Direction.values()) {
-                set.add(pos.relative(direction));
+            for (int k = 0; k < j; ++k) {
+                Direction enumdirection = aenumdirection[k];
+
+                set.add(pos.relative(enumdirection));
             }
 
-            for (BlockPos blockPos : set) {
-                level.updateNeighborsAt(blockPos, this);
+            Iterator iterator = set.iterator();
+
+            while (iterator.hasNext()) {
+                BlockPos blockposition1 = (BlockPos) iterator.next();
+
+                level.updateNeighborsAt(blockposition1, this);
             }
         }
+
     }
 
     private int calculateTargetStrength(Level level, BlockPos pos) {
         this.shouldSignal = false;
-        int bestNeighborSignal = level.getBestNeighborSignal(pos);
+        int i = level.getBestNeighborSignal(pos);
+
         this.shouldSignal = true;
-        int i = 0;
-        if (bestNeighborSignal < 15) {
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
-                BlockPos blockPos = pos.relative(direction);
-                BlockState blockState = level.getBlockState(blockPos);
-                i = Math.max(i, this.getWireSignal(blockState));
-                BlockPos blockPos1 = pos.above();
-                if (blockState.isRedstoneConductor(level, blockPos) && !level.getBlockState(blockPos1).isRedstoneConductor(level, blockPos1)) {
-                    i = Math.max(i, this.getWireSignal(level.getBlockState(blockPos.above())));
-                } else if (!blockState.isRedstoneConductor(level, blockPos)) {
-                    i = Math.max(i, this.getWireSignal(level.getBlockState(blockPos.below())));
+        int j = 0;
+
+        if (i < 15) {
+            Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                Direction enumdirection = (Direction) iterator.next();
+                BlockPos blockposition1 = pos.relative(enumdirection);
+                IBlockData iblockdata = level.getBlockState(blockposition1);
+
+                j = Math.max(j, this.getWireSignal(iblockdata));
+                BlockPos blockposition2 = pos.above();
+
+                if (iblockdata.isRedstoneConductor(level, blockposition1) && !level.getBlockState(blockposition2).isRedstoneConductor(level, blockposition2)) {
+                    j = Math.max(j, this.getWireSignal(level.getBlockState(blockposition1.above())));
+                } else if (!iblockdata.isRedstoneConductor(level, blockposition1)) {
+                    j = Math.max(j, this.getWireSignal(level.getBlockState(blockposition1.below())));
                 }
             }
         }
 
-        return Math.max(bestNeighborSignal, i - 1);
+        return Math.max(i, j - 1);
     }
 
-    private int getWireSignal(BlockState state) {
-        return state.is(this) ? state.getValue(POWER) : 0;
+    private int getWireSignal(IBlockData state) {
+        return state.is((Block) this) ? (Integer) state.getValue(RedStoneWireBlock.POWER) : 0;
     }
 
     private void checkCornerChangeAt(Level level, BlockPos pos) {
-        if (level.getBlockState(pos).is(this)) {
+        if (level.getBlockState(pos).is((Block) this)) {
             level.updateNeighborsAt(pos, this);
+            Direction[] aenumdirection = Direction.values();
+            int i = aenumdirection.length;
 
-            for (Direction direction : Direction.values()) {
-                level.updateNeighborsAt(pos.relative(direction), this);
+            for (int j = 0; j < i; ++j) {
+                Direction enumdirection = aenumdirection[j];
+
+                level.updateNeighborsAt(pos.relative(enumdirection), this);
             }
+
         }
     }
 
     @Override
-    public void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean isMoving) {
+    public void onPlace(IBlockData state, Level level, BlockPos pos, IBlockData oldState, boolean isMoving) {
         if (!oldState.is(state.getBlock()) && !level.isClientSide) {
             this.updatePowerStrength(level, pos, state);
+            Iterator iterator = Direction.Plane.VERTICAL.iterator();
 
-            for (Direction direction : Direction.Plane.VERTICAL) {
-                level.updateNeighborsAt(pos.relative(direction), this);
+            while (iterator.hasNext()) {
+                Direction enumdirection = (Direction) iterator.next();
+
+                level.updateNeighborsAt(pos.relative(enumdirection), this);
             }
 
             this.updateNeighborsOfNeighboringWires(level, pos);
@@ -346,12 +364,17 @@
     }
 
     @Override
-    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
+    public void onRemove(IBlockData state, Level level, BlockPos pos, IBlockData newState, boolean isMoving) {
         if (!isMoving && !state.is(newState.getBlock())) {
             super.onRemove(state, level, pos, newState, isMoving);
             if (!level.isClientSide) {
-                for (Direction direction : Direction.values()) {
-                    level.updateNeighborsAt(pos.relative(direction), this);
+                Direction[] aenumdirection = Direction.values();
+                int i = aenumdirection.length;
+
+                for (int j = 0; j < i; ++j) {
+                    Direction enumdirection = aenumdirection[j];
+
+                    level.updateNeighborsAt(pos.relative(enumdirection), this);
                 }
 
                 this.updatePowerStrength(level, pos, state);
@@ -361,22 +384,32 @@
     }
 
     private void updateNeighborsOfNeighboringWires(Level level, BlockPos pos) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            this.checkCornerChangeAt(level, pos.relative(direction));
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
+
+        Direction enumdirection;
+
+        while (iterator.hasNext()) {
+            enumdirection = (Direction) iterator.next();
+            this.checkCornerChangeAt(level, pos.relative(enumdirection));
         }
 
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            BlockPos blockPos = pos.relative(direction);
-            if (level.getBlockState(blockPos).isRedstoneConductor(level, blockPos)) {
-                this.checkCornerChangeAt(level, blockPos.above());
+        iterator = Direction.Plane.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            enumdirection = (Direction) iterator.next();
+            BlockPos blockposition1 = pos.relative(enumdirection);
+
+            if (level.getBlockState(blockposition1).isRedstoneConductor(level, blockposition1)) {
+                this.checkCornerChangeAt(level, blockposition1.above());
             } else {
-                this.checkCornerChangeAt(level, blockPos.below());
+                this.checkCornerChangeAt(level, blockposition1.below());
             }
         }
+
     }
 
     @Override
-    public void neighborChanged(BlockState state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
+    public void neighborChanged(IBlockData state, Level level, BlockPos pos, Block block, BlockPos fromPos, boolean isMoving) {
         if (!level.isClientSide) {
             if (state.canSurvive(level, pos)) {
                 this.updatePowerStrength(level, pos, state);
@@ -384,150 +417,137 @@
                 dropResources(state, level, pos);
                 level.removeBlock(pos, false);
             }
+
         }
     }
 
     @Override
-    public int getDirectSignal(BlockState blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
+    public int getDirectSignal(IBlockData blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
         return !this.shouldSignal ? 0 : blockState.getSignal(blockAccess, pos, side);
     }
 
     @Override
-    public int getSignal(BlockState blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
+    public int getSignal(IBlockData blockState, BlockGetter blockAccess, BlockPos pos, Direction side) {
         if (this.shouldSignal && side != Direction.DOWN) {
-            int i = blockState.getValue(POWER);
-            if (i == 0) {
-                return 0;
-            } else {
-                return side != Direction.UP
-                        && !this.getConnectionState(blockAccess, blockState, pos).getValue(PROPERTY_BY_DIRECTION.get(side.getOpposite())).isConnected()
-                    ? 0
-                    : i;
-            }
+            int i = (Integer) blockState.getValue(RedStoneWireBlock.POWER);
+
+            return i == 0 ? 0 : (side != Direction.UP && !((RedstoneSide) this.getConnectionState(blockAccess, blockState, pos).getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(side.getOpposite()))).isConnected() ? 0 : i);
         } else {
             return 0;
         }
     }
 
-    protected static boolean shouldConnectTo(BlockState state) {
-        return shouldConnectTo(state, null);
+    protected static boolean shouldConnectTo(IBlockData state) {
+        return shouldConnectTo(state, (Direction) null);
     }
 
-    protected static boolean shouldConnectTo(BlockState state, @Nullable Direction direction) {
+    protected static boolean shouldConnectTo(IBlockData state, @Nullable Direction direction) {
         if (state.is(Blocks.REDSTONE_WIRE)) {
             return true;
         } else if (state.is(Blocks.REPEATER)) {
-            Direction direction1 = state.getValue(RepeaterBlock.FACING);
-            return direction1 == direction || direction1.getOpposite() == direction;
+            Direction enumdirection1 = (Direction) state.getValue(RepeaterBlock.FACING);
+
+            return enumdirection1 == direction || enumdirection1.getOpposite() == direction;
         } else {
             return state.is(Blocks.OBSERVER) ? direction == state.getValue(ObserverBlock.FACING) : state.isSignalSource() && direction != null;
         }
     }
 
     @Override
-    public boolean isSignalSource(BlockState state) {
+    public boolean isSignalSource(IBlockData state) {
         return this.shouldSignal;
     }
 
     public static int getColorForPower(int power) {
-        Vec3 vec3 = COLORS[power];
-        return Mth.color((float)vec3.x(), (float)vec3.y(), (float)vec3.z());
+        Vec3 vec3d = RedStoneWireBlock.COLORS[power];
+
+        return Mth.color((float) vec3d.x(), (float) vec3d.y(), (float) vec3d.z());
     }
 
-    private void spawnParticlesAlongLine(
-        Level level, RandomSource random, BlockPos pos, Vec3 particleVec, Direction xDirection, Direction zDirection, float min, float max
-    ) {
-        float f = max - min;
-        if (!(random.nextFloat() >= 0.2F * f)) {
-            float f1 = 0.4375F;
-            float f2 = min + f * random.nextFloat();
-            double d = 0.5 + (double)(0.4375F * (float)xDirection.getStepX()) + (double)(f2 * (float)zDirection.getStepX());
-            double d1 = 0.5 + (double)(0.4375F * (float)xDirection.getStepY()) + (double)(f2 * (float)zDirection.getStepY());
-            double d2 = 0.5 + (double)(0.4375F * (float)xDirection.getStepZ()) + (double)(f2 * (float)zDirection.getStepZ());
-            level.addParticle(
-                new DustParticleOptions(particleVec.toVector3f(), 1.0F),
-                (double)pos.getX() + d,
-                (double)pos.getY() + d1,
-                (double)pos.getZ() + d2,
-                0.0,
-                0.0,
-                0.0
-            );
+    private void spawnParticlesAlongLine(Level level, RandomSource random, BlockPos pos, Vec3 particleVec, Direction xDirection, Direction zDirection, float min, float max) {
+        float f2 = max - min;
+
+        if (random.nextFloat() < 0.2F * f2) {
+            float f3 = 0.4375F;
+            float f4 = min + f2 * random.nextFloat();
+            double d0 = 0.5D + (double) (0.4375F * (float) xDirection.getStepX()) + (double) (f4 * (float) zDirection.getStepX());
+            double d1 = 0.5D + (double) (0.4375F * (float) xDirection.getStepY()) + (double) (f4 * (float) zDirection.getStepY());
+            double d2 = 0.5D + (double) (0.4375F * (float) xDirection.getStepZ()) + (double) (f4 * (float) zDirection.getStepZ());
+
+            level.addParticle(new ParticleParamRedstone(particleVec.toVector3f(), 1.0F), (double) pos.getX() + d0, (double) pos.getY() + d1, (double) pos.getZ() + d2, 0.0D, 0.0D, 0.0D);
         }
     }
 
     @Override
-    public void animateTick(BlockState state, Level level, BlockPos pos, RandomSource random) {
-        int i = state.getValue(POWER);
+    public void animateTick(IBlockData state, Level level, BlockPos pos, RandomSource random) {
+        int i = (Integer) state.getValue(RedStoneWireBlock.POWER);
+
         if (i != 0) {
-            for (Direction direction : Direction.Plane.HORIZONTAL) {
-                RedstoneSide redstoneSide = state.getValue(PROPERTY_BY_DIRECTION.get(direction));
-                switch (redstoneSide) {
+            Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                Direction enumdirection = (Direction) iterator.next();
+                RedstoneSide blockpropertyredstoneside = (RedstoneSide) state.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection));
+
+                switch (blockpropertyredstoneside) {
                     case UP:
-                        this.spawnParticlesAlongLine(level, random, pos, COLORS[i], direction, Direction.UP, -0.5F, 0.5F);
+                        this.spawnParticlesAlongLine(level, random, pos, RedStoneWireBlock.COLORS[i], enumdirection, Direction.UP, -0.5F, 0.5F);
                     case SIDE:
-                        this.spawnParticlesAlongLine(level, random, pos, COLORS[i], Direction.DOWN, direction, 0.0F, 0.5F);
+                        this.spawnParticlesAlongLine(level, random, pos, RedStoneWireBlock.COLORS[i], Direction.DOWN, enumdirection, 0.0F, 0.5F);
                         break;
                     case NONE:
                     default:
-                        this.spawnParticlesAlongLine(level, random, pos, COLORS[i], Direction.DOWN, direction, 0.0F, 0.3F);
+                        this.spawnParticlesAlongLine(level, random, pos, RedStoneWireBlock.COLORS[i], Direction.DOWN, enumdirection, 0.0F, 0.3F);
                 }
             }
+
         }
     }
 
     @Override
-    public BlockState rotate(BlockState state, Rotation rotation) {
+    public IBlockData rotate(IBlockData state, Rotation rotation) {
         switch (rotation) {
             case CLOCKWISE_180:
-                return state.setValue(NORTH, state.getValue(SOUTH))
-                    .setValue(EAST, state.getValue(WEST))
-                    .setValue(SOUTH, state.getValue(NORTH))
-                    .setValue(WEST, state.getValue(EAST));
+                return (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) state.setValue(RedStoneWireBlock.NORTH, (RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH))).setValue(RedStoneWireBlock.EAST, (RedstoneSide) state.getValue(RedStoneWireBlock.WEST))).setValue(RedStoneWireBlock.SOUTH, (RedstoneSide) state.getValue(RedStoneWireBlock.NORTH))).setValue(RedStoneWireBlock.WEST, (RedstoneSide) state.getValue(RedStoneWireBlock.EAST));
             case COUNTERCLOCKWISE_90:
-                return state.setValue(NORTH, state.getValue(EAST))
-                    .setValue(EAST, state.getValue(SOUTH))
-                    .setValue(SOUTH, state.getValue(WEST))
-                    .setValue(WEST, state.getValue(NORTH));
+                return (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) state.setValue(RedStoneWireBlock.NORTH, (RedstoneSide) state.getValue(RedStoneWireBlock.EAST))).setValue(RedStoneWireBlock.EAST, (RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH))).setValue(RedStoneWireBlock.SOUTH, (RedstoneSide) state.getValue(RedStoneWireBlock.WEST))).setValue(RedStoneWireBlock.WEST, (RedstoneSide) state.getValue(RedStoneWireBlock.NORTH));
             case CLOCKWISE_90:
-                return state.setValue(NORTH, state.getValue(WEST))
-                    .setValue(EAST, state.getValue(NORTH))
-                    .setValue(SOUTH, state.getValue(EAST))
-                    .setValue(WEST, state.getValue(SOUTH));
+                return (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) state.setValue(RedStoneWireBlock.NORTH, (RedstoneSide) state.getValue(RedStoneWireBlock.WEST))).setValue(RedStoneWireBlock.EAST, (RedstoneSide) state.getValue(RedStoneWireBlock.NORTH))).setValue(RedStoneWireBlock.SOUTH, (RedstoneSide) state.getValue(RedStoneWireBlock.EAST))).setValue(RedStoneWireBlock.WEST, (RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH));
             default:
                 return state;
         }
     }
 
     @Override
-    public BlockState mirror(BlockState state, Mirror mirror) {
+    public IBlockData mirror(IBlockData state, Mirror mirror) {
         switch (mirror) {
             case LEFT_RIGHT:
-                return state.setValue(NORTH, state.getValue(SOUTH)).setValue(SOUTH, state.getValue(NORTH));
+                return (IBlockData) ((IBlockData) state.setValue(RedStoneWireBlock.NORTH, (RedstoneSide) state.getValue(RedStoneWireBlock.SOUTH))).setValue(RedStoneWireBlock.SOUTH, (RedstoneSide) state.getValue(RedStoneWireBlock.NORTH));
             case FRONT_BACK:
-                return state.setValue(EAST, state.getValue(WEST)).setValue(WEST, state.getValue(EAST));
+                return (IBlockData) ((IBlockData) state.setValue(RedStoneWireBlock.EAST, (RedstoneSide) state.getValue(RedStoneWireBlock.WEST))).setValue(RedStoneWireBlock.WEST, (RedstoneSide) state.getValue(RedStoneWireBlock.EAST));
             default:
                 return super.mirror(state, mirror);
         }
     }
 
     @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
-        builder.add(NORTH, EAST, SOUTH, WEST, POWER);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(RedStoneWireBlock.NORTH, RedStoneWireBlock.EAST, RedStoneWireBlock.SOUTH, RedStoneWireBlock.WEST, RedStoneWireBlock.POWER);
     }
 
     @Override
-    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) {
+    public InteractionResult use(IBlockData state, Level level, BlockPos pos, Player player, EnumHand hand, BlockHitResult hit) {
         if (!player.getAbilities().mayBuild) {
             return InteractionResult.PASS;
         } else {
             if (isCross(state) || isDot(state)) {
-                BlockState blockState = isCross(state) ? this.defaultBlockState() : this.crossState;
-                blockState = blockState.setValue(POWER, state.getValue(POWER));
-                BlockState var9 = this.getConnectionState(level, blockState, pos);
-                if (var9 != state) {
-                    level.setBlock(pos, var9, 3);
-                    this.updatesOnShapeChange(level, pos, state, var9);
+                IBlockData iblockdata1 = isCross(state) ? this.defaultBlockState() : this.crossState;
+
+                iblockdata1 = (IBlockData) iblockdata1.setValue(RedStoneWireBlock.POWER, (Integer) state.getValue(RedStoneWireBlock.POWER));
+                iblockdata1 = this.getConnectionState(level, iblockdata1, pos);
+                if (iblockdata1 != state) {
+                    level.setBlock(pos, iblockdata1, 3);
+                    this.updatesOnShapeChange(level, pos, state, iblockdata1);
                     return InteractionResult.SUCCESS;
                 }
             }
@@ -536,13 +556,17 @@
         }
     }
 
-    private void updatesOnShapeChange(Level level, BlockPos pos, BlockState oldState, BlockState newState) {
-        for (Direction direction : Direction.Plane.HORIZONTAL) {
-            BlockPos blockPos = pos.relative(direction);
-            if (oldState.getValue(PROPERTY_BY_DIRECTION.get(direction)).isConnected() != newState.getValue(PROPERTY_BY_DIRECTION.get(direction)).isConnected()
-                && level.getBlockState(blockPos).isRedstoneConductor(level, blockPos)) {
-                level.updateNeighborsAtExceptFromFacing(blockPos, newState.getBlock(), direction.getOpposite());
+    private void updatesOnShapeChange(Level level, BlockPos pos, IBlockData oldState, IBlockData newState) {
+        Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            Direction enumdirection = (Direction) iterator.next();
+            BlockPos blockposition1 = pos.relative(enumdirection);
+
+            if (((RedstoneSide) oldState.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection))).isConnected() != ((RedstoneSide) newState.getValue((Property) RedStoneWireBlock.PROPERTY_BY_DIRECTION.get(enumdirection))).isConnected() && level.getBlockState(blockposition1).isRedstoneConductor(level, blockposition1)) {
+                level.updateNeighborsAtExceptFromFacing(blockposition1, newState.getBlock(), enumdirection.getOpposite());
             }
         }
+
     }
 }
