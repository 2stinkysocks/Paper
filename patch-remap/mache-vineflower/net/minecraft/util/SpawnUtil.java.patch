--- a/net/minecraft/util/SpawnUtil.java
+++ b/net/minecraft/util/SpawnUtil.java
@@ -1,38 +1,49 @@
 package net.minecraft.util;
 
 import java.util.Optional;
+import java.util.function.Consumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMobSpawn;
 import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.LeavesBlock;
 import net.minecraft.world.level.block.StainedGlassBlock;
 import net.minecraft.world.level.block.StainedGlassPaneBlock;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 
 public class SpawnUtil {
-    public static <T extends Mob> Optional<T> trySpawnMob(
-        EntityType<T> entityType, MobSpawnType spawnType, ServerLevel level, BlockPos pos, int attempts, int i, int yOffset, SpawnUtil.Strategy strategy
-    ) {
-        BlockPos.MutableBlockPos mutableBlockPos = pos.mutable();
 
-        for (int i1 = 0; i1 < attempts; i1++) {
-            int i2 = Mth.randomBetweenInclusive(level.random, -i, i);
-            int i3 = Mth.randomBetweenInclusive(level.random, -i, i);
-            mutableBlockPos.setWithOffset(pos, i2, yOffset, i3);
-            if (level.getWorldBorder().isWithinBounds(mutableBlockPos) && moveToPossibleSpawnPosition(level, yOffset, mutableBlockPos, strategy)) {
-                T mob = (T)entityType.create(level, null, null, mutableBlockPos, spawnType, false, false);
-                if (mob != null) {
-                    if (mob.checkSpawnRules(level, spawnType) && mob.checkSpawnObstruction(level)) {
-                        level.addFreshEntityWithPassengers(mob);
-                        return Optional.of(mob);
+    public SpawnUtil() {}
+
+    public static <T extends Mob> Optional<T> trySpawnMob(EntityType<T> entityType, EnumMobSpawn spawnType, ServerLevel level, BlockPos pos, int attempts, int j, int yOffset, SpawnUtil.Strategy strategy) {
+        // CraftBukkit start
+        return trySpawnMob(entityType, spawnType, level, pos, attempts, j, yOffset, strategy, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public static <T extends Mob> Optional<T> trySpawnMob(EntityType<T> entitytypes, EnumMobSpawn enummobspawn, ServerLevel worldserver, BlockPos blockposition, int i, int j, int k, SpawnUtil.Strategy spawnutil_a, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        // CraftBukkit end
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = blockposition.mutable();
+
+        for (int l = 0; l < i; ++l) {
+            int i1 = Mth.randomBetweenInclusive(worldserver.random, -j, j);
+            int j1 = Mth.randomBetweenInclusive(worldserver.random, -j, j);
+
+            blockposition_mutableblockposition.setWithOffset(blockposition, i1, k, j1);
+            if (worldserver.getWorldBorder().isWithinBounds((BlockPos) blockposition_mutableblockposition) && moveToPossibleSpawnPosition(worldserver, k, blockposition_mutableblockposition, spawnutil_a)) {
+                T t0 = entitytypes.create(worldserver, (CompoundTag) null, null, blockposition_mutableblockposition, enummobspawn, false, false); // CraftBukkit - decompile error
+
+                if (t0 != null) {
+                    if (t0.checkSpawnRules(worldserver, enummobspawn) && t0.checkSpawnObstruction(worldserver)) {
+                        worldserver.addFreshEntityWithPassengers(t0, reason); // CraftBukkit
+                        return Optional.of(t0);
                     }
 
-                    mob.discard();
+                    t0.discard();
                 }
             }
         }
@@ -41,47 +52,36 @@
     }
 
     private static boolean moveToPossibleSpawnPosition(ServerLevel level, int yOffset, BlockPos.MutableBlockPos pos, SpawnUtil.Strategy strategy) {
-        BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos().set(pos);
-        BlockState blockState = level.getBlockState(mutableBlockPos);
+        BlockPos.MutableBlockPos blockposition_mutableblockposition1 = (new BlockPos.MutableBlockPos()).set(pos);
+        IBlockData iblockdata = level.getBlockState(blockposition_mutableblockposition1);
 
-        for (int i = yOffset; i >= -yOffset; i--) {
+        for (int j = yOffset; j >= -yOffset; --j) {
             pos.move(Direction.DOWN);
-            mutableBlockPos.setWithOffset(pos, Direction.UP);
-            BlockState blockState1 = level.getBlockState(pos);
-            if (strategy.canSpawnOn(level, pos, blockState1, mutableBlockPos, blockState)) {
+            blockposition_mutableblockposition1.setWithOffset(pos, Direction.UP);
+            IBlockData iblockdata1 = level.getBlockState(pos);
+
+            if (strategy.canSpawnOn(level, pos, iblockdata1, blockposition_mutableblockposition1, iblockdata)) {
                 pos.move(Direction.UP);
                 return true;
             }
 
-            blockState = blockState1;
+            iblockdata = iblockdata1;
         }
 
         return false;
     }
 
     public interface Strategy {
+
+        /** @deprecated */
         @Deprecated
-        SpawnUtil.Strategy LEGACY_IRON_GOLEM = (level, blockPos, blockState, blockPos1, blockState1) -> !blockState.is(Blocks.COBWEB)
-                && !blockState.is(Blocks.CACTUS)
-                && !blockState.is(Blocks.GLASS_PANE)
-                && !(blockState.getBlock() instanceof StainedGlassPaneBlock)
-                && !(blockState.getBlock() instanceof StainedGlassBlock)
-                && !(blockState.getBlock() instanceof LeavesBlock)
-                && !blockState.is(Blocks.CONDUIT)
-                && !blockState.is(Blocks.ICE)
-                && !blockState.is(Blocks.TNT)
-                && !blockState.is(Blocks.GLOWSTONE)
-                && !blockState.is(Blocks.BEACON)
-                && !blockState.is(Blocks.SEA_LANTERN)
-                && !blockState.is(Blocks.FROSTED_ICE)
-                && !blockState.is(Blocks.TINTED_GLASS)
-                && !blockState.is(Blocks.GLASS)
-                && (blockState1.isAir() || blockState1.liquid())
-                && (blockState.isSolid() || blockState.is(Blocks.POWDER_SNOW));
-        SpawnUtil.Strategy ON_TOP_OF_COLLIDER = (level, blockPos, blockState, blockPos1, blockState1) -> blockState1.getCollisionShape(level, blockPos1)
-                    .isEmpty()
-                && Block.isFaceFull(blockState.getCollisionShape(level, blockPos), Direction.UP);
+        SpawnUtil.Strategy LEGACY_IRON_GOLEM = (worldserver, blockposition, iblockdata, blockposition1, iblockdata1) -> {
+            return !iblockdata.is(Blocks.COBWEB) && !iblockdata.is(Blocks.CACTUS) && !iblockdata.is(Blocks.GLASS_PANE) && !(iblockdata.getBlock() instanceof StainedGlassPaneBlock) && !(iblockdata.getBlock() instanceof StainedGlassBlock) && !(iblockdata.getBlock() instanceof LeavesBlock) && !iblockdata.is(Blocks.CONDUIT) && !iblockdata.is(Blocks.ICE) && !iblockdata.is(Blocks.TNT) && !iblockdata.is(Blocks.GLOWSTONE) && !iblockdata.is(Blocks.BEACON) && !iblockdata.is(Blocks.SEA_LANTERN) && !iblockdata.is(Blocks.FROSTED_ICE) && !iblockdata.is(Blocks.TINTED_GLASS) && !iblockdata.is(Blocks.GLASS) ? (iblockdata1.isAir() || iblockdata1.liquid()) && (iblockdata.isSolid() || iblockdata.is(Blocks.POWDER_SNOW)) : false;
+        };
+        SpawnUtil.Strategy ON_TOP_OF_COLLIDER = (worldserver, blockposition, iblockdata, blockposition1, iblockdata1) -> {
+            return iblockdata1.getCollisionShape(worldserver, blockposition1).isEmpty() && Block.isFaceFull(iblockdata.getCollisionShape(worldserver, blockposition), Direction.UP);
+        };
 
-        boolean canSpawnOn(ServerLevel level, BlockPos blockPos, BlockState blockState, BlockPos blockPos1, BlockState blockState1);
+        boolean canSpawnOn(ServerLevel level, BlockPos blockposition, IBlockData iblockdata, BlockPos blockposition1, IBlockData iblockdata1);
     }
 }
