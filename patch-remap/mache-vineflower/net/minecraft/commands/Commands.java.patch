--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -1,21 +1,19 @@
 package net.minecraft.commands;
 
 import com.google.common.collect.Maps;
-import com.mojang.brigadier.CommandDispatcher;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.arguments.ArgumentType;
 import com.mojang.brigadier.builder.ArgumentBuilder;
 import com.mojang.brigadier.builder.LiteralArgumentBuilder;
 import com.mojang.brigadier.builder.RequiredArgumentBuilder;
-import com.mojang.brigadier.context.CommandContext;
 import com.mojang.brigadier.context.CommandContextBuilder;
 import com.mojang.brigadier.context.ContextChain;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.RootCommandNode;
 import com.mojang.logging.LogUtils;
-import java.util.Collection;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -42,7 +40,6 @@
 import net.minecraft.network.chat.ComponentUtils;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.Style;
 import net.minecraft.network.protocol.game.ClientboundCommandsPacket;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.server.MinecraftServer;
@@ -137,17 +134,27 @@
 import net.minecraft.world.level.GameRules;
 import org.slf4j.Logger;
 
+// CraftBukkit start
+import com.google.common.base.Joiner;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import org.bukkit.event.player.PlayerCommandSendEvent;
+import org.bukkit.event.server.ServerCommandEvent;
+// CraftBukkit end
+
 public class Commands {
-    private static final ThreadLocal<ExecutionContext<CommandSourceStack>> CURRENT_EXECUTION_CONTEXT = new ThreadLocal<>();
+
+    private static final ThreadLocal<ExecutionContext<CommandSourceStack>> CURRENT_EXECUTION_CONTEXT = new ThreadLocal();
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final int LEVEL_ALL = 0;
     public static final int LEVEL_MODERATORS = 1;
     public static final int LEVEL_GAMEMASTERS = 2;
     public static final int LEVEL_ADMINS = 3;
     public static final int LEVEL_OWNERS = 4;
-    private final CommandDispatcher<CommandSourceStack> dispatcher = new CommandDispatcher<>();
+    private final com.mojang.brigadier.CommandDispatcher<CommandSourceStack> dispatcher = new com.mojang.brigadier.CommandDispatcher();
 
     public Commands(Commands.CommandSelection selection, CommandBuildContext context) {
+        this(); // CraftBukkit
         AdvancementCommands.register(this.dispatcher);
         AttributeCommand.register(this.dispatcher, context);
         ExecuteCommand.register(this.dispatcher, context);
@@ -248,157 +255,256 @@
             PublishCommand.register(this.dispatcher);
         }
 
+        // CraftBukkit start
+    }
+
+    public Commands() {
+        // CraftBukkkit end
         this.dispatcher.setConsumer(ExecutionCommandSource.resultConsumer());
     }
 
     public static <S> ParseResults<S> mapSource(ParseResults<S> parseResults, UnaryOperator<S> mapper) {
-        CommandContextBuilder<S> context = parseResults.getContext();
-        CommandContextBuilder<S> commandContextBuilder = context.withSource(mapper.apply(context.getSource()));
-        return new ParseResults<>(commandContextBuilder, parseResults.getReader(), parseResults.getExceptions());
+        CommandContextBuilder<S> commandcontextbuilder = parseResults.getContext();
+        CommandContextBuilder<S> commandcontextbuilder1 = commandcontextbuilder.withSource(mapper.apply(commandcontextbuilder.getSource()));
+
+        return new ParseResults(commandcontextbuilder1, parseResults.getReader(), parseResults.getExceptions());
     }
 
-    public void performPrefixedCommand(CommandSourceStack commandSourceStack, String string) {
-        string = string.startsWith("/") ? string.substring(1) : string;
-        this.performCommand(this.dispatcher.parse(string, commandSourceStack), string);
+    // CraftBukkit start
+    public void dispatchServerCommand(CommandSourceStack sender, String command) {
+        Joiner joiner = Joiner.on(" ");
+        if (command.startsWith("/")) {
+            command = command.substring(1);
+        }
+
+        ServerCommandEvent event = new ServerCommandEvent(sender.getBukkitSender(), command);
+        org.bukkit.Bukkit.getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        command = event.getCommand();
+
+        String[] args = command.split(" ");
+
+        String cmd = args[0];
+        if (cmd.startsWith("minecraft:")) cmd = cmd.substring("minecraft:".length());
+        if (cmd.startsWith("bukkit:")) cmd = cmd.substring("bukkit:".length());
+
+        // Block disallowed commands
+        if (cmd.equalsIgnoreCase("stop") || cmd.equalsIgnoreCase("kick") || cmd.equalsIgnoreCase("op")
+                || cmd.equalsIgnoreCase("deop") || cmd.equalsIgnoreCase("ban") || cmd.equalsIgnoreCase("ban-ip")
+                || cmd.equalsIgnoreCase("pardon") || cmd.equalsIgnoreCase("pardon-ip") || cmd.equalsIgnoreCase("reload")) {
+            return;
+        }
+
+        // Handle vanilla commands;
+        if (sender.getLevel().getCraftServer().getCommandBlockOverride(args[0])) {
+            args[0] = "minecraft:" + args[0];
+        }
+
+        String newCommand = joiner.join(args);
+        this.performPrefixedCommand(sender, newCommand, newCommand);
     }
+    // CraftBukkit end
 
-    public void performCommand(ParseResults<CommandSourceStack> parseResults, String string) {
-        CommandSourceStack commandSourceStack = parseResults.getContext().getSource();
-        commandSourceStack.getServer().getProfiler().push(() -> "/" + string);
-        ContextChain<CommandSourceStack> contextChain = finishParsing(parseResults, string, commandSourceStack);
+    public void performPrefixedCommand(CommandSourceStack commandlistenerwrapper, String s) {
+        // CraftBukkit start
+        this.performPrefixedCommand(commandlistenerwrapper, s, s);
+    }
 
+    public void performPrefixedCommand(CommandSourceStack commandlistenerwrapper, String s, String label) {
+        s = s.startsWith("/") ? s.substring(1) : s;
+        this.performCommand(this.dispatcher.parse(s, commandlistenerwrapper), s, label);
+        // CraftBukkit end
+    }
+
+    public void performCommand(ParseResults<CommandSourceStack> parseresults, String s) {
+        this.performCommand(parseresults, s, s);
+    }
+
+    public void performCommand(ParseResults<CommandSourceStack> parseresults, String s, String label) { // CraftBukkit
+        CommandSourceStack commandlistenerwrapper = (CommandSourceStack) parseresults.getContext().getSource();
+
+        commandlistenerwrapper.getServer().getProfiler().push(() -> {
+            return "/" + s;
+        });
+        ContextChain contextchain = finishParsing(parseresults, s, commandlistenerwrapper, label); // CraftBukkit
+
         try {
-            if (contextChain != null) {
-                executeCommandInContext(
-                    commandSourceStack,
-                    executionContext -> ExecutionContext.queueInitialCommandExecution(
-                            executionContext, string, contextChain, commandSourceStack, CommandResultCallback.EMPTY
-                        )
-                );
+            if (contextchain != null) {
+                executeCommandInContext(commandlistenerwrapper, (executioncontext) -> {
+                    ExecutionContext.queueInitialCommandExecution(executioncontext, s, contextchain, commandlistenerwrapper, CommandResultCallback.EMPTY);
+                });
             }
-        } catch (Exception var12) {
-            MutableComponent mutableComponent = Component.literal(var12.getMessage() == null ? var12.getClass().getName() : var12.getMessage());
-            if (LOGGER.isDebugEnabled()) {
-                LOGGER.error("Command exception: /{}", string, var12);
-                StackTraceElement[] stackTrace = var12.getStackTrace();
+        } catch (Exception exception) {
+            MutableComponent ichatmutablecomponent = Component.literal(exception.getMessage() == null ? exception.getClass().getName() : exception.getMessage());
 
-                for (int i = 0; i < Math.min(stackTrace.length, 3); i++) {
-                    mutableComponent.append("\n\n")
-                        .append(stackTrace[i].getMethodName())
-                        .append("\n ")
-                        .append(stackTrace[i].getFileName())
-                        .append(":")
-                        .append(String.valueOf(stackTrace[i].getLineNumber()));
+            if (Commands.LOGGER.isDebugEnabled()) {
+                Commands.LOGGER.error("Command exception: /{}", s, exception);
+                StackTraceElement[] astacktraceelement = exception.getStackTrace();
+
+                for (int i = 0; i < Math.min(astacktraceelement.length, 3); ++i) {
+                    ichatmutablecomponent.append("\n\n").append(astacktraceelement[i].getMethodName()).append("\n ").append(astacktraceelement[i].getFileName()).append(":").append(String.valueOf(astacktraceelement[i].getLineNumber()));
                 }
             }
 
-            commandSourceStack.sendFailure(
-                Component.translatable("command.failed")
-                    .withStyle(style -> style.withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, mutableComponent)))
-            );
+            commandlistenerwrapper.sendFailure(Component.translatable("command.failed").withStyle((chatmodifier) -> {
+                return chatmodifier.withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, ichatmutablecomponent));
+            }));
             if (SharedConstants.IS_RUNNING_IN_IDE) {
-                commandSourceStack.sendFailure(Component.literal(Util.describeError(var12)));
-                LOGGER.error("'/{}' threw an exception", string, var12);
+                commandlistenerwrapper.sendFailure(Component.literal(Util.describeError(exception)));
+                Commands.LOGGER.error("'/{}' threw an exception", s, exception);
             }
         } finally {
-            commandSourceStack.getServer().getProfiler().pop();
+            commandlistenerwrapper.getServer().getProfiler().pop();
         }
+
     }
 
     @Nullable
-    private static ContextChain<CommandSourceStack> finishParsing(
-        ParseResults<CommandSourceStack> parseResults, String string, CommandSourceStack commandSourceStack
-    ) {
+    private static ContextChain<CommandSourceStack> finishParsing(ParseResults<CommandSourceStack> parseresults, String s, CommandSourceStack commandlistenerwrapper, String label) { // CraftBukkit
         try {
-            validateParseResults(parseResults);
-            return ContextChain.tryFlatten(parseResults.getContext().build(string))
-                .orElseThrow(() -> CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(parseResults.getReader()));
-        } catch (CommandSyntaxException var7) {
-            commandSourceStack.sendFailure(ComponentUtils.fromMessage(var7.getRawMessage()));
-            if (var7.getInput() != null && var7.getCursor() >= 0) {
-                int min = Math.min(var7.getInput().length(), var7.getCursor());
-                MutableComponent mutableComponent = Component.empty()
-                    .withStyle(ChatFormatting.GRAY)
-                    .withStyle(style -> style.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/" + string)));
-                if (min > 10) {
-                    mutableComponent.append(CommonComponents.ELLIPSIS);
+            validateParseResults(parseresults);
+            return (ContextChain) ContextChain.tryFlatten(parseresults.getContext().build(s)).orElseThrow(() -> {
+                return CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(parseresults.getReader());
+            });
+        } catch (CommandSyntaxException commandsyntaxexception) {
+            commandlistenerwrapper.sendFailure(ComponentUtils.fromMessage(commandsyntaxexception.getRawMessage()));
+            if (commandsyntaxexception.getInput() != null && commandsyntaxexception.getCursor() >= 0) {
+                int i = Math.min(commandsyntaxexception.getInput().length(), commandsyntaxexception.getCursor());
+                MutableComponent ichatmutablecomponent = Component.empty().withStyle(ChatFormatting.GRAY).withStyle((chatmodifier) -> {
+                    return chatmodifier.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, label)); // CraftBukkit
+                });
+
+                if (i > 10) {
+                    ichatmutablecomponent.append(CommonComponents.ELLIPSIS);
                 }
 
-                mutableComponent.append(var7.getInput().substring(Math.max(0, min - 10), min));
-                if (min < var7.getInput().length()) {
-                    Component component = Component.literal(var7.getInput().substring(min)).withStyle(ChatFormatting.RED, ChatFormatting.UNDERLINE);
-                    mutableComponent.append(component);
+                ichatmutablecomponent.append(commandsyntaxexception.getInput().substring(Math.max(0, i - 10), i));
+                if (i < commandsyntaxexception.getInput().length()) {
+                    MutableComponent ichatmutablecomponent1 = Component.literal(commandsyntaxexception.getInput().substring(i)).withStyle(ChatFormatting.RED, ChatFormatting.UNDERLINE);
+
+                    ichatmutablecomponent.append((Component) ichatmutablecomponent1);
                 }
 
-                mutableComponent.append(Component.translatable("command.context.here").withStyle(ChatFormatting.RED, ChatFormatting.ITALIC));
-                commandSourceStack.sendFailure(mutableComponent);
+                ichatmutablecomponent.append((Component) Component.translatable("command.context.here").withStyle(ChatFormatting.RED, ChatFormatting.ITALIC));
+                commandlistenerwrapper.sendFailure(ichatmutablecomponent);
             }
 
             return null;
         }
     }
 
-    public static void executeCommandInContext(CommandSourceStack commandSourceStack, Consumer<ExecutionContext<CommandSourceStack>> consumer) {
-        MinecraftServer server = commandSourceStack.getServer();
-        ExecutionContext<CommandSourceStack> executionContext = CURRENT_EXECUTION_CONTEXT.get();
-        boolean flag = executionContext == null;
+    public static void executeCommandInContext(CommandSourceStack commandlistenerwrapper, Consumer<ExecutionContext<CommandSourceStack>> consumer) {
+        MinecraftServer minecraftserver = commandlistenerwrapper.getServer();
+        ExecutionContext<CommandSourceStack> executioncontext = (ExecutionContext) Commands.CURRENT_EXECUTION_CONTEXT.get();
+        boolean flag = executioncontext == null;
+
         if (flag) {
-            int max = Math.max(1, server.getGameRules().getInt(GameRules.RULE_MAX_COMMAND_CHAIN_LENGTH));
-            int _int = server.getGameRules().getInt(GameRules.RULE_MAX_COMMAND_FORK_COUNT);
+            int i = Math.max(1, minecraftserver.getGameRules().getInt(GameRules.RULE_MAX_COMMAND_CHAIN_LENGTH));
+            int j = minecraftserver.getGameRules().getInt(GameRules.RULE_MAX_COMMAND_FORK_COUNT);
 
-            try (ExecutionContext<CommandSourceStack> executionContext1 = new ExecutionContext<>(max, _int, server.getProfiler())) {
-                CURRENT_EXECUTION_CONTEXT.set(executionContext1);
-                consumer.accept(executionContext1);
-                executionContext1.runCommandQueue();
+            try {
+                ExecutionContext executioncontext1 = new ExecutionContext<>(i, j, minecraftserver.getProfiler());
+
+                try {
+                    Commands.CURRENT_EXECUTION_CONTEXT.set(executioncontext1);
+                    consumer.accept(executioncontext1);
+                    executioncontext1.runCommandQueue();
+                } catch (Throwable throwable) {
+                    try {
+                        executioncontext1.close();
+                    } catch (Throwable throwable1) {
+                        throwable.addSuppressed(throwable1);
+                    }
+
+                    throw throwable;
+                }
+
+                executioncontext1.close();
             } finally {
-                CURRENT_EXECUTION_CONTEXT.set(null);
+                Commands.CURRENT_EXECUTION_CONTEXT.set(null); // CraftBukkit - decompile error
             }
         } else {
-            consumer.accept(executionContext);
+            consumer.accept(executioncontext);
         }
+
     }
 
     public void sendCommands(ServerPlayer player) {
-        Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> map = Maps.newHashMap();
-        RootCommandNode<SharedSuggestionProvider> rootCommandNode = new RootCommandNode<>();
-        map.put(this.dispatcher.getRoot(), rootCommandNode);
-        this.fillUsableCommands(this.dispatcher.getRoot(), rootCommandNode, player.createCommandSourceStack(), map);
-        player.connection.send(new ClientboundCommandsPacket(rootCommandNode));
+        // CraftBukkit start
+        // Register Vanilla commands into builtRoot as before
+        Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> map = Maps.newIdentityHashMap(); // Use identity to prevent aliasing issues
+        RootCommandNode vanillaRoot = new RootCommandNode();
+
+        RootCommandNode<CommandSourceStack> vanilla = player.server.vanillaCommandDispatcher.getDispatcher().getRoot();
+        map.put(vanilla, vanillaRoot);
+        this.fillUsableCommands(vanilla, vanillaRoot, player.createCommandSourceStack(), (Map) map);
+
+        // Now build the global commands in a second pass
+        RootCommandNode<SharedSuggestionProvider> rootcommandnode = new RootCommandNode();
+
+        map.put(this.dispatcher.getRoot(), rootcommandnode);
+        this.fillUsableCommands(this.dispatcher.getRoot(), rootcommandnode, player.createCommandSourceStack(), map);
+
+        Collection<String> bukkit = new LinkedHashSet<>();
+        for (CommandNode node : rootcommandnode.getChildren()) {
+            bukkit.add(node.getName());
+        }
+
+        PlayerCommandSendEvent event = new PlayerCommandSendEvent(player.getBukkitEntity(), new LinkedHashSet<>(bukkit));
+        event.getPlayer().getServer().getPluginManager().callEvent(event);
+
+        // Remove labels that were removed during the event
+        for (String orig : bukkit) {
+            if (!event.getCommands().contains(orig)) {
+                rootcommandnode.removeCommand(orig);
+            }
+        }
+        // CraftBukkit end
+        player.connection.send(new ClientboundCommandsPacket(rootcommandnode));
     }
 
-    private void fillUsableCommands(
-        CommandNode<CommandSourceStack> rootCommandSource,
-        CommandNode<SharedSuggestionProvider> rootSuggestion,
-        CommandSourceStack source,
-        Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> commandNodeToSuggestionNode
-    ) {
-        for (CommandNode<CommandSourceStack> commandNode : rootCommandSource.getChildren()) {
-            if (commandNode.canUse(source)) {
-                ArgumentBuilder<SharedSuggestionProvider, ?> argumentBuilder = (ArgumentBuilder) commandNode.createBuilder();
-                argumentBuilder.requires(sharedSuggestionProvider -> true);
-                if (argumentBuilder.getCommand() != null) {
-                    argumentBuilder.executes(commandContext -> 0);
+    private void fillUsableCommands(CommandNode<CommandSourceStack> rootCommandSource, CommandNode<SharedSuggestionProvider> rootSuggestion, CommandSourceStack source, Map<CommandNode<CommandSourceStack>, CommandNode<SharedSuggestionProvider>> commandNodeToSuggestionNode) {
+        Iterator iterator = rootCommandSource.getChildren().iterator();
+
+        while (iterator.hasNext()) {
+            CommandNode<CommandSourceStack> commandnode2 = (CommandNode) iterator.next();
+
+            if (commandnode2.canUse(source)) {
+                ArgumentBuilder argumentbuilder = commandnode2.createBuilder(); // CraftBukkit - decompile error
+
+                argumentbuilder.requires((icompletionprovider) -> {
+                    return true;
+                });
+                if (argumentbuilder.getCommand() != null) {
+                    argumentbuilder.executes((commandcontext) -> {
+                        return 0;
+                    });
                 }
 
-                if (argumentBuilder instanceof RequiredArgumentBuilder) {
-                    RequiredArgumentBuilder<SharedSuggestionProvider, ?> requiredArgumentBuilder = (RequiredArgumentBuilder<SharedSuggestionProvider, ?>)argumentBuilder;
-                    if (requiredArgumentBuilder.getSuggestionsProvider() != null) {
-                        requiredArgumentBuilder.suggests(SuggestionProviders.safelySwap(requiredArgumentBuilder.getSuggestionsProvider()));
+                if (argumentbuilder instanceof RequiredArgumentBuilder) {
+                    RequiredArgumentBuilder<SharedSuggestionProvider, ?> requiredargumentbuilder = (RequiredArgumentBuilder) argumentbuilder;
+
+                    if (requiredargumentbuilder.getSuggestionsProvider() != null) {
+                        requiredargumentbuilder.suggests(SuggestionProviders.safelySwap(requiredargumentbuilder.getSuggestionsProvider()));
                     }
                 }
 
-                if (argumentBuilder.getRedirect() != null) {
-                    argumentBuilder.redirect(commandNodeToSuggestionNode.get(argumentBuilder.getRedirect()));
+                if (argumentbuilder.getRedirect() != null) {
+                    argumentbuilder.redirect((CommandNode) commandNodeToSuggestionNode.get(argumentbuilder.getRedirect()));
                 }
 
-                CommandNode<SharedSuggestionProvider> commandNode1 = argumentBuilder.build();
-                commandNodeToSuggestionNode.put(commandNode, commandNode1);
-                rootSuggestion.addChild(commandNode1);
-                if (!commandNode.getChildren().isEmpty()) {
-                    this.fillUsableCommands(commandNode, commandNode1, source, commandNodeToSuggestionNode);
+                CommandNode commandnode3 = argumentbuilder.build(); // CraftBukkit - decompile error
+
+                commandNodeToSuggestionNode.put(commandnode2, commandnode3);
+                rootSuggestion.addChild(commandnode3);
+                if (!commandnode2.getChildren().isEmpty()) {
+                    this.fillUsableCommands(commandnode2, commandnode3, source, commandNodeToSuggestionNode);
                 }
             }
         }
+
     }
 
     public static LiteralArgumentBuilder<CommandSourceStack> literal(String name) {
@@ -410,46 +516,40 @@
     }
 
     public static Predicate<String> createValidator(Commands.ParseFunction parser) {
-        return string -> {
+        return (s) -> {
             try {
-                parser.parse(new StringReader(string));
+                parser.parse(new StringReader(s));
                 return true;
-            } catch (CommandSyntaxException var3) {
+            } catch (CommandSyntaxException commandsyntaxexception) {
                 return false;
             }
         };
     }
 
-    public CommandDispatcher<CommandSourceStack> getDispatcher() {
+    public com.mojang.brigadier.CommandDispatcher<CommandSourceStack> getDispatcher() {
         return this.dispatcher;
     }
 
-    public static <S> void validateParseResults(ParseResults<S> parseResults) throws CommandSyntaxException {
-        CommandSyntaxException parseException = getParseException(parseResults);
-        if (parseException != null) {
-            throw parseException;
+    public static <S> void validateParseResults(ParseResults<S> parseresults) throws CommandSyntaxException {
+        CommandSyntaxException commandsyntaxexception = getParseException(parseresults);
+
+        if (commandsyntaxexception != null) {
+            throw commandsyntaxexception;
         }
     }
 
     @Nullable
     public static <S> CommandSyntaxException getParseException(ParseResults<S> result) {
-        if (!result.getReader().canRead()) {
-            return null;
-        } else if (result.getExceptions().size() == 1) {
-            return result.getExceptions().values().iterator().next();
-        } else {
-            return result.getContext().getRange().isEmpty()
-                ? CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(result.getReader())
-                : CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownArgument().createWithContext(result.getReader());
-        }
+        return !result.getReader().canRead() ? null : (result.getExceptions().size() == 1 ? (CommandSyntaxException) result.getExceptions().values().iterator().next() : (result.getContext().getRange().isEmpty() ? CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(result.getReader()) : CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownArgument().createWithContext(result.getReader())));
     }
 
     public static CommandBuildContext createValidationContext(final HolderLookup.Provider provider) {
         return new CommandBuildContext() {
             @Override
             public <T> HolderLookup<T> holderLookup(ResourceKey<? extends Registry<T>> registryResourceKey) {
-                final HolderLookup.RegistryLookup<T> registryLookup = provider.lookupOrThrow(registryResourceKey);
-                return new HolderLookup.Delegate<T>(registryLookup) {
+                final HolderLookup.RegistryLookup<T> holderlookup_c = provider.lookupOrThrow(registryResourceKey);
+
+                return new HolderLookup.Delegate<T>(holderlookup_c) {
                     @Override
                     public Optional<HolderSet.Named<T>> get(TagKey<T> tagKey) {
                         return Optional.of(this.getOrThrow(tagKey));
@@ -457,8 +557,11 @@
 
                     @Override
                     public HolderSet.Named<T> getOrThrow(TagKey<T> tagKey) {
-                        Optional<HolderSet.Named<T>> optional = registryLookup.get(tagKey);
-                        return optional.orElseGet(() -> HolderSet.emptyNamed(registryLookup, tagKey));
+                        Optional<HolderSet.Named<T>> optional = holderlookup_c.get(tagKey);
+
+                        return (HolderSet.Named) optional.orElseGet(() -> {
+                            return HolderSet.emptyNamed(holderlookup_c, tagKey);
+                        });
                     }
                 };
             }
@@ -466,43 +569,42 @@
     }
 
     public static void validate() {
-        CommandBuildContext commandBuildContext = createValidationContext(VanillaRegistries.createLookup());
-        CommandDispatcher<CommandSourceStack> dispatcher = new Commands(Commands.CommandSelection.ALL, commandBuildContext).getDispatcher();
-        RootCommandNode<CommandSourceStack> root = dispatcher.getRoot();
-        dispatcher.findAmbiguities(
-            (commandNode, commandNode1, commandNode2, collection) -> LOGGER.warn(
-                    "Ambiguity between arguments {} and {} with inputs: {}", dispatcher.getPath(commandNode1), dispatcher.getPath(commandNode2), collection
-                )
-        );
-        Set<ArgumentType<?>> set = ArgumentUtils.findUsedArgumentTypes(root);
-        Set<ArgumentType<?>> set1 = set.stream()
-            .filter(argumentType -> !ArgumentTypeInfos.isClassRecognized(argumentType.getClass()))
-            .collect(Collectors.toSet());
+        CommandBuildContext commandbuildcontext = createValidationContext(VanillaRegistries.createLookup());
+        com.mojang.brigadier.CommandDispatcher<CommandSourceStack> com_mojang_brigadier_commanddispatcher = (new Commands(Commands.CommandSelection.ALL, commandbuildcontext)).getDispatcher();
+        RootCommandNode<CommandSourceStack> rootcommandnode = com_mojang_brigadier_commanddispatcher.getRoot();
+
+        com_mojang_brigadier_commanddispatcher.findAmbiguities((commandnode, commandnode1, commandnode2, collection) -> {
+            Commands.LOGGER.warn("Ambiguity between arguments {} and {} with inputs: {}", new Object[]{com_mojang_brigadier_commanddispatcher.getPath(commandnode1), com_mojang_brigadier_commanddispatcher.getPath(commandnode2), collection});
+        });
+        Set<ArgumentType<?>> set = ArgumentUtils.findUsedArgumentTypes(rootcommandnode);
+        Set<ArgumentType<?>> set1 = (Set) set.stream().filter((argumenttype) -> {
+            return !ArgumentTypeInfos.isClassRecognized(argumenttype.getClass());
+        }).collect(Collectors.toSet());
+
         if (!set1.isEmpty()) {
-            LOGGER.warn(
-                "Missing type registration for following arguments:\n {}",
-                set1.stream().map(argumentType -> "\t" + argumentType).collect(Collectors.joining(",\n"))
-            );
+            Commands.LOGGER.warn("Missing type registration for following arguments:\n {}", set1.stream().map((argumenttype) -> {
+                return "\t" + argumenttype;
+            }).collect(Collectors.joining(",\n")));
             throw new IllegalStateException("Unregistered argument types");
         }
     }
 
     public static enum CommandSelection {
-        ALL(true, true),
-        DEDICATED(false, true),
-        INTEGRATED(true, false);
 
+        ALL(true, true), DEDICATED(false, true), INTEGRATED(true, false);
+
         final boolean includeIntegrated;
         final boolean includeDedicated;
 
-        private CommandSelection(boolean includeIntegrated, boolean includeDedicated) {
-            this.includeIntegrated = includeIntegrated;
-            this.includeDedicated = includeDedicated;
+        private CommandSelection(boolean flag, boolean flag1) {
+            this.includeIntegrated = flag;
+            this.includeDedicated = flag1;
         }
     }
 
     @FunctionalInterface
     public interface ParseFunction {
+
         void parse(StringReader input) throws CommandSyntaxException;
     }
 }
