--- a/net/minecraft/util/SpawnUtil.java
+++ b/net/minecraft/util/SpawnUtil.java
@@ -7,33 +7,39 @@
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMobSpawn;
 import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.LeavesBlock;
 import net.minecraft.world.level.block.StainedGlassBlock;
 import net.minecraft.world.level.block.StainedGlassPaneBlock;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 
 public class SpawnUtil {
 
     public SpawnUtil() {}
 
-    public static <T extends Mob> Optional<T> trySpawnMob(EntityType<T> entitytype, MobSpawnType mobspawntype, ServerLevel serverlevel, BlockPos blockpos, int i, int j, int k, SpawnUtil.Strategy spawnutil_strategy) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = blockpos.mutable();
+    public static <T extends Mob> Optional<T> trySpawnMob(EntityType<T> entityType, EnumMobSpawn spawnType, ServerLevel level, BlockPos pos, int attempts, int j, int yOffset, SpawnUtil.Strategy strategy) {
+        // CraftBukkit start
+        return trySpawnMob(entityType, spawnType, level, pos, attempts, j, yOffset, strategy, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
 
+    public static <T extends Mob> Optional<T> trySpawnMob(EntityType<T> entitytypes, EnumMobSpawn enummobspawn, ServerLevel worldserver, BlockPos blockposition, int i, int j, int k, SpawnUtil.Strategy spawnutil_a, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        // CraftBukkit end
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = blockposition.mutable();
+
         for (int l = 0; l < i; ++l) {
-            int i1 = Mth.randomBetweenInclusive(serverlevel.random, -j, j);
-            int j1 = Mth.randomBetweenInclusive(serverlevel.random, -j, j);
+            int i1 = Mth.randomBetweenInclusive(worldserver.random, -j, j);
+            int j1 = Mth.randomBetweenInclusive(worldserver.random, -j, j);
 
-            blockpos_mutableblockpos.setWithOffset(blockpos, i1, k, j1);
-            if (serverlevel.getWorldBorder().isWithinBounds((BlockPos) blockpos_mutableblockpos) && moveToPossibleSpawnPosition(serverlevel, k, blockpos_mutableblockpos, spawnutil_strategy)) {
-                T t0 = (Mob) entitytype.create(serverlevel, (CompoundTag) null, (Consumer) null, blockpos_mutableblockpos, mobspawntype, false, false);
+            blockposition_mutableblockposition.setWithOffset(blockposition, i1, k, j1);
+            if (worldserver.getWorldBorder().isWithinBounds((BlockPos) blockposition_mutableblockposition) && moveToPossibleSpawnPosition(worldserver, k, blockposition_mutableblockposition, spawnutil_a)) {
+                T t0 = entitytypes.create(worldserver, (CompoundTag) null, null, blockposition_mutableblockposition, enummobspawn, false, false); // CraftBukkit - decompile error
 
                 if (t0 != null) {
-                    if (t0.checkSpawnRules(serverlevel, mobspawntype) && t0.checkSpawnObstruction(serverlevel)) {
-                        serverlevel.addFreshEntityWithPassengers(t0);
+                    if (t0.checkSpawnRules(worldserver, enummobspawn) && t0.checkSpawnObstruction(worldserver)) {
+                        worldserver.addFreshEntityWithPassengers(t0, reason); // CraftBukkit
                         return Optional.of(t0);
                     }
 
@@ -45,21 +51,21 @@
         return Optional.empty();
     }
 
-    private static boolean moveToPossibleSpawnPosition(ServerLevel serverlevel, int i, BlockPos.MutableBlockPos blockpos_mutableblockpos, SpawnUtil.Strategy spawnutil_strategy) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos1 = (new BlockPos.MutableBlockPos()).set(blockpos_mutableblockpos);
-        BlockState blockstate = serverlevel.getBlockState(blockpos_mutableblockpos1);
+    private static boolean moveToPossibleSpawnPosition(ServerLevel level, int yOffset, BlockPos.MutableBlockPos pos, SpawnUtil.Strategy strategy) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition1 = (new BlockPos.MutableBlockPos()).set(pos);
+        IBlockData iblockdata = level.getBlockState(blockposition_mutableblockposition1);
 
-        for (int j = i; j >= -i; --j) {
-            blockpos_mutableblockpos.move(Direction.DOWN);
-            blockpos_mutableblockpos1.setWithOffset(blockpos_mutableblockpos, Direction.UP);
-            BlockState blockstate1 = serverlevel.getBlockState(blockpos_mutableblockpos);
+        for (int j = yOffset; j >= -yOffset; --j) {
+            pos.move(Direction.DOWN);
+            blockposition_mutableblockposition1.setWithOffset(pos, Direction.UP);
+            IBlockData iblockdata1 = level.getBlockState(pos);
 
-            if (spawnutil_strategy.canSpawnOn(serverlevel, blockpos_mutableblockpos, blockstate1, blockpos_mutableblockpos1, blockstate)) {
-                blockpos_mutableblockpos.move(Direction.UP);
+            if (strategy.canSpawnOn(level, pos, iblockdata1, blockposition_mutableblockposition1, iblockdata)) {
+                pos.move(Direction.UP);
                 return true;
             }
 
-            blockstate = blockstate1;
+            iblockdata = iblockdata1;
         }
 
         return false;
@@ -69,13 +75,13 @@
 
         /** @deprecated */
         @Deprecated
-        SpawnUtil.Strategy LEGACY_IRON_GOLEM = (serverlevel, blockpos, blockstate, blockpos1, blockstate1) -> {
-            return !blockstate.is(Blocks.COBWEB) && !blockstate.is(Blocks.CACTUS) && !blockstate.is(Blocks.GLASS_PANE) && !(blockstate.getBlock() instanceof StainedGlassPaneBlock) && !(blockstate.getBlock() instanceof StainedGlassBlock) && !(blockstate.getBlock() instanceof LeavesBlock) && !blockstate.is(Blocks.CONDUIT) && !blockstate.is(Blocks.ICE) && !blockstate.is(Blocks.TNT) && !blockstate.is(Blocks.GLOWSTONE) && !blockstate.is(Blocks.BEACON) && !blockstate.is(Blocks.SEA_LANTERN) && !blockstate.is(Blocks.FROSTED_ICE) && !blockstate.is(Blocks.TINTED_GLASS) && !blockstate.is(Blocks.GLASS) ? (blockstate1.isAir() || blockstate1.liquid()) && (blockstate.isSolid() || blockstate.is(Blocks.POWDER_SNOW)) : false;
+        SpawnUtil.Strategy LEGACY_IRON_GOLEM = (worldserver, blockposition, iblockdata, blockposition1, iblockdata1) -> {
+            return !iblockdata.is(Blocks.COBWEB) && !iblockdata.is(Blocks.CACTUS) && !iblockdata.is(Blocks.GLASS_PANE) && !(iblockdata.getBlock() instanceof StainedGlassPaneBlock) && !(iblockdata.getBlock() instanceof StainedGlassBlock) && !(iblockdata.getBlock() instanceof LeavesBlock) && !iblockdata.is(Blocks.CONDUIT) && !iblockdata.is(Blocks.ICE) && !iblockdata.is(Blocks.TNT) && !iblockdata.is(Blocks.GLOWSTONE) && !iblockdata.is(Blocks.BEACON) && !iblockdata.is(Blocks.SEA_LANTERN) && !iblockdata.is(Blocks.FROSTED_ICE) && !iblockdata.is(Blocks.TINTED_GLASS) && !iblockdata.is(Blocks.GLASS) ? (iblockdata1.isAir() || iblockdata1.liquid()) && (iblockdata.isSolid() || iblockdata.is(Blocks.POWDER_SNOW)) : false;
         };
-        SpawnUtil.Strategy ON_TOP_OF_COLLIDER = (serverlevel, blockpos, blockstate, blockpos1, blockstate1) -> {
-            return blockstate1.getCollisionShape(serverlevel, blockpos1).isEmpty() && Block.isFaceFull(blockstate.getCollisionShape(serverlevel, blockpos), Direction.UP);
+        SpawnUtil.Strategy ON_TOP_OF_COLLIDER = (worldserver, blockposition, iblockdata, blockposition1, iblockdata1) -> {
+            return iblockdata1.getCollisionShape(worldserver, blockposition1).isEmpty() && Block.isFaceFull(iblockdata.getCollisionShape(worldserver, blockposition), Direction.UP);
         };
 
-        boolean canSpawnOn(ServerLevel level, BlockPos blockPos, BlockState blockState, BlockPos blockPos1, BlockState blockState1);
+        boolean canSpawnOn(ServerLevel level, BlockPos blockposition, IBlockData iblockdata, BlockPos blockposition1, IBlockData iblockdata1);
     }
 }
