--- a/net/minecraft/server/commands/LootCommand.java
+++ b/net/minecraft/server/commands/LootCommand.java
@@ -15,7 +15,6 @@
 import java.util.List;
 import net.minecraft.commands.CommandBuildContext;
 import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
 import net.minecraft.commands.SharedSuggestionProvider;
 import net.minecraft.commands.arguments.EntityArgument;
 import net.minecraft.commands.arguments.ResourceLocationArgument;
@@ -37,7 +36,7 @@
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.storage.loot.LootDataManager;
 import net.minecraft.world.level.storage.loot.LootDataType;
 import net.minecraft.world.level.storage.loot.LootParams;
@@ -62,98 +61,98 @@
 
     public LootCommand() {}
 
-    public static void register(CommandDispatcher<CommandSourceStack> commanddispatcher, CommandBuildContext commandbuildcontext) {
-        commanddispatcher.register((LiteralArgumentBuilder) addTargets((LiteralArgumentBuilder) Commands.literal("loot").requires((commandsourcestack) -> {
-            return commandsourcestack.hasPermission(2);
-        }), (argumentbuilder, lootcommand_dropconsumer) -> {
-            return argumentbuilder.then(Commands.literal("fish").then(Commands.argument("loot_table", ResourceLocationArgument.id()).suggests(LootCommand.SUGGEST_LOOT_TABLE).then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) ((RequiredArgumentBuilder) Commands.argument("pos", BlockPosArgument.blockPos()).executes((commandcontext) -> {
-                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemStack.EMPTY, lootcommand_dropconsumer);
-            })).then(Commands.argument("tool", ItemArgument.item(commandbuildcontext)).executes((commandcontext) -> {
-                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemArgument.getItem(commandcontext, "tool").createItemStack(1, false), lootcommand_dropconsumer);
-            }))).then(Commands.literal("mainhand").executes((commandcontext) -> {
-                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.MAINHAND), lootcommand_dropconsumer);
-            }))).then(Commands.literal("offhand").executes((commandcontext) -> {
-                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.OFFHAND), lootcommand_dropconsumer);
-            }))))).then(Commands.literal("loot").then(Commands.argument("loot_table", ResourceLocationArgument.id()).suggests(LootCommand.SUGGEST_LOOT_TABLE).executes((commandcontext) -> {
-                return dropChestLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), lootcommand_dropconsumer);
-            }))).then(Commands.literal("kill").then(Commands.argument("target", EntityArgument.entity()).executes((commandcontext) -> {
-                return dropKillLoot(commandcontext, EntityArgument.getEntity(commandcontext, "target"), lootcommand_dropconsumer);
-            }))).then(Commands.literal("mine").then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) ((RequiredArgumentBuilder) Commands.argument("pos", BlockPosArgument.blockPos()).executes((commandcontext) -> {
-                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemStack.EMPTY, lootcommand_dropconsumer);
-            })).then(Commands.argument("tool", ItemArgument.item(commandbuildcontext)).executes((commandcontext) -> {
-                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemArgument.getItem(commandcontext, "tool").createItemStack(1, false), lootcommand_dropconsumer);
-            }))).then(Commands.literal("mainhand").executes((commandcontext) -> {
-                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.MAINHAND), lootcommand_dropconsumer);
-            }))).then(Commands.literal("offhand").executes((commandcontext) -> {
-                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.OFFHAND), lootcommand_dropconsumer);
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext context) {
+        dispatcher.register((LiteralArgumentBuilder) addTargets((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("loot").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
+        }), (argumentbuilder, commandloot_b) -> {
+            return argumentbuilder.then(net.minecraft.commands.Commands.literal("fish").then(net.minecraft.commands.Commands.argument("loot_table", ResourceLocationArgument.id()).suggests(LootCommand.SUGGEST_LOOT_TABLE).then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) ((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("pos", BlockPosArgument.blockPos()).executes((commandcontext) -> {
+                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemStack.EMPTY, commandloot_b);
+            })).then(net.minecraft.commands.Commands.argument("tool", ItemArgument.item(context)).executes((commandcontext) -> {
+                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemArgument.getItem(commandcontext, "tool").createItemStack(1, false), commandloot_b);
+            }))).then(net.minecraft.commands.Commands.literal("mainhand").executes((commandcontext) -> {
+                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.MAINHAND), commandloot_b);
+            }))).then(net.minecraft.commands.Commands.literal("offhand").executes((commandcontext) -> {
+                return dropFishingLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.OFFHAND), commandloot_b);
+            }))))).then(net.minecraft.commands.Commands.literal("loot").then(net.minecraft.commands.Commands.argument("loot_table", ResourceLocationArgument.id()).suggests(LootCommand.SUGGEST_LOOT_TABLE).executes((commandcontext) -> {
+                return dropChestLoot(commandcontext, ResourceLocationArgument.getId(commandcontext, "loot_table"), commandloot_b);
+            }))).then(net.minecraft.commands.Commands.literal("kill").then(net.minecraft.commands.Commands.argument("target", EntityArgument.entity()).executes((commandcontext) -> {
+                return dropKillLoot(commandcontext, EntityArgument.getEntity(commandcontext, "target"), commandloot_b);
+            }))).then(net.minecraft.commands.Commands.literal("mine").then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) ((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("pos", BlockPosArgument.blockPos()).executes((commandcontext) -> {
+                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemStack.EMPTY, commandloot_b);
+            })).then(net.minecraft.commands.Commands.argument("tool", ItemArgument.item(context)).executes((commandcontext) -> {
+                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), ItemArgument.getItem(commandcontext, "tool").createItemStack(1, false), commandloot_b);
+            }))).then(net.minecraft.commands.Commands.literal("mainhand").executes((commandcontext) -> {
+                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.MAINHAND), commandloot_b);
+            }))).then(net.minecraft.commands.Commands.literal("offhand").executes((commandcontext) -> {
+                return dropBlockLoot(commandcontext, BlockPosArgument.getLoadedBlockPos(commandcontext, "pos"), getSourceHandItem((CommandSourceStack) commandcontext.getSource(), EquipmentSlot.OFFHAND), commandloot_b);
             }))));
         }));
     }
 
-    private static <T extends ArgumentBuilder<CommandSourceStack, T>> T addTargets(T t0, LootCommand.TailProvider lootcommand_tailprovider) {
-        return t0.then(((LiteralArgumentBuilder) Commands.literal("replace").then(Commands.literal("entity").then(Commands.argument("entities", EntityArgument.entities()).then(lootcommand_tailprovider.construct(Commands.argument("slot", SlotArgument.slot()), (commandcontext, list, lootcommand_callback) -> {
-            return entityReplace(EntityArgument.getEntities(commandcontext, "entities"), SlotArgument.getSlot(commandcontext, "slot"), list.size(), list, lootcommand_callback);
-        }).then(lootcommand_tailprovider.construct(Commands.argument("count", IntegerArgumentType.integer(0)), (commandcontext, list, lootcommand_callback) -> {
-            return entityReplace(EntityArgument.getEntities(commandcontext, "entities"), SlotArgument.getSlot(commandcontext, "slot"), IntegerArgumentType.getInteger(commandcontext, "count"), list, lootcommand_callback);
-        })))))).then(Commands.literal("block").then(Commands.argument("targetPos", BlockPosArgument.blockPos()).then(lootcommand_tailprovider.construct(Commands.argument("slot", SlotArgument.slot()), (commandcontext, list, lootcommand_callback) -> {
-            return blockReplace((CommandSourceStack) commandcontext.getSource(), BlockPosArgument.getLoadedBlockPos(commandcontext, "targetPos"), SlotArgument.getSlot(commandcontext, "slot"), list.size(), list, lootcommand_callback);
-        }).then(lootcommand_tailprovider.construct(Commands.argument("count", IntegerArgumentType.integer(0)), (commandcontext, list, lootcommand_callback) -> {
-            return blockReplace((CommandSourceStack) commandcontext.getSource(), BlockPosArgument.getLoadedBlockPos(commandcontext, "targetPos"), IntegerArgumentType.getInteger(commandcontext, "slot"), IntegerArgumentType.getInteger(commandcontext, "count"), list, lootcommand_callback);
-        })))))).then(Commands.literal("insert").then(lootcommand_tailprovider.construct(Commands.argument("targetPos", BlockPosArgument.blockPos()), (commandcontext, list, lootcommand_callback) -> {
-            return blockDistribute((CommandSourceStack) commandcontext.getSource(), BlockPosArgument.getLoadedBlockPos(commandcontext, "targetPos"), list, lootcommand_callback);
-        }))).then(Commands.literal("give").then(lootcommand_tailprovider.construct(Commands.argument("players", EntityArgument.players()), (commandcontext, list, lootcommand_callback) -> {
-            return playerGive(EntityArgument.getPlayers(commandcontext, "players"), list, lootcommand_callback);
-        }))).then(Commands.literal("spawn").then(lootcommand_tailprovider.construct(Commands.argument("targetPos", Vec3Argument.vec3()), (commandcontext, list, lootcommand_callback) -> {
-            return dropInWorld((CommandSourceStack) commandcontext.getSource(), Vec3Argument.getVec3(commandcontext, "targetPos"), list, lootcommand_callback);
+    private static <T extends ArgumentBuilder<CommandSourceStack, T>> T addTargets(T builder, LootCommand.TailProvider tailProvider) {
+        return (T) builder.then(((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("replace").then(net.minecraft.commands.Commands.literal("entity").then(net.minecraft.commands.Commands.argument("entities", EntityArgument.entities()).then(tailProvider.construct(net.minecraft.commands.Commands.argument("slot", SlotArgument.slot()), (commandcontext, list, commandloot_a) -> { // CraftBukkit - decompile error
+            return entityReplace(EntityArgument.getEntities(commandcontext, "entities"), SlotArgument.getSlot(commandcontext, "slot"), list.size(), list, commandloot_a);
+        }).then(tailProvider.construct(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(0)), (commandcontext, list, commandloot_a) -> {
+            return entityReplace(EntityArgument.getEntities(commandcontext, "entities"), SlotArgument.getSlot(commandcontext, "slot"), IntegerArgumentType.getInteger(commandcontext, "count"), list, commandloot_a);
+        })))))).then(net.minecraft.commands.Commands.literal("block").then(net.minecraft.commands.Commands.argument("targetPos", BlockPosArgument.blockPos()).then(tailProvider.construct(net.minecraft.commands.Commands.argument("slot", SlotArgument.slot()), (commandcontext, list, commandloot_a) -> {
+            return blockReplace((CommandSourceStack) commandcontext.getSource(), BlockPosArgument.getLoadedBlockPos(commandcontext, "targetPos"), SlotArgument.getSlot(commandcontext, "slot"), list.size(), list, commandloot_a);
+        }).then(tailProvider.construct(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(0)), (commandcontext, list, commandloot_a) -> {
+            return blockReplace((CommandSourceStack) commandcontext.getSource(), BlockPosArgument.getLoadedBlockPos(commandcontext, "targetPos"), IntegerArgumentType.getInteger(commandcontext, "slot"), IntegerArgumentType.getInteger(commandcontext, "count"), list, commandloot_a);
+        })))))).then(net.minecraft.commands.Commands.literal("insert").then(tailProvider.construct(net.minecraft.commands.Commands.argument("targetPos", BlockPosArgument.blockPos()), (commandcontext, list, commandloot_a) -> {
+            return blockDistribute((CommandSourceStack) commandcontext.getSource(), BlockPosArgument.getLoadedBlockPos(commandcontext, "targetPos"), list, commandloot_a);
+        }))).then(net.minecraft.commands.Commands.literal("give").then(tailProvider.construct(net.minecraft.commands.Commands.argument("players", EntityArgument.players()), (commandcontext, list, commandloot_a) -> {
+            return playerGive(EntityArgument.getPlayers(commandcontext, "players"), list, commandloot_a);
+        }))).then(net.minecraft.commands.Commands.literal("spawn").then(tailProvider.construct(net.minecraft.commands.Commands.argument("targetPos", Vec3Argument.vec3()), (commandcontext, list, commandloot_a) -> {
+            return dropInWorld((CommandSourceStack) commandcontext.getSource(), Vec3Argument.getVec3(commandcontext, "targetPos"), list, commandloot_a);
         })));
     }
 
-    private static Container getContainer(CommandSourceStack commandsourcestack, BlockPos blockpos) throws CommandSyntaxException {
-        BlockEntity blockentity = commandsourcestack.getLevel().getBlockEntity(blockpos);
+    private static Container getContainer(CommandSourceStack source, BlockPos pos) throws CommandSyntaxException {
+        BlockEntity tileentity = source.getLevel().getBlockEntity(pos);
 
-        if (!(blockentity instanceof Container)) {
-            throw ItemCommands.ERROR_TARGET_NOT_A_CONTAINER.create(blockpos.getX(), blockpos.getY(), blockpos.getZ());
+        if (!(tileentity instanceof Container)) {
+            throw ItemCommands.ERROR_TARGET_NOT_A_CONTAINER.create(pos.getX(), pos.getY(), pos.getZ());
         } else {
-            return (Container) blockentity;
+            return (Container) tileentity;
         }
     }
 
-    private static int blockDistribute(CommandSourceStack commandsourcestack, BlockPos blockpos, List<ItemStack> list, LootCommand.Callback lootcommand_callback) throws CommandSyntaxException {
-        Container container = getContainer(commandsourcestack, blockpos);
-        List<ItemStack> list1 = Lists.newArrayListWithCapacity(list.size());
-        Iterator iterator = list.iterator();
+    private static int blockDistribute(CommandSourceStack source, BlockPos pos, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
+        Container iinventory = getContainer(source, pos);
+        List<ItemStack> list1 = Lists.newArrayListWithCapacity(items.size());
+        Iterator iterator = items.iterator();
 
         while (iterator.hasNext()) {
             ItemStack itemstack = (ItemStack) iterator.next();
 
-            if (distributeToContainer(container, itemstack.copy())) {
-                container.setChanged();
+            if (distributeToContainer(iinventory, itemstack.copy())) {
+                iinventory.setChanged();
                 list1.add(itemstack);
             }
         }
 
-        lootcommand_callback.accept(list1);
+        callback.accept(list1);
         return list1.size();
     }
 
-    private static boolean distributeToContainer(Container container, ItemStack itemstack) {
+    private static boolean distributeToContainer(Container container, ItemStack item) {
         boolean flag = false;
 
-        for (int i = 0; i < container.getContainerSize() && !itemstack.isEmpty(); ++i) {
+        for (int i = 0; i < container.getContainerSize() && !item.isEmpty(); ++i) {
             ItemStack itemstack1 = container.getItem(i);
 
-            if (container.canPlaceItem(i, itemstack)) {
+            if (container.canPlaceItem(i, item)) {
                 if (itemstack1.isEmpty()) {
-                    container.setItem(i, itemstack);
+                    container.setItem(i, item);
                     flag = true;
                     break;
                 }
 
-                if (canMergeItems(itemstack1, itemstack)) {
-                    int j = itemstack.getMaxStackSize() - itemstack1.getCount();
-                    int k = Math.min(itemstack.getCount(), j);
+                if (canMergeItems(itemstack1, item)) {
+                    int j = item.getMaxStackSize() - itemstack1.getCount();
+                    int k = Math.min(item.getCount(), j);
 
-                    itemstack.shrink(k);
+                    item.shrink(k);
                     itemstack1.grow(k);
                     flag = true;
                 }
@@ -163,205 +162,206 @@
         return flag;
     }
 
-    private static int blockReplace(CommandSourceStack commandsourcestack, BlockPos blockpos, int i, int j, List<ItemStack> list, LootCommand.Callback lootcommand_callback) throws CommandSyntaxException {
-        Container container = getContainer(commandsourcestack, blockpos);
-        int k = container.getContainerSize();
+    private static int blockReplace(CommandSourceStack source, BlockPos pos, int slot, int numSlots, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
+        Container iinventory = getContainer(source, pos);
+        int k = iinventory.getContainerSize();
 
-        if (i >= 0 && i < k) {
-            List<ItemStack> list1 = Lists.newArrayListWithCapacity(list.size());
+        if (slot >= 0 && slot < k) {
+            List<ItemStack> list1 = Lists.newArrayListWithCapacity(items.size());
 
-            for (int l = 0; l < j; ++l) {
-                int i1 = i + l;
-                ItemStack itemstack = l < list.size() ? (ItemStack) list.get(l) : ItemStack.EMPTY;
+            for (int l = 0; l < numSlots; ++l) {
+                int i1 = slot + l;
+                ItemStack itemstack = l < items.size() ? (ItemStack) items.get(l) : ItemStack.EMPTY;
 
-                if (container.canPlaceItem(i1, itemstack)) {
-                    container.setItem(i1, itemstack);
+                if (iinventory.canPlaceItem(i1, itemstack)) {
+                    iinventory.setItem(i1, itemstack);
                     list1.add(itemstack);
                 }
             }
 
-            lootcommand_callback.accept(list1);
+            callback.accept(list1);
             return list1.size();
         } else {
-            throw ItemCommands.ERROR_TARGET_INAPPLICABLE_SLOT.create(i);
+            throw ItemCommands.ERROR_TARGET_INAPPLICABLE_SLOT.create(slot);
         }
     }
 
-    private static boolean canMergeItems(ItemStack itemstack, ItemStack itemstack1) {
-        return itemstack.getCount() <= itemstack.getMaxStackSize() && ItemStack.isSameItemSameTags(itemstack, itemstack1);
+    private static boolean canMergeItems(ItemStack first, ItemStack second) {
+        return first.getCount() <= first.getMaxStackSize() && ItemStack.isSameItemSameTags(first, second);
     }
 
-    private static int playerGive(Collection<ServerPlayer> collection, List<ItemStack> list, LootCommand.Callback lootcommand_callback) throws CommandSyntaxException {
-        List<ItemStack> list1 = Lists.newArrayListWithCapacity(list.size());
-        Iterator iterator = list.iterator();
+    private static int playerGive(Collection<ServerPlayer> targets, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
+        List<ItemStack> list1 = Lists.newArrayListWithCapacity(items.size());
+        Iterator iterator = items.iterator();
 
         while (iterator.hasNext()) {
             ItemStack itemstack = (ItemStack) iterator.next();
-            Iterator iterator1 = collection.iterator();
+            Iterator iterator1 = targets.iterator();
 
             while (iterator1.hasNext()) {
-                ServerPlayer serverplayer = (ServerPlayer) iterator1.next();
+                ServerPlayer entityplayer = (ServerPlayer) iterator1.next();
 
-                if (serverplayer.getInventory().add(itemstack.copy())) {
+                if (entityplayer.getInventory().add(itemstack.copy())) {
                     list1.add(itemstack);
                 }
             }
         }
 
-        lootcommand_callback.accept(list1);
+        callback.accept(list1);
         return list1.size();
     }
 
-    private static void setSlots(Entity entity, List<ItemStack> list, int i, int j, List<ItemStack> list1) {
-        for (int k = 0; k < j; ++k) {
-            ItemStack itemstack = k < list.size() ? (ItemStack) list.get(k) : ItemStack.EMPTY;
-            SlotAccess slotaccess = entity.getSlot(i + k);
+    private static void setSlots(Entity target, List<ItemStack> items, int startSlot, int numSlots, List<ItemStack> setItems) {
+        for (int k = 0; k < numSlots; ++k) {
+            ItemStack itemstack = k < items.size() ? (ItemStack) items.get(k) : ItemStack.EMPTY;
+            SlotAccess slotaccess = target.getSlot(startSlot + k);
 
             if (slotaccess != SlotAccess.NULL && slotaccess.set(itemstack.copy())) {
-                list1.add(itemstack);
+                setItems.add(itemstack);
             }
         }
 
     }
 
-    private static int entityReplace(Collection<? extends Entity> collection, int i, int j, List<ItemStack> list, LootCommand.Callback lootcommand_callback) throws CommandSyntaxException {
-        List<ItemStack> list1 = Lists.newArrayListWithCapacity(list.size());
-        Iterator iterator = collection.iterator();
+    private static int entityReplace(Collection<? extends Entity> targets, int startSlot, int numSlots, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
+        List<ItemStack> list1 = Lists.newArrayListWithCapacity(items.size());
+        Iterator iterator = targets.iterator();
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
             if (entity instanceof ServerPlayer) {
-                ServerPlayer serverplayer = (ServerPlayer) entity;
+                ServerPlayer entityplayer = (ServerPlayer) entity;
 
-                setSlots(entity, list, i, j, list1);
-                serverplayer.containerMenu.broadcastChanges();
+                setSlots(entity, items, startSlot, numSlots, list1);
+                entityplayer.containerMenu.broadcastChanges();
             } else {
-                setSlots(entity, list, i, j, list1);
+                setSlots(entity, items, startSlot, numSlots, list1);
             }
         }
 
-        lootcommand_callback.accept(list1);
+        callback.accept(list1);
         return list1.size();
     }
 
-    private static int dropInWorld(CommandSourceStack commandsourcestack, Vec3 vec3, List<ItemStack> list, LootCommand.Callback lootcommand_callback) throws CommandSyntaxException {
-        ServerLevel serverlevel = commandsourcestack.getLevel();
+    private static int dropInWorld(CommandSourceStack source, Vec3 pos, List<ItemStack> items, LootCommand.Callback callback) throws CommandSyntaxException {
+        ServerLevel worldserver = source.getLevel();
 
-        list.forEach((itemstack) -> {
-            ItemEntity itementity = new ItemEntity(serverlevel, vec3.x, vec3.y, vec3.z, itemstack.copy());
+        items.removeIf(ItemStack::isEmpty); // CraftBukkit - SPIGOT-6959 Remove empty items for avoid throw an error in new EntityItem
+        items.forEach((itemstack) -> {
+            ItemEntity entityitem = new ItemEntity(worldserver, pos.x, pos.y, pos.z, itemstack.copy());
 
-            itementity.setDefaultPickUpDelay();
-            serverlevel.addFreshEntity(itementity);
+            entityitem.setDefaultPickUpDelay();
+            worldserver.addFreshEntity(entityitem);
         });
-        lootcommand_callback.accept(list);
-        return list.size();
+        callback.accept(items);
+        return items.size();
     }
 
-    private static void callback(CommandSourceStack commandsourcestack, List<ItemStack> list) {
-        if (list.size() == 1) {
-            ItemStack itemstack = (ItemStack) list.get(0);
+    private static void callback(CommandSourceStack source, List<ItemStack> items) {
+        if (items.size() == 1) {
+            ItemStack itemstack = (ItemStack) items.get(0);
 
-            commandsourcestack.sendSuccess(() -> {
+            source.sendSuccess(() -> {
                 return Component.translatable("commands.drop.success.single", itemstack.getCount(), itemstack.getDisplayName());
             }, false);
         } else {
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.drop.success.multiple", list.size());
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.drop.success.multiple", items.size());
             }, false);
         }
 
     }
 
-    private static void callback(CommandSourceStack commandsourcestack, List<ItemStack> list, ResourceLocation resourcelocation) {
-        if (list.size() == 1) {
-            ItemStack itemstack = (ItemStack) list.get(0);
+    private static void callback(CommandSourceStack source, List<ItemStack> items, ResourceLocation lootTable) {
+        if (items.size() == 1) {
+            ItemStack itemstack = (ItemStack) items.get(0);
 
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.drop.success.single_with_table", itemstack.getCount(), itemstack.getDisplayName(), Component.translationArg(resourcelocation));
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.drop.success.single_with_table", itemstack.getCount(), itemstack.getDisplayName(), Component.translationArg(lootTable));
             }, false);
         } else {
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.drop.success.multiple_with_table", list.size(), Component.translationArg(resourcelocation));
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.drop.success.multiple_with_table", items.size(), Component.translationArg(lootTable));
             }, false);
         }
 
     }
 
-    private static ItemStack getSourceHandItem(CommandSourceStack commandsourcestack, EquipmentSlot equipmentslot) throws CommandSyntaxException {
-        Entity entity = commandsourcestack.getEntityOrException();
+    private static ItemStack getSourceHandItem(CommandSourceStack source, EquipmentSlot slot) throws CommandSyntaxException {
+        Entity entity = source.getEntityOrException();
 
         if (entity instanceof LivingEntity) {
-            return ((LivingEntity) entity).getItemBySlot(equipmentslot);
+            return ((LivingEntity) entity).getItemBySlot(slot);
         } else {
             throw LootCommand.ERROR_NO_HELD_ITEMS.create(entity.getDisplayName());
         }
     }
 
-    private static int dropBlockLoot(CommandContext<CommandSourceStack> commandcontext, BlockPos blockpos, ItemStack itemstack, LootCommand.DropConsumer lootcommand_dropconsumer) throws CommandSyntaxException {
-        CommandSourceStack commandsourcestack = (CommandSourceStack) commandcontext.getSource();
-        ServerLevel serverlevel = commandsourcestack.getLevel();
-        BlockState blockstate = serverlevel.getBlockState(blockpos);
-        BlockEntity blockentity = serverlevel.getBlockEntity(blockpos);
-        LootParams.Builder lootparams_builder = (new LootParams.Builder(serverlevel)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(blockpos)).withParameter(LootContextParams.BLOCK_STATE, blockstate).withOptionalParameter(LootContextParams.BLOCK_ENTITY, blockentity).withOptionalParameter(LootContextParams.THIS_ENTITY, commandsourcestack.getEntity()).withParameter(LootContextParams.TOOL, itemstack);
-        List<ItemStack> list = blockstate.getDrops(lootparams_builder);
+    private static int dropBlockLoot(CommandContext<CommandSourceStack> context, BlockPos pos, ItemStack tool, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
+        CommandSourceStack commandlistenerwrapper = (CommandSourceStack) context.getSource();
+        ServerLevel worldserver = commandlistenerwrapper.getLevel();
+        IBlockData iblockdata = worldserver.getBlockState(pos);
+        BlockEntity tileentity = worldserver.getBlockEntity(pos);
+        LootParams.Builder lootparams_a = (new LootParams.Builder(worldserver)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(pos)).withParameter(LootContextParams.BLOCK_STATE, iblockdata).withOptionalParameter(LootContextParams.BLOCK_ENTITY, tileentity).withOptionalParameter(LootContextParams.THIS_ENTITY, commandlistenerwrapper.getEntity()).withParameter(LootContextParams.TOOL, tool);
+        List<ItemStack> list = iblockdata.getDrops(lootparams_a);
 
-        return lootcommand_dropconsumer.accept(commandcontext, list, (list1) -> {
-            callback(commandsourcestack, list1, blockstate.getBlock().getLootTable());
+        return dropConsumer.accept(context, list, (list1) -> {
+            callback(commandlistenerwrapper, list1, iblockdata.getBlock().getLootTable());
         });
     }
 
-    private static int dropKillLoot(CommandContext<CommandSourceStack> commandcontext, Entity entity, LootCommand.DropConsumer lootcommand_dropconsumer) throws CommandSyntaxException {
+    private static int dropKillLoot(CommandContext<CommandSourceStack> context, Entity entity, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
         if (!(entity instanceof LivingEntity)) {
             throw LootCommand.ERROR_NO_LOOT_TABLE.create(entity.getDisplayName());
         } else {
-            ResourceLocation resourcelocation = ((LivingEntity) entity).getLootTable();
-            CommandSourceStack commandsourcestack = (CommandSourceStack) commandcontext.getSource();
-            LootParams.Builder lootparams_builder = new LootParams.Builder(commandsourcestack.getLevel());
-            Entity entity1 = commandsourcestack.getEntity();
+            ResourceLocation minecraftkey = ((LivingEntity) entity).getLootTable();
+            CommandSourceStack commandlistenerwrapper = (CommandSourceStack) context.getSource();
+            LootParams.Builder lootparams_a = new LootParams.Builder(commandlistenerwrapper.getLevel());
+            Entity entity1 = commandlistenerwrapper.getEntity();
 
             if (entity1 instanceof Player) {
-                Player player = (Player) entity1;
+                Player entityhuman = (Player) entity1;
 
-                lootparams_builder.withParameter(LootContextParams.LAST_DAMAGE_PLAYER, player);
+                lootparams_a.withParameter(LootContextParams.LAST_DAMAGE_PLAYER, entityhuman);
             }
 
-            lootparams_builder.withParameter(LootContextParams.DAMAGE_SOURCE, entity.damageSources().magic());
-            lootparams_builder.withOptionalParameter(LootContextParams.DIRECT_KILLER_ENTITY, entity1);
-            lootparams_builder.withOptionalParameter(LootContextParams.KILLER_ENTITY, entity1);
-            lootparams_builder.withParameter(LootContextParams.THIS_ENTITY, entity);
-            lootparams_builder.withParameter(LootContextParams.ORIGIN, commandsourcestack.getPosition());
-            LootParams lootparams = lootparams_builder.create(LootContextParamSets.ENTITY);
-            LootTable loottable = commandsourcestack.getServer().getLootData().getLootTable(resourcelocation);
+            lootparams_a.withParameter(LootContextParams.DAMAGE_SOURCE, entity.damageSources().magic());
+            lootparams_a.withOptionalParameter(LootContextParams.DIRECT_KILLER_ENTITY, entity1);
+            lootparams_a.withOptionalParameter(LootContextParams.KILLER_ENTITY, entity1);
+            lootparams_a.withParameter(LootContextParams.THIS_ENTITY, entity);
+            lootparams_a.withParameter(LootContextParams.ORIGIN, commandlistenerwrapper.getPosition());
+            LootParams lootparams = lootparams_a.create(LootContextParamSets.ENTITY);
+            LootTable loottable = commandlistenerwrapper.getServer().getLootData().getLootTable(minecraftkey);
             List<ItemStack> list = loottable.getRandomItems(lootparams);
 
-            return lootcommand_dropconsumer.accept(commandcontext, list, (list1) -> {
-                callback(commandsourcestack, list1, resourcelocation);
+            return dropConsumer.accept(context, list, (list1) -> {
+                callback(commandlistenerwrapper, list1, minecraftkey);
             });
         }
     }
 
-    private static int dropChestLoot(CommandContext<CommandSourceStack> commandcontext, ResourceLocation resourcelocation, LootCommand.DropConsumer lootcommand_dropconsumer) throws CommandSyntaxException {
-        CommandSourceStack commandsourcestack = (CommandSourceStack) commandcontext.getSource();
-        LootParams lootparams = (new LootParams.Builder(commandsourcestack.getLevel())).withOptionalParameter(LootContextParams.THIS_ENTITY, commandsourcestack.getEntity()).withParameter(LootContextParams.ORIGIN, commandsourcestack.getPosition()).create(LootContextParamSets.CHEST);
+    private static int dropChestLoot(CommandContext<CommandSourceStack> context, ResourceLocation lootTable, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
+        CommandSourceStack commandlistenerwrapper = (CommandSourceStack) context.getSource();
+        LootParams lootparams = (new LootParams.Builder(commandlistenerwrapper.getLevel())).withOptionalParameter(LootContextParams.THIS_ENTITY, commandlistenerwrapper.getEntity()).withParameter(LootContextParams.ORIGIN, commandlistenerwrapper.getPosition()).create(LootContextParamSets.CHEST);
 
-        return drop(commandcontext, resourcelocation, lootparams, lootcommand_dropconsumer);
+        return drop(context, lootTable, lootparams, dropConsumer);
     }
 
-    private static int dropFishingLoot(CommandContext<CommandSourceStack> commandcontext, ResourceLocation resourcelocation, BlockPos blockpos, ItemStack itemstack, LootCommand.DropConsumer lootcommand_dropconsumer) throws CommandSyntaxException {
-        CommandSourceStack commandsourcestack = (CommandSourceStack) commandcontext.getSource();
-        LootParams lootparams = (new LootParams.Builder(commandsourcestack.getLevel())).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(blockpos)).withParameter(LootContextParams.TOOL, itemstack).withOptionalParameter(LootContextParams.THIS_ENTITY, commandsourcestack.getEntity()).create(LootContextParamSets.FISHING);
+    private static int dropFishingLoot(CommandContext<CommandSourceStack> context, ResourceLocation lootTable, BlockPos pos, ItemStack tool, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
+        CommandSourceStack commandlistenerwrapper = (CommandSourceStack) context.getSource();
+        LootParams lootparams = (new LootParams.Builder(commandlistenerwrapper.getLevel())).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(pos)).withParameter(LootContextParams.TOOL, tool).withOptionalParameter(LootContextParams.THIS_ENTITY, commandlistenerwrapper.getEntity()).create(LootContextParamSets.FISHING);
 
-        return drop(commandcontext, resourcelocation, lootparams, lootcommand_dropconsumer);
+        return drop(context, lootTable, lootparams, dropConsumer);
     }
 
-    private static int drop(CommandContext<CommandSourceStack> commandcontext, ResourceLocation resourcelocation, LootParams lootparams, LootCommand.DropConsumer lootcommand_dropconsumer) throws CommandSyntaxException {
-        CommandSourceStack commandsourcestack = (CommandSourceStack) commandcontext.getSource();
-        LootTable loottable = commandsourcestack.getServer().getLootData().getLootTable(resourcelocation);
-        List<ItemStack> list = loottable.getRandomItems(lootparams);
+    private static int drop(CommandContext<CommandSourceStack> context, ResourceLocation lootTable, LootParams params, LootCommand.DropConsumer dropConsumer) throws CommandSyntaxException {
+        CommandSourceStack commandlistenerwrapper = (CommandSourceStack) context.getSource();
+        LootTable loottable = commandlistenerwrapper.getServer().getLootData().getLootTable(lootTable);
+        List<ItemStack> list = loottable.getRandomItems(params);
 
-        return lootcommand_dropconsumer.accept(commandcontext, list, (list1) -> {
-            callback(commandsourcestack, list1);
+        return dropConsumer.accept(context, list, (list1) -> {
+            callback(commandlistenerwrapper, list1);
         });
     }
 
