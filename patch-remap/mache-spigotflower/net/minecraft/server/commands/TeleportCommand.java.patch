--- a/net/minecraft/server/commands/TeleportCommand.java
+++ b/net/minecraft/server/commands/TeleportCommand.java
@@ -14,7 +14,6 @@
 import java.util.Set;
 import javax.annotation.Nullable;
 import net.minecraft.commands.CommandSourceStack;
-import net.minecraft.commands.Commands;
 import net.minecraft.commands.arguments.EntityAnchorArgument;
 import net.minecraft.commands.arguments.EntityArgument;
 import net.minecraft.commands.arguments.coordinates.Coordinates;
@@ -33,6 +32,12 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
+// CraftBukkit start
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.event.entity.EntityTeleportEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+// CraftBukkit end
 
 public class TeleportCommand {
 
@@ -40,133 +45,156 @@
 
     public TeleportCommand() {}
 
-    public static void register(CommandDispatcher<CommandSourceStack> commanddispatcher) {
-        LiteralCommandNode<CommandSourceStack> literalcommandnode = commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) Commands.literal("teleport").requires((commandsourcestack) -> {
-            return commandsourcestack.hasPermission(2);
-        })).then(Commands.argument("location", Vec3Argument.vec3()).executes((commandcontext) -> {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        LiteralCommandNode<CommandSourceStack> literalcommandnode = dispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("teleport").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
+        })).then(net.minecraft.commands.Commands.argument("location", Vec3Argument.vec3()).executes((commandcontext) -> {
             return teleportToPos((CommandSourceStack) commandcontext.getSource(), Collections.singleton(((CommandSourceStack) commandcontext.getSource()).getEntityOrException()), ((CommandSourceStack) commandcontext.getSource()).getLevel(), Vec3Argument.getCoordinates(commandcontext, "location"), WorldCoordinates.current(), (TeleportCommand.LookAt) null);
-        }))).then(Commands.argument("destination", EntityArgument.entity()).executes((commandcontext) -> {
+        }))).then(net.minecraft.commands.Commands.argument("destination", EntityArgument.entity()).executes((commandcontext) -> {
             return teleportToEntity((CommandSourceStack) commandcontext.getSource(), Collections.singleton(((CommandSourceStack) commandcontext.getSource()).getEntityOrException()), EntityArgument.getEntity(commandcontext, "destination"));
-        }))).then(((RequiredArgumentBuilder) Commands.argument("targets", EntityArgument.entities()).then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) Commands.argument("location", Vec3Argument.vec3()).executes((commandcontext) -> {
+        }))).then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("targets", EntityArgument.entities()).then(((RequiredArgumentBuilder) ((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("location", Vec3Argument.vec3()).executes((commandcontext) -> {
             return teleportToPos((CommandSourceStack) commandcontext.getSource(), EntityArgument.getEntities(commandcontext, "targets"), ((CommandSourceStack) commandcontext.getSource()).getLevel(), Vec3Argument.getCoordinates(commandcontext, "location"), (Coordinates) null, (TeleportCommand.LookAt) null);
-        })).then(Commands.argument("rotation", RotationArgument.rotation()).executes((commandcontext) -> {
+        })).then(net.minecraft.commands.Commands.argument("rotation", RotationArgument.rotation()).executes((commandcontext) -> {
             return teleportToPos((CommandSourceStack) commandcontext.getSource(), EntityArgument.getEntities(commandcontext, "targets"), ((CommandSourceStack) commandcontext.getSource()).getLevel(), Vec3Argument.getCoordinates(commandcontext, "location"), RotationArgument.getRotation(commandcontext, "rotation"), (TeleportCommand.LookAt) null);
-        }))).then(((LiteralArgumentBuilder) Commands.literal("facing").then(Commands.literal("entity").then(((RequiredArgumentBuilder) Commands.argument("facingEntity", EntityArgument.entity()).executes((commandcontext) -> {
+        }))).then(((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("facing").then(net.minecraft.commands.Commands.literal("entity").then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("facingEntity", EntityArgument.entity()).executes((commandcontext) -> {
             return teleportToPos((CommandSourceStack) commandcontext.getSource(), EntityArgument.getEntities(commandcontext, "targets"), ((CommandSourceStack) commandcontext.getSource()).getLevel(), Vec3Argument.getCoordinates(commandcontext, "location"), (Coordinates) null, new TeleportCommand.LookAt(EntityArgument.getEntity(commandcontext, "facingEntity"), EntityAnchorArgument.Anchor.FEET));
-        })).then(Commands.argument("facingAnchor", EntityAnchorArgument.anchor()).executes((commandcontext) -> {
+        })).then(net.minecraft.commands.Commands.argument("facingAnchor", EntityAnchorArgument.anchor()).executes((commandcontext) -> {
             return teleportToPos((CommandSourceStack) commandcontext.getSource(), EntityArgument.getEntities(commandcontext, "targets"), ((CommandSourceStack) commandcontext.getSource()).getLevel(), Vec3Argument.getCoordinates(commandcontext, "location"), (Coordinates) null, new TeleportCommand.LookAt(EntityArgument.getEntity(commandcontext, "facingEntity"), EntityAnchorArgument.getAnchor(commandcontext, "facingAnchor")));
-        }))))).then(Commands.argument("facingLocation", Vec3Argument.vec3()).executes((commandcontext) -> {
+        }))))).then(net.minecraft.commands.Commands.argument("facingLocation", Vec3Argument.vec3()).executes((commandcontext) -> {
             return teleportToPos((CommandSourceStack) commandcontext.getSource(), EntityArgument.getEntities(commandcontext, "targets"), ((CommandSourceStack) commandcontext.getSource()).getLevel(), Vec3Argument.getCoordinates(commandcontext, "location"), (Coordinates) null, new TeleportCommand.LookAt(Vec3Argument.getVec3(commandcontext, "facingLocation")));
-        }))))).then(Commands.argument("destination", EntityArgument.entity()).executes((commandcontext) -> {
+        }))))).then(net.minecraft.commands.Commands.argument("destination", EntityArgument.entity()).executes((commandcontext) -> {
             return teleportToEntity((CommandSourceStack) commandcontext.getSource(), EntityArgument.getEntities(commandcontext, "targets"), EntityArgument.getEntity(commandcontext, "destination"));
         }))));
 
-        commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) Commands.literal("tp").requires((commandsourcestack) -> {
-            return commandsourcestack.hasPermission(2);
+        dispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("tp").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(2);
         })).redirect(literalcommandnode));
     }
 
-    private static int teleportToEntity(CommandSourceStack commandsourcestack, Collection<? extends Entity> collection, Entity entity) throws CommandSyntaxException {
-        Iterator iterator = collection.iterator();
+    private static int teleportToEntity(CommandSourceStack source, Collection<? extends Entity> targets, Entity destination) throws CommandSyntaxException {
+        Iterator iterator = targets.iterator();
 
         while (iterator.hasNext()) {
             Entity entity1 = (Entity) iterator.next();
 
-            performTeleport(commandsourcestack, entity1, (ServerLevel) entity.level(), entity.getX(), entity.getY(), entity.getZ(), EnumSet.noneOf(RelativeMovement.class), entity.getYRot(), entity.getXRot(), (TeleportCommand.LookAt) null);
+            performTeleport(source, entity1, (ServerLevel) destination.level(), destination.getX(), destination.getY(), destination.getZ(), EnumSet.noneOf(RelativeMovement.class), destination.getYRot(), destination.getXRot(), (TeleportCommand.LookAt) null);
         }
 
-        if (collection.size() == 1) {
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.teleport.success.entity.single", ((Entity) collection.iterator().next()).getDisplayName(), entity.getDisplayName());
+        if (targets.size() == 1) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.teleport.success.entity.single", ((Entity) targets.iterator().next()).getDisplayName(), destination.getDisplayName());
             }, true);
         } else {
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.teleport.success.entity.multiple", collection.size(), entity.getDisplayName());
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.teleport.success.entity.multiple", targets.size(), destination.getDisplayName());
             }, true);
         }
 
-        return collection.size();
+        return targets.size();
     }
 
-    private static int teleportToPos(CommandSourceStack commandsourcestack, Collection<? extends Entity> collection, ServerLevel serverlevel, Coordinates coordinates, @Nullable Coordinates coordinates1, @Nullable TeleportCommand.LookAt teleportcommand_lookat) throws CommandSyntaxException {
-        Vec3 vec3 = coordinates.getPosition(commandsourcestack);
-        Vec2 vec2 = coordinates1 == null ? null : coordinates1.getRotation(commandsourcestack);
+    private static int teleportToPos(CommandSourceStack source, Collection<? extends Entity> targets, ServerLevel level, Coordinates position, @Nullable Coordinates rotation, @Nullable TeleportCommand.LookAt facing) throws CommandSyntaxException {
+        Vec3 vec3d = position.getPosition(source);
+        Vec2 vec2f = rotation == null ? null : rotation.getRotation(source);
         Set<RelativeMovement> set = EnumSet.noneOf(RelativeMovement.class);
 
-        if (coordinates.isXRelative()) {
+        if (position.isXRelative()) {
             set.add(RelativeMovement.X);
         }
 
-        if (coordinates.isYRelative()) {
+        if (position.isYRelative()) {
             set.add(RelativeMovement.Y);
         }
 
-        if (coordinates.isZRelative()) {
+        if (position.isZRelative()) {
             set.add(RelativeMovement.Z);
         }
 
-        if (coordinates1 == null) {
+        if (rotation == null) {
             set.add(RelativeMovement.X_ROT);
             set.add(RelativeMovement.Y_ROT);
         } else {
-            if (coordinates1.isXRelative()) {
+            if (rotation.isXRelative()) {
                 set.add(RelativeMovement.X_ROT);
             }
 
-            if (coordinates1.isYRelative()) {
+            if (rotation.isYRelative()) {
                 set.add(RelativeMovement.Y_ROT);
             }
         }
 
-        Iterator iterator = collection.iterator();
+        Iterator iterator = targets.iterator();
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
-            if (coordinates1 == null) {
-                performTeleport(commandsourcestack, entity, serverlevel, vec3.x, vec3.y, vec3.z, set, entity.getYRot(), entity.getXRot(), teleportcommand_lookat);
+            if (rotation == null) {
+                performTeleport(source, entity, level, vec3d.x, vec3d.y, vec3d.z, set, entity.getYRot(), entity.getXRot(), facing);
             } else {
-                performTeleport(commandsourcestack, entity, serverlevel, vec3.x, vec3.y, vec3.z, set, vec2.y, vec2.x, teleportcommand_lookat);
+                performTeleport(source, entity, level, vec3d.x, vec3d.y, vec3d.z, set, vec2f.y, vec2f.x, facing);
             }
         }
 
-        if (collection.size() == 1) {
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.teleport.success.location.single", ((Entity) collection.iterator().next()).getDisplayName(), formatDouble(vec3.x), formatDouble(vec3.y), formatDouble(vec3.z));
+        if (targets.size() == 1) {
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.teleport.success.location.single", ((Entity) targets.iterator().next()).getDisplayName(), formatDouble(vec3d.x), formatDouble(vec3d.y), formatDouble(vec3d.z));
             }, true);
         } else {
-            commandsourcestack.sendSuccess(() -> {
-                return Component.translatable("commands.teleport.success.location.multiple", collection.size(), formatDouble(vec3.x), formatDouble(vec3.y), formatDouble(vec3.z));
+            source.sendSuccess(() -> {
+                return Component.translatable("commands.teleport.success.location.multiple", targets.size(), formatDouble(vec3d.x), formatDouble(vec3d.y), formatDouble(vec3d.z));
             }, true);
         }
 
-        return collection.size();
+        return targets.size();
     }
 
-    private static String formatDouble(double d0) {
-        return String.format(Locale.ROOT, "%f", d0);
+    private static String formatDouble(double value) {
+        return String.format(Locale.ROOT, "%f", value);
     }
 
-    private static void performTeleport(CommandSourceStack commandsourcestack, Entity entity, ServerLevel serverlevel, double d0, double d1, double d2, Set<RelativeMovement> set, float f, float f1, @Nullable TeleportCommand.LookAt teleportcommand_lookat) throws CommandSyntaxException {
-        BlockPos blockpos = BlockPos.containing(d0, d1, d2);
+    private static void performTeleport(CommandSourceStack source, Entity entity, ServerLevel level, double x, double d1, double y, Set<RelativeMovement> set, float z, float f1, @Nullable TeleportCommand.LookAt relativeList) throws CommandSyntaxException {
+        BlockPos blockposition = BlockPos.containing(x, d1, y);
 
-        if (!Level.isInSpawnableBounds(blockpos)) {
+        if (!Level.isInSpawnableBounds(blockposition)) {
             throw TeleportCommand.INVALID_POSITION.create();
         } else {
-            float f2 = Mth.wrapDegrees(f);
+            float f2 = Mth.wrapDegrees(z);
             float f3 = Mth.wrapDegrees(f1);
 
-            if (entity.teleportTo(serverlevel, d0, d1, d2, set, f2, f3)) {
-                if (teleportcommand_lookat != null) {
-                    teleportcommand_lookat.perform(commandsourcestack, entity);
+            // CraftBukkit start - Teleport event
+            boolean result;
+            if (entity instanceof ServerPlayer player) {
+                result = player.teleportTo(level, x, d1, y, set, f2, f3, PlayerTeleportEvent.TeleportCause.COMMAND);
+            } else {
+                Location to = new Location(level.getWorld(), x, d1, y, f2, f3);
+                EntityTeleportEvent event = new EntityTeleportEvent(entity.getBukkitEntity(), entity.getBukkitEntity().getLocation(), to);
+                level.getCraftServer().getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return;
                 }
 
+                x = to.getX();
+                d1 = to.getY();
+                y = to.getZ();
+                f2 = to.getYaw();
+                f3 = to.getPitch();
+                level = ((CraftWorld) to.getWorld()).getHandle();
+
+                result = entity.teleportTo(level, x, d1, y, set, f2, f3);
+            }
+
+            if (result) {
+                // CraftBukkit end
+                if (relativeList != null) {
+                    relativeList.perform(source, entity);
+                }
+
                 label23:
                 {
                     if (entity instanceof LivingEntity) {
-                        LivingEntity livingentity = (LivingEntity) entity;
+                        LivingEntity entityliving = (LivingEntity) entity;
 
-                        if (livingentity.isFallFlying()) {
+                        if (entityliving.isFallFlying()) {
                             break label23;
                         }
                     }
@@ -176,9 +204,9 @@
                 }
 
                 if (entity instanceof PathfinderMob) {
-                    PathfinderMob pathfindermob = (PathfinderMob) entity;
+                    PathfinderMob entitycreature = (PathfinderMob) entity;
 
-                    pathfindermob.getNavigation().stop();
+                    entitycreature.getNavigation().stop();
                 }
 
             }
@@ -191,27 +219,27 @@
         private final Entity entity;
         private final EntityAnchorArgument.Anchor anchor;
 
-        public LookAt(Entity entity, EntityAnchorArgument.Anchor entityanchorargument_anchor) {
+        public LookAt(Entity entity, EntityAnchorArgument.Anchor anchor) {
             this.entity = entity;
-            this.anchor = entityanchorargument_anchor;
-            this.position = entityanchorargument_anchor.apply(entity);
+            this.anchor = anchor;
+            this.position = anchor.apply(entity);
         }
 
-        public LookAt(Vec3 vec3) {
+        public LookAt(Vec3 position) {
             this.entity = null;
-            this.position = vec3;
+            this.position = position;
             this.anchor = null;
         }
 
-        public void perform(CommandSourceStack commandsourcestack, Entity entity) {
+        public void perform(CommandSourceStack source, Entity entity) {
             if (this.entity != null) {
                 if (entity instanceof ServerPlayer) {
-                    ((ServerPlayer) entity).lookAt(commandsourcestack.getAnchor(), this.entity, this.anchor);
+                    ((ServerPlayer) entity).lookAt(source.getAnchor(), this.entity, this.anchor);
                 } else {
-                    entity.lookAt(commandsourcestack.getAnchor(), this.position);
+                    entity.lookAt(source.getAnchor(), this.position);
                 }
             } else {
-                entity.lookAt(commandsourcestack.getAnchor(), this.position);
+                entity.lookAt(source.getAnchor(), this.position);
             }
 
         }
