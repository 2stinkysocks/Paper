--- a/net/minecraft/server/level/DistanceManager.java
+++ b/net/minecraft/server/level/DistanceManager.java
@@ -43,7 +43,7 @@
     static final int PLAYER_TICKET_LEVEL = ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING);
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
     final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
-    final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
+    public final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker();
     private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8);
     private final TickingTracker tickingTicketsTracker = new TickingTracker();
@@ -57,15 +57,15 @@
     private long ticketTickCounter;
     private int simulationDistance = 10;
 
-    protected DistanceManager(Executor executor, Executor executor1) {
-        Objects.requireNonNull(executor1);
-        ProcessorHandle<Runnable> processorhandle = ProcessorHandle.of("player ticket throttler", executor1::execute);
-        ChunkTaskPriorityQueueSorter chunktaskpriorityqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(processorhandle), executor, 4);
+    protected DistanceManager(Executor dispatcher, Executor mainThreadExecutor) {
+        Objects.requireNonNull(mainThreadExecutor);
+        ProcessorHandle<Runnable> mailbox = ProcessorHandle.of("player ticket throttler", mainThreadExecutor::execute);
+        ChunkTaskPriorityQueueSorter chunktaskqueuesorter = new ChunkTaskPriorityQueueSorter(ImmutableList.of(mailbox), dispatcher, 4);
 
-        this.ticketThrottler = chunktaskpriorityqueuesorter;
-        this.ticketThrottlerInput = chunktaskpriorityqueuesorter.getProcessor(processorhandle, true);
-        this.ticketThrottlerReleaser = chunktaskpriorityqueuesorter.getReleaseProcessor(processorhandle);
-        this.mainThreadExecutor = executor1;
+        this.ticketThrottler = chunktaskqueuesorter;
+        this.ticketThrottlerInput = chunktaskqueuesorter.getProcessor(mailbox, true);
+        this.ticketThrottlerReleaser = chunktaskqueuesorter.getReleaseProcessor(mailbox);
+        this.mainThreadExecutor = mainThreadExecutor;
     }
 
     protected void purgeStaleTickets() {
@@ -98,8 +98,8 @@
 
     }
 
-    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> sortedarrayset) {
-        return !sortedarrayset.isEmpty() ? ((Ticket) sortedarrayset.first()).getTicketLevel() : ChunkLevel.MAX_LEVEL + 1;
+    private static int getTicketLevelAt(SortedArraySet<Ticket<?>> tickets) {
+        return !tickets.isEmpty() ? ((Ticket) tickets.first()).getTicketLevel() : ChunkLevel.MAX_LEVEL + 1;
     }
 
     protected abstract boolean isChunkToRemove(long chunkPos);
@@ -108,9 +108,9 @@
     protected abstract ChunkHolder getChunk(long chunkPos);
 
     @Nullable
-    protected abstract ChunkHolder updateChunkScheduling(long chunkPos, int i, @Nullable ChunkHolder newLevel, int holder);
+    protected abstract ChunkHolder updateChunkScheduling(long chunkPos, int j, @Nullable ChunkHolder newLevel, int holder);
 
-    public boolean runAllUpdates(ChunkMap chunkmap) {
+    public boolean runAllUpdates(ChunkMap chunkManager) {
         this.naturalSpawnChunkCounter.runAllUpdates();
         this.tickingTicketsTracker.runAllUpdates();
         this.playerTicketManager.runAllUpdates();
@@ -122,10 +122,25 @@
         }
 
         if (!this.chunksToUpdateFutures.isEmpty()) {
-            this.chunksToUpdateFutures.forEach((chunkholder) -> {
-                chunkholder.updateFutures(chunkmap, this.mainThreadExecutor);
-            });
-            this.chunksToUpdateFutures.clear();
+            // CraftBukkit start
+            // Iterate pending chunk updates with protection against concurrent modification exceptions
+            java.util.Iterator<ChunkHolder> iter = this.chunksToUpdateFutures.iterator();
+            int expectedSize = this.chunksToUpdateFutures.size();
+            do {
+                ChunkHolder playerchunk = iter.next();
+                iter.remove();
+                expectedSize--;
+
+                playerchunk.updateFutures(chunkManager, this.mainThreadExecutor);
+
+                // Reset iterator if set was modified using add()
+                if (this.chunksToUpdateFutures.size() != expectedSize) {
+                    expectedSize = this.chunksToUpdateFutures.size();
+                    iter = this.chunksToUpdateFutures.iterator();
+                }
+            } while (iter.hasNext());
+            // CraftBukkit end
+
             return true;
         } else {
             if (!this.ticketsToRelease.isEmpty()) {
@@ -137,13 +152,13 @@
                     if (this.getTickets(j).stream().anyMatch((ticket) -> {
                         return ticket.getType() == TicketType.PLAYER;
                     })) {
-                        ChunkHolder chunkholder = chunkmap.getUpdatingChunkIfPresent(j);
+                        ChunkHolder playerchunk = chunkManager.getUpdatingChunkIfPresent(j);
 
-                        if (chunkholder == null) {
+                        if (playerchunk == null) {
                             throw new IllegalStateException();
                         }
 
-                        CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>> completablefuture = chunkholder.getEntityTickingChunkFuture();
+                        CompletableFuture<Either<LevelChunk, ChunkHolder.Failure>> completablefuture = playerchunk.getEntityTickingChunkFuture();
 
                         completablefuture.thenAccept((either) -> {
                             this.mainThreadExecutor.execute(() -> {
@@ -161,69 +176,86 @@
         }
     }
 
-    void addTicket(long i, Ticket<?> ticket) {
-        SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(i);
-        int j = getTicketLevelAt(sortedarrayset);
-        Ticket<?> ticket1 = (Ticket) sortedarrayset.addOrGet(ticket);
+    boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
+        int j = getTicketLevelAt(arraysetsorted);
+        Ticket<?> ticket1 = (Ticket) arraysetsorted.addOrGet(ticket);
 
         ticket1.setCreatedTick(this.ticketTickCounter);
         if (ticket.getTicketLevel() < j) {
             this.ticketTracker.update(i, ticket.getTicketLevel(), true);
         }
 
+        return ticket == ticket1; // CraftBukkit
     }
 
-    void removeTicket(long i, Ticket<?> ticket) {
-        SortedArraySet<Ticket<?>> sortedarrayset = this.getTickets(i);
+    boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        SortedArraySet<Ticket<?>> arraysetsorted = this.getTickets(i);
 
-        if (sortedarrayset.remove(ticket)) {
-            ;
+        boolean removed = false; // CraftBukkit
+        if (arraysetsorted.remove(ticket)) {
+            removed = true; // CraftBukkit
         }
 
-        if (sortedarrayset.isEmpty()) {
+        if (arraysetsorted.isEmpty()) {
             this.tickets.remove(i);
         }
 
-        this.ticketTracker.update(i, getTicketLevelAt(sortedarrayset), false);
+        this.ticketTracker.update(i, getTicketLevelAt(arraysetsorted), false);
+        return removed; // CraftBukkit
     }
 
-    public <T> void addTicket(TicketType<T> tickettype, ChunkPos chunkpos, int i, T t0) {
-        this.addTicket(chunkpos.toLong(), new Ticket<>(tickettype, i, t0));
+    public <T> void addTicket(TicketType<T> type, ChunkPos pos, int level, T value) {
+        this.addTicket(pos.toLong(), new Ticket<>(type, level, value));
     }
 
-    public <T> void removeTicket(TicketType<T> tickettype, ChunkPos chunkpos, int i, T t0) {
-        Ticket<T> ticket = new Ticket<>(tickettype, i, t0);
+    public <T> void removeTicket(TicketType<T> type, ChunkPos pos, int level, T value) {
+        Ticket<T> ticket = new Ticket<>(type, level, value);
 
-        this.removeTicket(chunkpos.toLong(), ticket);
+        this.removeTicket(pos.toLong(), ticket);
     }
 
-    public <T> void addRegionTicket(TicketType<T> tickettype, ChunkPos chunkpos, int i, T t0) {
+    public <T> void addRegionTicket(TicketType<T> type, ChunkPos pos, int distance, T value) {
+        // CraftBukkit start
+        addRegionTicketAtDistance(type, pos, distance, value);
+    }
+
+    public <T> boolean addRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
+        // CraftBukkit end
         Ticket<T> ticket = new Ticket<>(tickettype, ChunkLevel.byStatus(FullChunkStatus.FULL) - i, t0);
-        long j = chunkpos.toLong();
+        long j = chunkcoordintpair.toLong();
 
-        this.addTicket(j, ticket);
+        boolean added = this.addTicket(j, ticket); // CraftBukkit
         this.tickingTicketsTracker.addTicket(j, ticket);
+        return added; // CraftBukkit
     }
 
-    public <T> void removeRegionTicket(TicketType<T> tickettype, ChunkPos chunkpos, int i, T t0) {
+    public <T> void removeRegionTicket(TicketType<T> type, ChunkPos pos, int distance, T value) {
+        // CraftBukkit start
+        removeRegionTicketAtDistance(type, pos, distance, value);
+    }
+
+    public <T> boolean removeRegionTicketAtDistance(TicketType<T> tickettype, ChunkPos chunkcoordintpair, int i, T t0) {
+        // CraftBukkit end
         Ticket<T> ticket = new Ticket<>(tickettype, ChunkLevel.byStatus(FullChunkStatus.FULL) - i, t0);
-        long j = chunkpos.toLong();
+        long j = chunkcoordintpair.toLong();
 
-        this.removeTicket(j, ticket);
+        boolean removed = this.removeTicket(j, ticket); // CraftBukkit
         this.tickingTicketsTracker.removeTicket(j, ticket);
+        return removed; // CraftBukkit
     }
 
-    private SortedArraySet<Ticket<?>> getTickets(long i) {
-        return (SortedArraySet) this.tickets.computeIfAbsent(i, (j) -> {
+    private SortedArraySet<Ticket<?>> getTickets(long chunkPos) {
+        return (SortedArraySet) this.tickets.computeIfAbsent(chunkPos, (j) -> {
             return SortedArraySet.create(4);
         });
     }
 
-    protected void updateChunkForced(ChunkPos chunkpos, boolean flag) {
-        Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, ChunkMap.FORCED_TICKET_LEVEL, chunkpos);
-        long i = chunkpos.toLong();
+    protected void updateChunkForced(ChunkPos pos, boolean add) {
+        Ticket<ChunkPos> ticket = new Ticket<>(TicketType.FORCED, ChunkMap.FORCED_TICKET_LEVEL, pos);
+        long i = pos.toLong();
 
-        if (flag) {
+        if (add) {
             this.addTicket(i, ticket);
             this.tickingTicketsTracker.addTicket(i, ticket);
         } else {
@@ -233,29 +265,30 @@
 
     }
 
-    public void addPlayer(SectionPos sectionpos, ServerPlayer serverplayer) {
-        ChunkPos chunkpos = sectionpos.chunk();
-        long i = chunkpos.toLong();
+    public void addPlayer(SectionPos sectionPos, ServerPlayer player) {
+        ChunkPos chunkcoordintpair = sectionPos.chunk();
+        long i = chunkcoordintpair.toLong();
 
         ((ObjectSet) this.playersPerChunk.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
-        })).add(serverplayer);
+        })).add(player);
         this.naturalSpawnChunkCounter.update(i, 0, true);
         this.playerTicketManager.update(i, 0, true);
-        this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkpos, this.getPlayerTicketLevel(), chunkpos);
+        this.tickingTicketsTracker.addTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair);
     }
 
-    public void removePlayer(SectionPos sectionpos, ServerPlayer serverplayer) {
-        ChunkPos chunkpos = sectionpos.chunk();
-        long i = chunkpos.toLong();
+    public void removePlayer(SectionPos sectionPos, ServerPlayer player) {
+        ChunkPos chunkcoordintpair = sectionPos.chunk();
+        long i = chunkcoordintpair.toLong();
         ObjectSet<ServerPlayer> objectset = (ObjectSet) this.playersPerChunk.get(i);
+        if (objectset == null) return; // CraftBukkit - SPIGOT-6208
 
-        objectset.remove(serverplayer);
+        objectset.remove(player);
         if (objectset.isEmpty()) {
             this.playersPerChunk.remove(i);
             this.naturalSpawnChunkCounter.update(i, Integer.MAX_VALUE, false);
             this.playerTicketManager.update(i, Integer.MAX_VALUE, false);
-            this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkpos, this.getPlayerTicketLevel(), chunkpos);
+            this.tickingTicketsTracker.removeTicket(TicketType.PLAYER, chunkcoordintpair, this.getPlayerTicketLevel(), chunkcoordintpair);
         }
 
     }
@@ -264,27 +297,27 @@
         return Math.max(0, ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING) - this.simulationDistance);
     }
 
-    public boolean inEntityTickingRange(long i) {
-        return ChunkLevel.isEntityTicking(this.tickingTicketsTracker.getLevel(i));
+    public boolean inEntityTickingRange(long chunkPos) {
+        return ChunkLevel.isEntityTicking(this.tickingTicketsTracker.getLevel(chunkPos));
     }
 
-    public boolean inBlockTickingRange(long i) {
-        return ChunkLevel.isBlockTicking(this.tickingTicketsTracker.getLevel(i));
+    public boolean inBlockTickingRange(long chunkPos) {
+        return ChunkLevel.isBlockTicking(this.tickingTicketsTracker.getLevel(chunkPos));
     }
 
-    protected String getTicketDebugString(long i) {
-        SortedArraySet<Ticket<?>> sortedarrayset = (SortedArraySet) this.tickets.get(i);
+    protected String getTicketDebugString(long chunkPos) {
+        SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) this.tickets.get(chunkPos);
 
-        return sortedarrayset != null && !sortedarrayset.isEmpty() ? ((Ticket) sortedarrayset.first()).toString() : "no_ticket";
+        return arraysetsorted != null && !arraysetsorted.isEmpty() ? ((Ticket) arraysetsorted.first()).toString() : "no_ticket";
     }
 
-    protected void updatePlayerTickets(int i) {
-        this.playerTicketManager.updateViewDistance(i);
+    protected void updatePlayerTickets(int viewDistance) {
+        this.playerTicketManager.updateViewDistance(viewDistance);
     }
 
-    public void updateSimulationDistance(int i) {
-        if (i != this.simulationDistance) {
-            this.simulationDistance = i;
+    public void updateSimulationDistance(int simulationDistance) {
+        if (simulationDistance != this.simulationDistance) {
+            this.simulationDistance = simulationDistance;
             this.tickingTicketsTracker.replacePlayerTicketsLevel(this.getPlayerTicketLevel());
         }
 
@@ -295,31 +328,31 @@
         return this.naturalSpawnChunkCounter.chunks.size();
     }
 
-    public boolean hasPlayersNearby(long i) {
+    public boolean hasPlayersNearby(long chunkPos) {
         this.naturalSpawnChunkCounter.runAllUpdates();
-        return this.naturalSpawnChunkCounter.chunks.containsKey(i);
+        return this.naturalSpawnChunkCounter.chunks.containsKey(chunkPos);
     }
 
     public String getDebugStatus() {
         return this.ticketThrottler.getDebugStatus();
     }
 
-    private void dumpTickets(String s) {
+    private void dumpTickets(String filename) {
         try {
-            FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
+            FileOutputStream fileoutputstream = new FileOutputStream(new File(filename));
 
             try {
                 ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().iterator();
 
                 while (objectiterator.hasNext()) {
                     Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-                    ChunkPos chunkpos = new ChunkPos(entry.getLongKey());
+                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
                     Iterator iterator = ((SortedArraySet) entry.getValue()).iterator();
 
                     while (iterator.hasNext()) {
                         Ticket<?> ticket = (Ticket) iterator.next();
 
-                        fileoutputstream.write((chunkpos.x + "\t" + chunkpos.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
+                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + ticket.getType() + "\t" + ticket.getTicketLevel() + "\t\n").getBytes(StandardCharsets.UTF_8));
                     }
                 }
             } catch (Throwable throwable) {
@@ -334,7 +367,7 @@
 
             fileoutputstream.close();
         } catch (IOException ioexception) {
-            DistanceManager.LOGGER.error("Failed to dump tickets to {}", s, ioexception);
+            DistanceManager.LOGGER.error("Failed to dump tickets to {}", filename, ioexception);
         }
 
     }
@@ -378,6 +411,26 @@
         return !this.tickets.isEmpty();
     }
 
+    // CraftBukkit start
+    public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
+        Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
+
+        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
+            SortedArraySet<Ticket<?>> tickets = entry.getValue();
+            if (tickets.remove(target)) {
+                // copied from removeTicket
+                this.ticketTracker.update(entry.getLongKey(), getTicketLevelAt(tickets), false);
+
+                // can't use entry after it's removed
+                if (tickets.isEmpty()) {
+                    iterator.remove();
+                }
+            }
+        }
+    }
+    // CraftBukkit end
+
     private class ChunkTicketTracker extends ChunkTracker {
 
         private static final int MAX_LEVEL = ChunkLevel.MAX_LEVEL + 1;
@@ -387,21 +440,19 @@
         }
 
         @Override
-        @Override
-        protected int getLevelFromSource(long i) {
-            SortedArraySet<Ticket<?>> sortedarrayset = (SortedArraySet) DistanceManager.this.tickets.get(i);
+        protected int getLevelFromSource(long pos) {
+            SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(pos);
 
-            return sortedarrayset == null ? Integer.MAX_VALUE : (sortedarrayset.isEmpty() ? Integer.MAX_VALUE : ((Ticket) sortedarrayset.first()).getTicketLevel());
+            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
         }
 
         @Override
-        @Override
-        protected int getLevel(long i) {
-            if (!DistanceManager.this.isChunkToRemove(i)) {
-                ChunkHolder chunkholder = DistanceManager.this.getChunk(i);
+        protected int getLevel(long sectionPos) {
+            if (!DistanceManager.this.isChunkToRemove(sectionPos)) {
+                ChunkHolder playerchunk = DistanceManager.this.getChunk(sectionPos);
 
-                if (chunkholder != null) {
-                    return chunkholder.getTicketLevel();
+                if (playerchunk != null) {
+                    return playerchunk.getTicketLevel();
                 }
             }
 
@@ -409,22 +460,21 @@
         }
 
         @Override
-        @Override
-        protected void setLevel(long i, int j) {
-            ChunkHolder chunkholder = DistanceManager.this.getChunk(i);
-            int k = chunkholder == null ? DistanceManager.ChunkTicketTracker.MAX_LEVEL : chunkholder.getTicketLevel();
+        protected void setLevel(long sectionPos, int j) {
+            ChunkHolder playerchunk = DistanceManager.this.getChunk(sectionPos);
+            int k = playerchunk == null ? DistanceManager.ChunkTicketTracker.MAX_LEVEL : playerchunk.getTicketLevel();
 
             if (k != j) {
-                chunkholder = DistanceManager.this.updateChunkScheduling(i, j, chunkholder, k);
-                if (chunkholder != null) {
-                    DistanceManager.this.chunksToUpdateFutures.add(chunkholder);
+                playerchunk = DistanceManager.this.updateChunkScheduling(sectionPos, j, playerchunk, k);
+                if (playerchunk != null) {
+                    DistanceManager.this.chunksToUpdateFutures.add(playerchunk);
                 }
 
             }
         }
 
-        public int runDistanceUpdates(int i) {
-            return this.runUpdates(i);
+        public int runDistanceUpdates(int toUpdateCount) {
+            return this.runUpdates(toUpdateCount);
         }
     }
 
@@ -440,35 +490,32 @@
         }
 
         @Override
-        @Override
-        protected int getLevel(long i) {
-            return this.chunks.get(i);
+        protected int getLevel(long sectionPos) {
+            return this.chunks.get(sectionPos);
         }
 
         @Override
-        @Override
-        protected void setLevel(long i, int j) {
+        protected void setLevel(long sectionPos, int j) {
             byte b0;
 
             if (j > this.maxDistance) {
-                b0 = this.chunks.remove(i);
+                b0 = this.chunks.remove(sectionPos);
             } else {
-                b0 = this.chunks.put(i, (byte) j);
+                b0 = this.chunks.put(sectionPos, (byte) j);
             }
 
-            this.onLevelChange(i, b0, j);
+            this.onLevelChange(sectionPos, b0, j);
         }
 
-        protected void onLevelChange(long i, int j, int k) {}
+        protected void onLevelChange(long chunkPos, int j, int oldLevel) {}
 
         @Override
-        @Override
-        protected int getLevelFromSource(long i) {
-            return this.havePlayer(i) ? 0 : Integer.MAX_VALUE;
+        protected int getLevelFromSource(long pos) {
+            return this.havePlayer(pos) ? 0 : Integer.MAX_VALUE;
         }
 
-        private boolean havePlayer(long i) {
-            ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(i);
+        private boolean havePlayer(long chunkPos) {
+            ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(chunkPos);
 
             return objectset != null && !objectset.isEmpty();
         }
@@ -477,19 +524,19 @@
             this.runUpdates(Integer.MAX_VALUE);
         }
 
-        private void dumpChunks(String s) {
+        private void dumpChunks(String filename) {
             try {
-                FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
+                FileOutputStream fileoutputstream = new FileOutputStream(new File(filename));
 
                 try {
                     ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
 
                     while (objectiterator.hasNext()) {
                         it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
-                        ChunkPos chunkpos = new ChunkPos(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey());
+                        ChunkPos chunkcoordintpair = new ChunkPos(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey());
                         String s1 = Byte.toString(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue());
 
-                        fileoutputstream.write((chunkpos.x + "\t" + chunkpos.z + "\t" + s1 + "\n").getBytes(StandardCharsets.UTF_8));
+                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + s1 + "\n").getBytes(StandardCharsets.UTF_8));
                     }
                 } catch (Throwable throwable) {
                     try {
@@ -503,7 +550,7 @@
 
                 fileoutputstream.close();
             } catch (IOException ioexception) {
-                DistanceManager.LOGGER.error("Failed to dump chunks to {}", s, ioexception);
+                DistanceManager.LOGGER.error("Failed to dump chunks to {}", filename, ioexception);
             }
 
         }
@@ -521,12 +568,11 @@
         }
 
         @Override
-        @Override
-        protected void onLevelChange(long i, int j, int k) {
-            this.toUpdate.add(i);
+        protected void onLevelChange(long chunkPos, int j, int oldLevel) {
+            this.toUpdate.add(chunkPos);
         }
 
-        public void updateViewDistance(int i) {
+        public void updateViewDistance(int viewDistance) {
             ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
 
             while (objectiterator.hasNext()) {
@@ -534,44 +580,43 @@
                 byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
                 long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
 
-                this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= i);
+                this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= viewDistance);
             }
 
-            this.viewDistance = i;
+            this.viewDistance = viewDistance;
         }
 
-        private void onLevelChange(long i, int j, boolean flag, boolean flag1) {
+        private void onLevelChange(long chunkPos, int j, boolean flag, boolean flag1) {
             if (flag != flag1) {
-                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, DistanceManager.PLAYER_TICKET_LEVEL, new ChunkPos(i));
+                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, DistanceManager.PLAYER_TICKET_LEVEL, new ChunkPos(chunkPos));
 
                 if (flag1) {
                     DistanceManager.this.ticketThrottlerInput.tell(ChunkTaskPriorityQueueSorter.message(() -> {
                         DistanceManager.this.mainThreadExecutor.execute(() -> {
-                            if (this.haveTicketFor(this.getLevel(i))) {
-                                DistanceManager.this.addTicket(i, ticket);
-                                DistanceManager.this.ticketsToRelease.add(i);
+                            if (this.haveTicketFor(this.getLevel(chunkPos))) {
+                                DistanceManager.this.addTicket(chunkPos, ticket);
+                                DistanceManager.this.ticketsToRelease.add(chunkPos);
                             } else {
                                 DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
-                                }, i, false));
+                                }, chunkPos, false));
                             }
 
                         });
-                    }, i, () -> {
+                    }, chunkPos, () -> {
                         return j;
                     }));
                 } else {
                     DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
                         DistanceManager.this.mainThreadExecutor.execute(() -> {
-                            DistanceManager.this.removeTicket(i, ticket);
+                            DistanceManager.this.removeTicket(chunkPos, ticket);
                         });
-                    }, i, true));
+                    }, chunkPos, true));
                 }
             }
 
         }
 
         @Override
-        @Override
         public void runAllUpdates() {
             super.runAllUpdates();
             if (!this.toUpdate.isEmpty()) {
@@ -602,8 +647,8 @@
 
         }
 
-        private boolean haveTicketFor(int i) {
-            return i <= this.viewDistance;
+        private boolean haveTicketFor(int level) {
+            return level <= this.viewDistance;
         }
     }
 }
