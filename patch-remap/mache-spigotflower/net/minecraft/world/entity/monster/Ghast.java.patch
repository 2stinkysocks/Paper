--- a/net/minecraft/world/entity/monster/Ghast.java
+++ b/net/minecraft/world/entity/monster/Ghast.java
@@ -15,12 +15,12 @@
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityPose;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMobSpawn;
 import net.minecraft.world.entity.FlyingMob;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.Pose;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.control.MoveControl;
@@ -34,25 +34,24 @@
 import net.minecraft.world.phys.Vec3;
 import org.joml.Vector3f;
 
-public class Ghast extends FlyingMob implements Enemy {
+public class Ghast extends FlyingMob implements IMonster {
 
     private static final EntityDataAccessor<Boolean> DATA_IS_CHARGING = SynchedEntityData.defineId(Ghast.class, EntityDataSerializers.BOOLEAN);
     private int explosionPower = 1;
 
-    public Ghast(EntityType<? extends Ghast> entitytype, Level level) {
-        super(entitytype, level);
+    public Ghast(EntityType<? extends Ghast> entityType, Level level) {
+        super(entityType, level);
         this.xpReward = 5;
         this.moveControl = new Ghast.GhastMoveControl(this);
     }
 
     @Override
-    @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(5, new Ghast.RandomFloatAroundGoal(this));
         this.goalSelector.addGoal(7, new Ghast.GhastLookGoal(this));
         this.goalSelector.addGoal(7, new Ghast.GhastShootFireballGoal(this));
-        this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (livingentity) -> {
-            return Math.abs(livingentity.getY() - this.getY()) <= 4.0D;
+        this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entityliving) -> {
+            return Math.abs(entityliving.getY() - this.getY()) <= 4.0D;
         }));
     }
 
@@ -60,8 +59,8 @@
         return (Boolean) this.entityData.get(Ghast.DATA_IS_CHARGING);
     }
 
-    public void setCharging(boolean flag) {
-        this.entityData.set(Ghast.DATA_IS_CHARGING, flag);
+    public void setCharging(boolean charging) {
+        this.entityData.set(Ghast.DATA_IS_CHARGING, charging);
     }
 
     public int getExplosionPower() {
@@ -69,34 +68,30 @@
     }
 
     @Override
-    @Override
     protected boolean shouldDespawnInPeaceful() {
         return true;
     }
 
-    private static boolean isReflectedFireball(DamageSource damagesource) {
-        return damagesource.getDirectEntity() instanceof LargeFireball && damagesource.getEntity() instanceof Player;
+    private static boolean isReflectedFireball(DamageSource damageSource) {
+        return damageSource.getDirectEntity() instanceof LargeFireball && damageSource.getEntity() instanceof Player;
     }
 
     @Override
-    @Override
-    public boolean isInvulnerableTo(DamageSource damagesource) {
-        return !isReflectedFireball(damagesource) && super.isInvulnerableTo(damagesource);
+    public boolean isInvulnerableTo(DamageSource source) {
+        return !isReflectedFireball(source) && super.isInvulnerableTo(source);
     }
 
     @Override
-    @Override
-    public boolean hurt(DamageSource damagesource, float f) {
-        if (isReflectedFireball(damagesource)) {
-            super.hurt(damagesource, 1000.0F);
+    public boolean hurt(DamageSource source, float amount) {
+        if (isReflectedFireball(source)) {
+            super.hurt(source, 1000.0F);
             return true;
         } else {
-            return this.isInvulnerableTo(damagesource) ? false : super.hurt(damagesource, f);
+            return this.isInvulnerableTo(source) ? false : super.hurt(source, amount);
         }
     }
 
     @Override
-    @Override
     protected void defineSynchedData() {
         super.defineSynchedData();
         this.entityData.define(Ghast.DATA_IS_CHARGING, false);
@@ -107,77 +102,66 @@
     }
 
     @Override
-    @Override
     public SoundSource getSoundSource() {
         return SoundSource.HOSTILE;
     }
 
     @Override
-    @Override
     protected SoundEvent getAmbientSound() {
         return SoundEvents.GHAST_AMBIENT;
     }
 
     @Override
-    @Override
-    protected SoundEvent getHurtSound(DamageSource damagesource) {
+    protected SoundEvent getHurtSound(DamageSource damageSource) {
         return SoundEvents.GHAST_HURT;
     }
 
     @Override
-    @Override
     protected SoundEvent getDeathSound() {
         return SoundEvents.GHAST_DEATH;
     }
 
     @Override
-    @Override
     protected float getSoundVolume() {
         return 5.0F;
     }
 
-    public static boolean checkGhastSpawnRules(EntityType<Ghast> entitytype, LevelAccessor levelaccessor, MobSpawnType mobspawntype, BlockPos blockpos, RandomSource randomsource) {
-        return levelaccessor.getDifficulty() != Difficulty.PEACEFUL && randomsource.nextInt(20) == 0 && checkMobSpawnRules(entitytype, levelaccessor, mobspawntype, blockpos, randomsource);
+    public static boolean checkGhastSpawnRules(EntityType<Ghast> ghast, LevelAccessor level, EnumMobSpawn spawnType, BlockPos pos, RandomSource random) {
+        return level.getDifficulty() != Difficulty.PEACEFUL && random.nextInt(20) == 0 && checkMobSpawnRules(ghast, level, spawnType, pos, random);
     }
 
     @Override
-    @Override
     public int getMaxSpawnClusterSize() {
         return 1;
     }
 
     @Override
-    @Override
-    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entitydimensions, float f) {
-        return new Vector3f(0.0F, entitydimensions.height + 0.0625F * f, 0.0F);
+    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entitysize, float f) {
+        return new Vector3f(0.0F, entitysize.height + 0.0625F * f, 0.0F);
     }
 
     @Override
-    @Override
     protected float ridingOffset(Entity entity) {
         return 0.5F;
     }
 
     @Override
-    @Override
-    public void addAdditionalSaveData(CompoundTag compoundtag) {
-        super.addAdditionalSaveData(compoundtag);
-        compoundtag.putByte("ExplosionPower", (byte) this.explosionPower);
+    public void addAdditionalSaveData(CompoundTag compound) {
+        super.addAdditionalSaveData(compound);
+        compound.putByte("ExplosionPower", (byte) this.explosionPower);
     }
 
     @Override
-    @Override
-    public void readAdditionalSaveData(CompoundTag compoundtag) {
-        super.readAdditionalSaveData(compoundtag);
-        if (compoundtag.contains("ExplosionPower", 99)) {
-            this.explosionPower = compoundtag.getByte("ExplosionPower");
+    public void readAdditionalSaveData(CompoundTag compound) {
+        super.readAdditionalSaveData(compound);
+        if (compound.contains("ExplosionPower", 99)) {
+            this.explosionPower = compound.getByte("ExplosionPower");
         }
 
     }
 
     @Override
-    @Override
-    protected float getStandingEyeHeight(Pose pose, EntityDimensions entitydimensions) {
+    protected float getStandingEyeHeight(EntityPose pose, EntityDimensions size) {
         return 2.6F;
     }
 
@@ -192,17 +176,16 @@
         }
 
         @Override
-        @Override
         public void tick() {
             if (this.operation == MoveControl.Operation.MOVE_TO) {
                 if (this.floatDuration-- <= 0) {
                     this.floatDuration += this.ghast.getRandom().nextInt(5) + 2;
-                    Vec3 vec3 = new Vec3(this.wantedX - this.ghast.getX(), this.wantedY - this.ghast.getY(), this.wantedZ - this.ghast.getZ());
-                    double d0 = vec3.length();
+                    Vec3 vec3d = new Vec3(this.wantedX - this.ghast.getX(), this.wantedY - this.ghast.getY(), this.wantedZ - this.ghast.getZ());
+                    double d0 = vec3d.length();
 
-                    vec3 = vec3.normalize();
-                    if (this.canReach(vec3, Mth.ceil(d0))) {
-                        this.ghast.setDeltaMovement(this.ghast.getDeltaMovement().add(vec3.scale(0.1D)));
+                    vec3d = vec3d.normalize();
+                    if (this.canReach(vec3d, Mth.ceil(d0))) {
+                        this.ghast.setDeltaMovement(this.ghast.getDeltaMovement().add(vec3d.scale(0.1D)));
                     } else {
                         this.operation = MoveControl.Operation.WAIT;
                     }
@@ -211,12 +194,12 @@
             }
         }
 
-        private boolean canReach(Vec3 vec3, int i) {
-            AABB aabb = this.ghast.getBoundingBox();
+        private boolean canReach(Vec3 pos, int length) {
+            AABB axisalignedbb = this.ghast.getBoundingBox();
 
-            for (int j = 1; j < i; ++j) {
-                aabb = aabb.move(vec3);
-                if (!this.ghast.level().noCollision(this.ghast, aabb)) {
+            for (int j = 1; j < length; ++j) {
+                axisalignedbb = axisalignedbb.move(pos);
+                if (!this.ghast.level().noCollision(this.ghast, axisalignedbb)) {
                     return false;
                 }
             }
@@ -231,20 +214,19 @@
 
         public RandomFloatAroundGoal(Ghast ghast) {
             this.ghast = ghast;
-            this.setFlags(EnumSet.of(Goal.Flag.MOVE));
+            this.setFlags(EnumSet.of(Goal.Type.MOVE));
         }
 
         @Override
-        @Override
         public boolean canUse() {
-            MoveControl movecontrol = this.ghast.getMoveControl();
+            MoveControl controllermove = this.ghast.getMoveControl();
 
-            if (!movecontrol.hasWanted()) {
+            if (!controllermove.hasWanted()) {
                 return true;
             } else {
-                double d0 = movecontrol.getWantedX() - this.ghast.getX();
-                double d1 = movecontrol.getWantedY() - this.ghast.getY();
-                double d2 = movecontrol.getWantedZ() - this.ghast.getZ();
+                double d0 = controllermove.getWantedX() - this.ghast.getX();
+                double d1 = controllermove.getWantedY() - this.ghast.getY();
+                double d2 = controllermove.getWantedZ() - this.ghast.getZ();
                 double d3 = d0 * d0 + d1 * d1 + d2 * d2;
 
                 return d3 < 1.0D || d3 > 3600.0D;
@@ -252,13 +234,11 @@
         }
 
         @Override
-        @Override
         public boolean canContinueToUse() {
             return false;
         }
 
         @Override
-        @Override
         public void start() {
             RandomSource randomsource = this.ghast.getRandom();
             double d0 = this.ghast.getX() + (double) ((randomsource.nextFloat() * 2.0F - 1.0F) * 16.0F);
@@ -275,36 +255,33 @@
 
         public GhastLookGoal(Ghast ghast) {
             this.ghast = ghast;
-            this.setFlags(EnumSet.of(Goal.Flag.LOOK));
+            this.setFlags(EnumSet.of(Goal.Type.LOOK));
         }
 
         @Override
-        @Override
         public boolean canUse() {
             return true;
         }
 
         @Override
-        @Override
         public boolean requiresUpdateEveryTick() {
             return true;
         }
 
         @Override
-        @Override
         public void tick() {
             if (this.ghast.getTarget() == null) {
-                Vec3 vec3 = this.ghast.getDeltaMovement();
+                Vec3 vec3d = this.ghast.getDeltaMovement();
 
-                this.ghast.setYRot(-((float) Mth.atan2(vec3.x, vec3.z)) * 57.295776F);
+                this.ghast.setYRot(-((float) Mth.atan2(vec3d.x, vec3d.z)) * 57.295776F);
                 this.ghast.yBodyRot = this.ghast.getYRot();
             } else {
-                LivingEntity livingentity = this.ghast.getTarget();
+                LivingEntity entityliving = this.ghast.getTarget();
                 double d0 = 64.0D;
 
-                if (livingentity.distanceToSqr((Entity) this.ghast) < 4096.0D) {
-                    double d1 = livingentity.getX() - this.ghast.getX();
-                    double d2 = livingentity.getZ() - this.ghast.getZ();
+                if (entityliving.distanceToSqr((Entity) this.ghast) < 4096.0D) {
+                    double d1 = entityliving.getX() - this.ghast.getX();
+                    double d2 = entityliving.getZ() - this.ghast.getZ();
 
                     this.ghast.setYRot(-((float) Mth.atan2(d1, d2)) * 57.295776F);
                     this.ghast.yBodyRot = this.ghast.getYRot();
@@ -324,60 +301,57 @@
         }
 
         @Override
-        @Override
         public boolean canUse() {
             return this.ghast.getTarget() != null;
         }
 
         @Override
-        @Override
         public void start() {
             this.chargeTime = 0;
         }
 
         @Override
-        @Override
         public void stop() {
             this.ghast.setCharging(false);
         }
 
         @Override
-        @Override
         public boolean requiresUpdateEveryTick() {
             return true;
         }
 
         @Override
-        @Override
         public void tick() {
-            LivingEntity livingentity = this.ghast.getTarget();
+            LivingEntity entityliving = this.ghast.getTarget();
 
-            if (livingentity != null) {
+            if (entityliving != null) {
                 double d0 = 64.0D;
 
-                if (livingentity.distanceToSqr((Entity) this.ghast) < 4096.0D && this.ghast.hasLineOfSight(livingentity)) {
-                    Level level = this.ghast.level();
+                if (entityliving.distanceToSqr((Entity) this.ghast) < 4096.0D && this.ghast.hasLineOfSight(entityliving)) {
+                    Level world = this.ghast.level();
 
                     ++this.chargeTime;
                     if (this.chargeTime == 10 && !this.ghast.isSilent()) {
-                        level.levelEvent((Player) null, 1015, this.ghast.blockPosition(), 0);
+                        world.levelEvent((Player) null, 1015, this.ghast.blockPosition(), 0);
                     }
 
                     if (this.chargeTime == 20) {
                         double d1 = 4.0D;
-                        Vec3 vec3 = this.ghast.getViewVector(1.0F);
-                        double d2 = livingentity.getX() - (this.ghast.getX() + vec3.x * 4.0D);
-                        double d3 = livingentity.getY(0.5D) - (0.5D + this.ghast.getY(0.5D));
-                        double d4 = livingentity.getZ() - (this.ghast.getZ() + vec3.z * 4.0D);
+                        Vec3 vec3d = this.ghast.getViewVector(1.0F);
+                        double d2 = entityliving.getX() - (this.ghast.getX() + vec3d.x * 4.0D);
+                        double d3 = entityliving.getY(0.5D) - (0.5D + this.ghast.getY(0.5D));
+                        double d4 = entityliving.getZ() - (this.ghast.getZ() + vec3d.z * 4.0D);
 
                         if (!this.ghast.isSilent()) {
-                            level.levelEvent((Player) null, 1016, this.ghast.blockPosition(), 0);
+                            world.levelEvent((Player) null, 1016, this.ghast.blockPosition(), 0);
                         }
 
-                        LargeFireball largefireball = new LargeFireball(level, this.ghast, d2, d3, d4, this.ghast.getExplosionPower());
+                        LargeFireball entitylargefireball = new LargeFireball(world, this.ghast, d2, d3, d4, this.ghast.getExplosionPower());
 
-                        largefireball.setPos(this.ghast.getX() + vec3.x * 4.0D, this.ghast.getY(0.5D) + 0.5D, largefireball.getZ() + vec3.z * 4.0D);
-                        level.addFreshEntity(largefireball);
+                        // CraftBukkit - set bukkitYield when setting explosionpower
+                        entitylargefireball.bukkitYield = entitylargefireball.explosionPower = this.ghast.getExplosionPower();
+                        entitylargefireball.setPos(this.ghast.getX() + vec3d.x * 4.0D, this.ghast.getY(0.5D) + 0.5D, entitylargefireball.getZ() + vec3d.z * 4.0D);
+                        world.addFreshEntity(entitylargefireball);
                         this.chargeTime = -40;
                     }
                 } else if (this.chargeTime > 0) {
