--- a/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
+++ b/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
@@ -17,6 +17,10 @@
 import net.minecraft.world.entity.ai.village.poi.PoiTypes;
 import net.minecraft.world.entity.npc.Villager;
 import net.minecraft.world.level.pathfinder.Path;
+// CraftBukkit start
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+// CraftBukkit end
 
 public class VillagerMakeLove extends Behavior<Villager> {
 
@@ -28,112 +32,113 @@
         super(ImmutableMap.of(MemoryModuleType.BREED_TARGET, MemoryStatus.VALUE_PRESENT, MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, MemoryStatus.VALUE_PRESENT), 350, 350);
     }
 
-    @Override
-    protected boolean checkExtraStartConditions(ServerLevel serverlevel, Villager villager) {
-        return this.isBreedingPossible(villager);
+    protected boolean checkExtraStartConditions(ServerLevel level, Villager owner) {
+        return this.isBreedingPossible(owner);
     }
 
-    @Override
-    protected boolean canStillUse(ServerLevel serverlevel, Villager villager, long i) {
-        return i <= this.birthTimestamp && this.isBreedingPossible(villager);
+    protected boolean canStillUse(ServerLevel level, Villager entity, long gameTime) {
+        return gameTime <= this.birthTimestamp && this.isBreedingPossible(entity);
     }
 
-    @Override
-    protected void start(ServerLevel serverlevel, Villager villager, long i) {
-        AgeableMob ageablemob = (AgeableMob) villager.getBrain().getMemory(MemoryModuleType.BREED_TARGET).get();
+    protected void start(ServerLevel level, Villager entity, long gameTime) {
+        AgeableMob entityageable = (AgeableMob) entity.getBrain().getMemory(MemoryModuleType.BREED_TARGET).get();
 
-        BehaviorUtils.lockGazeAndWalkToEachOther(villager, ageablemob, 0.5F);
-        serverlevel.broadcastEntityEvent(ageablemob, (byte) 18);
-        serverlevel.broadcastEntityEvent(villager, (byte) 18);
-        int j = 275 + villager.getRandom().nextInt(50);
+        BehaviorUtils.lockGazeAndWalkToEachOther(entity, entityageable, 0.5F);
+        level.broadcastEntityEvent(entityageable, (byte) 18);
+        level.broadcastEntityEvent(entity, (byte) 18);
+        int j = 275 + entity.getRandom().nextInt(50);
 
-        this.birthTimestamp = i + (long) j;
+        this.birthTimestamp = gameTime + (long) j;
     }
 
-    @Override
-    protected void tick(ServerLevel serverlevel, Villager villager, long i) {
-        Villager villager1 = (Villager) villager.getBrain().getMemory(MemoryModuleType.BREED_TARGET).get();
+    protected void tick(ServerLevel level, Villager owner, long gameTime) {
+        Villager entityvillager1 = (Villager) owner.getBrain().getMemory(MemoryModuleType.BREED_TARGET).get();
 
-        if (villager.distanceToSqr((Entity) villager1) <= 5.0D) {
-            BehaviorUtils.lockGazeAndWalkToEachOther(villager, villager1, 0.5F);
-            if (i >= this.birthTimestamp) {
-                villager.eatAndDigestFood();
-                villager1.eatAndDigestFood();
-                this.tryToGiveBirth(serverlevel, villager, villager1);
-            } else if (villager.getRandom().nextInt(35) == 0) {
-                serverlevel.broadcastEntityEvent(villager1, (byte) 12);
-                serverlevel.broadcastEntityEvent(villager, (byte) 12);
+        if (owner.distanceToSqr((Entity) entityvillager1) <= 5.0D) {
+            BehaviorUtils.lockGazeAndWalkToEachOther(owner, entityvillager1, 0.5F);
+            if (gameTime >= this.birthTimestamp) {
+                owner.eatAndDigestFood();
+                entityvillager1.eatAndDigestFood();
+                this.tryToGiveBirth(level, owner, entityvillager1);
+            } else if (owner.getRandom().nextInt(35) == 0) {
+                level.broadcastEntityEvent(entityvillager1, (byte) 12);
+                level.broadcastEntityEvent(owner, (byte) 12);
             }
 
         }
     }
 
-    private void tryToGiveBirth(ServerLevel serverlevel, Villager villager, Villager villager1) {
-        Optional<BlockPos> optional = this.takeVacantBed(serverlevel, villager);
+    private void tryToGiveBirth(ServerLevel level, Villager parent, Villager partner) {
+        Optional<BlockPos> optional = this.takeVacantBed(level, parent);
 
         if (optional.isEmpty()) {
-            serverlevel.broadcastEntityEvent(villager1, (byte) 13);
-            serverlevel.broadcastEntityEvent(villager, (byte) 13);
+            level.broadcastEntityEvent(partner, (byte) 13);
+            level.broadcastEntityEvent(parent, (byte) 13);
         } else {
-            Optional<Villager> optional1 = this.breed(serverlevel, villager, villager1);
+            Optional<Villager> optional1 = this.breed(level, parent, partner);
 
             if (optional1.isPresent()) {
-                this.giveBedToChild(serverlevel, (Villager) optional1.get(), (BlockPos) optional.get());
+                this.giveBedToChild(level, (Villager) optional1.get(), (BlockPos) optional.get());
             } else {
-                serverlevel.getPoiManager().release((BlockPos) optional.get());
-                DebugPackets.sendPoiTicketCountPacket(serverlevel, (BlockPos) optional.get());
+                level.getPoiManager().release((BlockPos) optional.get());
+                DebugPackets.sendPoiTicketCountPacket(level, (BlockPos) optional.get());
             }
         }
 
     }
 
-    @Override
-    protected void stop(ServerLevel serverlevel, Villager villager, long i) {
-        villager.getBrain().eraseMemory(MemoryModuleType.BREED_TARGET);
+    protected void stop(ServerLevel level, Villager entity, long gameTime) {
+        entity.getBrain().eraseMemory(MemoryModuleType.BREED_TARGET);
     }
 
     private boolean isBreedingPossible(Villager villager) {
-        Brain<Villager> brain = villager.getBrain();
-        Optional<AgeableMob> optional = brain.getMemory(MemoryModuleType.BREED_TARGET).filter((ageablemob) -> {
-            return ageablemob.getType() == EntityType.VILLAGER;
+        Brain<Villager> behaviorcontroller = villager.getBrain();
+        Optional<AgeableMob> optional = behaviorcontroller.getMemory(MemoryModuleType.BREED_TARGET).filter((entityageable) -> {
+            return entityageable.getType() == EntityType.VILLAGER;
         });
 
-        return optional.isEmpty() ? false : BehaviorUtils.targetIsValid(brain, MemoryModuleType.BREED_TARGET, EntityType.VILLAGER) && villager.canBreed() && ((AgeableMob) optional.get()).canBreed();
+        return optional.isEmpty() ? false : BehaviorUtils.targetIsValid(behaviorcontroller, MemoryModuleType.BREED_TARGET, EntityType.VILLAGER) && villager.canBreed() && ((AgeableMob) optional.get()).canBreed();
     }
 
-    private Optional<BlockPos> takeVacantBed(ServerLevel serverlevel, Villager villager) {
-        return serverlevel.getPoiManager().take((holder) -> {
+    private Optional<BlockPos> takeVacantBed(ServerLevel level, Villager villager) {
+        return level.getPoiManager().take((holder) -> {
             return holder.is(PoiTypes.HOME);
-        }, (holder, blockpos) -> {
-            return this.canReach(villager, blockpos, holder);
+        }, (holder, blockposition) -> {
+            return this.canReach(villager, blockposition, holder);
         }, villager.blockPosition(), 48);
     }
 
-    private boolean canReach(Villager villager, BlockPos blockpos, Holder<PoiType> holder) {
-        Path path = villager.getNavigation().createPath(blockpos, ((PoiType) holder.value()).validRange());
+    private boolean canReach(Villager villager, BlockPos pos, Holder<PoiType> poiType) {
+        Path pathentity = villager.getNavigation().createPath(pos, ((PoiType) poiType.value()).validRange());
 
-        return path != null && path.canReach();
+        return pathentity != null && pathentity.canReach();
     }
 
-    private Optional<Villager> breed(ServerLevel serverlevel, Villager villager, Villager villager1) {
-        Villager villager2 = villager.getBreedOffspring(serverlevel, villager1);
+    private Optional<Villager> breed(ServerLevel level, Villager parent, Villager partner) {
+        Villager entityvillager2 = parent.getBreedOffspring(level, partner);
 
-        if (villager2 == null) {
+        if (entityvillager2 == null) {
             return Optional.empty();
         } else {
-            villager.setAge(6000);
-            villager1.setAge(6000);
-            villager2.setAge(-24000);
-            villager2.moveTo(villager.getX(), villager.getY(), villager.getZ(), 0.0F, 0.0F);
-            serverlevel.addFreshEntityWithPassengers(villager2);
-            serverlevel.broadcastEntityEvent(villager2, (byte) 12);
-            return Optional.of(villager2);
+            entityvillager2.setAge(-24000);
+            entityvillager2.moveTo(parent.getX(), parent.getY(), parent.getZ(), 0.0F, 0.0F);
+            // CraftBukkit start - call EntityBreedEvent
+            if (CraftEventFactory.callEntityBreedEvent(entityvillager2, parent, partner, null, null, 0).isCancelled()) {
+                return Optional.empty();
+            }
+            // Move age setting down
+            parent.setAge(6000);
+            partner.setAge(6000);
+            level.addFreshEntityWithPassengers(entityvillager2, CreatureSpawnEvent.SpawnReason.BREEDING);
+            // CraftBukkit end
+            level.broadcastEntityEvent(entityvillager2, (byte) 12);
+            return Optional.of(entityvillager2);
         }
     }
 
-    private void giveBedToChild(ServerLevel serverlevel, Villager villager, BlockPos blockpos) {
-        GlobalPos globalpos = GlobalPos.of(serverlevel.dimension(), blockpos);
+    private void giveBedToChild(ServerLevel level, Villager villager, BlockPos pos) {
+        GlobalPos globalpos = GlobalPos.of(level.dimension(), pos);
 
-        villager.getBrain().setMemory(MemoryModuleType.HOME, (Object) globalpos);
+        villager.getBrain().setMemory(MemoryModuleType.HOME, globalpos); // CraftBukkit - decompile error
     }
 }
