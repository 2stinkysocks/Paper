--- a/net/minecraft/world/entity/ai/behavior/BehaviorUtils.java
+++ b/net/minecraft/world/entity/ai/behavior/BehaviorUtils.java
@@ -24,174 +24,182 @@
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.ProjectileWeaponItem;
-import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.level.pathfinder.PathMode;
 import net.minecraft.world.phys.Vec3;
 
 public class BehaviorUtils {
 
     private BehaviorUtils() {}
 
-    public static void lockGazeAndWalkToEachOther(LivingEntity livingentity, LivingEntity livingentity1, float f) {
-        lookAtEachOther(livingentity, livingentity1);
-        setWalkAndLookTargetMemoriesToEachOther(livingentity, livingentity1, f);
+    public static void lockGazeAndWalkToEachOther(LivingEntity firstEntity, LivingEntity secondEntity, float speed) {
+        lookAtEachOther(firstEntity, secondEntity);
+        setWalkAndLookTargetMemoriesToEachOther(firstEntity, secondEntity, speed);
     }
 
-    public static boolean entityIsVisible(Brain<?> brain, LivingEntity livingentity) {
+    public static boolean entityIsVisible(Brain<?> brain, LivingEntity target) {
         Optional<NearestVisibleLivingEntities> optional = brain.getMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES);
 
-        return optional.isPresent() && ((NearestVisibleLivingEntities) optional.get()).contains(livingentity);
+        return optional.isPresent() && ((NearestVisibleLivingEntities) optional.get()).contains(target);
     }
 
-    public static boolean targetIsValid(Brain<?> brain, MemoryModuleType<? extends LivingEntity> memorymoduletype, EntityType<?> entitytype) {
-        return targetIsValid(brain, memorymoduletype, (livingentity) -> {
-            return livingentity.getType() == entitytype;
+    public static boolean targetIsValid(Brain<?> brains, MemoryModuleType<? extends LivingEntity> memorymodule, EntityType<?> entityType) {
+        return targetIsValid(brains, memorymodule, (entityliving) -> {
+            return entityliving.getType() == entityType;
         });
     }
 
-    private static boolean targetIsValid(Brain<?> brain, MemoryModuleType<? extends LivingEntity> memorymoduletype, Predicate<LivingEntity> predicate) {
-        return brain.getMemory(memorymoduletype).filter(predicate).filter(LivingEntity::isAlive).filter((livingentity) -> {
-            return entityIsVisible(brain, livingentity);
+    private static boolean targetIsValid(Brain<?> brain, MemoryModuleType<? extends LivingEntity> memoryType, Predicate<LivingEntity> livingPredicate) {
+        return brain.getMemory(memoryType).filter(livingPredicate).filter(LivingEntity::isAlive).filter((entityliving) -> {
+            return entityIsVisible(brain, entityliving);
         }).isPresent();
     }
 
-    private static void lookAtEachOther(LivingEntity livingentity, LivingEntity livingentity1) {
-        lookAtEntity(livingentity, livingentity1);
-        lookAtEntity(livingentity1, livingentity);
+    private static void lookAtEachOther(LivingEntity firstEntity, LivingEntity secondEntity) {
+        lookAtEntity(firstEntity, secondEntity);
+        lookAtEntity(secondEntity, firstEntity);
     }
 
-    public static void lookAtEntity(LivingEntity livingentity, LivingEntity livingentity1) {
-        livingentity.getBrain().setMemory(MemoryModuleType.LOOK_TARGET, (Object) (new EntityTracker(livingentity1, true)));
+    public static void lookAtEntity(LivingEntity entity, LivingEntity target) {
+        entity.getBrain().setMemory(MemoryModuleType.LOOK_TARGET, (new EntityTracker(target, true))); // CraftBukkit - decompile error
     }
 
-    private static void setWalkAndLookTargetMemoriesToEachOther(LivingEntity livingentity, LivingEntity livingentity1, float f) {
+    private static void setWalkAndLookTargetMemoriesToEachOther(LivingEntity firstEntity, LivingEntity secondEntity, float speed) {
         boolean flag = true;
 
-        setWalkAndLookTargetMemories(livingentity, (Entity) livingentity1, f, 2);
-        setWalkAndLookTargetMemories(livingentity1, (Entity) livingentity, f, 2);
+        setWalkAndLookTargetMemories(firstEntity, (Entity) secondEntity, speed, 2);
+        setWalkAndLookTargetMemories(secondEntity, (Entity) firstEntity, speed, 2);
     }
 
-    public static void setWalkAndLookTargetMemories(LivingEntity livingentity, Entity entity, float f, int i) {
-        setWalkAndLookTargetMemories(livingentity, (PositionTracker) (new EntityTracker(entity, true)), f, i);
+    public static void setWalkAndLookTargetMemories(LivingEntity livingEntity, Entity target, float speed, int distance) {
+        setWalkAndLookTargetMemories(livingEntity, (PositionTracker) (new EntityTracker(target, true)), speed, distance);
     }
 
-    public static void setWalkAndLookTargetMemories(LivingEntity livingentity, BlockPos blockpos, float f, int i) {
-        setWalkAndLookTargetMemories(livingentity, (PositionTracker) (new BlockPosTracker(blockpos)), f, i);
+    public static void setWalkAndLookTargetMemories(LivingEntity livingEntity, BlockPos pos, float speed, int distance) {
+        setWalkAndLookTargetMemories(livingEntity, (PositionTracker) (new BlockPosTracker(pos)), speed, distance);
     }
 
-    public static void setWalkAndLookTargetMemories(LivingEntity livingentity, PositionTracker positiontracker, float f, int i) {
-        WalkTarget walktarget = new WalkTarget(positiontracker, f, i);
+    public static void setWalkAndLookTargetMemories(LivingEntity entity, PositionTracker positionTracker, float speedModifier, int closeEnoughDist) {
+        WalkTarget memorytarget = new WalkTarget(positionTracker, speedModifier, closeEnoughDist);
 
-        livingentity.getBrain().setMemory(MemoryModuleType.LOOK_TARGET, (Object) positiontracker);
-        livingentity.getBrain().setMemory(MemoryModuleType.WALK_TARGET, (Object) walktarget);
+        entity.getBrain().setMemory(MemoryModuleType.LOOK_TARGET, positionTracker); // CraftBukkit - decompile error
+        entity.getBrain().setMemory(MemoryModuleType.WALK_TARGET, memorytarget); // CraftBukkit - decompile error
     }
 
-    public static void throwItem(LivingEntity livingentity, ItemStack itemstack, Vec3 vec3) {
-        Vec3 vec31 = new Vec3(0.30000001192092896D, 0.30000001192092896D, 0.30000001192092896D);
+    public static void throwItem(LivingEntity livingEntity, ItemStack stack, Vec3 offset) {
+        Vec3 vec3d1 = new Vec3(0.30000001192092896D, 0.30000001192092896D, 0.30000001192092896D);
 
-        throwItem(livingentity, itemstack, vec3, vec31, 0.3F);
+        throwItem(livingEntity, stack, offset, vec3d1, 0.3F);
     }
 
-    public static void throwItem(LivingEntity livingentity, ItemStack itemstack, Vec3 vec3, Vec3 vec31, float f) {
-        double d0 = livingentity.getEyeY() - (double) f;
-        ItemEntity itementity = new ItemEntity(livingentity.level(), livingentity.getX(), d0, livingentity.getZ(), itemstack);
+    public static void throwItem(LivingEntity entity, ItemStack stack, Vec3 offset, Vec3 speedMultiplier, float yOffset) {
+        if (stack.isEmpty()) return; // CraftBukkit - SPIGOT-4940: no empty loot
+        double d0 = entity.getEyeY() - (double) yOffset;
+        ItemEntity entityitem = new ItemEntity(entity.level(), entity.getX(), d0, entity.getZ(), stack);
 
-        itementity.setThrower(livingentity);
-        Vec3 vec32 = vec3.subtract(livingentity.position());
+        entityitem.setThrower(entity);
+        Vec3 vec3d2 = offset.subtract(entity.position());
 
-        vec32 = vec32.normalize().multiply(vec31.x, vec31.y, vec31.z);
-        itementity.setDeltaMovement(vec32);
-        itementity.setDefaultPickUpDelay();
-        livingentity.level().addFreshEntity(itementity);
+        vec3d2 = vec3d2.normalize().multiply(speedMultiplier.x, speedMultiplier.y, speedMultiplier.z);
+        entityitem.setDeltaMovement(vec3d2);
+        entityitem.setDefaultPickUpDelay();
+        // CraftBukkit start
+        org.bukkit.event.entity.EntityDropItemEvent event = new org.bukkit.event.entity.EntityDropItemEvent(entity.getBukkitEntity(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+        entityitem.level().getCraftServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        // CraftBukkit end
+        entity.level().addFreshEntity(entityitem);
     }
 
-    public static SectionPos findSectionClosestToVillage(ServerLevel serverlevel, SectionPos sectionpos, int i) {
-        int j = serverlevel.sectionsToVillage(sectionpos);
-        Stream stream = SectionPos.cube(sectionpos, i).filter((sectionpos1) -> {
-            return serverlevel.sectionsToVillage(sectionpos1) < j;
+    public static SectionPos findSectionClosestToVillage(ServerLevel serverLevel, SectionPos sectionPos, int radius) {
+        int j = serverLevel.sectionsToVillage(sectionPos);
+        Stream<SectionPos> stream = SectionPos.cube(sectionPos, radius).filter((sectionposition1) -> { // CraftBukkit - decompile error
+            return serverLevel.sectionsToVillage(sectionposition1) < j;
         });
 
-        Objects.requireNonNull(serverlevel);
-        return (SectionPos) stream.min(Comparator.comparingInt(serverlevel::sectionsToVillage)).orElse(sectionpos);
+        Objects.requireNonNull(serverLevel);
+        return (SectionPos) stream.min(Comparator.comparingInt(serverLevel::sectionsToVillage)).orElse(sectionPos);
     }
 
-    public static boolean isWithinAttackRange(Mob mob, LivingEntity livingentity, int i) {
+    public static boolean isWithinAttackRange(Mob mob, LivingEntity target, int cooldown) {
         Item item = mob.getMainHandItem().getItem();
 
         if (item instanceof ProjectileWeaponItem) {
-            ProjectileWeaponItem projectileweaponitem = (ProjectileWeaponItem) item;
+            ProjectileWeaponItem itemprojectileweapon = (ProjectileWeaponItem) item;
 
-            if (mob.canFireProjectileWeapon(projectileweaponitem)) {
-                int j = projectileweaponitem.getDefaultProjectileRange() - i;
+            if (mob.canFireProjectileWeapon(itemprojectileweapon)) {
+                int j = itemprojectileweapon.getDefaultProjectileRange() - cooldown;
 
-                return mob.closerThan(livingentity, (double) j);
+                return mob.closerThan(target, (double) j);
             }
         }
 
-        return mob.isWithinMeleeAttackRange(livingentity);
+        return mob.isWithinMeleeAttackRange(target);
     }
 
-    public static boolean isOtherTargetMuchFurtherAwayThanCurrentAttackTarget(LivingEntity livingentity, LivingEntity livingentity1, double d0) {
-        Optional<LivingEntity> optional = livingentity.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET);
+    public static boolean isOtherTargetMuchFurtherAwayThanCurrentAttackTarget(LivingEntity livingEntity, LivingEntity target, double distance) {
+        Optional<LivingEntity> optional = livingEntity.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET);
 
         if (optional.isEmpty()) {
             return false;
         } else {
-            double d1 = livingentity.distanceToSqr(((LivingEntity) optional.get()).position());
-            double d2 = livingentity.distanceToSqr(livingentity1.position());
+            double d1 = livingEntity.distanceToSqr(((LivingEntity) optional.get()).position());
+            double d2 = livingEntity.distanceToSqr(target.position());
 
-            return d2 > d1 + d0 * d0;
+            return d2 > d1 + distance * distance;
         }
     }
 
-    public static boolean canSee(LivingEntity livingentity, LivingEntity livingentity1) {
-        Brain<?> brain = livingentity.getBrain();
+    public static boolean canSee(LivingEntity livingEntity, LivingEntity target) {
+        Brain<?> behaviorcontroller = livingEntity.getBrain();
 
-        return !brain.hasMemoryValue(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES) ? false : ((NearestVisibleLivingEntities) brain.getMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES).get()).contains(livingentity1);
+        return !behaviorcontroller.hasMemoryValue(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES) ? false : ((NearestVisibleLivingEntities) behaviorcontroller.getMemory(MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES).get()).contains(target);
     }
 
-    public static LivingEntity getNearestTarget(LivingEntity livingentity, Optional<LivingEntity> optional, LivingEntity livingentity1) {
-        return optional.isEmpty() ? livingentity1 : getTargetNearestMe(livingentity, (LivingEntity) optional.get(), livingentity1);
+    public static LivingEntity getNearestTarget(LivingEntity centerEntity, Optional<LivingEntity> optionalEntity, LivingEntity livingEntity) {
+        return optionalEntity.isEmpty() ? livingEntity : getTargetNearestMe(centerEntity, (LivingEntity) optionalEntity.get(), livingEntity);
     }
 
-    public static LivingEntity getTargetNearestMe(LivingEntity livingentity, LivingEntity livingentity1, LivingEntity livingentity2) {
-        Vec3 vec3 = livingentity1.position();
-        Vec3 vec31 = livingentity2.position();
+    public static LivingEntity getTargetNearestMe(LivingEntity centerEntity, LivingEntity livingEntity1, LivingEntity livingEntity2) {
+        Vec3 vec3d = livingEntity1.position();
+        Vec3 vec3d1 = livingEntity2.position();
 
-        return livingentity.distanceToSqr(vec3) < livingentity.distanceToSqr(vec31) ? livingentity1 : livingentity2;
+        return centerEntity.distanceToSqr(vec3d) < centerEntity.distanceToSqr(vec3d1) ? livingEntity1 : livingEntity2;
     }
 
-    public static Optional<LivingEntity> getLivingEntityFromUUIDMemory(LivingEntity livingentity, MemoryModuleType<UUID> memorymoduletype) {
-        Optional<UUID> optional = livingentity.getBrain().getMemory(memorymoduletype);
+    public static Optional<LivingEntity> getLivingEntityFromUUIDMemory(LivingEntity livingEntity, MemoryModuleType<UUID> targetMemory) {
+        Optional<UUID> optional = livingEntity.getBrain().getMemory(targetMemory);
 
         return optional.map((uuid) -> {
-            return ((ServerLevel) livingentity.level()).getEntity(uuid);
+            return ((ServerLevel) livingEntity.level()).getEntity(uuid);
         }).map((entity) -> {
-            LivingEntity livingentity1;
+            LivingEntity entityliving1;
 
             if (entity instanceof LivingEntity) {
-                LivingEntity livingentity2 = (LivingEntity) entity;
+                LivingEntity entityliving2 = (LivingEntity) entity;
 
-                livingentity1 = livingentity2;
+                entityliving1 = entityliving2;
             } else {
-                livingentity1 = null;
+                entityliving1 = null;
             }
 
-            return livingentity1;
+            return entityliving1;
         });
     }
 
     @Nullable
-    public static Vec3 getRandomSwimmablePos(PathfinderMob pathfindermob, int i, int j) {
-        Vec3 vec3 = DefaultRandomPos.getPos(pathfindermob, i, j);
+    public static Vec3 getRandomSwimmablePos(PathfinderMob pathfinder, int radius, int verticalDistance) {
+        Vec3 vec3d = DefaultRandomPos.getPos(pathfinder, radius, verticalDistance);
 
-        for (int k = 0; vec3 != null && !pathfindermob.level().getBlockState(BlockPos.containing(vec3)).isPathfindable(pathfindermob.level(), BlockPos.containing(vec3), PathComputationType.WATER) && k++ < 10; vec3 = DefaultRandomPos.getPos(pathfindermob, i, j)) {
+        for (int k = 0; vec3d != null && !pathfinder.level().getBlockState(BlockPos.containing(vec3d)).isPathfindable(pathfinder.level(), BlockPos.containing(vec3d), PathMode.WATER) && k++ < 10; vec3d = DefaultRandomPos.getPos(pathfinder, radius, verticalDistance)) {
             ;
         }
 
-        return vec3;
+        return vec3d;
     }
 
-    public static boolean isBreeding(LivingEntity livingentity) {
-        return livingentity.getBrain().hasMemoryValue(MemoryModuleType.BREED_TARGET);
+    public static boolean isBreeding(LivingEntity entity) {
+        return entity.getBrain().hasMemoryValue(MemoryModuleType.BREED_TARGET);
     }
 }
