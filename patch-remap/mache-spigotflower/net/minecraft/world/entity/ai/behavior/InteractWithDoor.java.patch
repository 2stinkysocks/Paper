--- a/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
+++ b/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
@@ -18,7 +18,7 @@
 import net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor;
 import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.level.block.DoorBlock;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.pathfinder.Node;
 import net.minecraft.world.level.pathfinder.Path;
 import org.apache.commons.lang3.mutable.MutableInt;
@@ -36,53 +36,67 @@
         MutableObject<Node> mutableobject = new MutableObject((Object) null);
         MutableInt mutableint = new MutableInt(0);
 
-        return BehaviorBuilder.create((behaviorbuilder_instance) -> {
-            return behaviorbuilder_instance.group(behaviorbuilder_instance.present(MemoryModuleType.PATH), behaviorbuilder_instance.registered(MemoryModuleType.DOORS_TO_CLOSE), behaviorbuilder_instance.registered(MemoryModuleType.NEAREST_LIVING_ENTITIES)).apply(behaviorbuilder_instance, (memoryaccessor, memoryaccessor1, memoryaccessor2) -> {
-                return (serverlevel, livingentity, i) -> {
-                    Path path = (Path) behaviorbuilder_instance.get(memoryaccessor);
-                    Optional<Set<GlobalPos>> optional = behaviorbuilder_instance.tryGet(memoryaccessor1);
+        return BehaviorBuilder.create((behaviorbuilder_b) -> {
+            return behaviorbuilder_b.group(behaviorbuilder_b.present(MemoryModuleType.PATH), behaviorbuilder_b.registered(MemoryModuleType.DOORS_TO_CLOSE), behaviorbuilder_b.registered(MemoryModuleType.NEAREST_LIVING_ENTITIES)).apply(behaviorbuilder_b, (memoryaccessor, memoryaccessor1, memoryaccessor2) -> {
+                return (worldserver, entityliving, i) -> {
+                    Path pathentity = (Path) behaviorbuilder_b.get(memoryaccessor);
+                    Optional<Set<GlobalPos>> optional = behaviorbuilder_b.tryGet(memoryaccessor1);
 
-                    if (!path.notStarted() && !path.isDone()) {
-                        if (Objects.equals(mutableobject.getValue(), path.getNextNode())) {
+                    if (!pathentity.notStarted() && !pathentity.isDone()) {
+                        if (Objects.equals(mutableobject.getValue(), pathentity.getNextNode())) {
                             mutableint.setValue(20);
                         } else if (mutableint.decrementAndGet() > 0) {
                             return false;
                         }
 
-                        mutableobject.setValue(path.getNextNode());
-                        Node node = path.getPreviousNode();
-                        Node node1 = path.getNextNode();
-                        BlockPos blockpos = node.asBlockPos();
-                        BlockState blockstate = serverlevel.getBlockState(blockpos);
+                        mutableobject.setValue(pathentity.getNextNode());
+                        Node pathpoint = pathentity.getPreviousNode();
+                        Node pathpoint1 = pathentity.getNextNode();
+                        BlockPos blockposition = pathpoint.asBlockPos();
+                        IBlockData iblockdata = worldserver.getBlockState(blockposition);
 
-                        if (blockstate.is(BlockTags.WOODEN_DOORS, (blockbehaviour_blockstatebase) -> {
-                            return blockbehaviour_blockstatebase.getBlock() instanceof DoorBlock;
+                        if (iblockdata.is(BlockTags.WOODEN_DOORS, (blockbase_blockdata) -> {
+                            return blockbase_blockdata.getBlock() instanceof DoorBlock;
                         })) {
-                            DoorBlock doorblock = (DoorBlock) blockstate.getBlock();
+                            DoorBlock blockdoor = (DoorBlock) iblockdata.getBlock();
 
-                            if (!doorblock.isOpen(blockstate)) {
-                                doorblock.setOpen(livingentity, serverlevel, blockstate, blockpos, true);
+                            if (!blockdoor.isOpen(iblockdata)) {
+                                // CraftBukkit start - entities opening doors
+                                org.bukkit.event.entity.EntityInteractEvent event = new org.bukkit.event.entity.EntityInteractEvent(entityliving.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(entityliving.level(), blockposition));
+                                entityliving.level().getCraftServer().getPluginManager().callEvent(event);
+                                if (event.isCancelled()) {
+                                    return false;
+                                }
+                                // CraftBukkit end
+                                blockdoor.setOpen(entityliving, worldserver, iblockdata, blockposition, true);
                             }
 
-                            optional = rememberDoorToClose(memoryaccessor1, optional, serverlevel, blockpos);
+                            optional = rememberDoorToClose(memoryaccessor1, optional, worldserver, blockposition);
                         }
 
-                        BlockPos blockpos1 = node1.asBlockPos();
-                        BlockState blockstate1 = serverlevel.getBlockState(blockpos1);
+                        BlockPos blockposition1 = pathpoint1.asBlockPos();
+                        IBlockData iblockdata1 = worldserver.getBlockState(blockposition1);
 
-                        if (blockstate1.is(BlockTags.WOODEN_DOORS, (blockbehaviour_blockstatebase) -> {
-                            return blockbehaviour_blockstatebase.getBlock() instanceof DoorBlock;
+                        if (iblockdata1.is(BlockTags.WOODEN_DOORS, (blockbase_blockdata) -> {
+                            return blockbase_blockdata.getBlock() instanceof DoorBlock;
                         })) {
-                            DoorBlock doorblock1 = (DoorBlock) blockstate1.getBlock();
+                            DoorBlock blockdoor1 = (DoorBlock) iblockdata1.getBlock();
 
-                            if (!doorblock1.isOpen(blockstate1)) {
-                                doorblock1.setOpen(livingentity, serverlevel, blockstate1, blockpos1, true);
-                                optional = rememberDoorToClose(memoryaccessor1, optional, serverlevel, blockpos1);
+                            if (!blockdoor1.isOpen(iblockdata1)) {
+                                // CraftBukkit start - entities opening doors
+                                org.bukkit.event.entity.EntityInteractEvent event = new org.bukkit.event.entity.EntityInteractEvent(entityliving.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(entityliving.level(), blockposition1));
+                                entityliving.level().getCraftServer().getPluginManager().callEvent(event);
+                                if (event.isCancelled()) {
+                                    return false;
+                                }
+                                // CraftBukkit end
+                                blockdoor1.setOpen(entityliving, worldserver, iblockdata1, blockposition1, true);
+                                optional = rememberDoorToClose(memoryaccessor1, optional, worldserver, blockposition1);
                             }
                         }
 
                         optional.ifPresent((set) -> {
-                            closeDoorsThatIHaveOpenedOrPassedThrough(serverlevel, livingentity, node, node1, set, behaviorbuilder_instance.tryGet(memoryaccessor2));
+                            closeDoorsThatIHaveOpenedOrPassedThrough(worldserver, entityliving, pathpoint, pathpoint1, set, behaviorbuilder_b.tryGet(memoryaccessor2));
                         });
                         return true;
                     } else {
@@ -93,32 +107,32 @@
         });
     }
 
-    public static void closeDoorsThatIHaveOpenedOrPassedThrough(ServerLevel serverlevel, LivingEntity livingentity, @Nullable Node node, @Nullable Node node1, Set<GlobalPos> set, Optional<List<LivingEntity>> optional) {
-        Iterator iterator = set.iterator();
+    public static void closeDoorsThatIHaveOpenedOrPassedThrough(ServerLevel level, LivingEntity entity, @Nullable Node previous, @Nullable Node next, Set<GlobalPos> doorPositions, Optional<List<LivingEntity>> nearestLivingEntities) {
+        Iterator iterator = doorPositions.iterator();
 
         while (iterator.hasNext()) {
             GlobalPos globalpos = (GlobalPos) iterator.next();
-            BlockPos blockpos = globalpos.pos();
+            BlockPos blockposition = globalpos.pos();
 
-            if ((node == null || !node.asBlockPos().equals(blockpos)) && (node1 == null || !node1.asBlockPos().equals(blockpos))) {
-                if (isDoorTooFarAway(serverlevel, livingentity, globalpos)) {
+            if ((previous == null || !previous.asBlockPos().equals(blockposition)) && (next == null || !next.asBlockPos().equals(blockposition))) {
+                if (isDoorTooFarAway(level, entity, globalpos)) {
                     iterator.remove();
                 } else {
-                    BlockState blockstate = serverlevel.getBlockState(blockpos);
+                    IBlockData iblockdata = level.getBlockState(blockposition);
 
-                    if (!blockstate.is(BlockTags.WOODEN_DOORS, (blockbehaviour_blockstatebase) -> {
-                        return blockbehaviour_blockstatebase.getBlock() instanceof DoorBlock;
+                    if (!iblockdata.is(BlockTags.WOODEN_DOORS, (blockbase_blockdata) -> {
+                        return blockbase_blockdata.getBlock() instanceof DoorBlock;
                     })) {
                         iterator.remove();
                     } else {
-                        DoorBlock doorblock = (DoorBlock) blockstate.getBlock();
+                        DoorBlock blockdoor = (DoorBlock) iblockdata.getBlock();
 
-                        if (!doorblock.isOpen(blockstate)) {
+                        if (!blockdoor.isOpen(iblockdata)) {
                             iterator.remove();
-                        } else if (areOtherMobsComingThroughDoor(livingentity, blockpos, optional)) {
+                        } else if (areOtherMobsComingThroughDoor(entity, blockposition, nearestLivingEntities)) {
                             iterator.remove();
                         } else {
-                            doorblock.setOpen(livingentity, serverlevel, blockstate, blockpos, false);
+                            blockdoor.setOpen(entity, level, iblockdata, blockposition, false);
                             iterator.remove();
                         }
                     }
@@ -128,52 +142,52 @@
 
     }
 
-    private static boolean areOtherMobsComingThroughDoor(LivingEntity livingentity, BlockPos blockpos, Optional<List<LivingEntity>> optional) {
-        return optional.isEmpty() ? false : ((List) optional.get()).stream().filter((livingentity1) -> {
-            return livingentity1.getType() == livingentity.getType();
-        }).filter((livingentity1) -> {
-            return blockpos.closerToCenterThan(livingentity1.position(), 2.0D);
-        }).anyMatch((livingentity1) -> {
-            return isMobComingThroughDoor(livingentity1.getBrain(), blockpos);
+    private static boolean areOtherMobsComingThroughDoor(LivingEntity entity, BlockPos pos, Optional<List<LivingEntity>> nearestLivingEntities) {
+        return nearestLivingEntities.isEmpty() ? false : (nearestLivingEntities.get()).stream().filter((entityliving1) -> { // CraftBukkit - decompile error
+            return entityliving1.getType() == entity.getType();
+        }).filter((entityliving1) -> {
+            return pos.closerToCenterThan(entityliving1.position(), 2.0D);
+        }).anyMatch((entityliving1) -> {
+            return isMobComingThroughDoor(entityliving1.getBrain(), pos);
         });
     }
 
-    private static boolean isMobComingThroughDoor(Brain<?> brain, BlockPos blockpos) {
+    private static boolean isMobComingThroughDoor(Brain<?> brain, BlockPos pos) {
         if (!brain.hasMemoryValue(MemoryModuleType.PATH)) {
             return false;
         } else {
-            Path path = (Path) brain.getMemory(MemoryModuleType.PATH).get();
+            Path pathentity = (Path) brain.getMemory(MemoryModuleType.PATH).get();
 
-            if (path.isDone()) {
+            if (pathentity.isDone()) {
                 return false;
             } else {
-                Node node = path.getPreviousNode();
+                Node pathpoint = pathentity.getPreviousNode();
 
-                if (node == null) {
+                if (pathpoint == null) {
                     return false;
                 } else {
-                    Node node1 = path.getNextNode();
+                    Node pathpoint1 = pathentity.getNextNode();
 
-                    return blockpos.equals(node.asBlockPos()) || blockpos.equals(node1.asBlockPos());
+                    return pos.equals(pathpoint.asBlockPos()) || pos.equals(pathpoint1.asBlockPos());
                 }
             }
         }
     }
 
-    private static boolean isDoorTooFarAway(ServerLevel serverlevel, LivingEntity livingentity, GlobalPos globalpos) {
-        return globalpos.dimension() != serverlevel.dimension() || !globalpos.pos().closerToCenterThan(livingentity.position(), 3.0D);
+    private static boolean isDoorTooFarAway(ServerLevel level, LivingEntity entity, GlobalPos pos) {
+        return pos.dimension() != level.dimension() || !pos.pos().closerToCenterThan(entity.position(), 3.0D);
     }
 
-    private static Optional<Set<GlobalPos>> rememberDoorToClose(MemoryAccessor<Mu, Set<GlobalPos>> memoryaccessor, Optional<Set<GlobalPos>> optional, ServerLevel serverlevel, BlockPos blockpos) {
-        GlobalPos globalpos = GlobalPos.of(serverlevel.dimension(), blockpos);
+    private static Optional<Set<GlobalPos>> rememberDoorToClose(MemoryAccessor<Mu, Set<GlobalPos>> doorsToClose, Optional<Set<GlobalPos>> doorPositions, ServerLevel level, BlockPos pos) {
+        GlobalPos globalpos = GlobalPos.of(level.dimension(), pos);
 
-        return Optional.of((Set) optional.map((set) -> {
+        return Optional.of((Set) doorPositions.map((set) -> {
             set.add(globalpos);
             return set;
         }).orElseGet(() -> {
             Set<GlobalPos> set = Sets.newHashSet(new GlobalPos[]{globalpos});
 
-            memoryaccessor.set(set);
+            doorsToClose.set(set);
             return set;
         }));
     }
