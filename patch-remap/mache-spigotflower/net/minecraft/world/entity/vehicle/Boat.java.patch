--- a/net/minecraft/world/entity/vehicle/Boat.java
+++ b/net/minecraft/world/entity/vehicle/Boat.java
@@ -23,15 +23,15 @@
 import net.minecraft.util.ByIdMap;
 import net.minecraft.util.Mth;
 import net.minecraft.util.StringRepresentable;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityPose;
 import net.minecraft.world.entity.EntitySelector;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMoveType;
 import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.Pose;
 import net.minecraft.world.entity.VariantHolder;
 import net.minecraft.world.entity.animal.Animal;
 import net.minecraft.world.entity.animal.WaterAnimal;
@@ -40,12 +40,12 @@
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.IMaterial;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.WaterlilyBlock;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.AABB;
@@ -55,6 +55,15 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.joml.Vector3f;
 
+// CraftBukkit start
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.vehicle.VehicleDestroyEvent;
+import org.bukkit.event.vehicle.VehicleEntityCollisionEvent;
+import org.bukkit.event.vehicle.VehicleMoveEvent;
+// CraftBukkit end
+
 public class Boat extends VehicleEntity implements VariantHolder<Boat.Type> {
 
     private static final EntityDataAccessor<Integer> DATA_ID_TYPE = SynchedEntityData.defineId(Boat.class, EntityDataSerializers.INT);
@@ -83,8 +92,8 @@
     private boolean inputDown;
     private double waterLevel;
     private float landFriction;
-    private Boat.Status status;
-    private Boat.Status oldStatus;
+    public Boat.EnumStatus status;
+    private Boat.EnumStatus oldStatus;
     private double lastYd;
     private boolean isAboveBubbleColumn;
     private boolean bubbleColumnDirectionIsDown;
@@ -92,34 +101,39 @@
     private float bubbleAngle;
     private float bubbleAngleO;
 
-    public Boat(EntityType<? extends Boat> entitytype, Level level) {
-        super(entitytype, level);
+    // CraftBukkit start
+    // PAIL: Some of these haven't worked since a few updates, and since 1.9 they are less and less applicable.
+    public double maxSpeed = 0.4D;
+    public double occupiedDeceleration = 0.2D;
+    public double unoccupiedDeceleration = -1;
+    public boolean landBoats = false;
+    // CraftBukkit end
+
+    public Boat(EntityType<? extends Boat> entityType, Level level) {
+        super(entityType, level);
         this.paddlePositions = new float[2];
         this.blocksBuilding = true;
     }
 
-    public Boat(Level level, double d0, double d1, double d2) {
+    public Boat(Level level, double x, double d1, double y) {
         this(EntityType.BOAT, level);
-        this.setPos(d0, d1, d2);
-        this.xo = d0;
+        this.setPos(x, d1, y);
+        this.xo = x;
         this.yo = d1;
-        this.zo = d2;
+        this.zo = y;
     }
 
     @Override
-    @Override
-    protected float getEyeHeight(Pose pose, EntityDimensions entitydimensions) {
-        return entitydimensions.height;
+    protected float getEyeHeight(EntityPose pose, EntityDimensions size) {
+        return size.height;
     }
 
     @Override
-    @Override
     protected Entity.MovementEmission getMovementEmission() {
         return Entity.MovementEmission.EVENTS;
     }
 
     @Override
-    @Override
     protected void defineSynchedData() {
         super.defineSynchedData();
         this.entityData.define(Boat.DATA_ID_TYPE, Boat.Type.OAK.ordinal());
@@ -129,36 +143,31 @@
     }
 
     @Override
-    @Override
     public boolean canCollideWith(Entity entity) {
         return canVehicleCollide(this, entity);
     }
 
-    public static boolean canVehicleCollide(Entity entity, Entity entity1) {
-        return (entity1.canBeCollidedWith() || entity1.isPushable()) && !entity.isPassengerOfSameVehicle(entity1);
+    public static boolean canVehicleCollide(Entity vehicle, Entity entity) {
+        return (entity.canBeCollidedWith() || entity.isPushable()) && !vehicle.isPassengerOfSameVehicle(entity);
     }
 
     @Override
-    @Override
     public boolean canBeCollidedWith() {
         return true;
     }
 
     @Override
-    @Override
     public boolean isPushable() {
         return true;
     }
 
     @Override
-    @Override
-    protected Vec3 getRelativePortalPosition(Direction.Axis direction_axis, BlockUtil.FoundRectangle blockutil_foundrectangle) {
-        return LivingEntity.resetForwardDirectionOfRelativePortalPosition(super.getRelativePortalPosition(direction_axis, blockutil_foundrectangle));
+    protected Vec3 getRelativePortalPosition(Direction.Axis axis, BlockUtil.FoundRectangle portal) {
+        return LivingEntity.resetForwardDirectionOfRelativePortalPosition(super.getRelativePortalPosition(axis, portal));
     }
 
     @Override
-    @Override
-    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entitydimensions, float f) {
+    protected Vector3f getPassengerAttachmentPoint(Entity entity, EntityDimensions entitysize, float f) {
         float f1 = this.getSinglePassengerXOffset();
 
         if (this.getPassengers().size() > 1) {
@@ -175,15 +184,14 @@
             }
         }
 
-        return new Vector3f(0.0F, this.getVariant() == Boat.Type.BAMBOO ? entitydimensions.height * 0.8888889F : entitydimensions.height / 3.0F, f1);
+        return new Vector3f(0.0F, this.getVariant() == Boat.Type.BAMBOO ? entitysize.height * 0.8888889F : entitysize.height / 3.0F, f1);
     }
 
     @Override
-    @Override
-    public void onAboveBubbleCol(boolean flag) {
+    public void onAboveBubbleCol(boolean downwards) {
         if (!this.level().isClientSide) {
             this.isAboveBubbleColumn = true;
-            this.bubbleColumnDirectionIsDown = flag;
+            this.bubbleColumnDirectionIsDown = downwards;
             if (this.getBubbleTime() == 0) {
                 this.setBubbleTime(60);
             }
@@ -198,20 +206,38 @@
     }
 
     @Override
-    @Override
     public void push(Entity entity) {
         if (entity instanceof Boat) {
             if (entity.getBoundingBox().minY < this.getBoundingBox().maxY) {
+                // CraftBukkit start
+                if (!this.isPassengerOfSameVehicle(entity)) {
+                    VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), entity.getBukkitEntity());
+                    this.level().getCraftServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
                 super.push(entity);
             }
         } else if (entity.getBoundingBox().minY <= this.getBoundingBox().minY) {
+            // CraftBukkit start
+            if (!this.isPassengerOfSameVehicle(entity)) {
+                VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), entity.getBukkitEntity());
+                this.level().getCraftServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+            }
+            // CraftBukkit end
             super.push(entity);
         }
 
     }
 
     @Override
-    @Override
     public Item getDropItem() {
         Item item;
 
@@ -248,21 +274,18 @@
     }
 
     @Override
-    @Override
-    public void animateHurt(float f) {
+    public void animateHurt(float yaw) {
         this.setHurtDir(-this.getHurtDir());
         this.setHurtTime(10);
         this.setDamage(this.getDamage() * 11.0F);
     }
 
     @Override
-    @Override
     public boolean isPickable() {
         return !this.isRemoved();
     }
 
     @Override
-    @Override
     public void lerpTo(double d0, double d1, double d2, float f, float f1, int i) {
         this.lerpX = d0;
         this.lerpY = d1;
@@ -273,47 +296,41 @@
     }
 
     @Override
-    @Override
     public double lerpTargetX() {
         return this.lerpSteps > 0 ? this.lerpX : this.getX();
     }
 
     @Override
-    @Override
     public double lerpTargetY() {
         return this.lerpSteps > 0 ? this.lerpY : this.getY();
     }
 
     @Override
-    @Override
     public double lerpTargetZ() {
         return this.lerpSteps > 0 ? this.lerpZ : this.getZ();
     }
 
     @Override
-    @Override
     public float lerpTargetXRot() {
         return this.lerpSteps > 0 ? (float) this.lerpXRot : this.getXRot();
     }
 
     @Override
-    @Override
     public float lerpTargetYRot() {
         return this.lerpSteps > 0 ? (float) this.lerpYRot : this.getYRot();
     }
 
     @Override
-    @Override
     public Direction getMotionDirection() {
         return this.getDirection().getClockWise();
     }
 
+    private Location lastLocation; // CraftBukkit
     @Override
-    @Override
     public void tick() {
         this.oldStatus = this.status;
         this.status = this.getStatus();
-        if (this.status != Boat.Status.UNDER_WATER && this.status != Boat.Status.UNDER_FLOWING_WATER) {
+        if (this.status != Boat.EnumStatus.UNDER_WATER && this.status != Boat.EnumStatus.UNDER_FLOWING_WATER) {
             this.outOfControlTicks = 0.0F;
         } else {
             ++this.outOfControlTicks;
@@ -344,24 +361,40 @@
                 this.level().sendPacketToServer(new ServerboundPaddleBoatPacket(this.getPaddleState(0), this.getPaddleState(1)));
             }
 
-            this.move(MoverType.SELF, this.getDeltaMovement());
+            this.move(EnumMoveType.SELF, this.getDeltaMovement());
         } else {
             this.setDeltaMovement(Vec3.ZERO);
         }
 
+        // CraftBukkit start
+        org.bukkit.Server server = this.level().getCraftServer();
+        org.bukkit.World bworld = this.level().getWorld();
+
+        Location to = CraftLocation.toBukkit(this.position(), bworld, this.getYRot(), this.getXRot());
+        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+
+        server.getPluginManager().callEvent(new org.bukkit.event.vehicle.VehicleUpdateEvent(vehicle));
+
+        if (lastLocation != null && !lastLocation.equals(to)) {
+            VehicleMoveEvent event = new VehicleMoveEvent(vehicle, lastLocation, to);
+            server.getPluginManager().callEvent(event);
+        }
+        lastLocation = vehicle.getLocation();
+        // CraftBukkit end
+
         this.tickBubbleColumn();
 
         for (int i = 0; i <= 1; ++i) {
             if (this.getPaddleState(i)) {
                 if (!this.isSilent() && (double) (this.paddlePositions[i] % 6.2831855F) <= 0.7853981852531433D && (double) ((this.paddlePositions[i] + 0.3926991F) % 6.2831855F) >= 0.7853981852531433D) {
-                    SoundEvent soundevent = this.getPaddleSound();
+                    SoundEvent soundeffect = this.getPaddleSound();
 
-                    if (soundevent != null) {
-                        Vec3 vec3 = this.getViewVector(1.0F);
-                        double d0 = i == 1 ? -vec3.z : vec3.z;
-                        double d1 = i == 1 ? vec3.x : -vec3.x;
+                    if (soundeffect != null) {
+                        Vec3 vec3d = this.getViewVector(1.0F);
+                        double d0 = i == 1 ? -vec3d.z : vec3d.z;
+                        double d1 = i == 1 ? vec3d.x : -vec3d.x;
 
-                        this.level().playSound((Player) null, this.getX() + d0, this.getY(), this.getZ() + d1, soundevent, this.getSoundSource(), 1.0F, 0.8F + 0.4F * this.random.nextFloat());
+                        this.level().playSound((Player) null, this.getX() + d0, this.getY(), this.getZ() + d1, soundeffect, this.getSoundSource(), 1.0F, 0.8F + 0.4F * this.random.nextFloat());
                     }
                 }
 
@@ -420,15 +453,15 @@
 
                 if (j > 0 && i == 0) {
                     this.setBubbleTime(0);
-                    Vec3 vec3 = this.getDeltaMovement();
+                    Vec3 vec3d = this.getDeltaMovement();
 
                     if (this.bubbleColumnDirectionIsDown) {
-                        this.setDeltaMovement(vec3.add(0.0D, -0.7D, 0.0D));
+                        this.setDeltaMovement(vec3d.add(0.0D, -0.7D, 0.0D));
                         this.ejectPassengers();
                     } else {
-                        this.setDeltaMovement(vec3.x, this.hasPassenger((entity) -> {
+                        this.setDeltaMovement(vec3d.x, this.hasPassenger((entity) -> {
                             return entity instanceof Player;
-                        }) ? 2.7D : 0.6D, vec3.z);
+                        }) ? 2.7D : 0.6D, vec3d.z);
                     }
                 }
 
@@ -465,44 +498,44 @@
         }
     }
 
-    public void setPaddleState(boolean flag, boolean flag1) {
-        this.entityData.set(Boat.DATA_ID_PADDLE_LEFT, flag);
-        this.entityData.set(Boat.DATA_ID_PADDLE_RIGHT, flag1);
+    public void setPaddleState(boolean left, boolean right) {
+        this.entityData.set(Boat.DATA_ID_PADDLE_LEFT, left);
+        this.entityData.set(Boat.DATA_ID_PADDLE_RIGHT, right);
     }
 
-    public float getRowingTime(int i, float f) {
-        return this.getPaddleState(i) ? Mth.clampedLerp(this.paddlePositions[i] - 0.3926991F, this.paddlePositions[i], f) : 0.0F;
+    public float getRowingTime(int side, float limbSwing) {
+        return this.getPaddleState(side) ? Mth.clampedLerp(this.paddlePositions[side] - 0.3926991F, this.paddlePositions[side], limbSwing) : 0.0F;
     }
 
-    private Boat.Status getStatus() {
-        Boat.Status boat_status = this.isUnderwater();
+    private Boat.EnumStatus getStatus() {
+        Boat.EnumStatus entityboat_enumstatus = this.isUnderwater();
 
-        if (boat_status != null) {
+        if (entityboat_enumstatus != null) {
             this.waterLevel = this.getBoundingBox().maxY;
-            return boat_status;
+            return entityboat_enumstatus;
         } else if (this.checkInWater()) {
-            return Boat.Status.IN_WATER;
+            return Boat.EnumStatus.IN_WATER;
         } else {
             float f = this.getGroundFriction();
 
             if (f > 0.0F) {
                 this.landFriction = f;
-                return Boat.Status.ON_LAND;
+                return Boat.EnumStatus.ON_LAND;
             } else {
-                return Boat.Status.IN_AIR;
+                return Boat.EnumStatus.IN_AIR;
             }
         }
     }
 
     public float getWaterLevelAbove() {
-        AABB aabb = this.getBoundingBox();
-        int i = Mth.floor(aabb.minX);
-        int j = Mth.ceil(aabb.maxX);
-        int k = Mth.floor(aabb.maxY);
-        int l = Mth.ceil(aabb.maxY - this.lastYd);
-        int i1 = Mth.floor(aabb.minZ);
-        int j1 = Mth.ceil(aabb.maxZ);
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
+        AABB axisalignedbb = this.getBoundingBox();
+        int i = Mth.floor(axisalignedbb.minX);
+        int j = Mth.ceil(axisalignedbb.maxX);
+        int k = Mth.floor(axisalignedbb.maxY);
+        int l = Mth.ceil(axisalignedbb.maxY - this.lastYd);
+        int i1 = Mth.floor(axisalignedbb.minZ);
+        int j1 = Mth.ceil(axisalignedbb.maxZ);
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
         int k1 = k;
 
         while (k1 < l) {
@@ -520,11 +553,11 @@
                             continue label35;
                         }
 
-                        blockpos_mutableblockpos.set(l1, k1, i2);
-                        FluidState fluidstate = this.level().getFluidState(blockpos_mutableblockpos);
+                        blockposition_mutableblockposition.set(l1, k1, i2);
+                        FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
 
-                        if (fluidstate.is(FluidTags.WATER)) {
-                            f = Math.max(f, fluidstate.getHeight(this.level(), blockpos_mutableblockpos));
+                        if (fluid.is(FluidTags.WATER)) {
+                            f = Math.max(f, fluid.getHeight(this.level(), blockposition_mutableblockposition));
                         }
 
                         if (f >= 1.0F) {
@@ -534,7 +567,7 @@
                         ++i2;
                     }
                 } else if (f < 1.0F) {
-                    return (float) blockpos_mutableblockpos.getY() + f;
+                    return (float) blockposition_mutableblockposition.getY() + f;
                 }
 
                 ++k1;
@@ -546,18 +579,18 @@
     }
 
     public float getGroundFriction() {
-        AABB aabb = this.getBoundingBox();
-        AABB aabb1 = new AABB(aabb.minX, aabb.minY - 0.001D, aabb.minZ, aabb.maxX, aabb.minY, aabb.maxZ);
-        int i = Mth.floor(aabb1.minX) - 1;
-        int j = Mth.ceil(aabb1.maxX) + 1;
-        int k = Mth.floor(aabb1.minY) - 1;
-        int l = Mth.ceil(aabb1.maxY) + 1;
-        int i1 = Mth.floor(aabb1.minZ) - 1;
-        int j1 = Mth.ceil(aabb1.maxZ) + 1;
-        VoxelShape voxelshape = Shapes.create(aabb1);
+        AABB axisalignedbb = this.getBoundingBox();
+        AABB axisalignedbb1 = new AABB(axisalignedbb.minX, axisalignedbb.minY - 0.001D, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.minY, axisalignedbb.maxZ);
+        int i = Mth.floor(axisalignedbb1.minX) - 1;
+        int j = Mth.ceil(axisalignedbb1.maxX) + 1;
+        int k = Mth.floor(axisalignedbb1.minY) - 1;
+        int l = Mth.ceil(axisalignedbb1.maxY) + 1;
+        int i1 = Mth.floor(axisalignedbb1.minZ) - 1;
+        int j1 = Mth.ceil(axisalignedbb1.maxZ) + 1;
+        VoxelShape voxelshape = Shapes.create(axisalignedbb1);
         float f = 0.0F;
         int k1 = 0;
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
         for (int l1 = i; l1 < j; ++l1) {
             for (int i2 = i1; i2 < j1; ++i2) {
@@ -566,11 +599,11 @@
                 if (j2 != 2) {
                     for (int k2 = k; k2 < l; ++k2) {
                         if (j2 <= 0 || k2 != k && k2 != l - 1) {
-                            blockpos_mutableblockpos.set(l1, k2, i2);
-                            BlockState blockstate = this.level().getBlockState(blockpos_mutableblockpos);
+                            blockposition_mutableblockposition.set(l1, k2, i2);
+                            IBlockData iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
 
-                            if (!(blockstate.getBlock() instanceof WaterlilyBlock) && Shapes.joinIsNotEmpty(blockstate.getCollisionShape(this.level(), blockpos_mutableblockpos).move((double) l1, (double) k2, (double) i2), voxelshape, BooleanOp.AND)) {
-                                f += blockstate.getBlock().getFriction();
+                            if (!(iblockdata.getBlock() instanceof WaterlilyBlock) && Shapes.joinIsNotEmpty(iblockdata.getCollisionShape(this.level(), blockposition_mutableblockposition).move((double) l1, (double) k2, (double) i2), voxelshape, BooleanOp.AND)) {
+                                f += iblockdata.getBlock().getFriction();
                                 ++k1;
                             }
                         }
@@ -583,29 +616,29 @@
     }
 
     private boolean checkInWater() {
-        AABB aabb = this.getBoundingBox();
-        int i = Mth.floor(aabb.minX);
-        int j = Mth.ceil(aabb.maxX);
-        int k = Mth.floor(aabb.minY);
-        int l = Mth.ceil(aabb.minY + 0.001D);
-        int i1 = Mth.floor(aabb.minZ);
-        int j1 = Mth.ceil(aabb.maxZ);
+        AABB axisalignedbb = this.getBoundingBox();
+        int i = Mth.floor(axisalignedbb.minX);
+        int j = Mth.ceil(axisalignedbb.maxX);
+        int k = Mth.floor(axisalignedbb.minY);
+        int l = Mth.ceil(axisalignedbb.minY + 0.001D);
+        int i1 = Mth.floor(axisalignedbb.minZ);
+        int j1 = Mth.ceil(axisalignedbb.maxZ);
         boolean flag = false;
 
         this.waterLevel = -1.7976931348623157E308D;
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
                 for (int i2 = i1; i2 < j1; ++i2) {
-                    blockpos_mutableblockpos.set(k1, l1, i2);
-                    FluidState fluidstate = this.level().getFluidState(blockpos_mutableblockpos);
+                    blockposition_mutableblockposition.set(k1, l1, i2);
+                    FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
 
-                    if (fluidstate.is(FluidTags.WATER)) {
-                        float f = (float) l1 + fluidstate.getHeight(this.level(), blockpos_mutableblockpos);
+                    if (fluid.is(FluidTags.WATER)) {
+                        float f = (float) l1 + fluid.getHeight(this.level(), blockposition_mutableblockposition);
 
                         this.waterLevel = Math.max((double) f, this.waterLevel);
-                        flag |= aabb.minY < (double) f;
+                        flag |= axisalignedbb.minY < (double) f;
                     }
                 }
             }
@@ -615,27 +648,27 @@
     }
 
     @Nullable
-    private Boat.Status isUnderwater() {
-        AABB aabb = this.getBoundingBox();
-        double d0 = aabb.maxY + 0.001D;
-        int i = Mth.floor(aabb.minX);
-        int j = Mth.ceil(aabb.maxX);
-        int k = Mth.floor(aabb.maxY);
+    private Boat.EnumStatus isUnderwater() {
+        AABB axisalignedbb = this.getBoundingBox();
+        double d0 = axisalignedbb.maxY + 0.001D;
+        int i = Mth.floor(axisalignedbb.minX);
+        int j = Mth.ceil(axisalignedbb.maxX);
+        int k = Mth.floor(axisalignedbb.maxY);
         int l = Mth.ceil(d0);
-        int i1 = Mth.floor(aabb.minZ);
-        int j1 = Mth.ceil(aabb.maxZ);
+        int i1 = Mth.floor(axisalignedbb.minZ);
+        int j1 = Mth.ceil(axisalignedbb.maxZ);
         boolean flag = false;
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
         for (int k1 = i; k1 < j; ++k1) {
             for (int l1 = k; l1 < l; ++l1) {
                 for (int i2 = i1; i2 < j1; ++i2) {
-                    blockpos_mutableblockpos.set(k1, l1, i2);
-                    FluidState fluidstate = this.level().getFluidState(blockpos_mutableblockpos);
+                    blockposition_mutableblockposition.set(k1, l1, i2);
+                    FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
 
-                    if (fluidstate.is(FluidTags.WATER) && d0 < (double) ((float) blockpos_mutableblockpos.getY() + fluidstate.getHeight(this.level(), blockpos_mutableblockpos))) {
-                        if (!fluidstate.isSource()) {
-                            return Boat.Status.UNDER_FLOWING_WATER;
+                    if (fluid.is(FluidTags.WATER) && d0 < (double) ((float) blockposition_mutableblockposition.getY() + fluid.getHeight(this.level(), blockposition_mutableblockposition))) {
+                        if (!fluid.isSource()) {
+                            return Boat.EnumStatus.UNDER_FLOWING_WATER;
                         }
 
                         flag = true;
@@ -644,7 +677,7 @@
             }
         }
 
-        return flag ? Boat.Status.UNDER_WATER : null;
+        return flag ? Boat.EnumStatus.UNDER_WATER : null;
     }
 
     private void floatBoat() {
@@ -653,39 +686,39 @@
         double d2 = 0.0D;
 
         this.invFriction = 0.05F;
-        if (this.oldStatus == Boat.Status.IN_AIR && this.status != Boat.Status.IN_AIR && this.status != Boat.Status.ON_LAND) {
+        if (this.oldStatus == Boat.EnumStatus.IN_AIR && this.status != Boat.EnumStatus.IN_AIR && this.status != Boat.EnumStatus.ON_LAND) {
             this.waterLevel = this.getY(1.0D);
             this.setPos(this.getX(), (double) (this.getWaterLevelAbove() - this.getBbHeight()) + 0.101D, this.getZ());
             this.setDeltaMovement(this.getDeltaMovement().multiply(1.0D, 0.0D, 1.0D));
             this.lastYd = 0.0D;
-            this.status = Boat.Status.IN_WATER;
+            this.status = Boat.EnumStatus.IN_WATER;
         } else {
-            if (this.status == Boat.Status.IN_WATER) {
+            if (this.status == Boat.EnumStatus.IN_WATER) {
                 d2 = (this.waterLevel - this.getY()) / (double) this.getBbHeight();
                 this.invFriction = 0.9F;
-            } else if (this.status == Boat.Status.UNDER_FLOWING_WATER) {
+            } else if (this.status == Boat.EnumStatus.UNDER_FLOWING_WATER) {
                 d1 = -7.0E-4D;
                 this.invFriction = 0.9F;
-            } else if (this.status == Boat.Status.UNDER_WATER) {
+            } else if (this.status == Boat.EnumStatus.UNDER_WATER) {
                 d2 = 0.009999999776482582D;
                 this.invFriction = 0.45F;
-            } else if (this.status == Boat.Status.IN_AIR) {
+            } else if (this.status == Boat.EnumStatus.IN_AIR) {
                 this.invFriction = 0.9F;
-            } else if (this.status == Boat.Status.ON_LAND) {
+            } else if (this.status == Boat.EnumStatus.ON_LAND) {
                 this.invFriction = this.landFriction;
                 if (this.getControllingPassenger() instanceof Player) {
                     this.landFriction /= 2.0F;
                 }
             }
 
-            Vec3 vec3 = this.getDeltaMovement();
+            Vec3 vec3d = this.getDeltaMovement();
 
-            this.setDeltaMovement(vec3.x * (double) this.invFriction, vec3.y + d1, vec3.z * (double) this.invFriction);
+            this.setDeltaMovement(vec3d.x * (double) this.invFriction, vec3d.y + d1, vec3d.z * (double) this.invFriction);
             this.deltaRotation *= this.invFriction;
             if (d2 > 0.0D) {
-                Vec3 vec31 = this.getDeltaMovement();
+                Vec3 vec3d1 = this.getDeltaMovement();
 
-                this.setDeltaMovement(vec31.x, (vec31.y + d2 * 0.06153846016296973D) * 0.75D, vec31.z);
+                this.setDeltaMovement(vec3d1.x, (vec3d1.y + d2 * 0.06153846016296973D) * 0.75D, vec3d1.z);
             }
         }
 
@@ -730,170 +763,166 @@
     }
 
     @Override
-    @Override
-    protected void positionRider(Entity entity, Entity.MoveFunction entity_movefunction) {
-        super.positionRider(entity, entity_movefunction);
-        if (!entity.getType().is(EntityTypeTags.CAN_TURN_IN_BOATS)) {
-            entity.setYRot(entity.getYRot() + this.deltaRotation);
-            entity.setYHeadRot(entity.getYHeadRot() + this.deltaRotation);
-            this.clampRotation(entity);
-            if (entity instanceof Animal && this.getPassengers().size() == this.getMaxPassengers()) {
-                int i = entity.getId() % 2 == 0 ? 90 : 270;
+    protected void positionRider(Entity passenger, Entity.MoveFunction callback) {
+        super.positionRider(passenger, callback);
+        if (!passenger.getType().is(EntityTypeTags.CAN_TURN_IN_BOATS)) {
+            passenger.setYRot(passenger.getYRot() + this.deltaRotation);
+            passenger.setYHeadRot(passenger.getYHeadRot() + this.deltaRotation);
+            this.clampRotation(passenger);
+            if (passenger instanceof Animal && this.getPassengers().size() == this.getMaxPassengers()) {
+                int i = passenger.getId() % 2 == 0 ? 90 : 270;
 
-                entity.setYBodyRot(((Animal) entity).yBodyRot + (float) i);
-                entity.setYHeadRot(entity.getYHeadRot() + (float) i);
+                passenger.setYBodyRot(((Animal) passenger).yBodyRot + (float) i);
+                passenger.setYHeadRot(passenger.getYHeadRot() + (float) i);
             }
 
         }
     }
 
     @Override
-    @Override
-    public Vec3 getDismountLocationForPassenger(LivingEntity livingentity) {
-        Vec3 vec3 = getCollisionHorizontalEscapeVector((double) (this.getBbWidth() * Mth.SQRT_OF_TWO), (double) livingentity.getBbWidth(), livingentity.getYRot());
-        double d0 = this.getX() + vec3.x;
-        double d1 = this.getZ() + vec3.z;
-        BlockPos blockpos = BlockPos.containing(d0, this.getBoundingBox().maxY, d1);
-        BlockPos blockpos1 = blockpos.below();
+    public Vec3 getDismountLocationForPassenger(LivingEntity livingEntity) {
+        Vec3 vec3d = getCollisionHorizontalEscapeVector((double) (this.getBbWidth() * Mth.SQRT_OF_TWO), (double) livingEntity.getBbWidth(), livingEntity.getYRot());
+        double d0 = this.getX() + vec3d.x;
+        double d1 = this.getZ() + vec3d.z;
+        BlockPos blockposition = BlockPos.containing(d0, this.getBoundingBox().maxY, d1);
+        BlockPos blockposition1 = blockposition.below();
 
-        if (!this.level().isWaterAt(blockpos1)) {
+        if (!this.level().isWaterAt(blockposition1)) {
             List<Vec3> list = Lists.newArrayList();
-            double d2 = this.level().getBlockFloorHeight(blockpos);
+            double d2 = this.level().getBlockFloorHeight(blockposition);
 
             if (DismountHelper.isBlockFloorValid(d2)) {
-                list.add(new Vec3(d0, (double) blockpos.getY() + d2, d1));
+                list.add(new Vec3(d0, (double) blockposition.getY() + d2, d1));
             }
 
-            double d3 = this.level().getBlockFloorHeight(blockpos1);
+            double d3 = this.level().getBlockFloorHeight(blockposition1);
 
             if (DismountHelper.isBlockFloorValid(d3)) {
-                list.add(new Vec3(d0, (double) blockpos1.getY() + d3, d1));
+                list.add(new Vec3(d0, (double) blockposition1.getY() + d3, d1));
             }
 
-            UnmodifiableIterator unmodifiableiterator = livingentity.getDismountPoses().iterator();
+            UnmodifiableIterator unmodifiableiterator = livingEntity.getDismountPoses().iterator();
 
             while (unmodifiableiterator.hasNext()) {
-                Pose pose = (Pose) unmodifiableiterator.next();
+                EntityPose entitypose = (EntityPose) unmodifiableiterator.next();
                 Iterator iterator = list.iterator();
 
                 while (iterator.hasNext()) {
-                    Vec3 vec31 = (Vec3) iterator.next();
+                    Vec3 vec3d1 = (Vec3) iterator.next();
 
-                    if (DismountHelper.canDismountTo(this.level(), vec31, livingentity, pose)) {
-                        livingentity.setPose(pose);
-                        return vec31;
+                    if (DismountHelper.canDismountTo(this.level(), vec3d1, livingEntity, entitypose)) {
+                        livingEntity.setPose(entitypose);
+                        return vec3d1;
                     }
                 }
             }
         }
 
-        return super.getDismountLocationForPassenger(livingentity);
+        return super.getDismountLocationForPassenger(livingEntity);
     }
 
-    protected void clampRotation(Entity entity) {
-        entity.setYBodyRot(this.getYRot());
-        float f = Mth.wrapDegrees(entity.getYRot() - this.getYRot());
+    protected void clampRotation(Entity entityToUpdate) {
+        entityToUpdate.setYBodyRot(this.getYRot());
+        float f = Mth.wrapDegrees(entityToUpdate.getYRot() - this.getYRot());
         float f1 = Mth.clamp(f, -105.0F, 105.0F);
 
-        entity.yRotO += f1 - f;
-        entity.setYRot(entity.getYRot() + f1 - f);
-        entity.setYHeadRot(entity.getYRot());
+        entityToUpdate.yRotO += f1 - f;
+        entityToUpdate.setYRot(entityToUpdate.getYRot() + f1 - f);
+        entityToUpdate.setYHeadRot(entityToUpdate.getYRot());
     }
 
     @Override
-    @Override
-    public void onPassengerTurned(Entity entity) {
-        this.clampRotation(entity);
+    public void onPassengerTurned(Entity entityToUpdate) {
+        this.clampRotation(entityToUpdate);
     }
 
     @Override
-    @Override
-    protected void addAdditionalSaveData(CompoundTag compoundtag) {
-        compoundtag.putString("Type", this.getVariant().getSerializedName());
+    protected void addAdditionalSaveData(CompoundTag compound) {
+        compound.putString("Type", this.getVariant().getSerializedName());
     }
 
     @Override
-    @Override
-    protected void readAdditionalSaveData(CompoundTag compoundtag) {
-        if (compoundtag.contains("Type", 8)) {
-            this.setVariant(Boat.Type.byName(compoundtag.getString("Type")));
+    protected void readAdditionalSaveData(CompoundTag compound) {
+        if (compound.contains("Type", 8)) {
+            this.setVariant(Boat.Type.byName(compound.getString("Type")));
         }
 
     }
 
     @Override
-    @Override
-    public InteractionResult interact(Player player, InteractionHand interactionhand) {
+    public InteractionResult interact(Player player, EnumHand hand) {
         return player.isSecondaryUseActive() ? InteractionResult.PASS : (this.outOfControlTicks < 60.0F ? (!this.level().isClientSide ? (player.startRiding(this) ? InteractionResult.CONSUME : InteractionResult.PASS) : InteractionResult.SUCCESS) : InteractionResult.PASS);
     }
 
     @Override
-    @Override
-    protected void checkFallDamage(double d0, boolean flag, BlockState blockstate, BlockPos blockpos) {
+    protected void checkFallDamage(double y, boolean flag, IBlockData onGround, BlockPos state) {
         this.lastYd = this.getDeltaMovement().y;
         if (!this.isPassenger()) {
             if (flag) {
                 if (this.fallDistance > 3.0F) {
-                    if (this.status != Boat.Status.ON_LAND) {
+                    if (this.status != Boat.EnumStatus.ON_LAND) {
                         this.resetFallDistance();
                         return;
                     }
 
                     this.causeFallDamage(this.fallDistance, 1.0F, this.damageSources().fall());
                     if (!this.level().isClientSide && !this.isRemoved()) {
+                    // CraftBukkit start
+                    Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                    VehicleDestroyEvent destroyEvent = new VehicleDestroyEvent(vehicle, null);
+                    this.level().getCraftServer().getPluginManager().callEvent(destroyEvent);
+                    if (!destroyEvent.isCancelled()) {
                         this.kill();
                         if (this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
                             int i;
 
                             for (i = 0; i < 3; ++i) {
-                                this.spawnAtLocation((ItemLike) this.getVariant().getPlanks());
+                                this.spawnAtLocation((IMaterial) this.getVariant().getPlanks());
                             }
 
                             for (i = 0; i < 2; ++i) {
-                                this.spawnAtLocation((ItemLike) Items.STICK);
+                                this.spawnAtLocation((IMaterial) Items.STICK);
                             }
                         }
                     }
+                    } // CraftBukkit end
                 }
 
                 this.resetFallDistance();
-            } else if (!this.level().getFluidState(this.blockPosition().below()).is(FluidTags.WATER) && d0 < 0.0D) {
-                this.fallDistance -= (float) d0;
+            } else if (!this.level().getFluidState(this.blockPosition().below()).is(FluidTags.WATER) && y < 0.0D) {
+                this.fallDistance -= (float) y;
             }
 
         }
     }
 
-    public boolean getPaddleState(int i) {
-        return (Boolean) this.entityData.get(i == 0 ? Boat.DATA_ID_PADDLE_LEFT : Boat.DATA_ID_PADDLE_RIGHT) && this.getControllingPassenger() != null;
+    public boolean getPaddleState(int side) {
+        return (Boolean) this.entityData.get(side == 0 ? Boat.DATA_ID_PADDLE_LEFT : Boat.DATA_ID_PADDLE_RIGHT) && this.getControllingPassenger() != null;
     }
 
-    private void setBubbleTime(int i) {
-        this.entityData.set(Boat.DATA_ID_BUBBLE_TIME, i);
+    private void setBubbleTime(int bubbleTime) {
+        this.entityData.set(Boat.DATA_ID_BUBBLE_TIME, bubbleTime);
     }
 
     private int getBubbleTime() {
         return (Integer) this.entityData.get(Boat.DATA_ID_BUBBLE_TIME);
     }
 
-    public float getBubbleAngle(float f) {
-        return Mth.lerp(f, this.bubbleAngleO, this.bubbleAngle);
+    public float getBubbleAngle(float partialTicks) {
+        return Mth.lerp(partialTicks, this.bubbleAngleO, this.bubbleAngle);
     }
 
-    @Override
-    public void setVariant(Boat.Type boat_type) {
-        this.entityData.set(Boat.DATA_ID_TYPE, boat_type.ordinal());
+    public void setVariant(Boat.Type variant) {
+        this.entityData.set(Boat.DATA_ID_TYPE, variant.ordinal());
     }
 
     @Override
-    @Override
     public Boat.Type getVariant() {
         return Boat.Type.byId((Integer) this.entityData.get(Boat.DATA_ID_TYPE));
     }
 
     @Override
-    @Override
-    protected boolean canAddPassenger(Entity entity) {
+    protected boolean canAddPassenger(Entity passenger) {
         return this.getPassengers().size() < this.getMaxPassengers() && !this.isEyeInFluid(FluidTags.WATER);
     }
 
@@ -903,43 +932,39 @@
 
     @Nullable
     @Override
-    @Override
     public LivingEntity getControllingPassenger() {
         Entity entity = this.getFirstPassenger();
-        LivingEntity livingentity;
+        LivingEntity entityliving;
 
         if (entity instanceof LivingEntity) {
-            LivingEntity livingentity1 = (LivingEntity) entity;
+            LivingEntity entityliving1 = (LivingEntity) entity;
 
-            livingentity = livingentity1;
+            entityliving = entityliving1;
         } else {
-            livingentity = super.getControllingPassenger();
+            entityliving = super.getControllingPassenger();
         }
 
-        return livingentity;
+        return entityliving;
     }
 
-    public void setInput(boolean flag, boolean flag1, boolean flag2, boolean flag3) {
-        this.inputLeft = flag;
-        this.inputRight = flag1;
-        this.inputUp = flag2;
-        this.inputDown = flag3;
+    public void setInput(boolean inputLeft, boolean inputRight, boolean inputUp, boolean inputDown) {
+        this.inputLeft = inputLeft;
+        this.inputRight = inputRight;
+        this.inputUp = inputUp;
+        this.inputDown = inputDown;
     }
 
     @Override
-    @Override
     protected Component getTypeName() {
         return Component.translatable(this.getDropItem().getDescriptionId());
     }
 
     @Override
-    @Override
     public boolean isUnderWater() {
-        return this.status == Boat.Status.UNDER_WATER || this.status == Boat.Status.UNDER_FLOWING_WATER;
+        return this.status == Boat.EnumStatus.UNDER_WATER || this.status == Boat.EnumStatus.UNDER_FLOWING_WATER;
     }
 
     @Override
-    @Override
     public ItemStack getPickResult() {
         return new ItemStack(this.getDropItem());
     }
@@ -951,7 +976,7 @@
         private final String name;
         private final Block planks;
         public static final StringRepresentable.EnumCodec<Boat.Type> CODEC = StringRepresentable.fromEnum(Boat.Type::values);
-        private static final IntFunction<Boat.Type> BY_ID = ByIdMap.continuous(Enum::ordinal, values(), ByIdMap.OutOfBoundsStrategy.ZERO);
+        private static final IntFunction<Boat.Type> BY_ID = ByIdMap.continuous(Enum::ordinal, values(), ByIdMap.a.ZERO);
 
         private Type(Block block, String s) {
             this.name = s;
@@ -959,7 +984,6 @@
         }
 
         @Override
-        @Override
         public String getSerializedName() {
             return this.name;
         }
@@ -972,24 +996,23 @@
             return this.planks;
         }
 
-        @Override
         public String toString() {
             return this.name;
         }
 
-        public static Boat.Type byId(int i) {
-            return (Boat.Type) Boat.Type.BY_ID.apply(i);
+        public static Boat.Type byId(int id) {
+            return (Boat.Type) Boat.Type.BY_ID.apply(id);
         }
 
-        public static Boat.Type byName(String s) {
-            return (Boat.Type) Boat.Type.CODEC.byName(s, Boat.Type.OAK);
+        public static Boat.Type byName(String name) {
+            return (Boat.Type) Boat.Type.CODEC.byName(name, Boat.Type.OAK);
         }
     }
 
-    public static enum Status {
+    public static enum EnumStatus {
 
         IN_WATER, UNDER_WATER, UNDER_FLOWING_WATER, ON_LAND, IN_AIR;
 
-        private Status() {}
+        private EnumStatus() {}
     }
 }
