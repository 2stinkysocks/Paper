--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -28,6 +28,7 @@
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.NbtUtils;
+import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
@@ -50,23 +51,23 @@
 import net.minecraft.util.Unit;
 import net.minecraft.world.Container;
 import net.minecraft.world.Difficulty;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
+import net.minecraft.world.ITileInventory;
 import net.minecraft.world.InteractionResult;
-import net.minecraft.world.MenuProvider;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.effect.MobEffectUtil;
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityPose;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMonsterType;
+import net.minecraft.world.entity.EnumMoveType;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.entity.HumanoidArm;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobType;
-import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.Pose;
 import net.minecraft.world.entity.SlotAccess;
 import net.minecraft.world.entity.TamableAnimal;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
@@ -103,7 +104,7 @@
 import net.minecraft.world.level.block.entity.JigsawBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.entity.StructureBlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.pattern.BlockInWorld;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.AABB;
@@ -111,6 +112,16 @@
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard;
 import org.slf4j.Logger;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftVector;
+import org.bukkit.entity.Item;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.entity.EntityExhaustionEvent;
+import org.bukkit.event.player.PlayerDropItemEvent;
+import org.bukkit.event.player.PlayerVelocityEvent;
+// CraftBukkit end
 
 public abstract class Player extends LivingEntity {
 
@@ -127,7 +138,8 @@
     public static final float SWIMMING_BB_HEIGHT = 0.6F;
     public static final float DEFAULT_EYE_HEIGHT = 1.62F;
     public static final EntityDimensions STANDING_DIMENSIONS = EntityDimensions.scalable(0.6F, 1.8F);
-    private static final Map<Pose, EntityDimensions> POSES = ImmutableMap.builder().put(Pose.STANDING, Player.STANDING_DIMENSIONS).put(Pose.SLEEPING, Player.SLEEPING_DIMENSIONS).put(Pose.FALL_FLYING, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.SWIMMING, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.SPIN_ATTACK, EntityDimensions.scalable(0.6F, 0.6F)).put(Pose.CROUCHING, EntityDimensions.scalable(0.6F, 1.5F)).put(Pose.DYING, EntityDimensions.fixed(0.2F, 0.2F)).build();
+    // CraftBukkit - decompile error
+    private static final Map<EntityPose, EntityDimensions> POSES = ImmutableMap.<EntityPose, EntityDimensions>builder().put(EntityPose.STANDING, Player.STANDING_DIMENSIONS).put(EntityPose.SLEEPING, Player.SLEEPING_DIMENSIONS).put(EntityPose.FALL_FLYING, EntityDimensions.scalable(0.6F, 0.6F)).put(EntityPose.SWIMMING, EntityDimensions.scalable(0.6F, 0.6F)).put(EntityPose.SPIN_ATTACK, EntityDimensions.scalable(0.6F, 0.6F)).put(EntityPose.CROUCHING, EntityDimensions.scalable(0.6F, 1.5F)).put(EntityPose.DYING, EntityDimensions.fixed(0.2F, 0.2F)).build();
     private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
     private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
     protected static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
@@ -136,10 +148,10 @@
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     private long timeEntitySatOnShoulder;
     private final Inventory inventory = new Inventory(this);
-    protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer();
+    protected PlayerEnderChestContainer enderChestInventory = new PlayerEnderChestContainer(this); // CraftBukkit - add "this" to constructor
     public final InventoryMenu inventoryMenu;
     public AbstractContainerMenu containerMenu;
-    protected FoodData foodData = new FoodData();
+    protected FoodData foodData = new FoodData(this); // CraftBukkit - add "this" to constructor
     protected int jumpTriggerTime;
     public float oBob;
     public float bob;
@@ -150,13 +162,13 @@
     public double xCloak;
     public double yCloak;
     public double zCloak;
-    private int sleepCounter;
+    public int sleepCounter;
     protected boolean wasUnderwater;
     private final Abilities abilities = new Abilities();
     public int experienceLevel;
     public int totalExperience;
     public float experienceProgress;
-    protected int enchantmentSeed;
+    public int enchantmentSeed;
     protected final float defaultFlySpeed = 0.02F;
     private int lastLevelUpTime;
     private final GameProfile gameProfile;
@@ -168,30 +180,40 @@
     public FishingHook fishing;
     protected float hurtDir;
 
-    public Player(Level level, BlockPos blockpos, float f, GameProfile gameprofile) {
+    // CraftBukkit start
+    public boolean fauxSleeping;
+    public int oldLevel = -1;
+
+    @Override
+    public CraftHumanEntity getBukkitEntity() {
+        return (CraftHumanEntity) super.getBukkitEntity();
+    }
+    // CraftBukkit end
+
+    public Player(Level level, BlockPos pos, float yRot, GameProfile gameProfile) {
         super(EntityType.PLAYER, level);
         this.lastItemInMainHand = ItemStack.EMPTY;
         this.cooldowns = this.createItemCooldowns();
         this.lastDeathLocation = Optional.empty();
-        this.setUUID(gameprofile.getId());
-        this.gameProfile = gameprofile;
+        this.setUUID(gameProfile.getId());
+        this.gameProfile = gameProfile;
         this.inventoryMenu = new InventoryMenu(this.inventory, !level.isClientSide, this);
         this.containerMenu = this.inventoryMenu;
-        this.moveTo((double) blockpos.getX() + 0.5D, (double) (blockpos.getY() + 1), (double) blockpos.getZ() + 0.5D, f, 0.0F);
+        this.moveTo((double) pos.getX() + 0.5D, (double) (pos.getY() + 1), (double) pos.getZ() + 0.5D, yRot, 0.0F);
         this.rotOffs = 180.0F;
     }
 
-    public boolean blockActionRestricted(Level level, BlockPos blockpos, GameType gametype) {
-        if (!gametype.isBlockPlacingRestricted()) {
+    public boolean blockActionRestricted(Level level, BlockPos pos, GameType gameMode) {
+        if (!gameMode.isBlockPlacingRestricted()) {
             return false;
-        } else if (gametype == GameType.SPECTATOR) {
+        } else if (gameMode == GameType.SPECTATOR) {
             return true;
         } else if (this.mayBuild()) {
             return false;
         } else {
             ItemStack itemstack = this.getMainHandItem();
 
-            return itemstack.isEmpty() || !itemstack.hasAdventureModeBreakTagForBlock(level.registryAccess().registryOrThrow(Registries.BLOCK), new BlockInWorld(level, blockpos, false));
+            return itemstack.isEmpty() || !itemstack.hasAdventureModeBreakTagForBlock(level.registryAccess().registryOrThrow(Registries.BLOCK), new BlockInWorld(level, pos, false));
         }
     }
 
@@ -200,7 +222,6 @@
     }
 
     @Override
-    @Override
     protected void defineSynchedData() {
         super.defineSynchedData();
         this.entityData.define(Player.DATA_PLAYER_ABSORPTION_ID, 0.0F);
@@ -212,7 +233,6 @@
     }
 
     @Override
-    @Override
     public void tick() {
         this.noPhysics = this.isSpectator();
         if (this.isSpectator()) {
@@ -289,7 +309,6 @@
     }
 
     @Override
-    @Override
     protected float getMaxHeadRotationRelativeToBody() {
         return this.isBlocking() ? 15.0F : super.getMaxHeadRotationRelativeToBody();
     }
@@ -315,7 +334,7 @@
         ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
 
         if (itemstack.is(Items.TURTLE_HELMET) && !this.isEyeInFluid(FluidTags.WATER)) {
-            this.addEffect(new MobEffectInstance(MobEffects.WATER_BREATHING, 200, 0, false, false, true));
+            this.addEffect(new MobEffectInstance(MobEffects.WATER_BREATHING, 200, 0, false, false, true), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.TURTLE_HELMET); // CraftBukkit
         }
 
     }
@@ -369,134 +388,130 @@
     }
 
     protected void updatePlayerPose() {
-        if (this.canPlayerFitWithinBlocksAndEntitiesWhen(Pose.SWIMMING)) {
-            Pose pose;
+        if (this.canPlayerFitWithinBlocksAndEntitiesWhen(EntityPose.SWIMMING)) {
+            EntityPose entitypose;
 
             if (this.isFallFlying()) {
-                pose = Pose.FALL_FLYING;
+                entitypose = EntityPose.FALL_FLYING;
             } else if (this.isSleeping()) {
-                pose = Pose.SLEEPING;
+                entitypose = EntityPose.SLEEPING;
             } else if (this.isSwimming()) {
-                pose = Pose.SWIMMING;
+                entitypose = EntityPose.SWIMMING;
             } else if (this.isAutoSpinAttack()) {
-                pose = Pose.SPIN_ATTACK;
+                entitypose = EntityPose.SPIN_ATTACK;
             } else if (this.isShiftKeyDown() && !this.abilities.flying) {
-                pose = Pose.CROUCHING;
+                entitypose = EntityPose.CROUCHING;
             } else {
-                pose = Pose.STANDING;
+                entitypose = EntityPose.STANDING;
             }
 
-            Pose pose1;
+            EntityPose entitypose1;
 
-            if (!this.isSpectator() && !this.isPassenger() && !this.canPlayerFitWithinBlocksAndEntitiesWhen(pose)) {
-                if (this.canPlayerFitWithinBlocksAndEntitiesWhen(Pose.CROUCHING)) {
-                    pose1 = Pose.CROUCHING;
+            if (!this.isSpectator() && !this.isPassenger() && !this.canPlayerFitWithinBlocksAndEntitiesWhen(entitypose)) {
+                if (this.canPlayerFitWithinBlocksAndEntitiesWhen(EntityPose.CROUCHING)) {
+                    entitypose1 = EntityPose.CROUCHING;
                 } else {
-                    pose1 = Pose.SWIMMING;
+                    entitypose1 = EntityPose.SWIMMING;
                 }
             } else {
-                pose1 = pose;
+                entitypose1 = entitypose;
             }
 
-            this.setPose(pose1);
+            this.setPose(entitypose1);
         }
     }
 
-    protected boolean canPlayerFitWithinBlocksAndEntitiesWhen(Pose pose) {
-        return this.level().noCollision(this, this.getDimensions(pose).makeBoundingBox(this.position()).deflate(1.0E-7D));
+    protected boolean canPlayerFitWithinBlocksAndEntitiesWhen(EntityPose entitypose) {
+        return this.level().noCollision(this, this.getDimensions(entitypose).makeBoundingBox(this.position()).deflate(1.0E-7D));
     }
 
     @Override
-    @Override
     public int getPortalWaitTime() {
         return Math.max(1, this.level().getGameRules().getInt(this.abilities.invulnerable ? GameRules.RULE_PLAYERS_NETHER_PORTAL_CREATIVE_DELAY : GameRules.RULE_PLAYERS_NETHER_PORTAL_DEFAULT_DELAY));
     }
 
     @Override
-    @Override
     protected SoundEvent getSwimSound() {
         return SoundEvents.PLAYER_SWIM;
     }
 
     @Override
-    @Override
     protected SoundEvent getSwimSplashSound() {
         return SoundEvents.PLAYER_SPLASH;
     }
 
     @Override
-    @Override
     protected SoundEvent getSwimHighSpeedSplashSound() {
         return SoundEvents.PLAYER_SPLASH_HIGH_SPEED;
     }
 
     @Override
-    @Override
     public int getDimensionChangingDelay() {
         return 10;
     }
 
     @Override
-    @Override
-    public void playSound(SoundEvent soundevent, float f, float f1) {
-        this.level().playSound(this, this.getX(), this.getY(), this.getZ(), soundevent, this.getSoundSource(), f, f1);
+    public void playSound(SoundEvent sound, float volume, float pitch) {
+        this.level().playSound(this, this.getX(), this.getY(), this.getZ(), sound, this.getSoundSource(), volume, pitch);
     }
 
-    public void playNotifySound(SoundEvent soundevent, SoundSource soundsource, float f, float f1) {}
+    public void playNotifySound(SoundEvent sound, SoundSource source, float volume, float pitch) {}
 
     @Override
-    @Override
     public SoundSource getSoundSource() {
         return SoundSource.PLAYERS;
     }
 
     @Override
-    @Override
-    protected int getFireImmuneTicks() {
+    public int getFireImmuneTicks() {
         return 20;
     }
 
     @Override
-    @Override
-    public void handleEntityEvent(byte b0) {
-        if (b0 == 9) {
+    public void handleEntityEvent(byte id) {
+        if (id == 9) {
             this.completeUsingItem();
-        } else if (b0 == 23) {
+        } else if (id == 23) {
             this.reducedDebugInfo = false;
-        } else if (b0 == 22) {
+        } else if (id == 22) {
             this.reducedDebugInfo = true;
-        } else if (b0 == 43) {
+        } else if (id == 43) {
             this.addParticlesAroundSelf(ParticleTypes.CLOUD);
         } else {
-            super.handleEntityEvent(b0);
+            super.handleEntityEvent(id);
         }
 
     }
 
-    private void addParticlesAroundSelf(ParticleOptions particleoptions) {
+    private void addParticlesAroundSelf(ParticleOptions particleOption) {
         for (int i = 0; i < 5; ++i) {
             double d0 = this.random.nextGaussian() * 0.02D;
             double d1 = this.random.nextGaussian() * 0.02D;
             double d2 = this.random.nextGaussian() * 0.02D;
 
-            this.level().addParticle(particleoptions, this.getRandomX(1.0D), this.getRandomY() + 1.0D, this.getRandomZ(1.0D), d0, d1, d2);
+            this.level().addParticle(particleOption, this.getRandomX(1.0D), this.getRandomY() + 1.0D, this.getRandomZ(1.0D), d0, d1, d2);
         }
 
     }
 
-    protected void closeContainer() {
+    public void closeContainer() {
         this.containerMenu = this.inventoryMenu;
     }
 
     protected void doCloseContainer() {}
 
     @Override
-    @Override
     public void rideTick() {
         if (!this.level().isClientSide && this.wantsToStopRiding() && this.isPassenger()) {
             this.stopRiding();
-            this.setShiftKeyDown(false);
-        } else {
+            // CraftBukkit start - SPIGOT-7316: no longer passenger, dismount and return
+            if (!this.isPassenger()) {
+                this.setShiftKeyDown(false);
+                return;
+            }
+        }
+        {
+            // CraftBukkit end
             super.rideTick();
             this.oBob = this.bob;
             this.bob = 0.0F;
@@ -504,7 +519,6 @@
     }
 
     @Override
-    @Override
     protected void serverAiStep() {
         super.serverAiStep();
         this.updateSwingTime();
@@ -512,7 +526,6 @@
     }
 
     @Override
-    @Override
     public void aiStep() {
         if (this.jumpTriggerTime > 0) {
             --this.jumpTriggerTime;
@@ -520,7 +533,8 @@
 
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.level().getGameRules().getBoolean(GameRules.RULE_NATURAL_REGENERATION)) {
             if (this.getHealth() < this.getMaxHealth() && this.tickCount % 20 == 0) {
-                this.heal(1.0F);
+                // CraftBukkit - added regain reason of "REGEN" for filtering purposes.
+                this.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN);
             }
 
             if (this.foodData.needsFood() && this.tickCount % 10 == 0) {
@@ -542,15 +556,15 @@
 
         this.bob += (f - this.bob) * 0.4F;
         if (this.getHealth() > 0.0F && !this.isSpectator()) {
-            AABB aabb;
+            AABB axisalignedbb;
 
             if (this.isPassenger() && !this.getVehicle().isRemoved()) {
-                aabb = this.getBoundingBox().minmax(this.getVehicle().getBoundingBox()).inflate(1.0D, 0.0D, 1.0D);
+                axisalignedbb = this.getBoundingBox().minmax(this.getVehicle().getBoundingBox()).inflate(1.0D, 0.0D, 1.0D);
             } else {
-                aabb = this.getBoundingBox().inflate(1.0D, 0.5D, 1.0D);
+                axisalignedbb = this.getBoundingBox().inflate(1.0D, 0.5D, 1.0D);
             }
 
-            List<Entity> list = this.level().getEntities(this, aabb);
+            List<Entity> list = this.level().getEntities(this, axisalignedbb);
             List<Entity> list1 = Lists.newArrayList();
             Iterator iterator = list.iterator();
 
@@ -577,13 +591,13 @@
 
     }
 
-    private void playShoulderEntityAmbientSound(@Nullable CompoundTag compoundtag) {
-        if (compoundtag != null && (!compoundtag.contains("Silent") || !compoundtag.getBoolean("Silent")) && this.level().random.nextInt(200) == 0) {
-            String s = compoundtag.getString("id");
+    private void playShoulderEntityAmbientSound(@Nullable CompoundTag entityCompound) {
+        if (entityCompound != null && (!entityCompound.contains("Silent") || !entityCompound.getBoolean("Silent")) && this.level().random.nextInt(200) == 0) {
+            String s = entityCompound.getString("id");
 
-            EntityType.byString(s).filter((entitytype) -> {
-                return entitytype == EntityType.PARROT;
-            }).ifPresent((entitytype) -> {
+            EntityType.byString(s).filter((entitytypes) -> {
+                return entitytypes == EntityType.PARROT;
+            }).ifPresent((entitytypes) -> {
                 if (!Parrot.imitateNearbyMobs(this.level(), this)) {
                     this.level().playSound((Player) null, this.getX(), this.getY(), this.getZ(), Parrot.getAmbient(this.level(), this.level().random), this.getSoundSource(), 1.0F, Parrot.getPitch(this.level().random));
                 }
@@ -601,18 +615,18 @@
         return (Integer) this.entityData.get(Player.DATA_SCORE_ID);
     }
 
-    public void setScore(int i) {
-        this.entityData.set(Player.DATA_SCORE_ID, i);
+    public void setScore(int score) {
+        this.entityData.set(Player.DATA_SCORE_ID, score);
     }
 
-    public void increaseScore(int i) {
+    public void increaseScore(int score) {
         int j = this.getScore();
 
-        this.entityData.set(Player.DATA_SCORE_ID, j + i);
+        this.entityData.set(Player.DATA_SCORE_ID, j + score);
     }
 
-    public void startAutoSpinAttack(int i) {
-        this.autoSpinAttackTicks = i;
+    public void startAutoSpinAttack(int attackTicks) {
+        this.autoSpinAttackTicks = attackTicks;
         if (!this.level().isClientSide) {
             this.removeEntitiesOnShoulder();
             this.setLivingEntityFlag(4, true);
@@ -621,15 +635,14 @@
     }
 
     @Override
-    @Override
-    public void die(DamageSource damagesource) {
-        super.die(damagesource);
+    public void die(DamageSource cause) {
+        super.die(cause);
         this.reapplyPosition();
         if (!this.isSpectator()) {
-            this.dropAllDeathLoot(damagesource);
+            this.dropAllDeathLoot(cause);
         }
 
-        if (damagesource != null) {
+        if (cause != null) {
             this.setDeltaMovement((double) (-Mth.cos((this.getHurtDir() + this.getYRot()) * 0.017453292F) * 0.1F), 0.10000000149011612D, (double) (-Mth.sin((this.getHurtDir() + this.getYRot()) * 0.017453292F) * 0.1F));
         } else {
             this.setDeltaMovement(0.0D, 0.1D, 0.0D);
@@ -644,7 +657,6 @@
     }
 
     @Override
-    @Override
     protected void dropEquipment() {
         super.dropEquipment();
         if (!this.level().getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY)) {
@@ -666,37 +678,42 @@
     }
 
     @Override
-    @Override
-    protected SoundEvent getHurtSound(DamageSource damagesource) {
-        return damagesource.type().effects().sound();
+    protected SoundEvent getHurtSound(DamageSource damageSource) {
+        return damageSource.type().effects().sound();
     }
 
     @Override
-    @Override
     protected SoundEvent getDeathSound() {
         return SoundEvents.PLAYER_DEATH;
     }
 
     @Nullable
-    public ItemEntity drop(ItemStack itemstack, boolean flag) {
-        return this.drop(itemstack, false, flag);
+    public ItemEntity drop(ItemStack itemStack, boolean includeThrowerName) {
+        return this.drop(itemStack, false, includeThrowerName);
     }
 
     @Nullable
-    public ItemEntity drop(ItemStack itemstack, boolean flag, boolean flag1) {
+    public ItemEntity drop(ItemStack droppedItem, boolean dropAround, boolean includeThrowerName) {
+        // CraftBukkit start - SPIGOT-2942: Add boolean to call event
+        return drop(droppedItem, dropAround, includeThrowerName, true);
+    }
+
+    @Nullable
+    public ItemEntity drop(ItemStack itemstack, boolean flag, boolean flag1, boolean callEvent) {
+        // CraftBukkit end
         if (itemstack.isEmpty()) {
             return null;
         } else {
             if (this.level().isClientSide) {
-                this.swing(InteractionHand.MAIN_HAND);
+                this.swing(EnumHand.MAIN_HAND);
             }
 
             double d0 = this.getEyeY() - 0.30000001192092896D;
-            ItemEntity itementity = new ItemEntity(this.level(), this.getX(), d0, this.getZ(), itemstack);
+            ItemEntity entityitem = new ItemEntity(this.level(), this.getX(), d0, this.getZ(), itemstack);
 
-            itementity.setPickUpDelay(40);
+            entityitem.setPickUpDelay(40);
             if (flag1) {
-                itementity.setThrower(this);
+                entityitem.setThrower(this);
             }
 
             float f;
@@ -705,7 +722,7 @@
             if (flag) {
                 f = this.random.nextFloat() * 0.5F;
                 f1 = this.random.nextFloat() * 6.2831855F;
-                itementity.setDeltaMovement((double) (-Mth.sin(f1) * f), 0.20000000298023224D, (double) (Mth.cos(f1) * f));
+                entityitem.setDeltaMovement((double) (-Mth.sin(f1) * f), 0.20000000298023224D, (double) (Mth.cos(f1) * f));
             } else {
                 f = 0.3F;
                 f1 = Mth.sin(this.getXRot() * 0.017453292F);
@@ -715,15 +732,42 @@
                 float f5 = this.random.nextFloat() * 6.2831855F;
                 float f6 = 0.02F * this.random.nextFloat();
 
-                itementity.setDeltaMovement((double) (-f3 * f2 * 0.3F) + Math.cos((double) f5) * (double) f6, (double) (-f1 * 0.3F + 0.1F + (this.random.nextFloat() - this.random.nextFloat()) * 0.1F), (double) (f4 * f2 * 0.3F) + Math.sin((double) f5) * (double) f6);
+                entityitem.setDeltaMovement((double) (-f3 * f2 * 0.3F) + Math.cos((double) f5) * (double) f6, (double) (-f1 * 0.3F + 0.1F + (this.random.nextFloat() - this.random.nextFloat()) * 0.1F), (double) (f4 * f2 * 0.3F) + Math.sin((double) f5) * (double) f6);
             }
 
-            return itementity;
+            // CraftBukkit start - fire PlayerDropItemEvent
+            if (!callEvent) { // SPIGOT-2942: Add boolean to call event
+                return entityitem;
+            }
+            org.bukkit.entity.Player player = (org.bukkit.entity.Player) this.getBukkitEntity();
+            Item drop = (Item) entityitem.getBukkitEntity();
+
+            PlayerDropItemEvent event = new PlayerDropItemEvent(player, drop);
+            this.level().getCraftServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                org.bukkit.inventory.ItemStack cur = player.getInventory().getItemInHand();
+                if (flag1 && (cur == null || cur.getAmount() == 0)) {
+                    // The complete stack was dropped
+                    player.getInventory().setItemInHand(drop.getItemStack());
+                } else if (flag1 && cur.isSimilar(drop.getItemStack()) && cur.getAmount() < cur.getMaxStackSize() && drop.getItemStack().getAmount() == 1) {
+                    // Only one item is dropped
+                    cur.setAmount(cur.getAmount() + 1);
+                    player.getInventory().setItemInHand(cur);
+                } else {
+                    // Fallback
+                    player.getInventory().addItem(drop.getItemStack());
+                }
+                return null;
+            }
+            // CraftBukkit end
+
+            return entityitem;
         }
     }
 
-    public float getDestroySpeed(BlockState blockstate) {
-        float f = this.inventory.getDestroySpeed(blockstate);
+    public float getDestroySpeed(IBlockData state) {
+        float f = this.inventory.getDestroySpeed(state);
 
         if (f > 1.0F) {
             int i = EnchantmentHelper.getBlockEfficiency(this);
@@ -770,46 +814,45 @@
         return f;
     }
 
-    public boolean hasCorrectToolForDrops(BlockState blockstate) {
-        return !blockstate.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(blockstate);
+    public boolean hasCorrectToolForDrops(IBlockData state) {
+        return !state.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(state);
     }
 
     @Override
-    @Override
-    public void readAdditionalSaveData(CompoundTag compoundtag) {
-        super.readAdditionalSaveData(compoundtag);
+    public void readAdditionalSaveData(CompoundTag compound) {
+        super.readAdditionalSaveData(compound);
         this.setUUID(this.gameProfile.getId());
-        ListTag listtag = compoundtag.getList("Inventory", 10);
+        ListTag nbttaglist = compound.getList("Inventory", 10);
 
-        this.inventory.load(listtag);
-        this.inventory.selected = compoundtag.getInt("SelectedItemSlot");
-        this.sleepCounter = compoundtag.getShort("SleepTimer");
-        this.experienceProgress = compoundtag.getFloat("XpP");
-        this.experienceLevel = compoundtag.getInt("XpLevel");
-        this.totalExperience = compoundtag.getInt("XpTotal");
-        this.enchantmentSeed = compoundtag.getInt("XpSeed");
+        this.inventory.load(nbttaglist);
+        this.inventory.selected = compound.getInt("SelectedItemSlot");
+        this.sleepCounter = compound.getShort("SleepTimer");
+        this.experienceProgress = compound.getFloat("XpP");
+        this.experienceLevel = compound.getInt("XpLevel");
+        this.totalExperience = compound.getInt("XpTotal");
+        this.enchantmentSeed = compound.getInt("XpSeed");
         if (this.enchantmentSeed == 0) {
             this.enchantmentSeed = this.random.nextInt();
         }
 
-        this.setScore(compoundtag.getInt("Score"));
-        this.foodData.readAdditionalSaveData(compoundtag);
-        this.abilities.loadSaveData(compoundtag);
+        this.setScore(compound.getInt("Score"));
+        this.foodData.readAdditionalSaveData(compound);
+        this.abilities.loadSaveData(compound);
         this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue((double) this.abilities.getWalkingSpeed());
-        if (compoundtag.contains("EnderItems", 9)) {
-            this.enderChestInventory.fromTag(compoundtag.getList("EnderItems", 10));
+        if (compound.contains("EnderItems", 9)) {
+            this.enderChestInventory.fromTag(compound.getList("EnderItems", 10));
         }
 
-        if (compoundtag.contains("ShoulderEntityLeft", 10)) {
-            this.setShoulderEntityLeft(compoundtag.getCompound("ShoulderEntityLeft"));
+        if (compound.contains("ShoulderEntityLeft", 10)) {
+            this.setShoulderEntityLeft(compound.getCompound("ShoulderEntityLeft"));
         }
 
-        if (compoundtag.contains("ShoulderEntityRight", 10)) {
-            this.setShoulderEntityRight(compoundtag.getCompound("ShoulderEntityRight"));
+        if (compound.contains("ShoulderEntityRight", 10)) {
+            this.setShoulderEntityRight(compound.getCompound("ShoulderEntityRight"));
         }
 
-        if (compoundtag.contains("LastDeathLocation", 10)) {
-            DataResult dataresult = GlobalPos.CODEC.parse(NbtOps.INSTANCE, compoundtag.get("LastDeathLocation"));
+        if (compound.contains("LastDeathLocation", 10)) {
+            DataResult<GlobalPos> dataresult = GlobalPos.CODEC.parse(NbtOps.INSTANCE, compound.get("LastDeathLocation")); // CraftBukkit - decompile error
             Logger logger = Player.LOGGER;
 
             Objects.requireNonNull(logger);
@@ -819,52 +862,49 @@
     }
 
     @Override
-    @Override
-    public void addAdditionalSaveData(CompoundTag compoundtag) {
-        super.addAdditionalSaveData(compoundtag);
-        NbtUtils.addCurrentDataVersion(compoundtag);
-        compoundtag.put("Inventory", this.inventory.save(new ListTag()));
-        compoundtag.putInt("SelectedItemSlot", this.inventory.selected);
-        compoundtag.putShort("SleepTimer", (short) this.sleepCounter);
-        compoundtag.putFloat("XpP", this.experienceProgress);
-        compoundtag.putInt("XpLevel", this.experienceLevel);
-        compoundtag.putInt("XpTotal", this.totalExperience);
-        compoundtag.putInt("XpSeed", this.enchantmentSeed);
-        compoundtag.putInt("Score", this.getScore());
-        this.foodData.addAdditionalSaveData(compoundtag);
-        this.abilities.addSaveData(compoundtag);
-        compoundtag.put("EnderItems", this.enderChestInventory.createTag());
+    public void addAdditionalSaveData(CompoundTag compound) {
+        super.addAdditionalSaveData(compound);
+        NbtUtils.addCurrentDataVersion(compound);
+        compound.put("Inventory", this.inventory.save(new ListTag()));
+        compound.putInt("SelectedItemSlot", this.inventory.selected);
+        compound.putShort("SleepTimer", (short) this.sleepCounter);
+        compound.putFloat("XpP", this.experienceProgress);
+        compound.putInt("XpLevel", this.experienceLevel);
+        compound.putInt("XpTotal", this.totalExperience);
+        compound.putInt("XpSeed", this.enchantmentSeed);
+        compound.putInt("Score", this.getScore());
+        this.foodData.addAdditionalSaveData(compound);
+        this.abilities.addSaveData(compound);
+        compound.put("EnderItems", this.enderChestInventory.createTag());
         if (!this.getShoulderEntityLeft().isEmpty()) {
-            compoundtag.put("ShoulderEntityLeft", this.getShoulderEntityLeft());
+            compound.put("ShoulderEntityLeft", this.getShoulderEntityLeft());
         }
 
         if (!this.getShoulderEntityRight().isEmpty()) {
-            compoundtag.put("ShoulderEntityRight", this.getShoulderEntityRight());
+            compound.put("ShoulderEntityRight", this.getShoulderEntityRight());
         }
 
         this.getLastDeathLocation().flatMap((globalpos) -> {
-            DataResult dataresult = GlobalPos.CODEC.encodeStart(NbtOps.INSTANCE, globalpos);
+            DataResult<Tag> dataresult = GlobalPos.CODEC.encodeStart(NbtOps.INSTANCE, globalpos); // CraftBukkit - decompile error
             Logger logger = Player.LOGGER;
 
             Objects.requireNonNull(logger);
             return dataresult.resultOrPartial(logger::error);
-        }).ifPresent((tag) -> {
-            compoundtag.put("LastDeathLocation", tag);
+        }).ifPresent((nbtbase) -> {
+            compound.put("LastDeathLocation", nbtbase);
         });
     }
 
     @Override
-    @Override
-    public boolean isInvulnerableTo(DamageSource damagesource) {
-        return super.isInvulnerableTo(damagesource) ? true : (damagesource.is(DamageTypeTags.IS_DROWNING) ? !this.level().getGameRules().getBoolean(GameRules.RULE_DROWNING_DAMAGE) : (damagesource.is(DamageTypeTags.IS_FALL) ? !this.level().getGameRules().getBoolean(GameRules.RULE_FALL_DAMAGE) : (damagesource.is(DamageTypeTags.IS_FIRE) ? !this.level().getGameRules().getBoolean(GameRules.RULE_FIRE_DAMAGE) : (damagesource.is(DamageTypeTags.IS_FREEZING) ? !this.level().getGameRules().getBoolean(GameRules.RULE_FREEZE_DAMAGE) : false))));
+    public boolean isInvulnerableTo(DamageSource source) {
+        return super.isInvulnerableTo(source) ? true : (source.is(DamageTypeTags.IS_DROWNING) ? !this.level().getGameRules().getBoolean(GameRules.RULE_DROWNING_DAMAGE) : (source.is(DamageTypeTags.IS_FALL) ? !this.level().getGameRules().getBoolean(GameRules.RULE_FALL_DAMAGE) : (source.is(DamageTypeTags.IS_FIRE) ? !this.level().getGameRules().getBoolean(GameRules.RULE_FIRE_DAMAGE) : (source.is(DamageTypeTags.IS_FREEZING) ? !this.level().getGameRules().getBoolean(GameRules.RULE_FREEZE_DAMAGE) : false))));
     }
 
     @Override
-    @Override
-    public boolean hurt(DamageSource damagesource, float f) {
-        if (this.isInvulnerableTo(damagesource)) {
+    public boolean hurt(DamageSource source, float amount) {
+        if (this.isInvulnerableTo(source)) {
             return false;
-        } else if (this.abilities.invulnerable && !damagesource.is(DamageTypeTags.BYPASSES_INVULNERABILITY)) {
+        } else if (this.abilities.invulnerable && !source.is(DamageTypeTags.BYPASSES_INVULNERABILITY)) {
             return false;
         } else {
             this.noActionTime = 0;
@@ -872,80 +912,100 @@
                 return false;
             } else {
                 if (!this.level().isClientSide) {
-                    this.removeEntitiesOnShoulder();
+                    // this.removeEntitiesOnShoulder(); // CraftBukkit - moved down
                 }
 
-                if (damagesource.scalesWithDifficulty()) {
+                if (source.scalesWithDifficulty()) {
                     if (this.level().getDifficulty() == Difficulty.PEACEFUL) {
-                        f = 0.0F;
+                        return false; // CraftBukkit - f = 0.0f -> return false
                     }
 
                     if (this.level().getDifficulty() == Difficulty.EASY) {
-                        f = Math.min(f / 2.0F + 1.0F, f);
+                        amount = Math.min(amount / 2.0F + 1.0F, amount);
                     }
 
                     if (this.level().getDifficulty() == Difficulty.HARD) {
-                        f = f * 3.0F / 2.0F;
+                        amount = amount * 3.0F / 2.0F;
                     }
                 }
 
-                return f == 0.0F ? false : super.hurt(damagesource, f);
+                // CraftBukkit start - Don't filter out 0 damage
+                boolean damaged = super.hurt(source, amount);
+                if (damaged) {
+                    this.removeEntitiesOnShoulder();
+                }
+                return damaged;
+                // CraftBukkit end
             }
         }
     }
 
     @Override
-    @Override
-    protected void blockUsingShield(LivingEntity livingentity) {
-        super.blockUsingShield(livingentity);
-        if (livingentity.canDisableShield()) {
+    protected void blockUsingShield(LivingEntity entity) {
+        super.blockUsingShield(entity);
+        if (entity.canDisableShield()) {
             this.disableShield(true);
         }
 
     }
 
     @Override
-    @Override
     public boolean canBeSeenAsEnemy() {
         return !this.getAbilities().invulnerable && super.canBeSeenAsEnemy();
     }
 
-    public boolean canHarmPlayer(Player player) {
-        PlayerTeam playerteam = this.getTeam();
-        PlayerTeam playerteam1 = player.getTeam();
+    public boolean canHarmPlayer(Player other) {
+        // CraftBukkit start - Change to check OTHER player's scoreboard team according to API
+        // To summarize this method's logic, it's "Can parameter hurt this"
+        org.bukkit.scoreboard.Team team;
+        if (other instanceof ServerPlayer) {
+            ServerPlayer thatPlayer = (ServerPlayer) other;
+            team = thatPlayer.getBukkitEntity().getScoreboard().getPlayerTeam(thatPlayer.getBukkitEntity());
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
+        } else {
+            // This should never be called, but is implemented anyway
+            org.bukkit.OfflinePlayer thisPlayer = other.level().getCraftServer().getOfflinePlayer(other.getScoreboardName());
+            team = other.level().getCraftServer().getScoreboardManager().getMainScoreboard().getPlayerTeam(thisPlayer);
+            if (team == null || team.allowFriendlyFire()) {
+                return true;
+            }
+        }
 
-        return playerteam == null ? true : (!playerteam.isAlliedTo(playerteam1) ? true : playerteam.isAllowFriendlyFire());
+        if (this instanceof ServerPlayer) {
+            return !team.hasPlayer(((ServerPlayer) this).getBukkitEntity());
+        }
+        return !team.hasPlayer(this.level().getCraftServer().getOfflinePlayer(this.getScoreboardName()));
+        // CraftBukkit end
     }
 
     @Override
-    @Override
-    protected void hurtArmor(DamageSource damagesource, float f) {
-        this.inventory.hurtArmor(damagesource, f, Inventory.ALL_ARMOR_SLOTS);
+    protected void hurtArmor(DamageSource damageSource, float damage) {
+        this.inventory.hurtArmor(damageSource, damage, Inventory.ALL_ARMOR_SLOTS);
     }
 
     @Override
-    @Override
-    protected void hurtHelmet(DamageSource damagesource, float f) {
-        this.inventory.hurtArmor(damagesource, f, Inventory.HELMET_SLOT_ONLY);
+    protected void hurtHelmet(DamageSource damageSource, float damageAmount) {
+        this.inventory.hurtArmor(damageSource, damageAmount, Inventory.HELMET_SLOT_ONLY);
     }
 
     @Override
-    @Override
-    protected void hurtCurrentlyUsedShield(float f) {
+    protected void hurtCurrentlyUsedShield(float damage) {
         if (this.useItem.is(Items.SHIELD)) {
             if (!this.level().isClientSide) {
                 this.awardStat(Stats.ITEM_USED.get(this.useItem.getItem()));
             }
 
-            if (f >= 3.0F) {
-                int i = 1 + Mth.floor(f);
-                InteractionHand interactionhand = this.getUsedItemHand();
+            if (damage >= 3.0F) {
+                int i = 1 + Mth.floor(damage);
+                EnumHand enumhand = this.getUsedItemHand();
 
-                this.useItem.hurtAndBreak(i, this, (player) -> {
-                    player.broadcastBreakEvent(interactionhand);
+                this.useItem.hurtAndBreak(i, this, (entityhuman) -> {
+                    entityhuman.broadcastBreakEvent(enumhand);
                 });
                 if (this.useItem.isEmpty()) {
-                    if (interactionhand == InteractionHand.MAIN_HAND) {
+                    if (enumhand == EnumHand.MAIN_HAND) {
                         this.setItemSlot(EquipmentSlot.MAINHAND, ItemStack.EMPTY);
                     } else {
                         this.setItemSlot(EquipmentSlot.OFFHAND, ItemStack.EMPTY);
@@ -959,9 +1019,13 @@
         }
     }
 
+    // CraftBukkit start
     @Override
-    @Override
-    protected void actuallyHurt(DamageSource damagesource, float f) {
+    protected boolean damageEntity0(DamageSource damagesource, float f) { // void -> boolean
+        if (true) {
+            return super.damageEntity0(damagesource, f);
+        }
+        // CraftBukkit end
         if (!this.isInvulnerableTo(damagesource)) {
             f = this.getDamageAfterArmorAbsorb(damagesource, f);
             f = this.getDamageAfterMagicAbsorb(damagesource, f);
@@ -976,7 +1040,7 @@
             }
 
             if (f != 0.0F) {
-                this.causeFoodExhaustion(damagesource.getFoodExhaustion());
+                this.causeFoodExhaustion(damagesource.getFoodExhaustion(), EntityExhaustionEvent.ExhaustionReason.DAMAGED); // CraftBukkit - EntityExhaustionEvent
                 this.getCombatTracker().recordDamage(damagesource, f);
                 this.setHealth(this.getHealth() - f);
                 if (f < 3.4028235E37F) {
@@ -986,10 +1050,10 @@
                 this.gameEvent(GameEvent.ENTITY_DAMAGE);
             }
         }
+        return false; // CraftBukkit
     }
 
     @Override
-    @Override
     protected boolean onSoulSpeedBlock() {
         return !this.abilities.flying && super.onSoulSpeedBlock();
     }
@@ -998,59 +1062,59 @@
         return false;
     }
 
-    public void openTextEdit(SignBlockEntity signblockentity, boolean flag) {}
+    public void openTextEdit(SignBlockEntity signEntity, boolean isFrontText) {}
 
-    public void openMinecartCommandBlock(BaseCommandBlock basecommandblock) {}
+    public void openMinecartCommandBlock(BaseCommandBlock commandEntity) {}
 
-    public void openCommandBlock(CommandBlockEntity commandblockentity) {}
+    public void openCommandBlock(CommandBlockEntity commandBlockEntity) {}
 
-    public void openStructureBlock(StructureBlockEntity structureblockentity) {}
+    public void openStructureBlock(StructureBlockEntity structureEntity) {}
 
-    public void openJigsawBlock(JigsawBlockEntity jigsawblockentity) {}
+    public void openJigsawBlock(JigsawBlockEntity jigsawBlockEntity) {}
 
-    public void openHorseInventory(AbstractHorse abstracthorse, Container container) {}
+    public void openHorseInventory(AbstractHorse horse, Container inventory) {}
 
-    public OptionalInt openMenu(@Nullable MenuProvider menuprovider) {
+    public OptionalInt openMenu(@Nullable ITileInventory menu) {
         return OptionalInt.empty();
     }
 
-    public void sendMerchantOffers(int i, MerchantOffers merchantoffers, int j, int k, boolean flag, boolean flag1) {}
+    public void sendMerchantOffers(int containerId, MerchantOffers offers, int villagerLevel, int villagerXp, boolean showProgress, boolean canRestock) {}
 
-    public void openItemGui(ItemStack itemstack, InteractionHand interactionhand) {}
+    public void openItemGui(ItemStack stack, EnumHand hand) {}
 
-    public InteractionResult interactOn(Entity entity, InteractionHand interactionhand) {
+    public InteractionResult interactOn(Entity entityToInteractOn, EnumHand hand) {
         if (this.isSpectator()) {
-            if (entity instanceof MenuProvider) {
-                this.openMenu((MenuProvider) entity);
+            if (entityToInteractOn instanceof ITileInventory) {
+                this.openMenu((ITileInventory) entityToInteractOn);
             }
 
             return InteractionResult.PASS;
         } else {
-            ItemStack itemstack = this.getItemInHand(interactionhand);
+            ItemStack itemstack = this.getItemInHand(hand);
             ItemStack itemstack1 = itemstack.copy();
-            InteractionResult interactionresult = entity.interact(this, interactionhand);
+            InteractionResult enuminteractionresult = entityToInteractOn.interact(this, hand);
 
-            if (interactionresult.consumesAction()) {
-                if (this.abilities.instabuild && itemstack == this.getItemInHand(interactionhand) && itemstack.getCount() < itemstack1.getCount()) {
+            if (enuminteractionresult.consumesAction()) {
+                if (this.abilities.instabuild && itemstack == this.getItemInHand(hand) && itemstack.getCount() < itemstack1.getCount()) {
                     itemstack.setCount(itemstack1.getCount());
                 }
 
-                return interactionresult;
+                return enuminteractionresult;
             } else {
-                if (!itemstack.isEmpty() && entity instanceof LivingEntity) {
+                if (!itemstack.isEmpty() && entityToInteractOn instanceof LivingEntity) {
                     if (this.abilities.instabuild) {
                         itemstack = itemstack1;
                     }
 
-                    InteractionResult interactionresult1 = itemstack.interactLivingEntity(this, (LivingEntity) entity, interactionhand);
+                    InteractionResult enuminteractionresult1 = itemstack.interactLivingEntity(this, (LivingEntity) entityToInteractOn, hand);
 
-                    if (interactionresult1.consumesAction()) {
-                        this.level().gameEvent(GameEvent.ENTITY_INTERACT, entity.position(), GameEvent.Context.of((Entity) this));
+                    if (enuminteractionresult1.consumesAction()) {
+                        this.level().gameEvent(GameEvent.ENTITY_INTERACT, entityToInteractOn.position(), GameEvent.Context.of((Entity) this));
                         if (itemstack.isEmpty() && !this.abilities.instabuild) {
-                            this.setItemInHand(interactionhand, ItemStack.EMPTY);
+                            this.setItemInHand(hand, ItemStack.EMPTY);
                         }
 
-                        return interactionresult1;
+                        return enuminteractionresult1;
                     }
                 }
 
@@ -1060,36 +1124,31 @@
     }
 
     @Override
-    @Override
     protected float ridingOffset(Entity entity) {
         return -0.6F;
     }
 
     @Override
-    @Override
     public void removeVehicle() {
         super.removeVehicle();
         this.boardingCooldown = 0;
     }
 
     @Override
-    @Override
     protected boolean isImmobile() {
         return super.isImmobile() || this.isSleeping();
     }
 
     @Override
-    @Override
     public boolean isAffectedByFluids() {
         return !this.abilities.flying;
     }
 
     @Override
-    @Override
-    protected Vec3 maybeBackOffFromEdge(Vec3 vec3, MoverType movertype) {
-        if (!this.abilities.flying && vec3.y <= 0.0D && (movertype == MoverType.SELF || movertype == MoverType.PLAYER) && this.isStayingOnGroundSurface() && this.isAboveGround()) {
-            double d0 = vec3.x;
-            double d1 = vec3.z;
+    protected Vec3 maybeBackOffFromEdge(Vec3 vec, EnumMoveType mover) {
+        if (!this.abilities.flying && vec.y <= 0.0D && (mover == EnumMoveType.SELF || mover == EnumMoveType.PLAYER) && this.isStayingOnGroundSurface() && this.isAboveGround()) {
+            double d0 = vec.x;
+            double d1 = vec.z;
             double d2 = 0.05D;
 
             while (d0 != 0.0D && this.level().noCollision(this, this.getBoundingBox().move(d0, (double) (-this.maxUpStep()), 0.0D))) {
@@ -1130,33 +1189,33 @@
                 }
             }
 
-            vec3 = new Vec3(d0, vec3.y, d1);
+            vec = new Vec3(d0, vec.y, d1);
         }
 
-        return vec3;
+        return vec;
     }
 
     private boolean isAboveGround() {
         return this.onGround() || this.fallDistance < this.maxUpStep() && !this.level().noCollision(this, this.getBoundingBox().move(0.0D, (double) (this.fallDistance - this.maxUpStep()), 0.0D));
     }
 
-    public void attack(Entity entity) {
-        if (entity.isAttackable()) {
-            if (!entity.skipAttackInteraction(this)) {
+    public void attack(Entity target) {
+        if (target.isAttackable()) {
+            if (!target.skipAttackInteraction(this)) {
                 float f = (float) this.getAttributeValue(Attributes.ATTACK_DAMAGE);
                 float f1;
 
-                if (entity instanceof LivingEntity) {
-                    f1 = EnchantmentHelper.getDamageBonus(this.getMainHandItem(), ((LivingEntity) entity).getMobType());
+                if (target instanceof LivingEntity) {
+                    f1 = EnchantmentHelper.getDamageBonus(this.getMainHandItem(), ((LivingEntity) target).getMobType());
                 } else {
-                    f1 = EnchantmentHelper.getDamageBonus(this.getMainHandItem(), MobType.UNDEFINED);
+                    f1 = EnchantmentHelper.getDamageBonus(this.getMainHandItem(), EnumMonsterType.UNDEFINED);
                 }
 
                 float f2 = this.getAttackStrengthScale(0.5F);
 
                 f *= 0.2F + f2 * f2 * 0.8F;
                 f1 *= f2;
-                this.resetAttackStrengthTicker();
+                // this.resetAttackCooldown(); // CraftBukkit - Moved to EntityLiving to reset the cooldown after the damage is dealt
                 if (f > 0.0F || f1 > 0.0F) {
                     boolean flag = f2 > 0.9F;
                     boolean flag1 = false;
@@ -1169,7 +1228,7 @@
                         flag1 = true;
                     }
 
-                    boolean flag2 = flag && this.fallDistance > 0.0F && !this.onGround() && !this.onClimbable() && !this.isInWater() && !this.hasEffect(MobEffects.BLINDNESS) && !this.isPassenger() && entity instanceof LivingEntity;
+                    boolean flag2 = flag && this.fallDistance > 0.0F && !this.onGround() && !this.onClimbable() && !this.isInWater() && !this.hasEffect(MobEffects.BLINDNESS) && !this.isPassenger() && target instanceof LivingEntity;
 
                     flag2 = flag2 && !this.isSprinting();
                     if (flag2) {
@@ -1181,7 +1240,7 @@
                     double d0 = (double) (this.walkDist - this.walkDistO);
 
                     if (flag && !flag2 && !flag1 && this.onGround() && d0 < (double) this.getSpeed()) {
-                        ItemStack itemstack = this.getItemInHand(InteractionHand.MAIN_HAND);
+                        ItemStack itemstack = this.getItemInHand(EnumHand.MAIN_HAND);
 
                         if (itemstack.getItem() instanceof SwordItem) {
                             flag3 = true;
@@ -1192,23 +1251,30 @@
                     boolean flag4 = false;
                     int j = EnchantmentHelper.getFireAspect(this);
 
-                    if (entity instanceof LivingEntity) {
-                        f3 = ((LivingEntity) entity).getHealth();
-                        if (j > 0 && !entity.isOnFire()) {
-                            flag4 = true;
-                            entity.setSecondsOnFire(1);
+                    if (target instanceof LivingEntity) {
+                        f3 = ((LivingEntity) target).getHealth();
+                        if (j > 0 && !target.isOnFire()) {
+                            // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                            EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), target.getBukkitEntity(), 1);
+                            org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+                            if (!combustEvent.isCancelled()) {
+                                flag4 = true;
+                                target.setSecondsOnFire(combustEvent.getDuration(), false);
+                            }
+                            // CraftBukkit end
                         }
                     }
 
-                    Vec3 vec3 = entity.getDeltaMovement();
-                    boolean flag5 = entity.hurt(this.damageSources().playerAttack(this), f);
+                    Vec3 vec3d = target.getDeltaMovement();
+                    boolean flag5 = target.hurt(this.damageSources().playerAttack(this), f);
 
                     if (flag5) {
                         if (i > 0) {
-                            if (entity instanceof LivingEntity) {
-                                ((LivingEntity) entity).knockback((double) ((float) i * 0.5F), (double) Mth.sin(this.getYRot() * 0.017453292F), (double) (-Mth.cos(this.getYRot() * 0.017453292F)));
+                            if (target instanceof LivingEntity) {
+                                ((LivingEntity) target).knockback((double) ((float) i * 0.5F), (double) Mth.sin(this.getYRot() * 0.017453292F), (double) (-Mth.cos(this.getYRot() * 0.017453292F)));
                             } else {
-                                entity.push((double) (-Mth.sin(this.getYRot() * 0.017453292F) * (float) i * 0.5F), 0.1D, (double) (Mth.cos(this.getYRot() * 0.017453292F) * (float) i * 0.5F));
+                                target.push((double) (-Mth.sin(this.getYRot() * 0.017453292F) * (float) i * 0.5F), 0.1D, (double) (Mth.cos(this.getYRot() * 0.017453292F) * (float) i * 0.5F));
                             }
 
                             this.setDeltaMovement(this.getDeltaMovement().multiply(0.6D, 1.0D, 0.6D));
@@ -1217,15 +1283,18 @@
 
                         if (flag3) {
                             float f4 = 1.0F + EnchantmentHelper.getSweepingDamageRatio(this) * f;
-                            List<LivingEntity> list = this.level().getEntitiesOfClass(LivingEntity.class, entity.getBoundingBox().inflate(1.0D, 0.25D, 1.0D));
+                            List<LivingEntity> list = this.level().getEntitiesOfClass(LivingEntity.class, target.getBoundingBox().inflate(1.0D, 0.25D, 1.0D));
                             Iterator iterator = list.iterator();
 
                             while (iterator.hasNext()) {
-                                LivingEntity livingentity = (LivingEntity) iterator.next();
+                                LivingEntity entityliving = (LivingEntity) iterator.next();
 
-                                if (livingentity != this && livingentity != entity && !this.isAlliedTo((Entity) livingentity) && (!(livingentity instanceof ArmorStand) || !((ArmorStand) livingentity).isMarker()) && this.distanceToSqr((Entity) livingentity) < 9.0D) {
-                                    livingentity.knockback(0.4000000059604645D, (double) Mth.sin(this.getYRot() * 0.017453292F), (double) (-Mth.cos(this.getYRot() * 0.017453292F)));
-                                    livingentity.hurt(this.damageSources().playerAttack(this), f4);
+                                if (entityliving != this && entityliving != target && !this.isAlliedTo((Entity) entityliving) && (!(entityliving instanceof ArmorStand) || !((ArmorStand) entityliving).isMarker()) && this.distanceToSqr((Entity) entityliving) < 9.0D) {
+                                    // CraftBukkit start - Only apply knockback if the damage hits
+                                    if (entityliving.hurt(this.damageSources().playerAttack(this).sweep(), f4)) {
+                                    entityliving.knockback(0.4000000059604645D, (double) Mth.sin(this.getYRot() * 0.017453292F), (double) (-Mth.cos(this.getYRot() * 0.017453292F)));
+                                    }
+                                    // CraftBukkit end
                                 }
                             }
 
@@ -1233,15 +1302,32 @@
                             this.sweepAttack();
                         }
 
-                        if (entity instanceof ServerPlayer && entity.hurtMarked) {
-                            ((ServerPlayer) entity).connection.send(new ClientboundSetEntityMotionPacket(entity));
-                            entity.hurtMarked = false;
-                            entity.setDeltaMovement(vec3);
+                        if (target instanceof ServerPlayer && target.hurtMarked) {
+                            // CraftBukkit start - Add Velocity Event
+                            boolean cancelled = false;
+                            org.bukkit.entity.Player player = (org.bukkit.entity.Player) target.getBukkitEntity();
+                            org.bukkit.util.Vector velocity = CraftVector.toBukkit(vec3d);
+
+                            PlayerVelocityEvent event = new PlayerVelocityEvent(player, velocity.clone());
+                            this.level().getCraftServer().getPluginManager().callEvent(event);
+
+                            if (event.isCancelled()) {
+                                cancelled = true;
+                            } else if (!velocity.equals(event.getVelocity())) {
+                                player.setVelocity(event.getVelocity());
+                            }
+
+                            if (!cancelled) {
+                            ((ServerPlayer) target).connection.send(new ClientboundSetEntityMotionPacket(target));
+                            target.hurtMarked = false;
+                            target.setDeltaMovement(vec3d);
+                            }
+                            // CraftBukkit end
                         }
 
                         if (flag2) {
                             this.level().playSound((Player) null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_CRIT, this.getSoundSource(), 1.0F, 1.0F);
-                            this.crit(entity);
+                            this.crit(target);
                         }
 
                         if (!flag2 && !flag3) {
@@ -1253,50 +1339,62 @@
                         }
 
                         if (f1 > 0.0F) {
-                            this.magicCrit(entity);
+                            this.magicCrit(target);
                         }
 
-                        this.setLastHurtMob(entity);
-                        if (entity instanceof LivingEntity) {
-                            EnchantmentHelper.doPostHurtEffects((LivingEntity) entity, this);
+                        this.setLastHurtMob(target);
+                        if (target instanceof LivingEntity) {
+                            EnchantmentHelper.doPostHurtEffects((LivingEntity) target, this);
                         }
 
-                        EnchantmentHelper.doPostDamageEffects(this, entity);
+                        EnchantmentHelper.doPostDamageEffects(this, target);
                         ItemStack itemstack1 = this.getMainHandItem();
-                        Object object = entity;
+                        Object object = target;
 
-                        if (entity instanceof EnderDragonPart) {
-                            object = ((EnderDragonPart) entity).parentMob;
+                        if (target instanceof EnderDragonPart) {
+                            object = ((EnderDragonPart) target).parentMob;
                         }
 
                         if (!this.level().isClientSide && !itemstack1.isEmpty() && object instanceof LivingEntity) {
                             itemstack1.hurtEnemy((LivingEntity) object, this);
                             if (itemstack1.isEmpty()) {
-                                this.setItemInHand(InteractionHand.MAIN_HAND, ItemStack.EMPTY);
+                                this.setItemInHand(EnumHand.MAIN_HAND, ItemStack.EMPTY);
                             }
                         }
 
-                        if (entity instanceof LivingEntity) {
-                            float f5 = f3 - ((LivingEntity) entity).getHealth();
+                        if (target instanceof LivingEntity) {
+                            float f5 = f3 - ((LivingEntity) target).getHealth();
 
                             this.awardStat(Stats.DAMAGE_DEALT, Math.round(f5 * 10.0F));
                             if (j > 0) {
-                                entity.setSecondsOnFire(j * 4);
+                                // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                                EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), target.getBukkitEntity(), j * 4);
+                                org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+                                if (!combustEvent.isCancelled()) {
+                                    target.setSecondsOnFire(combustEvent.getDuration(), false);
+                                }
+                                // CraftBukkit end
                             }
 
                             if (this.level() instanceof ServerLevel && f5 > 2.0F) {
                                 int k = (int) ((double) f5 * 0.5D);
 
-                                ((ServerLevel) this.level()).sendParticles(ParticleTypes.DAMAGE_INDICATOR, entity.getX(), entity.getY(0.5D), entity.getZ(), k, 0.1D, 0.0D, 0.1D, 0.2D);
+                                ((ServerLevel) this.level()).sendParticles(ParticleTypes.DAMAGE_INDICATOR, target.getX(), target.getY(0.5D), target.getZ(), k, 0.1D, 0.0D, 0.1D, 0.2D);
                             }
                         }
 
-                        this.causeFoodExhaustion(0.1F);
+                        this.causeFoodExhaustion(0.1F, EntityExhaustionEvent.ExhaustionReason.ATTACK); // CraftBukkit - EntityExhaustionEvent
                     } else {
                         this.level().playSound((Player) null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_ATTACK_NODAMAGE, this.getSoundSource(), 1.0F, 1.0F);
                         if (flag4) {
-                            entity.clearFire();
+                            target.clearFire();
                         }
+                        // CraftBukkit start - resync on cancelled event
+                        if (this instanceof ServerPlayer) {
+                            ((ServerPlayer) this).getBukkitEntity().updateInventory();
+                        }
+                        // CraftBukkit end
                     }
                 }
 
@@ -1305,15 +1403,14 @@
     }
 
     @Override
-    @Override
-    protected void doAutoAttackOnTouch(LivingEntity livingentity) {
-        this.attack(livingentity);
+    protected void doAutoAttackOnTouch(LivingEntity target) {
+        this.attack(target);
     }
 
-    public void disableShield(boolean flag) {
+    public void disableShield(boolean becauseOfAxe) {
         float f = 0.25F + (float) EnchantmentHelper.getBlockEfficiency(this) * 0.05F;
 
-        if (flag) {
+        if (becauseOfAxe) {
             f += 0.75F;
         }
 
@@ -1325,9 +1422,9 @@
 
     }
 
-    public void crit(Entity entity) {}
+    public void crit(Entity entityHit) {}
 
-    public void magicCrit(Entity entity) {}
+    public void magicCrit(Entity entityHit) {}
 
     public void sweepAttack() {
         double d0 = (double) (-Mth.sin(this.getYRot() * 0.017453292F));
@@ -1342,9 +1439,8 @@
     public void respawn() {}
 
     @Override
-    @Override
-    public void remove(Entity.RemovalReason entity_removalreason) {
-        super.remove(entity_removalreason);
+    public void remove(Entity.RemovalReason reason) {
+        super.remove(reason);
         this.inventoryMenu.removed(this);
         if (this.containerMenu != null && this.hasContainerOpen()) {
             this.doCloseContainer();
@@ -1368,55 +1464,60 @@
         return this.abilities;
     }
 
-    public void updateTutorialInventoryAction(ItemStack itemstack, ItemStack itemstack1, ClickAction clickaction) {}
+    public void updateTutorialInventoryAction(ItemStack carried, ItemStack clicked, ClickAction action) {}
 
     public boolean hasContainerOpen() {
         return this.containerMenu != this.inventoryMenu;
     }
 
-    public Either<Player.BedSleepingProblem, Unit> startSleepInBed(BlockPos blockpos) {
-        this.startSleeping(blockpos);
+    public Either<Player.BedSleepingProblem, Unit> startSleepInBed(BlockPos bedPos) {
+        // CraftBukkit start
+        return this.startSleepInBed(bedPos, false);
+    }
+
+    public Either<Player.BedSleepingProblem, Unit> startSleepInBed(BlockPos blockposition, boolean force) {
+        // CraftBukkit end
+        this.startSleeping(blockposition);
         this.sleepCounter = 0;
         return Either.right(Unit.INSTANCE);
     }
 
-    public void stopSleepInBed(boolean flag, boolean flag1) {
+    public void stopSleepInBed(boolean wakeImmediately, boolean updateLevelForSleepingPlayers) {
         super.stopSleeping();
-        if (this.level() instanceof ServerLevel && flag1) {
+        if (this.level() instanceof ServerLevel && updateLevelForSleepingPlayers) {
             ((ServerLevel) this.level()).updateSleepingPlayerList();
         }
 
-        this.sleepCounter = flag ? 0 : 100;
+        this.sleepCounter = wakeImmediately ? 0 : 100;
     }
 
     @Override
-    @Override
     public void stopSleeping() {
         this.stopSleepInBed(true, true);
     }
 
-    public static Optional<Vec3> findRespawnPositionAndUseSpawnBlock(ServerLevel serverlevel, BlockPos blockpos, float f, boolean flag, boolean flag1) {
-        BlockState blockstate = serverlevel.getBlockState(blockpos);
-        Block block = blockstate.getBlock();
+    public static Optional<Vec3> findRespawnPositionAndUseSpawnBlock(ServerLevel serverLevel, BlockPos spawnBlockPos, float playerOrientation, boolean isRespawnForced, boolean respawnAfterWinningTheGame) {
+        IBlockData iblockdata = serverLevel.getBlockState(spawnBlockPos);
+        Block block = iblockdata.getBlock();
 
-        if (block instanceof RespawnAnchorBlock && (flag || (Integer) blockstate.getValue(RespawnAnchorBlock.CHARGE) > 0) && RespawnAnchorBlock.canSetSpawn(serverlevel)) {
-            Optional<Vec3> optional = RespawnAnchorBlock.findStandUpPosition(EntityType.PLAYER, serverlevel, blockpos);
+        if (block instanceof RespawnAnchorBlock && (isRespawnForced || (Integer) iblockdata.getValue(RespawnAnchorBlock.CHARGE) > 0) && RespawnAnchorBlock.canSetSpawn(serverLevel)) {
+            Optional<Vec3> optional = RespawnAnchorBlock.findStandUpPosition(EntityType.PLAYER, serverLevel, spawnBlockPos);
 
-            if (!flag && !flag1 && optional.isPresent()) {
-                serverlevel.setBlock(blockpos, (BlockState) blockstate.setValue(RespawnAnchorBlock.CHARGE, (Integer) blockstate.getValue(RespawnAnchorBlock.CHARGE) - 1), 3);
+            if (!isRespawnForced && !respawnAfterWinningTheGame && optional.isPresent()) {
+                serverLevel.setBlock(spawnBlockPos, (IBlockData) iblockdata.setValue(RespawnAnchorBlock.CHARGE, (Integer) iblockdata.getValue(RespawnAnchorBlock.CHARGE) - 1), 3);
             }
 
             return optional;
-        } else if (block instanceof BedBlock && BedBlock.canSetSpawn(serverlevel)) {
-            return BedBlock.findStandUpPosition(EntityType.PLAYER, serverlevel, blockpos, (Direction) blockstate.getValue(BedBlock.FACING), f);
-        } else if (!flag) {
+        } else if (block instanceof BedBlock && BedBlock.canSetSpawn(serverLevel)) {
+            return BedBlock.findStandUpPosition(EntityType.PLAYER, serverLevel, spawnBlockPos, (Direction) iblockdata.getValue(BedBlock.FACING), playerOrientation);
+        } else if (!isRespawnForced) {
             return Optional.empty();
         } else {
-            boolean flag2 = block.isPossibleToRespawnInThis(blockstate);
-            BlockState blockstate1 = serverlevel.getBlockState(blockpos.above());
-            boolean flag3 = blockstate1.getBlock().isPossibleToRespawnInThis(blockstate1);
+            boolean flag2 = block.isPossibleToRespawnInThis(iblockdata);
+            IBlockData iblockdata1 = serverLevel.getBlockState(spawnBlockPos.above());
+            boolean flag3 = iblockdata1.getBlock().isPossibleToRespawnInThis(iblockdata1);
 
-            return flag2 && flag3 ? Optional.of(new Vec3((double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.1D, (double) blockpos.getZ() + 0.5D)) : Optional.empty();
+            return flag2 && flag3 ? Optional.of(new Vec3((double) spawnBlockPos.getX() + 0.5D, (double) spawnBlockPos.getY() + 0.1D, (double) spawnBlockPos.getZ() + 0.5D)) : Optional.empty();
         }
     }
 
@@ -1428,25 +1529,25 @@
         return this.sleepCounter;
     }
 
-    public void displayClientMessage(Component component, boolean flag) {}
+    public void displayClientMessage(Component chatComponent, boolean actionBar) {}
 
-    public void awardStat(ResourceLocation resourcelocation) {
-        this.awardStat(Stats.CUSTOM.get(resourcelocation));
+    public void awardStat(ResourceLocation statKey) {
+        this.awardStat(Stats.CUSTOM.get(statKey));
     }
 
-    public void awardStat(ResourceLocation resourcelocation, int i) {
-        this.awardStat(Stats.CUSTOM.get(resourcelocation), i);
+    public void awardStat(ResourceLocation stat, int increment) {
+        this.awardStat(Stats.CUSTOM.get(stat), increment);
     }
 
     public void awardStat(Stat<?> stat) {
         this.awardStat(stat, 1);
     }
 
-    public void awardStat(Stat<?> stat, int i) {}
+    public void awardStat(Stat<?> stat, int increment) {}
 
     public void resetStat(Stat<?> stat) {}
 
-    public int awardRecipes(Collection<RecipeHolder<?>> collection) {
+    public int awardRecipes(Collection<RecipeHolder<?>> recipes) {
         return 0;
     }
 
@@ -1454,26 +1555,24 @@
 
     public void awardRecipesByKey(List<ResourceLocation> list) {}
 
-    public int resetRecipes(Collection<RecipeHolder<?>> collection) {
+    public int resetRecipes(Collection<RecipeHolder<?>> recipes) {
         return 0;
     }
 
     @Override
-    @Override
     public void jumpFromGround() {
         super.jumpFromGround();
         this.awardStat(Stats.JUMP);
         if (this.isSprinting()) {
-            this.causeFoodExhaustion(0.2F);
+            this.causeFoodExhaustion(0.2F, EntityExhaustionEvent.ExhaustionReason.JUMP_SPRINT); // CraftBukkit - EntityExhaustionEvent
         } else {
-            this.causeFoodExhaustion(0.05F);
+            this.causeFoodExhaustion(0.05F, EntityExhaustionEvent.ExhaustionReason.JUMP); // CraftBukkit - EntityExhaustionEvent
         }
 
     }
 
     @Override
-    @Override
-    public void travel(Vec3 vec3) {
+    public void travel(Vec3 travelVector) {
         double d0;
 
         if (this.isSwimming() && !this.isPassenger()) {
@@ -1481,28 +1580,31 @@
             double d1 = d0 < -0.2D ? 0.085D : 0.06D;
 
             if (d0 <= 0.0D || this.jumping || !this.level().getBlockState(BlockPos.containing(this.getX(), this.getY() + 1.0D - 0.1D, this.getZ())).getFluidState().isEmpty()) {
-                Vec3 vec31 = this.getDeltaMovement();
+                Vec3 vec3d1 = this.getDeltaMovement();
 
-                this.setDeltaMovement(vec31.add(0.0D, (d0 - vec31.y) * d1, 0.0D));
+                this.setDeltaMovement(vec3d1.add(0.0D, (d0 - vec3d1.y) * d1, 0.0D));
             }
         }
 
         if (this.abilities.flying && !this.isPassenger()) {
             d0 = this.getDeltaMovement().y;
-            super.travel(vec3);
-            Vec3 vec32 = this.getDeltaMovement();
+            super.travel(travelVector);
+            Vec3 vec3d2 = this.getDeltaMovement();
 
-            this.setDeltaMovement(vec32.x, d0 * 0.6D, vec32.z);
+            this.setDeltaMovement(vec3d2.x, d0 * 0.6D, vec3d2.z);
             this.resetFallDistance();
-            this.setSharedFlag(7, false);
+            // CraftBukkit start
+            if (getSharedFlag(7) && !org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
+                this.setSharedFlag(7, false);
+            }
+            // CraftBukkit end
         } else {
-            super.travel(vec3);
+            super.travel(travelVector);
         }
 
     }
 
     @Override
-    @Override
     public void updateSwimming() {
         if (this.abilities.flying) {
             this.setSwimming(false);
@@ -1512,27 +1614,25 @@
 
     }
 
-    protected boolean freeAt(BlockPos blockpos) {
-        return !this.level().getBlockState(blockpos).isSuffocating(this.level(), blockpos);
+    protected boolean freeAt(BlockPos pos) {
+        return !this.level().getBlockState(pos).isSuffocating(this.level(), pos);
     }
 
     @Override
-    @Override
     public float getSpeed() {
         return (float) this.getAttributeValue(Attributes.MOVEMENT_SPEED);
     }
 
     @Override
-    @Override
-    public boolean causeFallDamage(float f, float f1, DamageSource damagesource) {
+    public boolean causeFallDamage(float fallDistance, float multiplier, DamageSource source) {
         if (this.abilities.mayfly) {
             return false;
         } else {
-            if (f >= 2.0F) {
-                this.awardStat(Stats.FALL_ONE_CM, (int) Math.round((double) f * 100.0D));
+            if (fallDistance >= 2.0F) {
+                this.awardStat(Stats.FALL_ONE_CM, (int) Math.round((double) fallDistance * 100.0D));
             }
 
-            return super.causeFallDamage(f, f1, damagesource);
+            return super.causeFallDamage(fallDistance, multiplier, source);
         }
     }
 
@@ -1550,16 +1650,27 @@
     }
 
     public void startFallFlying() {
-        this.setSharedFlag(7, true);
+        // CraftBukkit start
+        if (!org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, true).isCancelled()) {
+            this.setSharedFlag(7, true);
+        } else {
+            // SPIGOT-5542: must toggle like below
+            this.setSharedFlag(7, true);
+            this.setSharedFlag(7, false);
+        }
+        // CraftBukkit end
     }
 
     public void stopFallFlying() {
+        // CraftBukkit start
+        if (!org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
         this.setSharedFlag(7, true);
         this.setSharedFlag(7, false);
+        }
+        // CraftBukkit end
     }
 
     @Override
-    @Override
     protected void doWaterSplashEffect() {
         if (!this.isSpectator()) {
             super.doWaterSplashEffect();
@@ -1568,55 +1679,51 @@
     }
 
     @Override
-    @Override
-    protected void playStepSound(BlockPos blockpos, BlockState blockstate) {
+    protected void playStepSound(BlockPos pos, IBlockData state) {
         if (this.isInWater()) {
             this.waterSwimSound();
-            this.playMuffledStepSound(blockstate);
+            this.playMuffledStepSound(state);
         } else {
-            BlockPos blockpos1 = this.getPrimaryStepSoundBlockPos(blockpos);
+            BlockPos blockposition1 = this.getPrimaryStepSoundBlockPos(pos);
 
-            if (!blockpos.equals(blockpos1)) {
-                BlockState blockstate1 = this.level().getBlockState(blockpos1);
+            if (!pos.equals(blockposition1)) {
+                IBlockData iblockdata1 = this.level().getBlockState(blockposition1);
 
-                if (blockstate1.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS)) {
-                    this.playCombinationStepSounds(blockstate1, blockstate);
+                if (iblockdata1.is(BlockTags.COMBINATION_STEP_SOUND_BLOCKS)) {
+                    this.playCombinationStepSounds(iblockdata1, state);
                 } else {
-                    super.playStepSound(blockpos1, blockstate1);
+                    super.playStepSound(blockposition1, iblockdata1);
                 }
             } else {
-                super.playStepSound(blockpos, blockstate);
+                super.playStepSound(pos, state);
             }
         }
 
     }
 
     @Override
-    @Override
-    public LivingEntity.Fallsounds getFallSounds() {
-        return new LivingEntity.Fallsounds(SoundEvents.PLAYER_SMALL_FALL, SoundEvents.PLAYER_BIG_FALL);
+    public LivingEntity.a getFallSounds() {
+        return new LivingEntity.a(SoundEvents.PLAYER_SMALL_FALL, SoundEvents.PLAYER_BIG_FALL);
     }
 
     @Override
-    @Override
-    public boolean killedEntity(ServerLevel serverlevel, LivingEntity livingentity) {
-        this.awardStat(Stats.ENTITY_KILLED.get(livingentity.getType()));
+    public boolean killedEntity(ServerLevel level, LivingEntity entity) {
+        this.awardStat(Stats.ENTITY_KILLED.get(entity.getType()));
         return true;
     }
 
     @Override
-    @Override
-    public void makeStuckInBlock(BlockState blockstate, Vec3 vec3) {
+    public void makeStuckInBlock(IBlockData state, Vec3 motionMultiplier) {
         if (!this.abilities.flying) {
-            super.makeStuckInBlock(blockstate, vec3);
+            super.makeStuckInBlock(state, motionMultiplier);
         }
 
     }
 
-    public void giveExperiencePoints(int i) {
-        this.increaseScore(i);
-        this.experienceProgress += (float) i / (float) this.getXpNeededForNextLevel();
-        this.totalExperience = Mth.clamp(this.totalExperience + i, 0, Integer.MAX_VALUE);
+    public void giveExperiencePoints(int xpPoints) {
+        this.increaseScore(xpPoints);
+        this.experienceProgress += (float) xpPoints / (float) this.getXpNeededForNextLevel();
+        this.totalExperience = Mth.clamp(this.totalExperience + xpPoints, 0, Integer.MAX_VALUE);
 
         while (this.experienceProgress < 0.0F) {
             float f = this.experienceProgress * (float) this.getXpNeededForNextLevel();
@@ -1642,8 +1749,8 @@
         return this.enchantmentSeed;
     }
 
-    public void onEnchantmentPerformed(ItemStack itemstack, int i) {
-        this.experienceLevel -= i;
+    public void onEnchantmentPerformed(ItemStack enchantedItem, int levelCost) {
+        this.experienceLevel -= levelCost;
         if (this.experienceLevel < 0) {
             this.experienceLevel = 0;
             this.experienceProgress = 0.0F;
@@ -1653,15 +1760,15 @@
         this.enchantmentSeed = this.random.nextInt();
     }
 
-    public void giveExperienceLevels(int i) {
-        this.experienceLevel += i;
+    public void giveExperienceLevels(int levels) {
+        this.experienceLevel += levels;
         if (this.experienceLevel < 0) {
             this.experienceLevel = 0;
             this.experienceProgress = 0.0F;
             this.totalExperience = 0;
         }
 
-        if (i > 0 && this.experienceLevel % 5 == 0 && (float) this.lastLevelUpTime < (float) this.tickCount - 100.0F) {
+        if (levels > 0 && this.experienceLevel % 5 == 0 && (float) this.lastLevelUpTime < (float) this.tickCount - 100.0F) {
             float f = this.experienceLevel > 30 ? 1.0F : (float) this.experienceLevel / 30.0F;
 
             this.level().playSound((Player) null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_LEVELUP, this.getSoundSource(), f * 0.75F, 1.0F);
@@ -1674,10 +1781,21 @@
         return this.experienceLevel >= 30 ? 112 + (this.experienceLevel - 30) * 9 : (this.experienceLevel >= 15 ? 37 + (this.experienceLevel - 15) * 5 : 7 + this.experienceLevel * 2);
     }
 
-    public void causeFoodExhaustion(float f) {
+    // CraftBukkit start
+    public void causeFoodExhaustion(float exhaustion) {
+        this.causeFoodExhaustion(exhaustion, EntityExhaustionEvent.ExhaustionReason.UNKNOWN);
+    }
+
+    public void causeFoodExhaustion(float f, EntityExhaustionEvent.ExhaustionReason reason) {
+        // CraftBukkit end
         if (!this.abilities.invulnerable) {
             if (!this.level().isClientSide) {
-                this.foodData.addExhaustion(f);
+                // CraftBukkit start
+                EntityExhaustionEvent event = CraftEventFactory.callPlayerExhaustionEvent(this, reason, f);
+                if (!event.isCancelled()) {
+                    this.foodData.addExhaustion(event.getExhaustion());
+                }
+                // CraftBukkit end
             }
 
         }
@@ -1691,8 +1809,8 @@
         return this.foodData;
     }
 
-    public boolean canEat(boolean flag) {
-        return this.abilities.invulnerable || flag || this.foodData.needsFood();
+    public boolean canEat(boolean canAlwaysEat) {
+        return this.abilities.invulnerable || canAlwaysEat || this.foodData.needsFood();
     }
 
     public boolean isHurt() {
@@ -1703,19 +1821,18 @@
         return this.abilities.mayBuild;
     }
 
-    public boolean mayUseItemAt(BlockPos blockpos, Direction direction, ItemStack itemstack) {
+    public boolean mayUseItemAt(BlockPos pos, Direction facing, ItemStack stack) {
         if (this.abilities.mayBuild) {
             return true;
         } else {
-            BlockPos blockpos1 = blockpos.relative(direction.getOpposite());
-            BlockInWorld blockinworld = new BlockInWorld(this.level(), blockpos1, false);
+            BlockPos blockposition1 = pos.relative(facing.getOpposite());
+            BlockInWorld shapedetectorblock = new BlockInWorld(this.level(), blockposition1, false);
 
-            return itemstack.hasAdventureModePlaceTagForBlock(this.level().registryAccess().registryOrThrow(Registries.BLOCK), blockinworld);
+            return stack.hasAdventureModePlaceTagForBlock(this.level().registryAccess().registryOrThrow(Registries.BLOCK), shapedetectorblock);
         }
     }
 
     @Override
-    @Override
     public int getExperienceReward() {
         if (!this.level().getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) && !this.isSpectator()) {
             int i = this.experienceLevel * 7;
@@ -1727,19 +1844,16 @@
     }
 
     @Override
-    @Override
     protected boolean isAlwaysExperienceDropper() {
         return true;
     }
 
     @Override
-    @Override
     public boolean shouldShowName() {
         return true;
     }
 
     @Override
-    @Override
     protected Entity.MovementEmission getMovementEmission() {
         return !this.abilities.flying && (!this.onGround() || !this.isDiscrete()) ? Entity.MovementEmission.ALL : Entity.MovementEmission.NONE;
     }
@@ -1747,7 +1861,6 @@
     public void onUpdateAbilities() {}
 
     @Override
-    @Override
     public Component getName() {
         return Component.literal(this.gameProfile.getName());
     }
@@ -1757,55 +1870,57 @@
     }
 
     @Override
+    public ItemStack getItemBySlot(EquipmentSlot slot) {
+        return slot == EquipmentSlot.MAINHAND ? this.inventory.getSelected() : (slot == EquipmentSlot.OFFHAND ? (ItemStack) this.inventory.offhand.get(0) : (slot.getType() == EquipmentSlot.Function.ARMOR ? (ItemStack) this.inventory.armor.get(slot.getIndex()) : ItemStack.EMPTY));
+    }
+
     @Override
-    public ItemStack getItemBySlot(EquipmentSlot equipmentslot) {
-        return equipmentslot == EquipmentSlot.MAINHAND ? this.inventory.getSelected() : (equipmentslot == EquipmentSlot.OFFHAND ? (ItemStack) this.inventory.offhand.get(0) : (equipmentslot.getType() == EquipmentSlot.Type.ARMOR ? (ItemStack) this.inventory.armor.get(equipmentslot.getIndex()) : ItemStack.EMPTY));
+    protected boolean doesEmitEquipEvent(EquipmentSlot slot) {
+        return slot.getType() == EquipmentSlot.Function.ARMOR;
     }
 
     @Override
-    @Override
-    protected boolean doesEmitEquipEvent(EquipmentSlot equipmentslot) {
-        return equipmentslot.getType() == EquipmentSlot.Type.ARMOR;
+    public void setItemSlot(EquipmentSlot slot, ItemStack stack) {
+        // CraftBukkit start
+        setItemSlot(slot, stack, false);
     }
 
     @Override
-    @Override
-    public void setItemSlot(EquipmentSlot equipmentslot, ItemStack itemstack) {
+    public void setItemSlot(EquipmentSlot enumitemslot, ItemStack itemstack, boolean silent) {
+        // CraftBukkit end
         this.verifyEquippedItem(itemstack);
-        if (equipmentslot == EquipmentSlot.MAINHAND) {
-            this.onEquipItem(equipmentslot, (ItemStack) this.inventory.items.set(this.inventory.selected, itemstack), itemstack);
-        } else if (equipmentslot == EquipmentSlot.OFFHAND) {
-            this.onEquipItem(equipmentslot, (ItemStack) this.inventory.offhand.set(0, itemstack), itemstack);
-        } else if (equipmentslot.getType() == EquipmentSlot.Type.ARMOR) {
-            this.onEquipItem(equipmentslot, (ItemStack) this.inventory.armor.set(equipmentslot.getIndex(), itemstack), itemstack);
+        if (enumitemslot == EquipmentSlot.MAINHAND) {
+            this.onEquipItem(enumitemslot, (ItemStack) this.inventory.items.set(this.inventory.selected, itemstack), itemstack, silent); // CraftBukkit
+        } else if (enumitemslot == EquipmentSlot.OFFHAND) {
+            this.onEquipItem(enumitemslot, (ItemStack) this.inventory.offhand.set(0, itemstack), itemstack, silent); // CraftBukkit
+        } else if (enumitemslot.getType() == EquipmentSlot.Function.ARMOR) {
+            this.onEquipItem(enumitemslot, (ItemStack) this.inventory.armor.set(enumitemslot.getIndex(), itemstack), itemstack, silent); // CraftBukkit
         }
 
     }
 
-    public boolean addItem(ItemStack itemstack) {
-        return this.inventory.add(itemstack);
+    public boolean addItem(ItemStack stack) {
+        return this.inventory.add(stack);
     }
 
     @Override
-    @Override
     public Iterable<ItemStack> getHandSlots() {
         return Lists.newArrayList(new ItemStack[]{this.getMainHandItem(), this.getOffhandItem()});
     }
 
     @Override
-    @Override
     public Iterable<ItemStack> getArmorSlots() {
         return this.inventory.armor;
     }
 
-    public boolean setEntityOnShoulder(CompoundTag compoundtag) {
+    public boolean setEntityOnShoulder(CompoundTag entityCompound) {
         if (!this.isPassenger() && this.onGround() && !this.isInWater() && !this.isInPowderSnow) {
             if (this.getShoulderEntityLeft().isEmpty()) {
-                this.setShoulderEntityLeft(compoundtag);
+                this.setShoulderEntityLeft(entityCompound);
                 this.timeEntitySatOnShoulder = this.level().getGameTime();
                 return true;
             } else if (this.getShoulderEntityRight().isEmpty()) {
-                this.setShoulderEntityRight(compoundtag);
+                this.setShoulderEntityRight(entityCompound);
                 this.timeEntitySatOnShoulder = this.level().getGameTime();
                 return true;
             } else {
@@ -1818,40 +1933,42 @@
 
     protected void removeEntitiesOnShoulder() {
         if (this.timeEntitySatOnShoulder + 20L < this.level().getGameTime()) {
-            this.respawnEntityOnShoulder(this.getShoulderEntityLeft());
-            this.setShoulderEntityLeft(new CompoundTag());
-            this.respawnEntityOnShoulder(this.getShoulderEntityRight());
-            this.setShoulderEntityRight(new CompoundTag());
+            // CraftBukkit start
+            if (this.respawnEntityOnShoulder(this.getShoulderEntityLeft())) {
+                this.setShoulderEntityLeft(new CompoundTag());
+            }
+            if (this.respawnEntityOnShoulder(this.getShoulderEntityRight())) {
+                this.setShoulderEntityRight(new CompoundTag());
+            }
+            // CraftBukkit end
         }
 
     }
 
-    private void respawnEntityOnShoulder(CompoundTag compoundtag) {
-        if (!this.level().isClientSide && !compoundtag.isEmpty()) {
-            EntityType.create(compoundtag, this.level()).ifPresent((entity) -> {
+    private boolean respawnEntityOnShoulder(CompoundTag nbttagcompound) { // CraftBukkit void->boolean
+        if (!this.level().isClientSide && !nbttagcompound.isEmpty()) {
+            return EntityType.create(nbttagcompound, this.level()).map((entity) -> { // CraftBukkit
                 if (entity instanceof TamableAnimal) {
                     ((TamableAnimal) entity).setOwnerUUID(this.uuid);
                 }
 
                 entity.setPos(this.getX(), this.getY() + 0.699999988079071D, this.getZ());
-                ((ServerLevel) this.level()).addWithUUID(entity);
-            });
+                return ((ServerLevel) this.level()).addWithUUID(entity, CreatureSpawnEvent.SpawnReason.SHOULDER_ENTITY); // CraftBukkit
+            }).orElse(true); // CraftBukkit
         }
 
+        return true; // CraftBukkit
     }
 
     @Override
-    @Override
     public abstract boolean isSpectator();
 
     @Override
-    @Override
     public boolean canBeHitByProjectile() {
         return !this.isSpectator() && super.canBeHitByProjectile();
     }
 
     @Override
-    @Override
     public boolean isSwimming() {
         return !this.abilities.flying && !this.isSpectator() && super.isSwimming();
     }
@@ -1859,7 +1976,6 @@
     public abstract boolean isCreative();
 
     @Override
-    @Override
     public boolean isPushedByFluid() {
         return !this.abilities.flying;
     }
@@ -1869,30 +1985,27 @@
     }
 
     @Override
-    @Override
     public Component getDisplayName() {
-        MutableComponent mutablecomponent = PlayerTeam.formatNameForTeam(this.getTeam(), this.getName());
+        MutableComponent ichatmutablecomponent = PlayerTeam.formatNameForTeam(this.getTeam(), this.getName());
 
-        return this.decorateDisplayNameComponent(mutablecomponent);
+        return this.decorateDisplayNameComponent(ichatmutablecomponent);
     }
 
-    private MutableComponent decorateDisplayNameComponent(MutableComponent mutablecomponent) {
+    private MutableComponent decorateDisplayNameComponent(MutableComponent displayName) {
         String s = this.getGameProfile().getName();
 
-        return mutablecomponent.withStyle((style) -> {
-            return style.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/tell " + s + " ")).withHoverEvent(this.createHoverEvent()).withInsertion(s);
+        return displayName.withStyle((chatmodifier) -> {
+            return chatmodifier.withClickEvent(new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, "/tell " + s + " ")).withHoverEvent(this.createHoverEvent()).withInsertion(s);
         });
     }
 
     @Override
-    @Override
     public String getScoreboardName() {
         return this.getGameProfile().getName();
     }
 
     @Override
-    @Override
-    public float getStandingEyeHeight(Pose pose, EntityDimensions entitydimensions) {
+    public float getStandingEyeHeight(EntityPose pose, EntityDimensions size) {
         switch (pose) {
             case SWIMMING:
             case FALL_FLYING:
@@ -1906,30 +2019,27 @@
     }
 
     @Override
-    @Override
     protected void internalSetAbsorptionAmount(float f) {
         this.getEntityData().set(Player.DATA_PLAYER_ABSORPTION_ID, f);
     }
 
     @Override
-    @Override
     public float getAbsorptionAmount() {
         return (Float) this.getEntityData().get(Player.DATA_PLAYER_ABSORPTION_ID);
     }
 
-    public boolean isModelPartShown(PlayerModelPart playermodelpart) {
-        return ((Byte) this.getEntityData().get(Player.DATA_PLAYER_MODE_CUSTOMISATION) & playermodelpart.getMask()) == playermodelpart.getMask();
+    public boolean isModelPartShown(PlayerModelPart part) {
+        return ((Byte) this.getEntityData().get(Player.DATA_PLAYER_MODE_CUSTOMISATION) & part.getMask()) == part.getMask();
     }
 
     @Override
-    @Override
-    public SlotAccess getSlot(int i) {
-        if (i >= 0 && i < this.inventory.items.size()) {
-            return SlotAccess.forContainer(this.inventory, i);
+    public SlotAccess getSlot(int slot) {
+        if (slot >= 0 && slot < this.inventory.items.size()) {
+            return SlotAccess.forContainer(this.inventory, slot);
         } else {
-            int j = i - 200;
+            int j = slot - 200;
 
-            return j >= 0 && j < this.enderChestInventory.getContainerSize() ? SlotAccess.forContainer(this.enderChestInventory, j) : super.getSlot(i);
+            return j >= 0 && j < this.enderChestInventory.getContainerSize() ? SlotAccess.forContainer(this.enderChestInventory, j) : super.getSlot(slot);
         }
     }
 
@@ -1937,48 +2047,46 @@
         return this.reducedDebugInfo;
     }
 
-    public void setReducedDebugInfo(boolean flag) {
-        this.reducedDebugInfo = flag;
+    public void setReducedDebugInfo(boolean reducedDebugInfo) {
+        this.reducedDebugInfo = reducedDebugInfo;
     }
 
     @Override
-    @Override
-    public void setRemainingFireTicks(int i) {
-        super.setRemainingFireTicks(this.abilities.invulnerable ? Math.min(i, 1) : i);
+    public void setRemainingFireTicks(int ticks) {
+        super.setRemainingFireTicks(this.abilities.invulnerable ? Math.min(ticks, 1) : ticks);
     }
 
     @Override
-    @Override
     public HumanoidArm getMainArm() {
         return (Byte) this.entityData.get(Player.DATA_PLAYER_MAIN_HAND) == 0 ? HumanoidArm.LEFT : HumanoidArm.RIGHT;
     }
 
-    public void setMainArm(HumanoidArm humanoidarm) {
-        this.entityData.set(Player.DATA_PLAYER_MAIN_HAND, (byte) (humanoidarm == HumanoidArm.LEFT ? 0 : 1));
+    public void setMainArm(HumanoidArm hand) {
+        this.entityData.set(Player.DATA_PLAYER_MAIN_HAND, (byte) (hand == HumanoidArm.LEFT ? 0 : 1));
     }
 
     public CompoundTag getShoulderEntityLeft() {
         return (CompoundTag) this.entityData.get(Player.DATA_SHOULDER_LEFT);
     }
 
-    protected void setShoulderEntityLeft(CompoundTag compoundtag) {
-        this.entityData.set(Player.DATA_SHOULDER_LEFT, compoundtag);
+    public void setShoulderEntityLeft(CompoundTag entityCompound) {
+        this.entityData.set(Player.DATA_SHOULDER_LEFT, entityCompound);
     }
 
     public CompoundTag getShoulderEntityRight() {
         return (CompoundTag) this.entityData.get(Player.DATA_SHOULDER_RIGHT);
     }
 
-    protected void setShoulderEntityRight(CompoundTag compoundtag) {
-        this.entityData.set(Player.DATA_SHOULDER_RIGHT, compoundtag);
+    public void setShoulderEntityRight(CompoundTag entityCompound) {
+        this.entityData.set(Player.DATA_SHOULDER_RIGHT, entityCompound);
     }
 
     public float getCurrentItemAttackStrengthDelay() {
         return (float) (1.0D / this.getAttributeValue(Attributes.ATTACK_SPEED) * 20.0D);
     }
 
-    public float getAttackStrengthScale(float f) {
-        return Mth.clamp(((float) this.attackStrengthTicker + f) / this.getCurrentItemAttackStrengthDelay(), 0.0F, 1.0F);
+    public float getAttackStrengthScale(float adjustTicks) {
+        return Mth.clamp(((float) this.attackStrengthTicker + adjustTicks) / this.getCurrentItemAttackStrengthDelay(), 0.0F, 1.0F);
     }
 
     public void resetAttackStrengthTicker() {
@@ -1990,7 +2098,6 @@
     }
 
     @Override
-    @Override
     protected float getBlockSpeedFactor() {
         return !this.abilities.flying && !this.isFallFlying() ? super.getBlockSpeedFactor() : 1.0F;
     }
@@ -2004,38 +2111,34 @@
     }
 
     @Override
-    @Override
     public boolean canTakeItem(ItemStack itemstack) {
-        EquipmentSlot equipmentslot = Mob.getEquipmentSlotForItem(itemstack);
+        EquipmentSlot enumitemslot = Mob.getEquipmentSlotForItem(itemstack);
 
-        return this.getItemBySlot(equipmentslot).isEmpty();
+        return this.getItemBySlot(enumitemslot).isEmpty();
     }
 
     @Override
-    @Override
-    public EntityDimensions getDimensions(Pose pose) {
+    public EntityDimensions getDimensions(EntityPose pose) {
         return (EntityDimensions) Player.POSES.getOrDefault(pose, Player.STANDING_DIMENSIONS);
     }
 
     @Override
-    @Override
-    public ImmutableList<Pose> getDismountPoses() {
-        return ImmutableList.of(Pose.STANDING, Pose.CROUCHING, Pose.SWIMMING);
+    public ImmutableList<EntityPose> getDismountPoses() {
+        return ImmutableList.of(EntityPose.STANDING, EntityPose.CROUCHING, EntityPose.SWIMMING);
     }
 
     @Override
-    @Override
-    public ItemStack getProjectile(ItemStack itemstack) {
-        if (!(itemstack.getItem() instanceof ProjectileWeaponItem)) {
+    public ItemStack getProjectile(ItemStack shootable) {
+        if (!(shootable.getItem() instanceof ProjectileWeaponItem)) {
             return ItemStack.EMPTY;
         } else {
-            Predicate<ItemStack> predicate = ((ProjectileWeaponItem) itemstack.getItem()).getSupportedHeldProjectiles();
+            Predicate<ItemStack> predicate = ((ProjectileWeaponItem) shootable.getItem()).getSupportedHeldProjectiles();
             ItemStack itemstack1 = ProjectileWeaponItem.getHeldProjectile(this, predicate);
 
             if (!itemstack1.isEmpty()) {
                 return itemstack1;
             } else {
-                predicate = ((ProjectileWeaponItem) itemstack.getItem()).getAllSupportedProjectiles();
+                predicate = ((ProjectileWeaponItem) shootable.getItem()).getAllSupportedProjectiles();
 
                 for (int i = 0; i < this.inventory.getContainerSize(); ++i) {
                     ItemStack itemstack2 = this.inventory.getItem(i);
@@ -2051,64 +2154,60 @@
     }
 
     @Override
-    @Override
-    public ItemStack eat(Level level, ItemStack itemstack) {
-        this.getFoodData().eat(itemstack.getItem(), itemstack);
-        this.awardStat(Stats.ITEM_USED.get(itemstack.getItem()));
+    public ItemStack eat(Level level, ItemStack food) {
+        this.getFoodData().eat(food.getItem(), food);
+        this.awardStat(Stats.ITEM_USED.get(food.getItem()));
         level.playSound((Player) null, this.getX(), this.getY(), this.getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 0.5F, level.random.nextFloat() * 0.1F + 0.9F);
         if (this instanceof ServerPlayer) {
-            CriteriaTriggers.CONSUME_ITEM.trigger((ServerPlayer) this, itemstack);
+            CriteriaTriggers.CONSUME_ITEM.trigger((ServerPlayer) this, food);
         }
 
-        return super.eat(level, itemstack);
+        return super.eat(level, food);
     }
 
     @Override
-    @Override
-    protected boolean shouldRemoveSoulSpeed(BlockState blockstate) {
-        return this.abilities.flying || super.shouldRemoveSoulSpeed(blockstate);
+    protected boolean shouldRemoveSoulSpeed(IBlockData state) {
+        return this.abilities.flying || super.shouldRemoveSoulSpeed(state);
     }
 
     @Override
-    @Override
-    public Vec3 getRopeHoldPosition(float f) {
+    public Vec3 getRopeHoldPosition(float partialTicks) {
         double d0 = 0.22D * (this.getMainArm() == HumanoidArm.RIGHT ? -1.0D : 1.0D);
-        float f1 = Mth.lerp(f * 0.5F, this.getXRot(), this.xRotO) * 0.017453292F;
-        float f2 = Mth.lerp(f, this.yBodyRotO, this.yBodyRot) * 0.017453292F;
+        float f1 = Mth.lerp(partialTicks * 0.5F, this.getXRot(), this.xRotO) * 0.017453292F;
+        float f2 = Mth.lerp(partialTicks, this.yBodyRotO, this.yBodyRot) * 0.017453292F;
         double d1;
 
         if (!this.isFallFlying() && !this.isAutoSpinAttack()) {
             if (this.isVisuallySwimming()) {
-                return this.getPosition(f).add((new Vec3(d0, 0.2D, -0.15D)).xRot(-f1).yRot(-f2));
+                return this.getPosition(partialTicks).add((new Vec3(d0, 0.2D, -0.15D)).xRot(-f1).yRot(-f2));
             } else {
                 double d2 = this.getBoundingBox().getYsize() - 1.0D;
 
                 d1 = this.isCrouching() ? -0.2D : 0.07D;
-                return this.getPosition(f).add((new Vec3(d0, d2, d1)).yRot(-f2));
+                return this.getPosition(partialTicks).add((new Vec3(d0, d2, d1)).yRot(-f2));
             }
         } else {
-            Vec3 vec3 = this.getViewVector(f);
-            Vec3 vec31 = this.getDeltaMovement();
+            Vec3 vec3d = this.getViewVector(partialTicks);
+            Vec3 vec3d1 = this.getDeltaMovement();
 
-            d1 = vec31.horizontalDistanceSqr();
-            double d3 = vec3.horizontalDistanceSqr();
+            d1 = vec3d1.horizontalDistanceSqr();
+            double d3 = vec3d.horizontalDistanceSqr();
             float f3;
 
             if (d1 > 0.0D && d3 > 0.0D) {
-                double d4 = (vec31.x * vec3.x + vec31.z * vec3.z) / Math.sqrt(d1 * d3);
-                double d5 = vec31.x * vec3.z - vec31.z * vec3.x;
+                double d4 = (vec3d1.x * vec3d.x + vec3d1.z * vec3d.z) / Math.sqrt(d1 * d3);
+                double d5 = vec3d1.x * vec3d.z - vec3d1.z * vec3d.x;
 
                 f3 = (float) (Math.signum(d5) * Math.acos(d4));
             } else {
                 f3 = 0.0F;
             }
 
-            return this.getPosition(f).add((new Vec3(d0, -0.11D, 0.85D)).zRot(-f3).xRot(-f1).yRot(-f2));
+            return this.getPosition(partialTicks).add((new Vec3(d0, -0.11D, 0.85D)).zRot(-f3).xRot(-f1).yRot(-f2));
         }
     }
 
     @Override
-    @Override
     public boolean isAlwaysTicking() {
         return true;
     }
@@ -2118,7 +2217,6 @@
     }
 
     @Override
-    @Override
     public boolean shouldBeSaved() {
         return false;
     }
@@ -2127,31 +2225,27 @@
         return this.lastDeathLocation;
     }
 
-    public void setLastDeathLocation(Optional<GlobalPos> optional) {
-        this.lastDeathLocation = optional;
+    public void setLastDeathLocation(Optional<GlobalPos> lastDeathLocation) {
+        this.lastDeathLocation = lastDeathLocation;
     }
 
     @Override
-    @Override
     public float getHurtDir() {
         return this.hurtDir;
     }
 
     @Override
-    @Override
-    public void animateHurt(float f) {
-        super.animateHurt(f);
-        this.hurtDir = f;
+    public void animateHurt(float yaw) {
+        super.animateHurt(yaw);
+        this.hurtDir = yaw;
     }
 
     @Override
-    @Override
     public boolean canSprint() {
         return true;
     }
 
     @Override
-    @Override
     protected float getFlyingSpeed() {
         return this.abilities.flying && !this.isPassenger() ? (this.isSprinting() ? this.abilities.getFlyingSpeed() * 2.0F : this.abilities.getFlyingSpeed()) : (this.isSprinting() ? 0.025999999F : 0.02F);
     }
@@ -2177,8 +2271,8 @@
             this.message = null;
         }
 
-        private BedSleepingProblem(Component component) {
-            this.message = component;
+        private BedSleepingProblem(Component ichatbasecomponent) {
+            this.message = ichatbasecomponent;
         }
 
         @Nullable
