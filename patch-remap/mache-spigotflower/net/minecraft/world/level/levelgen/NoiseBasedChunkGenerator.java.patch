--- a/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -1,3 +1,4 @@
+// keep
 package net.minecraft.world.level.levelgen;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -37,7 +38,7 @@
 import net.minecraft.world.level.biome.BiomeResolver;
 import net.minecraft.world.level.biome.BiomeSource;
 import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.chunk.CarvingMask;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
@@ -52,59 +53,57 @@
 public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
     public static final Codec<NoiseBasedChunkGenerator> CODEC = RecordCodecBuilder.create((instance) -> {
-        return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((noisebasedchunkgenerator) -> {
-            return noisebasedchunkgenerator.biomeSource;
-        }), NoiseGeneratorSettings.CODEC.fieldOf("settings").forGetter((noisebasedchunkgenerator) -> {
-            return noisebasedchunkgenerator.settings;
+        return instance.group(BiomeSource.CODEC.fieldOf("biome_source").forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.biomeSource;
+        }), NoiseGeneratorSettings.CODEC.fieldOf("settings").forGetter((chunkgeneratorabstract) -> {
+            return chunkgeneratorabstract.settings;
         })).apply(instance, instance.stable(NoiseBasedChunkGenerator::new));
     });
-    private static final BlockState AIR = Blocks.AIR.defaultBlockState();
-    private final Holder<NoiseGeneratorSettings> settings;
+    private static final IBlockData AIR = Blocks.AIR.defaultBlockState();
+    public final Holder<NoiseGeneratorSettings> settings;
     private final Supplier<Aquifer.FluidPicker> globalFluidPicker;
 
-    public NoiseBasedChunkGenerator(BiomeSource biomesource, Holder<NoiseGeneratorSettings> holder) {
-        super(biomesource);
-        this.settings = holder;
+    public NoiseBasedChunkGenerator(BiomeSource biomeSource, Holder<NoiseGeneratorSettings> settings) {
+        super(biomeSource);
+        this.settings = settings;
         this.globalFluidPicker = Suppliers.memoize(() -> {
-            return createFluidPicker((NoiseGeneratorSettings) holder.value());
+            return createFluidPicker((NoiseGeneratorSettings) settings.value());
         });
     }
 
-    private static Aquifer.FluidPicker createFluidPicker(NoiseGeneratorSettings noisegeneratorsettings) {
-        Aquifer.FluidStatus aquifer_fluidstatus = new Aquifer.FluidStatus(-54, Blocks.LAVA.defaultBlockState());
-        int i = noisegeneratorsettings.seaLevel();
-        Aquifer.FluidStatus aquifer_fluidstatus1 = new Aquifer.FluidStatus(i, noisegeneratorsettings.defaultFluid());
-        Aquifer.FluidStatus aquifer_fluidstatus2 = new Aquifer.FluidStatus(DimensionType.MIN_Y * 2, Blocks.AIR.defaultBlockState());
+    private static Aquifer.FluidPicker createFluidPicker(NoiseGeneratorSettings settings) {
+        Aquifer.FluidStatus aquifer_b = new Aquifer.FluidStatus(-54, Blocks.LAVA.defaultBlockState());
+        int i = settings.seaLevel();
+        Aquifer.FluidStatus aquifer_b1 = new Aquifer.FluidStatus(i, settings.defaultFluid());
+        Aquifer.FluidStatus aquifer_b2 = new Aquifer.FluidStatus(DimensionType.MIN_Y * 2, Blocks.AIR.defaultBlockState());
 
         return (j, k, l) -> {
-            return k < Math.min(-54, i) ? aquifer_fluidstatus : aquifer_fluidstatus1;
+            return k < Math.min(-54, i) ? aquifer_b : aquifer_b1;
         };
     }
 
     @Override
-    @Override
-    public CompletableFuture<ChunkAccess> createBiomes(Executor executor, RandomState randomstate, Blender blender, StructureManager structuremanager, ChunkAccess chunkaccess) {
+    public CompletableFuture<ChunkAccess> createBiomes(Executor executor, RandomState randomState, Blender blender, StructureManager structureManager, ChunkAccess chunk) {
         return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("init_biomes", () -> {
-            this.doCreateBiomes(blender, randomstate, structuremanager, chunkaccess);
-            return chunkaccess;
+            this.doCreateBiomes(blender, randomState, structureManager, chunk);
+            return chunk;
         }), Util.backgroundExecutor());
     }
 
-    private void doCreateBiomes(Blender blender, RandomState randomstate, StructureManager structuremanager, ChunkAccess chunkaccess) {
-        NoiseChunk noisechunk = chunkaccess.getOrCreateNoiseChunk((chunkaccess1) -> {
-            return this.createNoiseChunk(chunkaccess1, structuremanager, blender, randomstate);
+    private void doCreateBiomes(Blender blender, RandomState random, StructureManager structureManager, ChunkAccess chunk) {
+        NoiseChunk noisechunk = chunk.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, structureManager, blender, random);
         });
-        BiomeResolver biomeresolver = BelowZeroRetrogen.getBiomeResolver(blender.getBiomeResolver(this.biomeSource), chunkaccess);
+        BiomeResolver biomeresolver = BelowZeroRetrogen.getBiomeResolver(blender.getBiomeResolver(this.biomeSource), chunk);
 
-        chunkaccess.fillBiomesFromNoise(biomeresolver, noisechunk.cachedClimateSampler(randomstate.router(), ((NoiseGeneratorSettings) this.settings.value()).spawnTarget()));
+        chunk.fillBiomesFromNoise(biomeresolver, noisechunk.cachedClimateSampler(random.router(), ((NoiseGeneratorSettings) this.settings.value()).spawnTarget()));
     }
 
-    private NoiseChunk createNoiseChunk(ChunkAccess chunkaccess, StructureManager structuremanager, Blender blender, RandomState randomstate) {
-        return NoiseChunk.forChunk(chunkaccess, randomstate, Beardifier.forStructuresInChunk(structuremanager, chunkaccess.getPos()), (NoiseGeneratorSettings) this.settings.value(), (Aquifer.FluidPicker) this.globalFluidPicker.get(), blender);
+    private NoiseChunk createNoiseChunk(ChunkAccess chunk, StructureManager structureManager, Blender blender, RandomState random) {
+        return NoiseChunk.forChunk(chunk, random, Beardifier.forStructuresInChunk(structureManager, chunk.getPos()), (NoiseGeneratorSettings) this.settings.value(), (Aquifer.FluidPicker) this.globalFluidPicker.get(), blender);
     }
 
     @Override
-    @Override
     protected Codec<? extends ChunkGenerator> codec() {
         return NoiseBasedChunkGenerator.CODEC;
     }
@@ -113,39 +112,36 @@
         return this.settings;
     }
 
-    public boolean stable(ResourceKey<NoiseGeneratorSettings> resourcekey) {
-        return this.settings.is(resourcekey);
+    public boolean stable(ResourceKey<NoiseGeneratorSettings> settings) {
+        return this.settings.is(settings);
     }
 
     @Override
-    @Override
-    public int getBaseHeight(int i, int j, Heightmap.Types heightmap_types, LevelHeightAccessor levelheightaccessor, RandomState randomstate) {
-        return this.iterateNoiseColumn(levelheightaccessor, randomstate, i, j, (MutableObject) null, heightmap_types.isOpaque()).orElse(levelheightaccessor.getMinBuildHeight());
+    public int getBaseHeight(int x, int z, Heightmap.Types type, LevelHeightAccessor level, RandomState random) {
+        return this.iterateNoiseColumn(level, random, x, z, (MutableObject) null, type.isOpaque()).orElse(level.getMinBuildHeight());
     }
 
     @Override
-    @Override
-    public NoiseColumn getBaseColumn(int i, int j, LevelHeightAccessor levelheightaccessor, RandomState randomstate) {
+    public NoiseColumn getBaseColumn(int x, int z, LevelHeightAccessor height, RandomState random) {
         MutableObject<NoiseColumn> mutableobject = new MutableObject();
 
-        this.iterateNoiseColumn(levelheightaccessor, randomstate, i, j, mutableobject, (Predicate) null);
+        this.iterateNoiseColumn(height, random, x, z, mutableobject, (Predicate) null);
         return (NoiseColumn) mutableobject.getValue();
     }
 
     @Override
-    @Override
-    public void addDebugScreenInfo(List<String> list, RandomState randomstate, BlockPos blockpos) {
+    public void addDebugScreenInfo(List<String> info, RandomState random, BlockPos pos) {
         DecimalFormat decimalformat = new DecimalFormat("0.000");
-        NoiseRouter noiserouter = randomstate.router();
-        DensityFunction.SinglePointContext densityfunction_singlepointcontext = new DensityFunction.SinglePointContext(blockpos.getX(), blockpos.getY(), blockpos.getZ());
-        double d0 = noiserouter.ridges().compute(densityfunction_singlepointcontext);
-        String s = decimalformat.format(noiserouter.temperature().compute(densityfunction_singlepointcontext));
+        NoiseRouter noiserouter = random.router();
+        DensityFunction.e densityfunction_e = new DensityFunction.e(pos.getX(), pos.getY(), pos.getZ());
+        double d0 = noiserouter.ridges().compute(densityfunction_e);
+        String s = decimalformat.format(noiserouter.temperature().compute(densityfunction_e));
 
-        list.add("NoiseRouter T: " + s + " V: " + decimalformat.format(noiserouter.vegetation().compute(densityfunction_singlepointcontext)) + " C: " + decimalformat.format(noiserouter.continents().compute(densityfunction_singlepointcontext)) + " E: " + decimalformat.format(noiserouter.erosion().compute(densityfunction_singlepointcontext)) + " D: " + decimalformat.format(noiserouter.depth().compute(densityfunction_singlepointcontext)) + " W: " + decimalformat.format(d0) + " PV: " + decimalformat.format((double) NoiseRouterData.peaksAndValleys((float) d0)) + " AS: " + decimalformat.format(noiserouter.initialDensityWithoutJaggedness().compute(densityfunction_singlepointcontext)) + " N: " + decimalformat.format(noiserouter.finalDensity().compute(densityfunction_singlepointcontext)));
+        info.add("NoiseRouter T: " + s + " V: " + decimalformat.format(noiserouter.vegetation().compute(densityfunction_e)) + " C: " + decimalformat.format(noiserouter.continents().compute(densityfunction_e)) + " E: " + decimalformat.format(noiserouter.erosion().compute(densityfunction_e)) + " D: " + decimalformat.format(noiserouter.depth().compute(densityfunction_e)) + " W: " + decimalformat.format(d0) + " PV: " + decimalformat.format((double) NoiseRouterData.peaksAndValleys((float) d0)) + " AS: " + decimalformat.format(noiserouter.initialDensityWithoutJaggedness().compute(densityfunction_e)) + " N: " + decimalformat.format(noiserouter.finalDensity().compute(densityfunction_e)));
     }
 
-    private OptionalInt iterateNoiseColumn(LevelHeightAccessor levelheightaccessor, RandomState randomstate, int i, int j, @Nullable MutableObject<NoiseColumn> mutableobject, @Nullable Predicate<BlockState> predicate) {
-        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().clampToHeightAccessor(levelheightaccessor);
+    private OptionalInt iterateNoiseColumn(LevelHeightAccessor level, RandomState random, int x, int z, @Nullable MutableObject<NoiseColumn> column, @Nullable Predicate<IBlockData> stoppingState) {
+        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().clampToHeightAccessor(level);
         int k = noisesettings.getCellHeight();
         int l = noisesettings.minY();
         int i1 = Mth.floorDiv(l, k);
@@ -154,25 +150,25 @@
         if (j1 <= 0) {
             return OptionalInt.empty();
         } else {
-            BlockState[] ablockstate;
+            IBlockData[] aiblockdata;
 
-            if (mutableobject == null) {
-                ablockstate = null;
+            if (column == null) {
+                aiblockdata = null;
             } else {
-                ablockstate = new BlockState[noisesettings.height()];
-                mutableobject.setValue(new NoiseColumn(l, ablockstate));
+                aiblockdata = new IBlockData[noisesettings.height()];
+                column.setValue(new NoiseColumn(l, aiblockdata));
             }
 
             int k1 = noisesettings.getCellWidth();
-            int l1 = Math.floorDiv(i, k1);
-            int i2 = Math.floorDiv(j, k1);
-            int j2 = Math.floorMod(i, k1);
-            int k2 = Math.floorMod(j, k1);
+            int l1 = Math.floorDiv(x, k1);
+            int i2 = Math.floorDiv(z, k1);
+            int j2 = Math.floorMod(x, k1);
+            int k2 = Math.floorMod(z, k1);
             int l2 = l1 * k1;
             int i3 = i2 * k1;
             double d0 = (double) j2 / (double) k1;
             double d1 = (double) k2 / (double) k1;
-            NoiseChunk noisechunk = new NoiseChunk(1, randomstate, l2, i3, noisesettings, DensityFunctions.BeardifierMarker.INSTANCE, (NoiseGeneratorSettings) this.settings.value(), (Aquifer.FluidPicker) this.globalFluidPicker.get(), Blender.empty());
+            NoiseChunk noisechunk = new NoiseChunk(1, random, l2, i3, noisesettings, DensityFunctions.b.INSTANCE, (NoiseGeneratorSettings) this.settings.value(), (Aquifer.FluidPicker) this.globalFluidPicker.get(), Blender.empty());
 
             noisechunk.initializeForFirstCellX();
             noisechunk.advanceCellX(0);
@@ -185,18 +181,18 @@
                     double d2 = (double) k3 / (double) k;
 
                     noisechunk.updateForY(l3, d2);
-                    noisechunk.updateForX(i, d0);
-                    noisechunk.updateForZ(j, d1);
-                    BlockState blockstate = noisechunk.getInterpolatedState();
-                    BlockState blockstate1 = blockstate == null ? ((NoiseGeneratorSettings) this.settings.value()).defaultBlock() : blockstate;
+                    noisechunk.updateForX(x, d0);
+                    noisechunk.updateForZ(z, d1);
+                    IBlockData iblockdata = noisechunk.getInterpolatedState();
+                    IBlockData iblockdata1 = iblockdata == null ? ((NoiseGeneratorSettings) this.settings.value()).defaultBlock() : iblockdata;
 
-                    if (ablockstate != null) {
+                    if (aiblockdata != null) {
                         int i4 = j3 * k + k3;
 
-                        ablockstate[i4] = blockstate1;
+                        aiblockdata[i4] = iblockdata1;
                     }
 
-                    if (predicate != null && predicate.test(blockstate1)) {
+                    if (stoppingState != null && stoppingState.test(iblockdata1)) {
                         noisechunk.stopInterpolation();
                         return OptionalInt.of(l3 + 1);
                     }
@@ -209,59 +205,57 @@
     }
 
     @Override
-    @Override
-    public void buildSurface(WorldGenRegion worldgenregion, StructureManager structuremanager, RandomState randomstate, ChunkAccess chunkaccess) {
-        if (!SharedConstants.debugVoidTerrain(chunkaccess.getPos())) {
-            WorldGenerationContext worldgenerationcontext = new WorldGenerationContext(this, worldgenregion);
+    public void buildSurface(WorldGenRegion level, StructureManager structureManager, RandomState random, ChunkAccess chunk) {
+        if (!SharedConstants.debugVoidTerrain(chunk.getPos())) {
+            WorldGenerationContext worldgenerationcontext = new WorldGenerationContext(this, level);
 
-            this.buildSurface(chunkaccess, worldgenerationcontext, randomstate, structuremanager, worldgenregion.getBiomeManager(), worldgenregion.registryAccess().registryOrThrow(Registries.BIOME), Blender.of(worldgenregion));
+            this.buildSurface(chunk, worldgenerationcontext, random, structureManager, level.getBiomeManager(), level.registryAccess().registryOrThrow(Registries.BIOME), Blender.of(level));
         }
     }
 
     @VisibleForTesting
-    public void buildSurface(ChunkAccess chunkaccess, WorldGenerationContext worldgenerationcontext, RandomState randomstate, StructureManager structuremanager, BiomeManager biomemanager, Registry<Biome> registry, Blender blender) {
-        NoiseChunk noisechunk = chunkaccess.getOrCreateNoiseChunk((chunkaccess1) -> {
-            return this.createNoiseChunk(chunkaccess1, structuremanager, blender, randomstate);
+    public void buildSurface(ChunkAccess chunk, WorldGenerationContext context, RandomState random, StructureManager structureManager, BiomeManager biomeManager, Registry<Biome> biomes, Blender blender) {
+        NoiseChunk noisechunk = chunk.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, structureManager, blender, random);
         });
-        NoiseGeneratorSettings noisegeneratorsettings = (NoiseGeneratorSettings) this.settings.value();
+        NoiseGeneratorSettings generatorsettingbase = (NoiseGeneratorSettings) this.settings.value();
 
-        randomstate.surfaceSystem().buildSurface(randomstate, biomemanager, registry, noisegeneratorsettings.useLegacyRandomSource(), worldgenerationcontext, chunkaccess, noisechunk, noisegeneratorsettings.surfaceRule());
+        random.surfaceSystem().buildSurface(random, biomeManager, biomes, generatorsettingbase.useLegacyRandomSource(), context, chunk, noisechunk, generatorsettingbase.surfaceRule());
     }
 
     @Override
-    @Override
-    public void applyCarvers(WorldGenRegion worldgenregion, long i, RandomState randomstate, BiomeManager biomemanager, StructureManager structuremanager, ChunkAccess chunkaccess, GenerationStep.Carving generationstep_carving) {
-        BiomeManager biomemanager1 = biomemanager.withDifferentSource((j, k, l) -> {
+    public void applyCarvers(WorldGenRegion level, long seed, RandomState randomstate, BiomeManager random, StructureManager biomeManager, ChunkAccess structureManager, GenerationStep.Carving chunk) {
+        BiomeManager biomemanager1 = random.withDifferentSource((j, k, l) -> {
             return this.biomeSource.getNoiseBiome(j, k, l, randomstate.sampler());
         });
-        WorldgenRandom worldgenrandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
+        WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
         boolean flag = true;
-        ChunkPos chunkpos = chunkaccess.getPos();
-        NoiseChunk noisechunk = chunkaccess.getOrCreateNoiseChunk((chunkaccess1) -> {
-            return this.createNoiseChunk(chunkaccess1, structuremanager, Blender.of(worldgenregion), randomstate);
+        ChunkPos chunkcoordintpair = structureManager.getPos();
+        NoiseChunk noisechunk = structureManager.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, biomeManager, Blender.of(level), randomstate);
         });
         Aquifer aquifer = noisechunk.aquifer();
-        CarvingContext carvingcontext = new CarvingContext(this, worldgenregion.registryAccess(), chunkaccess.getHeightAccessorForGeneration(), noisechunk, randomstate, ((NoiseGeneratorSettings) this.settings.value()).surfaceRule());
-        CarvingMask carvingmask = ((ProtoChunk) chunkaccess).getOrCreateCarvingMask(generationstep_carving);
+        CarvingContext carvingcontext = new CarvingContext(this, level.registryAccess(), structureManager.getHeightAccessorForGeneration(), noisechunk, randomstate, ((NoiseGeneratorSettings) this.settings.value()).surfaceRule());
+        CarvingMask carvingmask = ((ProtoChunk) structureManager).getOrCreateCarvingMask(chunk);
 
         for (int j = -8; j <= 8; ++j) {
             for (int k = -8; k <= 8; ++k) {
-                ChunkPos chunkpos1 = new ChunkPos(chunkpos.x + j, chunkpos.z + k);
-                ChunkAccess chunkaccess1 = worldgenregion.getChunk(chunkpos1.x, chunkpos1.z);
-                BiomeGenerationSettings biomegenerationsettings = chunkaccess1.carverBiome(() -> {
-                    return this.getBiomeGenerationSettings(this.biomeSource.getNoiseBiome(QuartPos.fromBlock(chunkpos1.getMinBlockX()), 0, QuartPos.fromBlock(chunkpos1.getMinBlockZ()), randomstate.sampler()));
+                ChunkPos chunkcoordintpair1 = new ChunkPos(chunkcoordintpair.x + j, chunkcoordintpair.z + k);
+                ChunkAccess ichunkaccess1 = level.getChunk(chunkcoordintpair1.x, chunkcoordintpair1.z);
+                BiomeGenerationSettings biomesettingsgeneration = ichunkaccess1.carverBiome(() -> {
+                    return this.getBiomeGenerationSettings(this.biomeSource.getNoiseBiome(QuartPos.fromBlock(chunkcoordintpair1.getMinBlockX()), 0, QuartPos.fromBlock(chunkcoordintpair1.getMinBlockZ()), randomstate.sampler()));
                 });
-                Iterable<Holder<ConfiguredWorldCarver<?>>> iterable = biomegenerationsettings.getCarvers(generationstep_carving);
+                Iterable<Holder<ConfiguredWorldCarver<?>>> iterable = biomesettingsgeneration.getCarvers(chunk);
                 int l = 0;
 
                 for (Iterator iterator = iterable.iterator(); iterator.hasNext(); ++l) {
                     Holder<ConfiguredWorldCarver<?>> holder = (Holder) iterator.next();
-                    ConfiguredWorldCarver<?> configuredworldcarver = (ConfiguredWorldCarver) holder.value();
+                    ConfiguredWorldCarver<?> worldgencarverwrapper = (ConfiguredWorldCarver) holder.value();
 
-                    worldgenrandom.setLargeFeatureSeed(i + (long) l, chunkpos1.x, chunkpos1.z);
-                    if (configuredworldcarver.isStartChunk(worldgenrandom)) {
+                    seededrandom.setLargeFeatureSeed(seed + (long) l, chunkcoordintpair1.x, chunkcoordintpair1.z);
+                    if (worldgencarverwrapper.isStartChunk(seededrandom)) {
                         Objects.requireNonNull(biomemanager1);
-                        configuredworldcarver.carve(carvingcontext, chunkaccess, biomemanager1::getBiome, worldgenrandom, aquifer, chunkpos1, carvingmask);
+                        worldgencarverwrapper.carve(carvingcontext, structureManager, biomemanager1::getBiome, seededrandom, aquifer, chunkcoordintpair1, carvingmask);
                     }
                 }
             }
@@ -270,55 +264,54 @@
     }
 
     @Override
-    @Override
-    public CompletableFuture<ChunkAccess> fillFromNoise(Executor executor, Blender blender, RandomState randomstate, StructureManager structuremanager, ChunkAccess chunkaccess) {
-        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().clampToHeightAccessor(chunkaccess.getHeightAccessorForGeneration());
+    public CompletableFuture<ChunkAccess> fillFromNoise(Executor executor, Blender blender, RandomState random, StructureManager structureManager, ChunkAccess chunk) {
+        NoiseSettings noisesettings = ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().clampToHeightAccessor(chunk.getHeightAccessorForGeneration());
         int i = noisesettings.minY();
         int j = Mth.floorDiv(i, noisesettings.getCellHeight());
         int k = Mth.floorDiv(noisesettings.height(), noisesettings.getCellHeight());
 
         if (k <= 0) {
-            return CompletableFuture.completedFuture(chunkaccess);
+            return CompletableFuture.completedFuture(chunk);
         } else {
-            int l = chunkaccess.getSectionIndex(k * noisesettings.getCellHeight() - 1 + i);
-            int i1 = chunkaccess.getSectionIndex(i);
+            int l = chunk.getSectionIndex(k * noisesettings.getCellHeight() - 1 + i);
+            int i1 = chunk.getSectionIndex(i);
             Set<LevelChunkSection> set = Sets.newHashSet();
 
             for (int j1 = l; j1 >= i1; --j1) {
-                LevelChunkSection levelchunksection = chunkaccess.getSection(j1);
+                LevelChunkSection chunksection = chunk.getSection(j1);
 
-                levelchunksection.acquire();
-                set.add(levelchunksection);
+                chunksection.acquire();
+                set.add(chunksection);
             }
 
             return CompletableFuture.supplyAsync(Util.wrapThreadWithTaskName("wgen_fill_noise", () -> {
-                return this.doFill(blender, structuremanager, randomstate, chunkaccess, j, k);
-            }), Util.backgroundExecutor()).whenCompleteAsync((chunkaccess1, throwable) -> {
+                return this.doFill(blender, structureManager, random, chunk, j, k);
+            }), Util.backgroundExecutor()).whenCompleteAsync((ichunkaccess1, throwable) -> {
                 Iterator iterator = set.iterator();
 
                 while (iterator.hasNext()) {
-                    LevelChunkSection levelchunksection1 = (LevelChunkSection) iterator.next();
+                    LevelChunkSection chunksection1 = (LevelChunkSection) iterator.next();
 
-                    levelchunksection1.release();
+                    chunksection1.release();
                 }
 
             }, executor);
         }
     }
 
-    private ChunkAccess doFill(Blender blender, StructureManager structuremanager, RandomState randomstate, ChunkAccess chunkaccess, int i, int j) {
-        NoiseChunk noisechunk = chunkaccess.getOrCreateNoiseChunk((chunkaccess1) -> {
-            return this.createNoiseChunk(chunkaccess1, structuremanager, blender, randomstate);
+    private ChunkAccess doFill(Blender blender, StructureManager structureManager, RandomState random, ChunkAccess chunk, int minCellY, int cellCountY) {
+        NoiseChunk noisechunk = chunk.getOrCreateNoiseChunk((ichunkaccess1) -> {
+            return this.createNoiseChunk(ichunkaccess1, structureManager, blender, random);
         });
-        Heightmap heightmap = chunkaccess.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
-        Heightmap heightmap1 = chunkaccess.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
-        ChunkPos chunkpos = chunkaccess.getPos();
-        int k = chunkpos.getMinBlockX();
-        int l = chunkpos.getMinBlockZ();
+        Heightmap heightmap = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
+        Heightmap heightmap1 = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
+        ChunkPos chunkcoordintpair = chunk.getPos();
+        int k = chunkcoordintpair.getMinBlockX();
+        int l = chunkcoordintpair.getMinBlockZ();
         Aquifer aquifer = noisechunk.aquifer();
 
         noisechunk.initializeForFirstCellX();
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
         int i1 = noisechunk.cellWidth();
         int j1 = noisechunk.cellHeight();
         int k1 = 16 / i1;
@@ -328,20 +321,20 @@
             noisechunk.advanceCellX(i2);
 
             for (int j2 = 0; j2 < l1; ++j2) {
-                int k2 = chunkaccess.getSectionsCount() - 1;
-                LevelChunkSection levelchunksection = chunkaccess.getSection(k2);
+                int k2 = chunk.getSectionsCount() - 1;
+                LevelChunkSection chunksection = chunk.getSection(k2);
 
-                for (int l2 = j - 1; l2 >= 0; --l2) {
+                for (int l2 = cellCountY - 1; l2 >= 0; --l2) {
                     noisechunk.selectCellYZ(l2, j2);
 
                     for (int i3 = j1 - 1; i3 >= 0; --i3) {
-                        int j3 = (i + l2) * j1 + i3;
+                        int j3 = (minCellY + l2) * j1 + i3;
                         int k3 = j3 & 15;
-                        int l3 = chunkaccess.getSectionIndex(j3);
+                        int l3 = chunk.getSectionIndex(j3);
 
                         if (k2 != l3) {
                             k2 = l3;
-                            levelchunksection = chunkaccess.getSection(l3);
+                            chunksection = chunk.getSection(l3);
                         }
 
                         double d0 = (double) i3 / (double) j1;
@@ -361,20 +354,20 @@
                                 double d2 = (double) l4 / (double) i1;
 
                                 noisechunk.updateForZ(i5, d2);
-                                BlockState blockstate = noisechunk.getInterpolatedState();
+                                IBlockData iblockdata = noisechunk.getInterpolatedState();
 
-                                if (blockstate == null) {
-                                    blockstate = ((NoiseGeneratorSettings) this.settings.value()).defaultBlock();
+                                if (iblockdata == null) {
+                                    iblockdata = ((NoiseGeneratorSettings) this.settings.value()).defaultBlock();
                                 }
 
-                                blockstate = this.debugPreliminarySurfaceLevel(noisechunk, j4, j3, i5, blockstate);
-                                if (blockstate != NoiseBasedChunkGenerator.AIR && !SharedConstants.debugVoidTerrain(chunkaccess.getPos())) {
-                                    levelchunksection.setBlockState(k4, k3, j5, blockstate, false);
-                                    heightmap.update(k4, j3, j5, blockstate);
-                                    heightmap1.update(k4, j3, j5, blockstate);
-                                    if (aquifer.shouldScheduleFluidUpdate() && !blockstate.getFluidState().isEmpty()) {
-                                        blockpos_mutableblockpos.set(j4, j3, i5);
-                                        chunkaccess.markPosForPostprocessing(blockpos_mutableblockpos);
+                                iblockdata = this.debugPreliminarySurfaceLevel(noisechunk, j4, j3, i5, iblockdata);
+                                if (iblockdata != NoiseBasedChunkGenerator.AIR && !SharedConstants.debugVoidTerrain(chunk.getPos())) {
+                                    chunksection.setBlockState(k4, k3, j5, iblockdata, false);
+                                    heightmap.update(k4, j3, j5, iblockdata);
+                                    heightmap1.update(k4, j3, j5, iblockdata);
+                                    if (aquifer.shouldScheduleFluidUpdate() && !iblockdata.getFluidState().isEmpty()) {
+                                        blockposition_mutableblockposition.set(j4, j3, i5);
+                                        chunk.markPosForPostprocessing(blockposition_mutableblockposition);
                                     }
                                 }
                             }
@@ -387,41 +380,37 @@
         }
 
         noisechunk.stopInterpolation();
-        return chunkaccess;
+        return chunk;
     }
 
-    private BlockState debugPreliminarySurfaceLevel(NoiseChunk noisechunk, int i, int j, int k, BlockState blockstate) {
-        return blockstate;
+    private IBlockData debugPreliminarySurfaceLevel(NoiseChunk chunk, int x, int y, int z, IBlockData state) {
+        return state;
     }
 
     @Override
-    @Override
     public int getGenDepth() {
         return ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().height();
     }
 
     @Override
-    @Override
     public int getSeaLevel() {
         return ((NoiseGeneratorSettings) this.settings.value()).seaLevel();
     }
 
     @Override
-    @Override
     public int getMinY() {
         return ((NoiseGeneratorSettings) this.settings.value()).noiseSettings().minY();
     }
 
     @Override
-    @Override
-    public void spawnOriginalMobs(WorldGenRegion worldgenregion) {
+    public void spawnOriginalMobs(WorldGenRegion level) {
         if (!((NoiseGeneratorSettings) this.settings.value()).disableMobGeneration()) {
-            ChunkPos chunkpos = worldgenregion.getCenter();
-            Holder<Biome> holder = worldgenregion.getBiome(chunkpos.getWorldPosition().atY(worldgenregion.getMaxBuildHeight() - 1));
-            WorldgenRandom worldgenrandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
+            ChunkPos chunkcoordintpair = level.getCenter();
+            Holder<Biome> holder = level.getBiome(chunkcoordintpair.getWorldPosition().atY(level.getMaxBuildHeight() - 1));
+            WorldgenRandom seededrandom = new WorldgenRandom(new LegacyRandomSource(RandomSupport.generateUniqueSeed()));
 
-            worldgenrandom.setDecorationSeed(worldgenregion.getSeed(), chunkpos.getMinBlockX(), chunkpos.getMinBlockZ());
-            NaturalSpawner.spawnMobsForChunkGeneration(worldgenregion, holder, chunkpos, worldgenrandom);
+            seededrandom.setDecorationSeed(level.getSeed(), chunkcoordintpair.getMinBlockX(), chunkcoordintpair.getMinBlockZ());
+            NaturalSpawner.spawnMobsForChunkGeneration(level, holder, chunkcoordintpair, seededrandom);
         }
     }
 }
