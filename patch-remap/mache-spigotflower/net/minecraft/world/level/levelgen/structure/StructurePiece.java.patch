--- a/net/minecraft/world/level/levelgen/structure/StructurePiece.java
+++ b/net/minecraft/world/level/levelgen/structure/StructurePiece.java
@@ -29,9 +29,7 @@
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.entity.ChestBlockEntity;
-import net.minecraft.world.level.block.entity.DispenserBlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
@@ -42,7 +40,7 @@
 public abstract class StructurePiece {
 
     private static final Logger LOGGER = LogUtils.getLogger();
-    protected static final BlockState CAVE_AIR = Blocks.CAVE_AIR.defaultBlockState();
+    protected static final IBlockData CAVE_AIR = Blocks.CAVE_AIR.defaultBlockState();
     protected BoundingBox boundingBox;
     @Nullable
     private Direction orientation;
@@ -50,58 +48,53 @@
     private Rotation rotation;
     protected int genDepth;
     private final StructurePieceType type;
-    private static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build();
+    public static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build();  // CraftBukkit - decompile error / PAIL private -> public
 
-    protected StructurePiece(StructurePieceType structurepiecetype, int i, BoundingBox boundingbox) {
-        this.type = structurepiecetype;
-        this.genDepth = i;
-        this.boundingBox = boundingbox;
+    protected StructurePiece(StructurePieceType type, int genDepth, BoundingBox boundingBox) {
+        this.type = type;
+        this.genDepth = genDepth;
+        this.boundingBox = boundingBox;
     }
 
-    public StructurePiece(StructurePieceType structurepiecetype, CompoundTag compoundtag) {
-        int i = compoundtag.getInt("GD");
-        DataResult dataresult = BoundingBox.CODEC.parse(NbtOps.INSTANCE, compoundtag.get("BB"));
-        Logger logger = StructurePiece.LOGGER;
-
-        Objects.requireNonNull(logger);
-        this(structurepiecetype, i, (BoundingBox) dataresult.resultOrPartial(logger::error).orElseThrow(() -> {
+    public StructurePiece(StructurePieceType type, CompoundTag tag) {
+        // CraftBukkit start - decompile error
+        this(type, tag.getInt("GD"), (BoundingBox) BoundingBox.CODEC.parse(NbtOps.INSTANCE, tag.get("BB")).resultOrPartial(Objects.requireNonNull(StructurePiece.LOGGER)::error).orElseThrow(() -> {
             return new IllegalArgumentException("Invalid boundingbox");
         }));
-        int j = compoundtag.getInt("O");
+        // CraftBukkit end
+        int j = tag.getInt("O");
 
         this.setOrientation(j == -1 ? null : Direction.from2DDataValue(j));
     }
 
-    protected static BoundingBox makeBoundingBox(int i, int j, int k, Direction direction, int l, int i1, int j1) {
-        return direction.getAxis() == Direction.Axis.Z ? new BoundingBox(i, j, k, i + l - 1, j + i1 - 1, k + j1 - 1) : new BoundingBox(i, j, k, i + j1 - 1, j + i1 - 1, k + l - 1);
+    protected static BoundingBox makeBoundingBox(int x, int y, int z, Direction direction, int offsetX, int offsetY, int offsetZ) {
+        return direction.getAxis() == Direction.Axis.Z ? new BoundingBox(x, y, z, x + offsetX - 1, y + offsetY - 1, z + offsetZ - 1) : new BoundingBox(x, y, z, x + offsetZ - 1, y + offsetY - 1, z + offsetX - 1);
     }
 
-    protected static Direction getRandomHorizontalDirection(RandomSource randomsource) {
-        return Direction.Plane.HORIZONTAL.getRandomDirection(randomsource);
+    protected static Direction getRandomHorizontalDirection(RandomSource random) {
+        return Direction.Plane.HORIZONTAL.getRandomDirection(random);
     }
 
-    public final CompoundTag createTag(StructurePieceSerializationContext structurepieceserializationcontext) {
-        CompoundTag compoundtag = new CompoundTag();
+    public final CompoundTag createTag(StructurePieceSerializationContext context) {
+        CompoundTag nbttagcompound = new CompoundTag();
 
-        compoundtag.putString("id", BuiltInRegistries.STRUCTURE_PIECE.getKey(this.getType()).toString());
-        DataResult dataresult = BoundingBox.CODEC.encodeStart(NbtOps.INSTANCE, this.boundingBox);
-        Logger logger = StructurePiece.LOGGER;
-
-        Objects.requireNonNull(logger);
-        dataresult.resultOrPartial(logger::error).ifPresent((tag) -> {
-            compoundtag.put("BB", tag);
+        nbttagcompound.putString("id", BuiltInRegistries.STRUCTURE_PIECE.getKey(this.getType()).toString());
+        // CraftBukkit start - decompile error
+        BoundingBox.CODEC.encodeStart(NbtOps.INSTANCE, this.boundingBox).resultOrPartial(Objects.requireNonNull(StructurePiece.LOGGER)::error).ifPresent((nbtbase) -> {
+             nbttagcompound.put("BB", nbtbase);
         });
-        Direction direction = this.getOrientation();
+        // CraftBukkit end
+        Direction enumdirection = this.getOrientation();
 
-        compoundtag.putInt("O", direction == null ? -1 : direction.get2DDataValue());
-        compoundtag.putInt("GD", this.genDepth);
-        this.addAdditionalSaveData(structurepieceserializationcontext, compoundtag);
-        return compoundtag;
+        nbttagcompound.putInt("O", enumdirection == null ? -1 : enumdirection.get2DDataValue());
+        nbttagcompound.putInt("GD", this.genDepth);
+        this.addAdditionalSaveData(context, nbttagcompound);
+        return nbttagcompound;
     }
 
     protected abstract void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag tag);
 
-    public void addChildren(StructurePiece structurepiece, StructurePieceAccessor structurepieceaccessor, RandomSource randomsource) {}
+    public void addChildren(StructurePiece piece, StructurePieceAccessor pieces, RandomSource random) {}
 
     public abstract void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos);
 
@@ -113,74 +106,74 @@
         return this.genDepth;
     }
 
-    public void setGenDepth(int i) {
-        this.genDepth = i;
+    public void setGenDepth(int genDepth) {
+        this.genDepth = genDepth;
     }
 
-    public boolean isCloseToChunk(ChunkPos chunkpos, int i) {
-        int j = chunkpos.getMinBlockX();
-        int k = chunkpos.getMinBlockZ();
+    public boolean isCloseToChunk(ChunkPos chunkPos, int distance) {
+        int j = chunkPos.getMinBlockX();
+        int k = chunkPos.getMinBlockZ();
 
-        return this.boundingBox.intersects(j - i, k - i, j + 15 + i, k + 15 + i);
+        return this.boundingBox.intersects(j - distance, k - distance, j + 15 + distance, k + 15 + distance);
     }
 
     public BlockPos getLocatorPosition() {
         return new BlockPos(this.boundingBox.getCenter());
     }
 
-    protected BlockPos.MutableBlockPos getWorldPos(int i, int j, int k) {
-        return new BlockPos.MutableBlockPos(this.getWorldX(i, k), this.getWorldY(j), this.getWorldZ(i, k));
+    protected BlockPos.MutableBlockPos getWorldPos(int x, int y, int z) {
+        return new BlockPos.MutableBlockPos(this.getWorldX(x, z), this.getWorldY(y), this.getWorldZ(x, z));
     }
 
-    protected int getWorldX(int i, int j) {
-        Direction direction = this.getOrientation();
+    protected int getWorldX(int x, int z) {
+        Direction enumdirection = this.getOrientation();
 
-        if (direction == null) {
-            return i;
+        if (enumdirection == null) {
+            return x;
         } else {
-            switch (direction) {
+            switch (enumdirection) {
                 case NORTH:
                 case SOUTH:
-                    return this.boundingBox.minX() + i;
+                    return this.boundingBox.minX() + x;
                 case WEST:
-                    return this.boundingBox.maxX() - j;
+                    return this.boundingBox.maxX() - z;
                 case EAST:
-                    return this.boundingBox.minX() + j;
+                    return this.boundingBox.minX() + z;
                 default:
-                    return i;
+                    return x;
             }
         }
     }
 
-    protected int getWorldY(int i) {
-        return this.getOrientation() == null ? i : i + this.boundingBox.minY();
+    protected int getWorldY(int y) {
+        return this.getOrientation() == null ? y : y + this.boundingBox.minY();
     }
 
-    protected int getWorldZ(int i, int j) {
-        Direction direction = this.getOrientation();
+    protected int getWorldZ(int x, int z) {
+        Direction enumdirection = this.getOrientation();
 
-        if (direction == null) {
-            return j;
+        if (enumdirection == null) {
+            return z;
         } else {
-            switch (direction) {
+            switch (enumdirection) {
                 case NORTH:
-                    return this.boundingBox.maxZ() - j;
+                    return this.boundingBox.maxZ() - z;
                 case SOUTH:
-                    return this.boundingBox.minZ() + j;
+                    return this.boundingBox.minZ() + z;
                 case WEST:
                 case EAST:
-                    return this.boundingBox.minZ() + i;
+                    return this.boundingBox.minZ() + x;
                 default:
-                    return j;
+                    return z;
             }
         }
     }
 
-    protected void placeBlock(WorldGenLevel worldgenlevel, BlockState blockstate, int i, int j, int k, BoundingBox boundingbox) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = this.getWorldPos(i, j, k);
+    protected void placeBlock(WorldGenLevel level, IBlockData blockstate, int x, int y, int z, BoundingBox boundingbox) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
 
-        if (boundingbox.isInside(blockpos_mutableblockpos)) {
-            if (this.canBeReplaced(worldgenlevel, i, j, k, boundingbox)) {
+        if (boundingbox.isInside(blockposition_mutableblockposition)) {
+            if (this.canBeReplaced(level, x, y, z, boundingbox)) {
                 if (this.mirror != Mirror.NONE) {
                     blockstate = blockstate.mirror(this.mirror);
                 }
@@ -189,57 +182,94 @@
                     blockstate = blockstate.rotate(this.rotation);
                 }
 
-                worldgenlevel.setBlock(blockpos_mutableblockpos, blockstate, 2);
-                FluidState fluidstate = worldgenlevel.getFluidState(blockpos_mutableblockpos);
+                level.setBlock(blockposition_mutableblockposition, blockstate, 2);
+                // CraftBukkit start - fluid handling is already done if we have a transformer generator access
+                if (level instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess) {
+                    return;
+                }
+                // CraftBukkit end
+                FluidState fluid = level.getFluidState(blockposition_mutableblockposition);
 
-                if (!fluidstate.isEmpty()) {
-                    worldgenlevel.scheduleTick(blockpos_mutableblockpos, fluidstate.getType(), 0);
+                if (!fluid.isEmpty()) {
+                    level.scheduleTick(blockposition_mutableblockposition, fluid.getType(), 0);
                 }
 
                 if (StructurePiece.SHAPE_CHECK_BLOCKS.contains(blockstate.getBlock())) {
-                    worldgenlevel.getChunk(blockpos_mutableblockpos).markPosForPostprocessing(blockpos_mutableblockpos);
+                    level.getChunk(blockposition_mutableblockposition).markPosForPostprocessing(blockposition_mutableblockposition);
                 }
 
             }
         }
     }
 
-    protected boolean canBeReplaced(LevelReader levelreader, int i, int j, int k, BoundingBox boundingbox) {
+    // CraftBukkit start
+    protected boolean placeCraftBlockEntity(ServerLevelAccessor worldAccess, BlockPos position, org.bukkit.craftbukkit.block.CraftBlockEntityState<?> craftBlockEntityState, int i) {
+        if (worldAccess instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess transformerAccess) {
+            return transformerAccess.setCraftBlock(position, craftBlockEntityState, i);
+        }
+        boolean result = worldAccess.setBlock(position, craftBlockEntityState.getHandle(), i);
+        BlockEntity tileEntity = worldAccess.getBlockEntity(position);
+        if (tileEntity != null) {
+            tileEntity.load(craftBlockEntityState.getSnapshotNBT());
+        }
+        return result;
+    }
+
+    protected void placeCraftSpawner(ServerLevelAccessor worldAccess, BlockPos position, org.bukkit.entity.EntityType entityType, int i) {
+        // This method is used in structures that are generated by code and place spawners as they set the entity after the block was placed making it impossible for plugins to access that information
+        org.bukkit.craftbukkit.block.CraftCreatureSpawner spawner = (org.bukkit.craftbukkit.block.CraftCreatureSpawner) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(position, Blocks.SPAWNER.defaultBlockState(), null);
+        spawner.setSpawnedType(entityType);
+        placeCraftBlockEntity(worldAccess, position, spawner, i);
+    }
+
+    protected void setCraftLootTable(ServerLevelAccessor worldAccess, BlockPos position, RandomSource randomSource, net.minecraft.resources.ResourceLocation loottableKey) {
+        // This method is used in structures that use data markers to a loot table to loot containers as otherwise plugins won't have access to that information.
+        net.minecraft.world.level.block.entity.BlockEntity tileEntity = worldAccess.getBlockEntity(position);
+        if (tileEntity instanceof net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity tileEntityLootable) {
+            tileEntityLootable.setLootTable(loottableKey, randomSource.nextLong());
+            if (worldAccess instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess transformerAccess) {
+                transformerAccess.setCraftBlock(position, (org.bukkit.craftbukkit.block.CraftBlockState) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(position, tileEntity.getBlockState(), tileEntityLootable.saveWithFullMetadata()), 3);
+            }
+        }
+    }
+    // CraftBukkit end
+
+    protected boolean canBeReplaced(LevelReader level, int x, int y, int z, BoundingBox box) {
         return true;
     }
 
-    protected BlockState getBlock(BlockGetter blockgetter, int i, int j, int k, BoundingBox boundingbox) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = this.getWorldPos(i, j, k);
+    protected IBlockData getBlock(BlockGetter level, int x, int y, int z, BoundingBox box) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
 
-        return !boundingbox.isInside(blockpos_mutableblockpos) ? Blocks.AIR.defaultBlockState() : blockgetter.getBlockState(blockpos_mutableblockpos);
+        return !box.isInside(blockposition_mutableblockposition) ? Blocks.AIR.defaultBlockState() : level.getBlockState(blockposition_mutableblockposition);
     }
 
-    protected boolean isInterior(LevelReader levelreader, int i, int j, int k, BoundingBox boundingbox) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = this.getWorldPos(i, j + 1, k);
+    protected boolean isInterior(LevelReader level, int x, int y, int z, BoundingBox box) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y + 1, z);
 
-        return !boundingbox.isInside(blockpos_mutableblockpos) ? false : blockpos_mutableblockpos.getY() < levelreader.getHeight(Heightmap.Types.OCEAN_FLOOR_WG, blockpos_mutableblockpos.getX(), blockpos_mutableblockpos.getZ());
+        return !box.isInside(blockposition_mutableblockposition) ? false : blockposition_mutableblockposition.getY() < level.getHeight(Heightmap.Types.OCEAN_FLOOR_WG, blockposition_mutableblockposition.getX(), blockposition_mutableblockposition.getZ());
     }
 
-    protected void generateAirBox(WorldGenLevel worldgenlevel, BoundingBox boundingbox, int i, int j, int k, int l, int i1, int j1) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    this.placeBlock(worldgenlevel, Blocks.AIR.defaultBlockState(), l1, k1, i2, boundingbox);
+    protected void generateAirBox(WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
+        for (int k1 = minY; k1 <= maxY; ++k1) {
+            for (int l1 = minX; l1 <= maxX; ++l1) {
+                for (int i2 = minZ; i2 <= maxZ; ++i2) {
+                    this.placeBlock(level, Blocks.AIR.defaultBlockState(), l1, k1, i2, box);
                 }
             }
         }
 
     }
 
-    protected void generateBox(WorldGenLevel worldgenlevel, BoundingBox boundingbox, int i, int j, int k, int l, int i1, int j1, BlockState blockstate, BlockState blockstate1, boolean flag) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    if (!flag || !this.getBlock(worldgenlevel, l1, k1, i2, boundingbox).isAir()) {
-                        if (k1 != j && k1 != i1 && l1 != i && l1 != l && i2 != k && i2 != j1) {
-                            this.placeBlock(worldgenlevel, blockstate1, l1, k1, i2, boundingbox);
+    protected void generateBox(WorldGenLevel level, BoundingBox box, int xMin, int yMin, int zMin, int xMax, int yMax, int zMax, IBlockData boundaryBlockState, IBlockData insideBlockState, boolean existingOnly) {
+        for (int k1 = yMin; k1 <= yMax; ++k1) {
+            for (int l1 = xMin; l1 <= xMax; ++l1) {
+                for (int i2 = zMin; i2 <= zMax; ++i2) {
+                    if (!existingOnly || !this.getBlock(level, l1, k1, i2, box).isAir()) {
+                        if (k1 != yMin && k1 != yMax && l1 != xMin && l1 != xMax && i2 != zMin && i2 != zMax) {
+                            this.placeBlock(level, insideBlockState, l1, k1, i2, box);
                         } else {
-                            this.placeBlock(worldgenlevel, blockstate, l1, k1, i2, boundingbox);
+                            this.placeBlock(level, boundaryBlockState, l1, k1, i2, box);
                         }
                     }
                 }
@@ -248,17 +278,17 @@
 
     }
 
-    protected void generateBox(WorldGenLevel worldgenlevel, BoundingBox boundingbox, BoundingBox boundingbox1, BlockState blockstate, BlockState blockstate1, boolean flag) {
-        this.generateBox(worldgenlevel, boundingbox, boundingbox1.minX(), boundingbox1.minY(), boundingbox1.minZ(), boundingbox1.maxX(), boundingbox1.maxY(), boundingbox1.maxZ(), blockstate, blockstate1, flag);
+    protected void generateBox(WorldGenLevel level, BoundingBox boundingBox, BoundingBox box, IBlockData boundaryBlockState, IBlockData insideBlockState, boolean existingOnly) {
+        this.generateBox(level, boundingBox, box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ(), boundaryBlockState, insideBlockState, existingOnly);
     }
 
-    protected void generateBox(WorldGenLevel worldgenlevel, BoundingBox boundingbox, int i, int j, int k, int l, int i1, int j1, boolean flag, RandomSource randomsource, StructurePiece.BlockSelector structurepiece_blockselector) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    if (!flag || !this.getBlock(worldgenlevel, l1, k1, i2, boundingbox).isAir()) {
-                        structurepiece_blockselector.next(randomsource, l1, k1, i2, k1 == j || k1 == i1 || l1 == i || l1 == l || i2 == k || i2 == j1);
-                        this.placeBlock(worldgenlevel, structurepiece_blockselector.getNext(), l1, k1, i2, boundingbox);
+    protected void generateBox(WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean alwaysReplace, RandomSource random, StructurePiece.BlockSelector blockSelector) {
+        for (int k1 = minY; k1 <= maxY; ++k1) {
+            for (int l1 = minX; l1 <= maxX; ++l1) {
+                for (int i2 = minZ; i2 <= maxZ; ++i2) {
+                    if (!alwaysReplace || !this.getBlock(level, l1, k1, i2, box).isAir()) {
+                        blockSelector.next(random, l1, k1, i2, k1 == minY || k1 == maxY || l1 == minX || l1 == maxX || i2 == minZ || i2 == maxZ);
+                        this.placeBlock(level, blockSelector.getNext(), l1, k1, i2, box);
                     }
                 }
             }
@@ -266,19 +296,19 @@
 
     }
 
-    protected void generateBox(WorldGenLevel worldgenlevel, BoundingBox boundingbox, BoundingBox boundingbox1, boolean flag, RandomSource randomsource, StructurePiece.BlockSelector structurepiece_blockselector) {
-        this.generateBox(worldgenlevel, boundingbox, boundingbox1.minX(), boundingbox1.minY(), boundingbox1.minZ(), boundingbox1.maxX(), boundingbox1.maxY(), boundingbox1.maxZ(), flag, randomsource, structurepiece_blockselector);
+    protected void generateBox(WorldGenLevel level, BoundingBox boundingBox, BoundingBox box, boolean alwaysReplace, RandomSource random, StructurePiece.BlockSelector blockSelector) {
+        this.generateBox(level, boundingBox, box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ(), alwaysReplace, random, blockSelector);
     }
 
-    protected void generateMaybeBox(WorldGenLevel worldgenlevel, BoundingBox boundingbox, RandomSource randomsource, float f, int i, int j, int k, int l, int i1, int j1, BlockState blockstate, BlockState blockstate1, boolean flag, boolean flag1) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    if (randomsource.nextFloat() <= f && (!flag || !this.getBlock(worldgenlevel, l1, k1, i2, boundingbox).isAir()) && (!flag1 || this.isInterior(worldgenlevel, l1, k1, i2, boundingbox))) {
-                        if (k1 != j && k1 != i1 && l1 != i && l1 != l && i2 != k && i2 != j1) {
-                            this.placeBlock(worldgenlevel, blockstate1, l1, k1, i2, boundingbox);
+    protected void generateMaybeBox(WorldGenLevel level, BoundingBox box, RandomSource random, float chance, int x1, int y1, int z1, int x2, int y2, int z2, IBlockData edgeState, IBlockData state, boolean requireNonAir, boolean requireSkylight) {
+        for (int k1 = y1; k1 <= y2; ++k1) {
+            for (int l1 = x1; l1 <= x2; ++l1) {
+                for (int i2 = z1; i2 <= z2; ++i2) {
+                    if (random.nextFloat() <= chance && (!requireNonAir || !this.getBlock(level, l1, k1, i2, box).isAir()) && (!requireSkylight || this.isInterior(level, l1, k1, i2, box))) {
+                        if (k1 != y1 && k1 != y2 && l1 != x1 && l1 != x2 && i2 != z1 && i2 != z2) {
+                            this.placeBlock(level, state, l1, k1, i2, box);
                         } else {
-                            this.placeBlock(worldgenlevel, blockstate, l1, k1, i2, boundingbox);
+                            this.placeBlock(level, edgeState, l1, k1, i2, box);
                         }
                     }
                 }
@@ -287,34 +317,34 @@
 
     }
 
-    protected void maybeGenerateBlock(WorldGenLevel worldgenlevel, BoundingBox boundingbox, RandomSource randomsource, float f, int i, int j, int k, BlockState blockstate) {
-        if (randomsource.nextFloat() < f) {
-            this.placeBlock(worldgenlevel, blockstate, i, j, k, boundingbox);
+    protected void maybeGenerateBlock(WorldGenLevel level, BoundingBox box, RandomSource random, float chance, int x, int y, int z, IBlockData state) {
+        if (random.nextFloat() < chance) {
+            this.placeBlock(level, state, x, y, z, box);
         }
 
     }
 
-    protected void generateUpperHalfSphere(WorldGenLevel worldgenlevel, BoundingBox boundingbox, int i, int j, int k, int l, int i1, int j1, BlockState blockstate, boolean flag) {
-        float f = (float) (l - i + 1);
-        float f1 = (float) (i1 - j + 1);
-        float f2 = (float) (j1 - k + 1);
-        float f3 = (float) i + f / 2.0F;
-        float f4 = (float) k + f2 / 2.0F;
+    protected void generateUpperHalfSphere(WorldGenLevel level, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, IBlockData state, boolean excludeAir) {
+        float f = (float) (maxX - minX + 1);
+        float f1 = (float) (maxY - minY + 1);
+        float f2 = (float) (maxZ - minZ + 1);
+        float f3 = (float) minX + f / 2.0F;
+        float f4 = (float) minZ + f2 / 2.0F;
 
-        for (int k1 = j; k1 <= i1; ++k1) {
-            float f5 = (float) (k1 - j) / f1;
+        for (int k1 = minY; k1 <= maxY; ++k1) {
+            float f5 = (float) (k1 - minY) / f1;
 
-            for (int l1 = i; l1 <= l; ++l1) {
+            for (int l1 = minX; l1 <= maxX; ++l1) {
                 float f6 = ((float) l1 - f3) / (f * 0.5F);
 
-                for (int i2 = k; i2 <= j1; ++i2) {
+                for (int i2 = minZ; i2 <= maxZ; ++i2) {
                     float f7 = ((float) i2 - f4) / (f2 * 0.5F);
 
-                    if (!flag || !this.getBlock(worldgenlevel, l1, k1, i2, boundingbox).isAir()) {
+                    if (!excludeAir || !this.getBlock(level, l1, k1, i2, box).isAir()) {
                         float f8 = f6 * f6 + f5 * f5 + f7 * f7;
 
                         if (f8 <= 1.05F) {
-                            this.placeBlock(worldgenlevel, blockstate, l1, k1, i2, boundingbox);
+                            this.placeBlock(level, state, l1, k1, i2, box);
                         }
                     }
                 }
@@ -323,86 +353,94 @@
 
     }
 
-    protected void fillColumnDown(WorldGenLevel worldgenlevel, BlockState blockstate, int i, int j, int k, BoundingBox boundingbox) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = this.getWorldPos(i, j, k);
+    protected void fillColumnDown(WorldGenLevel level, IBlockData state, int x, int y, int z, BoundingBox box) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
 
-        if (boundingbox.isInside(blockpos_mutableblockpos)) {
-            while (this.isReplaceableByStructures(worldgenlevel.getBlockState(blockpos_mutableblockpos)) && blockpos_mutableblockpos.getY() > worldgenlevel.getMinBuildHeight() + 1) {
-                worldgenlevel.setBlock(blockpos_mutableblockpos, blockstate, 2);
-                blockpos_mutableblockpos.move(Direction.DOWN);
+        if (box.isInside(blockposition_mutableblockposition)) {
+            while (this.isReplaceableByStructures(level.getBlockState(blockposition_mutableblockposition)) && blockposition_mutableblockposition.getY() > level.getMinBuildHeight() + 1) {
+                level.setBlock(blockposition_mutableblockposition, state, 2);
+                blockposition_mutableblockposition.move(Direction.DOWN);
             }
 
         }
     }
 
-    protected boolean isReplaceableByStructures(BlockState blockstate) {
-        return blockstate.isAir() || blockstate.liquid() || blockstate.is(Blocks.GLOW_LICHEN) || blockstate.is(Blocks.SEAGRASS) || blockstate.is(Blocks.TALL_SEAGRASS);
+    protected boolean isReplaceableByStructures(IBlockData state) {
+        return state.isAir() || state.liquid() || state.is(Blocks.GLOW_LICHEN) || state.is(Blocks.SEAGRASS) || state.is(Blocks.TALL_SEAGRASS);
     }
 
-    protected boolean createChest(WorldGenLevel worldgenlevel, BoundingBox boundingbox, RandomSource randomsource, int i, int j, int k, ResourceLocation resourcelocation) {
-        return this.createChest(worldgenlevel, boundingbox, randomsource, this.getWorldPos(i, j, k), resourcelocation, (BlockState) null);
+    protected boolean createChest(WorldGenLevel level, BoundingBox box, RandomSource random, int x, int y, int z, ResourceLocation lootTable) {
+        return this.createChest(level, box, random, this.getWorldPos(x, y, z), lootTable, (IBlockData) null);
     }
 
-    public static BlockState reorient(BlockGetter blockgetter, BlockPos blockpos, BlockState blockstate) {
-        Direction direction = null;
+    public static IBlockData reorient(BlockGetter level, BlockPos pos, IBlockData state) {
+        Direction enumdirection = null;
         Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
         while (iterator.hasNext()) {
-            Direction direction1 = (Direction) iterator.next();
-            BlockPos blockpos1 = blockpos.relative(direction1);
-            BlockState blockstate1 = blockgetter.getBlockState(blockpos1);
+            Direction enumdirection1 = (Direction) iterator.next();
+            BlockPos blockposition1 = pos.relative(enumdirection1);
+            IBlockData iblockdata1 = level.getBlockState(blockposition1);
 
-            if (blockstate1.is(Blocks.CHEST)) {
-                return blockstate;
+            if (iblockdata1.is(Blocks.CHEST)) {
+                return state;
             }
 
-            if (blockstate1.isSolidRender(blockgetter, blockpos1)) {
-                if (direction != null) {
-                    direction = null;
+            if (iblockdata1.isSolidRender(level, blockposition1)) {
+                if (enumdirection != null) {
+                    enumdirection = null;
                     break;
                 }
 
-                direction = direction1;
+                enumdirection = enumdirection1;
             }
         }
 
-        if (direction != null) {
-            return (BlockState) blockstate.setValue(HorizontalDirectionalBlock.FACING, direction.getOpposite());
+        if (enumdirection != null) {
+            return (IBlockData) state.setValue(HorizontalDirectionalBlock.FACING, enumdirection.getOpposite());
         } else {
-            Direction direction2 = (Direction) blockstate.getValue(HorizontalDirectionalBlock.FACING);
-            BlockPos blockpos2 = blockpos.relative(direction2);
+            Direction enumdirection2 = (Direction) state.getValue(HorizontalDirectionalBlock.FACING);
+            BlockPos blockposition2 = pos.relative(enumdirection2);
 
-            if (blockgetter.getBlockState(blockpos2).isSolidRender(blockgetter, blockpos2)) {
-                direction2 = direction2.getOpposite();
-                blockpos2 = blockpos.relative(direction2);
+            if (level.getBlockState(blockposition2).isSolidRender(level, blockposition2)) {
+                enumdirection2 = enumdirection2.getOpposite();
+                blockposition2 = pos.relative(enumdirection2);
             }
 
-            if (blockgetter.getBlockState(blockpos2).isSolidRender(blockgetter, blockpos2)) {
-                direction2 = direction2.getClockWise();
-                blockpos2 = blockpos.relative(direction2);
+            if (level.getBlockState(blockposition2).isSolidRender(level, blockposition2)) {
+                enumdirection2 = enumdirection2.getClockWise();
+                blockposition2 = pos.relative(enumdirection2);
             }
 
-            if (blockgetter.getBlockState(blockpos2).isSolidRender(blockgetter, blockpos2)) {
-                direction2 = direction2.getOpposite();
-                blockpos.relative(direction2);
+            if (level.getBlockState(blockposition2).isSolidRender(level, blockposition2)) {
+                enumdirection2 = enumdirection2.getOpposite();
+                pos.relative(enumdirection2);
             }
 
-            return (BlockState) blockstate.setValue(HorizontalDirectionalBlock.FACING, direction2);
+            return (IBlockData) state.setValue(HorizontalDirectionalBlock.FACING, enumdirection2);
         }
     }
 
-    protected boolean createChest(ServerLevelAccessor serverlevelaccessor, BoundingBox boundingbox, RandomSource randomsource, BlockPos blockpos, ResourceLocation resourcelocation, @Nullable BlockState blockstate) {
-        if (boundingbox.isInside(blockpos) && !serverlevelaccessor.getBlockState(blockpos).is(Blocks.CHEST)) {
-            if (blockstate == null) {
-                blockstate = reorient(serverlevelaccessor, blockpos, Blocks.CHEST.defaultBlockState());
+    protected boolean createChest(ServerLevelAccessor level, BoundingBox box, RandomSource random, BlockPos pos, ResourceLocation lootTable, @Nullable IBlockData state) {
+        if (box.isInside(pos) && !level.getBlockState(pos).is(Blocks.CHEST)) {
+            if (state == null) {
+                state = reorient(level, pos, Blocks.CHEST.defaultBlockState());
             }
 
-            serverlevelaccessor.setBlock(blockpos, blockstate, 2);
-            BlockEntity blockentity = serverlevelaccessor.getBlockEntity(blockpos);
+            // CraftBukkit start
+            /*
+            worldaccess.setBlock(blockposition, iblockdata, 2);
+            TileEntity tileentity = worldaccess.getBlockEntity(blockposition);
 
-            if (blockentity instanceof ChestBlockEntity) {
-                ((ChestBlockEntity) blockentity).setLootTable(resourcelocation, randomsource.nextLong());
+            if (tileentity instanceof TileEntityChest) {
+                ((TileEntityChest) tileentity).setLootTable(minecraftkey, randomsource.nextLong());
             }
+            */
+            org.bukkit.craftbukkit.block.CraftChest chestState = (org.bukkit.craftbukkit.block.CraftChest) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(pos, state, null);
+            chestState.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(lootTable)));
+            chestState.setSeed(random.nextLong());
+            placeCraftBlockEntity(level, pos, chestState, 2);
+            // CraftBukkit end
 
             return true;
         } else {
@@ -410,29 +448,48 @@
         }
     }
 
-    protected boolean createDispenser(WorldGenLevel worldgenlevel, BoundingBox boundingbox, RandomSource randomsource, int i, int j, int k, Direction direction, ResourceLocation resourcelocation) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = this.getWorldPos(i, j, k);
+    protected boolean createDispenser(WorldGenLevel level, BoundingBox box, RandomSource random, int x, int y, int z, Direction facing, ResourceLocation lootTable) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = this.getWorldPos(x, y, z);
 
-        if (boundingbox.isInside(blockpos_mutableblockpos) && !worldgenlevel.getBlockState(blockpos_mutableblockpos).is(Blocks.DISPENSER)) {
-            this.placeBlock(worldgenlevel, (BlockState) Blocks.DISPENSER.defaultBlockState().setValue(DispenserBlock.FACING, direction), i, j, k, boundingbox);
-            BlockEntity blockentity = worldgenlevel.getBlockEntity(blockpos_mutableblockpos);
+        if (box.isInside(blockposition_mutableblockposition) && !level.getBlockState(blockposition_mutableblockposition).is(Blocks.DISPENSER)) {
+            // CraftBukkit start
+            /*
+            this.placeBlock(generatoraccessseed, (IBlockData) Blocks.DISPENSER.defaultBlockState().setValue(BlockDispenser.FACING, enumdirection), i, j, k, structureboundingbox);
+            TileEntity tileentity = generatoraccessseed.getBlockEntity(blockposition_mutableblockposition);
 
-            if (blockentity instanceof DispenserBlockEntity) {
-                ((DispenserBlockEntity) blockentity).setLootTable(resourcelocation, randomsource.nextLong());
+            if (tileentity instanceof TileEntityDispenser) {
+                ((TileEntityDispenser) tileentity).setLootTable(minecraftkey, randomsource.nextLong());
             }
+            */
+            if (!this.canBeReplaced(level, x, y, z, box)) {
+                return true;
+            }
+            IBlockData iblockdata = Blocks.DISPENSER.defaultBlockState().setValue(DispenserBlock.FACING, facing);
+            if (this.mirror != Mirror.NONE) {
+                iblockdata = iblockdata.mirror(this.mirror);
+            }
+            if (this.rotation != Rotation.NONE) {
+                iblockdata = iblockdata.rotate(this.rotation);
+            }
 
+            org.bukkit.craftbukkit.block.CraftDispenser dispenserState = (org.bukkit.craftbukkit.block.CraftDispenser) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(blockposition_mutableblockposition, iblockdata, null);
+            dispenserState.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(lootTable)));
+            dispenserState.setSeed(random.nextLong());
+            placeCraftBlockEntity(level, blockposition_mutableblockposition, dispenserState, 2);
+            // CraftBukkit end
+
             return true;
         } else {
             return false;
         }
     }
 
-    public void move(int i, int j, int k) {
-        this.boundingBox.move(i, j, k);
+    public void move(int x, int y, int z) {
+        this.boundingBox.move(x, y, z);
     }
 
-    public static BoundingBox createBoundingBox(Stream<StructurePiece> stream) {
-        Stream stream1 = stream.map(StructurePiece::getBoundingBox);
+    public static BoundingBox createBoundingBox(Stream<StructurePiece> pieces) {
+        Stream<BoundingBox> stream1 = pieces.map(StructurePiece::getBoundingBox); // CraftBukkit - decompile error
 
         Objects.requireNonNull(stream1);
         return (BoundingBox) BoundingBox.encapsulatingBoxes(stream1::iterator).orElseThrow(() -> {
@@ -441,8 +498,8 @@
     }
 
     @Nullable
-    public static StructurePiece findCollisionPiece(List<StructurePiece> list, BoundingBox boundingbox) {
-        Iterator iterator = list.iterator();
+    public static StructurePiece findCollisionPiece(List<StructurePiece> pieces, BoundingBox boundingBox) {
+        Iterator iterator = pieces.iterator();
 
         StructurePiece structurepiece;
 
@@ -452,7 +509,7 @@
             }
 
             structurepiece = (StructurePiece) iterator.next();
-        } while (!structurepiece.getBoundingBox().intersects(boundingbox));
+        } while (!structurepiece.getBoundingBox().intersects(boundingBox));
 
         return structurepiece;
     }
@@ -462,13 +519,13 @@
         return this.orientation;
     }
 
-    public void setOrientation(@Nullable Direction direction) {
-        this.orientation = direction;
-        if (direction == null) {
+    public void setOrientation(@Nullable Direction orientation) {
+        this.orientation = orientation;
+        if (orientation == null) {
             this.rotation = Rotation.NONE;
             this.mirror = Mirror.NONE;
         } else {
-            switch (direction) {
+            switch (orientation) {
                 case SOUTH:
                     this.mirror = Mirror.LEFT_RIGHT;
                     this.rotation = Rotation.NONE;
@@ -503,7 +560,7 @@
 
     public abstract static class BlockSelector {
 
-        protected BlockState next;
+        protected IBlockData next;
 
         public BlockSelector() {
             this.next = Blocks.AIR.defaultBlockState();
@@ -511,7 +568,7 @@
 
         public abstract void next(RandomSource random, int x, int y, int z, boolean wall);
 
-        public BlockState getNext() {
+        public IBlockData getNext() {
             return this.next;
         }
     }
