--- a/net/minecraft/world/level/levelgen/structure/structures/OceanRuinPieces.java
+++ b/net/minecraft/world/level/levelgen/structure/structures/OceanRuinPieces.java
@@ -13,8 +13,8 @@
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.valueproviders.ConstantInt;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.SpawnGroupData;
+import net.minecraft.world.entity.EnumMobSpawn;
+import net.minecraft.world.entity.GroupDataEntity;
 import net.minecraft.world.entity.monster.Drowned;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.ChunkPos;
@@ -26,9 +26,7 @@
 import net.minecraft.world.level.block.ChestBlock;
 import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.entity.ChestBlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -36,12 +34,12 @@
 import net.minecraft.world.level.levelgen.structure.TemplateStructurePiece;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
-import net.minecraft.world.level.levelgen.structure.templatesystem.AlwaysTrueTest;
 import net.minecraft.world.level.levelgen.structure.templatesystem.BlockIgnoreProcessor;
 import net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest;
 import net.minecraft.world.level.levelgen.structure.templatesystem.BlockRotProcessor;
 import net.minecraft.world.level.levelgen.structure.templatesystem.CappedProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.PosAlwaysTrueTest;
+import net.minecraft.world.level.levelgen.structure.templatesystem.DefinedStructureTestTrue;
+import net.minecraft.world.level.levelgen.structure.templatesystem.PosRuleTestTrue;
 import net.minecraft.world.level.levelgen.structure.templatesystem.ProcessorRule;
 import net.minecraft.world.level.levelgen.structure.templatesystem.RuleProcessor;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings;
@@ -67,84 +65,84 @@
 
     public OceanRuinPieces() {}
 
-    private static StructureProcessor archyRuleProcessor(Block block, Block block1, ResourceLocation resourcelocation) {
-        return new CappedProcessor(new RuleProcessor(List.of(new ProcessorRule(new BlockMatchTest(block), AlwaysTrueTest.INSTANCE, PosAlwaysTrueTest.INSTANCE, block1.defaultBlockState(), new AppendLoot(resourcelocation)))), ConstantInt.of(5));
+    private static StructureProcessor archyRuleProcessor(Block input, Block output, ResourceLocation lootTable) {
+        return new CappedProcessor(new RuleProcessor(List.of(new ProcessorRule(new BlockMatchTest(input), DefinedStructureTestTrue.INSTANCE, PosRuleTestTrue.INSTANCE, output.defaultBlockState(), new AppendLoot(lootTable)))), ConstantInt.of(5));
     }
 
-    private static ResourceLocation getSmallWarmRuin(RandomSource randomsource) {
-        return (ResourceLocation) Util.getRandom((Object[]) OceanRuinPieces.WARM_RUINS, randomsource);
+    private static ResourceLocation getSmallWarmRuin(RandomSource random) {
+        return (ResourceLocation) Util.getRandom((Object[]) OceanRuinPieces.WARM_RUINS, random);
     }
 
-    private static ResourceLocation getBigWarmRuin(RandomSource randomsource) {
-        return (ResourceLocation) Util.getRandom((Object[]) OceanRuinPieces.BIG_WARM_RUINS, randomsource);
+    private static ResourceLocation getBigWarmRuin(RandomSource random) {
+        return (ResourceLocation) Util.getRandom((Object[]) OceanRuinPieces.BIG_WARM_RUINS, random);
     }
 
-    public static void addPieces(StructureTemplateManager structuretemplatemanager, BlockPos blockpos, Rotation rotation, StructurePieceAccessor structurepieceaccessor, RandomSource randomsource, OceanRuinStructure oceanruinstructure) {
-        boolean flag = randomsource.nextFloat() <= oceanruinstructure.largeProbability;
+    public static void addPieces(StructureTemplateManager structureTemplateManager, BlockPos pos, Rotation rotation, StructurePieceAccessor structurePieceAccessor, RandomSource random, OceanRuinStructure structure) {
+        boolean flag = random.nextFloat() <= structure.largeProbability;
         float f = flag ? 0.9F : 0.8F;
 
-        addPiece(structuretemplatemanager, blockpos, rotation, structurepieceaccessor, randomsource, oceanruinstructure, flag, f);
-        if (flag && randomsource.nextFloat() <= oceanruinstructure.clusterProbability) {
-            addClusterRuins(structuretemplatemanager, randomsource, rotation, blockpos, oceanruinstructure, structurepieceaccessor);
+        addPiece(structureTemplateManager, pos, rotation, structurePieceAccessor, random, structure, flag, f);
+        if (flag && random.nextFloat() <= structure.clusterProbability) {
+            addClusterRuins(structureTemplateManager, random, rotation, pos, structure, structurePieceAccessor);
         }
 
     }
 
-    private static void addClusterRuins(StructureTemplateManager structuretemplatemanager, RandomSource randomsource, Rotation rotation, BlockPos blockpos, OceanRuinStructure oceanruinstructure, StructurePieceAccessor structurepieceaccessor) {
-        BlockPos blockpos1 = new BlockPos(blockpos.getX(), 90, blockpos.getZ());
-        BlockPos blockpos2 = StructureTemplate.transform(new BlockPos(15, 0, 15), Mirror.NONE, rotation, BlockPos.ZERO).offset(blockpos1);
-        BoundingBox boundingbox = BoundingBox.fromCorners(blockpos1, blockpos2);
-        BlockPos blockpos3 = new BlockPos(Math.min(blockpos1.getX(), blockpos2.getX()), blockpos1.getY(), Math.min(blockpos1.getZ(), blockpos2.getZ()));
-        List<BlockPos> list = allPositions(randomsource, blockpos3);
-        int i = Mth.nextInt(randomsource, 4, 8);
+    private static void addClusterRuins(StructureTemplateManager structureTemplateManager, RandomSource random, Rotation rotation, BlockPos pos, OceanRuinStructure structure, StructurePieceAccessor structurePieceAccessor) {
+        BlockPos blockposition1 = new BlockPos(pos.getX(), 90, pos.getZ());
+        BlockPos blockposition2 = StructureTemplate.transform(new BlockPos(15, 0, 15), Mirror.NONE, rotation, BlockPos.ZERO).offset(blockposition1);
+        BoundingBox structureboundingbox = BoundingBox.fromCorners(blockposition1, blockposition2);
+        BlockPos blockposition3 = new BlockPos(Math.min(blockposition1.getX(), blockposition2.getX()), blockposition1.getY(), Math.min(blockposition1.getZ(), blockposition2.getZ()));
+        List<BlockPos> list = allPositions(random, blockposition3);
+        int i = Mth.nextInt(random, 4, 8);
 
         for (int j = 0; j < i; ++j) {
             if (!list.isEmpty()) {
-                int k = randomsource.nextInt(list.size());
-                BlockPos blockpos4 = (BlockPos) list.remove(k);
-                Rotation rotation1 = Rotation.getRandom(randomsource);
-                BlockPos blockpos5 = StructureTemplate.transform(new BlockPos(5, 0, 6), Mirror.NONE, rotation1, BlockPos.ZERO).offset(blockpos4);
-                BoundingBox boundingbox1 = BoundingBox.fromCorners(blockpos4, blockpos5);
+                int k = random.nextInt(list.size());
+                BlockPos blockposition4 = (BlockPos) list.remove(k);
+                Rotation enumblockrotation1 = Rotation.getRandom(random);
+                BlockPos blockposition5 = StructureTemplate.transform(new BlockPos(5, 0, 6), Mirror.NONE, enumblockrotation1, BlockPos.ZERO).offset(blockposition4);
+                BoundingBox structureboundingbox1 = BoundingBox.fromCorners(blockposition4, blockposition5);
 
-                if (!boundingbox1.intersects(boundingbox)) {
-                    addPiece(structuretemplatemanager, blockpos4, rotation1, structurepieceaccessor, randomsource, oceanruinstructure, false, 0.8F);
+                if (!structureboundingbox1.intersects(structureboundingbox)) {
+                    addPiece(structureTemplateManager, blockposition4, enumblockrotation1, structurePieceAccessor, random, structure, false, 0.8F);
                 }
             }
         }
 
     }
 
-    private static List<BlockPos> allPositions(RandomSource randomsource, BlockPos blockpos) {
+    private static List<BlockPos> allPositions(RandomSource random, BlockPos pos) {
         List<BlockPos> list = Lists.newArrayList();
 
-        list.add(blockpos.offset(-16 + Mth.nextInt(randomsource, 1, 8), 0, 16 + Mth.nextInt(randomsource, 1, 7)));
-        list.add(blockpos.offset(-16 + Mth.nextInt(randomsource, 1, 8), 0, Mth.nextInt(randomsource, 1, 7)));
-        list.add(blockpos.offset(-16 + Mth.nextInt(randomsource, 1, 8), 0, -16 + Mth.nextInt(randomsource, 4, 8)));
-        list.add(blockpos.offset(Mth.nextInt(randomsource, 1, 7), 0, 16 + Mth.nextInt(randomsource, 1, 7)));
-        list.add(blockpos.offset(Mth.nextInt(randomsource, 1, 7), 0, -16 + Mth.nextInt(randomsource, 4, 6)));
-        list.add(blockpos.offset(16 + Mth.nextInt(randomsource, 1, 7), 0, 16 + Mth.nextInt(randomsource, 3, 8)));
-        list.add(blockpos.offset(16 + Mth.nextInt(randomsource, 1, 7), 0, Mth.nextInt(randomsource, 1, 7)));
-        list.add(blockpos.offset(16 + Mth.nextInt(randomsource, 1, 7), 0, -16 + Mth.nextInt(randomsource, 4, 8)));
+        list.add(pos.offset(-16 + Mth.nextInt(random, 1, 8), 0, 16 + Mth.nextInt(random, 1, 7)));
+        list.add(pos.offset(-16 + Mth.nextInt(random, 1, 8), 0, Mth.nextInt(random, 1, 7)));
+        list.add(pos.offset(-16 + Mth.nextInt(random, 1, 8), 0, -16 + Mth.nextInt(random, 4, 8)));
+        list.add(pos.offset(Mth.nextInt(random, 1, 7), 0, 16 + Mth.nextInt(random, 1, 7)));
+        list.add(pos.offset(Mth.nextInt(random, 1, 7), 0, -16 + Mth.nextInt(random, 4, 6)));
+        list.add(pos.offset(16 + Mth.nextInt(random, 1, 7), 0, 16 + Mth.nextInt(random, 3, 8)));
+        list.add(pos.offset(16 + Mth.nextInt(random, 1, 7), 0, Mth.nextInt(random, 1, 7)));
+        list.add(pos.offset(16 + Mth.nextInt(random, 1, 7), 0, -16 + Mth.nextInt(random, 4, 8)));
         return list;
     }
 
-    private static void addPiece(StructureTemplateManager structuretemplatemanager, BlockPos blockpos, Rotation rotation, StructurePieceAccessor structurepieceaccessor, RandomSource randomsource, OceanRuinStructure oceanruinstructure, boolean flag, float f) {
-        switch (oceanruinstructure.biomeTemp) {
+    private static void addPiece(StructureTemplateManager structureTemplateManager, BlockPos pos, Rotation rotation, StructurePieceAccessor structurePieceAccessor, RandomSource random, OceanRuinStructure structure, boolean isLarge, float integrity) {
+        switch (structure.biomeTemp) {
             case WARM:
             default:
-                ResourceLocation resourcelocation = flag ? getBigWarmRuin(randomsource) : getSmallWarmRuin(randomsource);
+                ResourceLocation minecraftkey = isLarge ? getBigWarmRuin(random) : getSmallWarmRuin(random);
 
-                structurepieceaccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structuretemplatemanager, resourcelocation, blockpos, rotation, f, oceanruinstructure.biomeTemp, flag));
+                structurePieceAccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structureTemplateManager, minecraftkey, pos, rotation, integrity, structure.biomeTemp, isLarge));
                 break;
             case COLD:
-                ResourceLocation[] aresourcelocation = flag ? OceanRuinPieces.BIG_RUINS_BRICK : OceanRuinPieces.RUINS_BRICK;
-                ResourceLocation[] aresourcelocation1 = flag ? OceanRuinPieces.BIG_RUINS_CRACKED : OceanRuinPieces.RUINS_CRACKED;
-                ResourceLocation[] aresourcelocation2 = flag ? OceanRuinPieces.BIG_RUINS_MOSSY : OceanRuinPieces.RUINS_MOSSY;
-                int i = randomsource.nextInt(aresourcelocation.length);
+                ResourceLocation[] aminecraftkey = isLarge ? OceanRuinPieces.BIG_RUINS_BRICK : OceanRuinPieces.RUINS_BRICK;
+                ResourceLocation[] aminecraftkey1 = isLarge ? OceanRuinPieces.BIG_RUINS_CRACKED : OceanRuinPieces.RUINS_CRACKED;
+                ResourceLocation[] aminecraftkey2 = isLarge ? OceanRuinPieces.BIG_RUINS_MOSSY : OceanRuinPieces.RUINS_MOSSY;
+                int i = random.nextInt(aminecraftkey.length);
 
-                structurepieceaccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structuretemplatemanager, aresourcelocation[i], blockpos, rotation, f, oceanruinstructure.biomeTemp, flag));
-                structurepieceaccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structuretemplatemanager, aresourcelocation1[i], blockpos, rotation, 0.7F, oceanruinstructure.biomeTemp, flag));
-                structurepieceaccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structuretemplatemanager, aresourcelocation2[i], blockpos, rotation, 0.5F, oceanruinstructure.biomeTemp, flag));
+                structurePieceAccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structureTemplateManager, aminecraftkey[i], pos, rotation, integrity, structure.biomeTemp, isLarge));
+                structurePieceAccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structureTemplateManager, aminecraftkey1[i], pos, rotation, 0.7F, structure.biomeTemp, isLarge));
+                structurePieceAccessor.addPiece(new OceanRuinPieces.OceanRuinPiece(structureTemplateManager, aminecraftkey2[i], pos, rotation, 0.5F, structure.biomeTemp, isLarge));
         }
 
     }
@@ -155,69 +153,75 @@
         private final float integrity;
         private final boolean isLarge;
 
-        public OceanRuinPiece(StructureTemplateManager structuretemplatemanager, ResourceLocation resourcelocation, BlockPos blockpos, Rotation rotation, float f, OceanRuinStructure.Type oceanruinstructure_type, boolean flag) {
-            super(StructurePieceType.OCEAN_RUIN, 0, structuretemplatemanager, resourcelocation, resourcelocation.toString(), makeSettings(rotation, f, oceanruinstructure_type), blockpos);
-            this.integrity = f;
-            this.biomeType = oceanruinstructure_type;
-            this.isLarge = flag;
+        public OceanRuinPiece(StructureTemplateManager structureTemplateManager, ResourceLocation location, BlockPos pos, Rotation rotation, float integrity, OceanRuinStructure.Type biomeType, boolean isLarge) {
+            super(StructurePieceType.OCEAN_RUIN, 0, structureTemplateManager, location, location.toString(), makeSettings(rotation, integrity, biomeType), pos);
+            this.integrity = integrity;
+            this.biomeType = biomeType;
+            this.isLarge = isLarge;
         }
 
-        private OceanRuinPiece(StructureTemplateManager structuretemplatemanager, CompoundTag compoundtag, Rotation rotation, float f, OceanRuinStructure.Type oceanruinstructure_type, boolean flag) {
-            super(StructurePieceType.OCEAN_RUIN, compoundtag, structuretemplatemanager, (resourcelocation) -> {
-                return makeSettings(rotation, f, oceanruinstructure_type);
+        private OceanRuinPiece(StructureTemplateManager structureTemplateManager, CompoundTag genDepth, Rotation rotation, float integrity, OceanRuinStructure.Type biomeType, boolean isLarge) {
+            super(StructurePieceType.OCEAN_RUIN, genDepth, structureTemplateManager, (minecraftkey) -> {
+                return makeSettings(rotation, integrity, biomeType);
             });
-            this.integrity = f;
-            this.biomeType = oceanruinstructure_type;
-            this.isLarge = flag;
+            this.integrity = integrity;
+            this.biomeType = biomeType;
+            this.isLarge = isLarge;
         }
 
-        private static StructurePlaceSettings makeSettings(Rotation rotation, float f, OceanRuinStructure.Type oceanruinstructure_type) {
-            StructureProcessor structureprocessor = oceanruinstructure_type == OceanRuinStructure.Type.COLD ? OceanRuinPieces.COLD_SUSPICIOUS_BLOCK_PROCESSOR : OceanRuinPieces.WARM_SUSPICIOUS_BLOCK_PROCESSOR;
+        private static StructurePlaceSettings makeSettings(Rotation rotation, float integrity, OceanRuinStructure.Type structureType) {
+            StructureProcessor definedstructureprocessor = structureType == OceanRuinStructure.Type.COLD ? OceanRuinPieces.COLD_SUSPICIOUS_BLOCK_PROCESSOR : OceanRuinPieces.WARM_SUSPICIOUS_BLOCK_PROCESSOR;
 
-            return (new StructurePlaceSettings()).setRotation(rotation).setMirror(Mirror.NONE).addProcessor(new BlockRotProcessor(f)).addProcessor(BlockIgnoreProcessor.STRUCTURE_AND_AIR).addProcessor(structureprocessor);
+            return (new StructurePlaceSettings()).setRotation(rotation).setMirror(Mirror.NONE).addProcessor(new BlockRotProcessor(integrity)).addProcessor(BlockIgnoreProcessor.STRUCTURE_AND_AIR).addProcessor(definedstructureprocessor);
         }
 
-        public static OceanRuinPieces.OceanRuinPiece create(StructureTemplateManager structuretemplatemanager, CompoundTag compoundtag) {
-            Rotation rotation = Rotation.valueOf(compoundtag.getString("Rot"));
-            float f = compoundtag.getFloat("Integrity");
-            OceanRuinStructure.Type oceanruinstructure_type = OceanRuinStructure.Type.valueOf(compoundtag.getString("BiomeType"));
-            boolean flag = compoundtag.getBoolean("IsLarge");
+        public static OceanRuinPieces.OceanRuinPiece create(StructureTemplateManager structureTemplateManager, CompoundTag tag) {
+            Rotation enumblockrotation = Rotation.valueOf(tag.getString("Rot"));
+            float f = tag.getFloat("Integrity");
+            OceanRuinStructure.Type oceanruinstructure_a = OceanRuinStructure.Type.valueOf(tag.getString("BiomeType"));
+            boolean flag = tag.getBoolean("IsLarge");
 
-            return new OceanRuinPieces.OceanRuinPiece(structuretemplatemanager, compoundtag, rotation, f, oceanruinstructure_type, flag);
+            return new OceanRuinPieces.OceanRuinPiece(structureTemplateManager, tag, enumblockrotation, f, oceanruinstructure_a, flag);
         }
 
         @Override
-        @Override
-        protected void addAdditionalSaveData(StructurePieceSerializationContext structurepieceserializationcontext, CompoundTag compoundtag) {
-            super.addAdditionalSaveData(structurepieceserializationcontext, compoundtag);
-            compoundtag.putString("Rot", this.placeSettings.getRotation().name());
-            compoundtag.putFloat("Integrity", this.integrity);
-            compoundtag.putString("BiomeType", this.biomeType.toString());
-            compoundtag.putBoolean("IsLarge", this.isLarge);
+        protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag tag) {
+            super.addAdditionalSaveData(context, tag);
+            tag.putString("Rot", this.placeSettings.getRotation().name());
+            tag.putFloat("Integrity", this.integrity);
+            tag.putString("BiomeType", this.biomeType.toString());
+            tag.putBoolean("IsLarge", this.isLarge);
         }
 
         @Override
-        @Override
-        protected void handleDataMarker(String s, BlockPos blockpos, ServerLevelAccessor serverlevelaccessor, RandomSource randomsource, BoundingBox boundingbox) {
-            if ("chest".equals(s)) {
-                serverlevelaccessor.setBlock(blockpos, (BlockState) Blocks.CHEST.defaultBlockState().setValue(ChestBlock.WATERLOGGED, serverlevelaccessor.getFluidState(blockpos).is(FluidTags.WATER)), 2);
-                BlockEntity blockentity = serverlevelaccessor.getBlockEntity(blockpos);
+        protected void handleDataMarker(String name, BlockPos pos, ServerLevelAccessor level, RandomSource random, BoundingBox box) {
+            if ("chest".equals(name)) {
+                // CraftBukkit start - transform block to ensure loot table is accessible
+                /*
+                worldaccess.setBlock(blockposition, (IBlockData) Blocks.CHEST.defaultBlockState().setValue(BlockChest.WATERLOGGED, worldaccess.getFluidState(blockposition).is(TagsFluid.WATER)), 2);
+                TileEntity tileentity = worldaccess.getBlockEntity(blockposition);
 
-                if (blockentity instanceof ChestBlockEntity) {
-                    ((ChestBlockEntity) blockentity).setLootTable(this.isLarge ? BuiltInLootTables.UNDERWATER_RUIN_BIG : BuiltInLootTables.UNDERWATER_RUIN_SMALL, randomsource.nextLong());
+                if (tileentity instanceof TileEntityChest) {
+                    ((TileEntityChest) tileentity).setLootTable(this.isLarge ? LootTables.UNDERWATER_RUIN_BIG : LootTables.UNDERWATER_RUIN_SMALL, randomsource.nextLong());
                 }
-            } else if ("drowned".equals(s)) {
-                Drowned drowned = (Drowned) EntityType.DROWNED.create(serverlevelaccessor.getLevel());
+                */
+                org.bukkit.craftbukkit.block.CraftChest craftChest = (org.bukkit.craftbukkit.block.CraftChest) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(pos, Blocks.CHEST.defaultBlockState().setValue(ChestBlock.WATERLOGGED, level.getFluidState(pos).is(FluidTags.WATER)), null);
+                craftChest.setSeed(random.nextLong());
+                craftChest.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(this.isLarge ? BuiltInLootTables.UNDERWATER_RUIN_BIG : BuiltInLootTables.UNDERWATER_RUIN_SMALL)));
+                placeCraftBlockEntity(level, pos, craftChest, 2);
+                // CraftBukkit end
+            } else if ("drowned".equals(name)) {
+                Drowned entitydrowned = (Drowned) EntityType.DROWNED.create(level.getLevel());
 
-                if (drowned != null) {
-                    drowned.setPersistenceRequired();
-                    drowned.moveTo(blockpos, 0.0F, 0.0F);
-                    drowned.finalizeSpawn(serverlevelaccessor, serverlevelaccessor.getCurrentDifficultyAt(blockpos), MobSpawnType.STRUCTURE, (SpawnGroupData) null, (CompoundTag) null);
-                    serverlevelaccessor.addFreshEntityWithPassengers(drowned);
-                    if (blockpos.getY() > serverlevelaccessor.getSeaLevel()) {
-                        serverlevelaccessor.setBlock(blockpos, Blocks.AIR.defaultBlockState(), 2);
+                if (entitydrowned != null) {
+                    entitydrowned.setPersistenceRequired();
+                    entitydrowned.moveTo(pos, 0.0F, 0.0F);
+                    entitydrowned.finalizeSpawn(level, level.getCurrentDifficultyAt(pos), EnumMobSpawn.STRUCTURE, (GroupDataEntity) null, (CompoundTag) null);
+                    level.addFreshEntityWithPassengers(entitydrowned);
+                    if (pos.getY() > level.getSeaLevel()) {
+                        level.setBlock(pos, Blocks.AIR.defaultBlockState(), 2);
                     } else {
-                        serverlevelaccessor.setBlock(blockpos, Blocks.WATER.defaultBlockState(), 2);
+                        level.setBlock(pos, Blocks.WATER.defaultBlockState(), 2);
                     }
                 }
             }
@@ -225,36 +229,35 @@
         }
 
         @Override
-        @Override
-        public void postProcess(WorldGenLevel worldgenlevel, StructureManager structuremanager, ChunkGenerator chunkgenerator, RandomSource randomsource, BoundingBox boundingbox, ChunkPos chunkpos, BlockPos blockpos) {
-            int i = worldgenlevel.getHeight(Heightmap.Types.OCEAN_FLOOR_WG, this.templatePosition.getX(), this.templatePosition.getZ());
+        public void postProcess(WorldGenLevel level, StructureManager structureManager, ChunkGenerator generator, RandomSource random, BoundingBox box, ChunkPos chunkPos, BlockPos pos) {
+            int i = level.getHeight(Heightmap.Types.OCEAN_FLOOR_WG, this.templatePosition.getX(), this.templatePosition.getZ());
 
             this.templatePosition = new BlockPos(this.templatePosition.getX(), i, this.templatePosition.getZ());
-            BlockPos blockpos1 = StructureTemplate.transform(new BlockPos(this.template.getSize().getX() - 1, 0, this.template.getSize().getZ() - 1), Mirror.NONE, this.placeSettings.getRotation(), BlockPos.ZERO).offset(this.templatePosition);
+            BlockPos blockposition1 = StructureTemplate.transform(new BlockPos(this.template.getSize().getX() - 1, 0, this.template.getSize().getZ() - 1), Mirror.NONE, this.placeSettings.getRotation(), BlockPos.ZERO).offset(this.templatePosition);
 
-            this.templatePosition = new BlockPos(this.templatePosition.getX(), this.getHeight(this.templatePosition, worldgenlevel, blockpos1), this.templatePosition.getZ());
-            super.postProcess(worldgenlevel, structuremanager, chunkgenerator, randomsource, boundingbox, chunkpos, blockpos);
+            this.templatePosition = new BlockPos(this.templatePosition.getX(), this.getHeight(this.templatePosition, level, blockposition1), this.templatePosition.getZ());
+            super.postProcess(level, structureManager, generator, random, box, chunkPos, pos);
         }
 
-        private int getHeight(BlockPos blockpos, BlockGetter blockgetter, BlockPos blockpos1) {
-            int i = blockpos.getY();
+        private int getHeight(BlockPos templatePos, BlockGetter level, BlockPos pos) {
+            int i = templatePos.getY();
             int j = 512;
             int k = i - 1;
             int l = 0;
-            Iterator iterator = BlockPos.betweenClosed(blockpos, blockpos1).iterator();
+            Iterator iterator = BlockPos.betweenClosed(templatePos, pos).iterator();
 
             while (iterator.hasNext()) {
-                BlockPos blockpos2 = (BlockPos) iterator.next();
-                int i1 = blockpos2.getX();
-                int j1 = blockpos2.getZ();
-                int k1 = blockpos.getY() - 1;
-                BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos(i1, k1, j1);
-                BlockState blockstate = blockgetter.getBlockState(blockpos_mutableblockpos);
+                BlockPos blockposition2 = (BlockPos) iterator.next();
+                int i1 = blockposition2.getX();
+                int j1 = blockposition2.getZ();
+                int k1 = templatePos.getY() - 1;
+                BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(i1, k1, j1);
+                IBlockData iblockdata = level.getBlockState(blockposition_mutableblockposition);
 
-                for (FluidState fluidstate = blockgetter.getFluidState(blockpos_mutableblockpos); (blockstate.isAir() || fluidstate.is(FluidTags.WATER) || blockstate.is(BlockTags.ICE)) && k1 > blockgetter.getMinBuildHeight() + 1; fluidstate = blockgetter.getFluidState(blockpos_mutableblockpos)) {
+                for (FluidState fluid = level.getFluidState(blockposition_mutableblockposition); (iblockdata.isAir() || fluid.is(FluidTags.WATER) || iblockdata.is(BlockTags.ICE)) && k1 > level.getMinBuildHeight() + 1; fluid = level.getFluidState(blockposition_mutableblockposition)) {
                     --k1;
-                    blockpos_mutableblockpos.set(i1, k1, j1);
-                    blockstate = blockgetter.getBlockState(blockpos_mutableblockpos);
+                    blockposition_mutableblockposition.set(i1, k1, j1);
+                    iblockdata = level.getBlockState(blockposition_mutableblockposition);
                 }
 
                 j = Math.min(j, k1);
@@ -263,7 +266,7 @@
                 }
             }
 
-            int l1 = Math.abs(blockpos.getX() - blockpos1.getX());
+            int l1 = Math.abs(templatePos.getX() - pos.getX());
 
             if (k - j > 2 && l > l1 - 2) {
                 i = j + 1;
