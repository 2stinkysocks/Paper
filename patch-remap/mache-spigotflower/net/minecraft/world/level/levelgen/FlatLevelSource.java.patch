--- a/net/minecraft/world/level/levelgen/FlatLevelSource.java
+++ b/net/minecraft/world/level/levelgen/FlatLevelSource.java
@@ -19,7 +19,7 @@
 import net.minecraft.world.level.biome.BiomeManager;
 import net.minecraft.world.level.biome.FixedBiomeSource;
 import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
@@ -34,28 +34,32 @@
     });
     private final FlatLevelGeneratorSettings settings;
 
-    public FlatLevelSource(FlatLevelGeneratorSettings flatlevelgeneratorsettings) {
-        FixedBiomeSource fixedbiomesource = new FixedBiomeSource(flatlevelgeneratorsettings.getBiome());
+    public FlatLevelSource(FlatLevelGeneratorSettings settings) {
+        // CraftBukkit start
+        // WorldChunkManagerHell worldchunkmanagerhell = new WorldChunkManagerHell(generatorsettingsflat.getBiome());
 
-        Objects.requireNonNull(flatlevelgeneratorsettings);
-        super(fixedbiomesource, Util.memoize(flatlevelgeneratorsettings::adjustGenerationSettings));
-        this.settings = flatlevelgeneratorsettings;
+        // Objects.requireNonNull(generatorsettingsflat);
+        this(settings, new FixedBiomeSource(settings.getBiome()));
     }
 
+    public FlatLevelSource(FlatLevelGeneratorSettings generatorsettingsflat, net.minecraft.world.level.biome.BiomeSource worldchunkmanager) {
+        super(worldchunkmanager, Util.memoize(generatorsettingsflat::adjustGenerationSettings));
+        // CraftBukkit end
+        this.settings = generatorsettingsflat;
+    }
+
     @Override
-    @Override
-    public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> holderlookup, RandomState randomstate, long i) {
+    public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> structureSetLookup, RandomState randomState, long seed) {
         Stream<Holder<StructureSet>> stream = (Stream) this.settings.structureOverrides().map(HolderSet::stream).orElseGet(() -> {
-            return holderlookup.listElements().map((holder_reference) -> {
-                return holder_reference;
+            return structureSetLookup.listElements().map((holder_c) -> {
+                return holder_c;
             });
         });
 
-        return ChunkGeneratorStructureState.createForFlat(randomstate, i, this.biomeSource, stream);
+        return ChunkGeneratorStructureState.createForFlat(randomState, seed, this.biomeSource, stream);
     }
 
     @Override
-    @Override
     protected Codec<? extends ChunkGenerator> codec() {
         return FlatLevelSource.CODEC;
     }
@@ -65,94 +69,83 @@
     }
 
     @Override
-    @Override
-    public void buildSurface(WorldGenRegion worldgenregion, StructureManager structuremanager, RandomState randomstate, ChunkAccess chunkaccess) {}
+    public void buildSurface(WorldGenRegion level, StructureManager structureManager, RandomState random, ChunkAccess chunk) {}
 
     @Override
-    @Override
-    public int getSpawnHeight(LevelHeightAccessor levelheightaccessor) {
-        return levelheightaccessor.getMinBuildHeight() + Math.min(levelheightaccessor.getHeight(), this.settings.getLayers().size());
+    public int getSpawnHeight(LevelHeightAccessor level) {
+        return level.getMinBuildHeight() + Math.min(level.getHeight(), this.settings.getLayers().size());
     }
 
     @Override
-    @Override
-    public CompletableFuture<ChunkAccess> fillFromNoise(Executor executor, Blender blender, RandomState randomstate, StructureManager structuremanager, ChunkAccess chunkaccess) {
-        List<BlockState> list = this.settings.getLayers();
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
-        Heightmap heightmap = chunkaccess.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
-        Heightmap heightmap1 = chunkaccess.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
+    public CompletableFuture<ChunkAccess> fillFromNoise(Executor executor, Blender blender, RandomState random, StructureManager structureManager, ChunkAccess chunk) {
+        List<IBlockData> list = this.settings.getLayers();
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+        Heightmap heightmap = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.OCEAN_FLOOR_WG);
+        Heightmap heightmap1 = chunk.getOrCreateHeightmapUnprimed(Heightmap.Types.WORLD_SURFACE_WG);
 
-        for (int i = 0; i < Math.min(chunkaccess.getHeight(), list.size()); ++i) {
-            BlockState blockstate = (BlockState) list.get(i);
+        for (int i = 0; i < Math.min(chunk.getHeight(), list.size()); ++i) {
+            IBlockData iblockdata = (IBlockData) list.get(i);
 
-            if (blockstate != null) {
-                int j = chunkaccess.getMinBuildHeight() + i;
+            if (iblockdata != null) {
+                int j = chunk.getMinBuildHeight() + i;
 
                 for (int k = 0; k < 16; ++k) {
                     for (int l = 0; l < 16; ++l) {
-                        chunkaccess.setBlockState(blockpos_mutableblockpos.set(k, j, l), blockstate, false);
-                        heightmap.update(k, j, l, blockstate);
-                        heightmap1.update(k, j, l, blockstate);
+                        chunk.setBlockState(blockposition_mutableblockposition.set(k, j, l), iblockdata, false);
+                        heightmap.update(k, j, l, iblockdata);
+                        heightmap1.update(k, j, l, iblockdata);
                     }
                 }
             }
         }
 
-        return CompletableFuture.completedFuture(chunkaccess);
+        return CompletableFuture.completedFuture(chunk);
     }
 
     @Override
-    @Override
-    public int getBaseHeight(int i, int j, Heightmap.Types heightmap_types, LevelHeightAccessor levelheightaccessor, RandomState randomstate) {
-        List<BlockState> list = this.settings.getLayers();
+    public int getBaseHeight(int x, int z, Heightmap.Types type, LevelHeightAccessor level, RandomState random) {
+        List<IBlockData> list = this.settings.getLayers();
 
-        for (int k = Math.min(list.size(), levelheightaccessor.getMaxBuildHeight()) - 1; k >= 0; --k) {
-            BlockState blockstate = (BlockState) list.get(k);
+        for (int k = Math.min(list.size(), level.getMaxBuildHeight()) - 1; k >= 0; --k) {
+            IBlockData iblockdata = (IBlockData) list.get(k);
 
-            if (blockstate != null && heightmap_types.isOpaque().test(blockstate)) {
-                return levelheightaccessor.getMinBuildHeight() + k + 1;
+            if (iblockdata != null && type.isOpaque().test(iblockdata)) {
+                return level.getMinBuildHeight() + k + 1;
             }
         }
 
-        return levelheightaccessor.getMinBuildHeight();
+        return level.getMinBuildHeight();
     }
 
     @Override
-    @Override
-    public NoiseColumn getBaseColumn(int i, int j, LevelHeightAccessor levelheightaccessor, RandomState randomstate) {
-        return new NoiseColumn(levelheightaccessor.getMinBuildHeight(), (BlockState[]) this.settings.getLayers().stream().limit((long) levelheightaccessor.getHeight()).map((blockstate) -> {
-            return blockstate == null ? Blocks.AIR.defaultBlockState() : blockstate;
+    public NoiseColumn getBaseColumn(int x, int z, LevelHeightAccessor height, RandomState random) {
+        return new NoiseColumn(height.getMinBuildHeight(), (IBlockData[]) this.settings.getLayers().stream().limit((long) height.getHeight()).map((iblockdata) -> {
+            return iblockdata == null ? Blocks.AIR.defaultBlockState() : iblockdata;
         }).toArray((k) -> {
-            return new BlockState[k];
+            return new IBlockData[k];
         }));
     }
 
     @Override
-    @Override
-    public void addDebugScreenInfo(List<String> list, RandomState randomstate, BlockPos blockpos) {}
+    public void addDebugScreenInfo(List<String> info, RandomState random, BlockPos pos) {}
 
     @Override
-    @Override
-    public void applyCarvers(WorldGenRegion worldgenregion, long i, RandomState randomstate, BiomeManager biomemanager, StructureManager structuremanager, ChunkAccess chunkaccess, GenerationStep.Carving generationstep_carving) {}
+    public void applyCarvers(WorldGenRegion level, long seed, RandomState randomstate, BiomeManager random, StructureManager biomeManager, ChunkAccess structureManager, GenerationStep.Carving chunk) {}
 
     @Override
-    @Override
-    public void spawnOriginalMobs(WorldGenRegion worldgenregion) {}
+    public void spawnOriginalMobs(WorldGenRegion level) {}
 
     @Override
-    @Override
     public int getMinY() {
         return 0;
     }
 
     @Override
-    @Override
     public int getGenDepth() {
         return 384;
     }
 
     @Override
-    @Override
     public int getSeaLevel() {
         return -63;
     }
