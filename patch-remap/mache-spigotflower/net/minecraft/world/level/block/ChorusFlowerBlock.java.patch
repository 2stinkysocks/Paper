--- a/net/minecraft/world/level/block/ChorusFlowerBlock.java
+++ b/net/minecraft/world/level/block/ChorusFlowerBlock.java
@@ -15,18 +15,20 @@
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+
 public class ChorusFlowerBlock extends Block {
 
     public static final MapCodec<ChorusFlowerBlock> CODEC = RecordCodecBuilder.mapCodec((instance) -> {
-        return instance.group(BuiltInRegistries.BLOCK.byNameCodec().fieldOf("plant").forGetter((chorusflowerblock) -> {
-            return chorusflowerblock.plant;
+        return instance.group(BuiltInRegistries.BLOCK.byNameCodec().fieldOf("plant").forGetter((blockchorusflower) -> {
+            return blockchorusflower.plant;
         }), propertiesCodec()).apply(instance, ChorusFlowerBlock::new);
     });
     public static final int DEAD_AGE = 5;
@@ -35,62 +37,57 @@
     private final Block plant;
 
     @Override
-    @Override
     public MapCodec<ChorusFlowerBlock> codec() {
         return ChorusFlowerBlock.CODEC;
     }
 
-    protected ChorusFlowerBlock(Block block, BlockBehaviour.Properties blockbehaviour_properties) {
-        super(blockbehaviour_properties);
+    protected ChorusFlowerBlock(Block block, BlockBehaviour.Properties blockbase_info) {
+        super(blockbase_info);
         this.plant = block;
-        this.registerDefaultState((BlockState) ((BlockState) this.stateDefinition.any()).setValue(ChorusFlowerBlock.AGE, 0));
+        this.registerDefaultState((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(ChorusFlowerBlock.AGE, 0));
     }
 
     @Override
-    @Override
-    public void tick(BlockState blockstate, ServerLevel serverlevel, BlockPos blockpos, RandomSource randomsource) {
-        if (!blockstate.canSurvive(serverlevel, blockpos)) {
-            serverlevel.destroyBlock(blockpos, true);
+    public void tick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        if (!state.canSurvive(level, pos)) {
+            level.destroyBlock(pos, true);
         }
 
     }
 
     @Override
-    @Override
-    public boolean isRandomlyTicking(BlockState blockstate) {
-        return (Integer) blockstate.getValue(ChorusFlowerBlock.AGE) < 5;
+    public boolean isRandomlyTicking(IBlockData state) {
+        return (Integer) state.getValue(ChorusFlowerBlock.AGE) < 5;
     }
 
     @Override
-    @Override
-    public VoxelShape getBlockSupportShape(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos) {
+    public VoxelShape getBlockSupportShape(IBlockData state, BlockGetter level, BlockPos pos) {
         return ChorusFlowerBlock.BLOCK_SUPPORT_SHAPE;
     }
 
     @Override
-    @Override
-    public void randomTick(BlockState blockstate, ServerLevel serverlevel, BlockPos blockpos, RandomSource randomsource) {
-        BlockPos blockpos1 = blockpos.above();
+    public void randomTick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        BlockPos blockposition1 = pos.above();
 
-        if (serverlevel.isEmptyBlock(blockpos1) && blockpos1.getY() < serverlevel.getMaxBuildHeight()) {
-            int i = (Integer) blockstate.getValue(ChorusFlowerBlock.AGE);
+        if (level.isEmptyBlock(blockposition1) && blockposition1.getY() < level.getMaxBuildHeight()) {
+            int i = (Integer) state.getValue(ChorusFlowerBlock.AGE);
 
             if (i < 5) {
                 boolean flag = false;
                 boolean flag1 = false;
-                BlockState blockstate1 = serverlevel.getBlockState(blockpos.below());
+                IBlockData iblockdata1 = level.getBlockState(pos.below());
                 int j;
 
-                if (blockstate1.is(Blocks.END_STONE)) {
+                if (iblockdata1.is(Blocks.END_STONE)) {
                     flag = true;
-                } else if (blockstate1.is(this.plant)) {
+                } else if (iblockdata1.is(this.plant)) {
                     j = 1;
 
                     for (int k = 0; k < 4; ++k) {
-                        BlockState blockstate2 = serverlevel.getBlockState(blockpos.below(j + 1));
+                        IBlockData iblockdata2 = level.getBlockState(pos.below(j + 1));
 
-                        if (!blockstate2.is(this.plant)) {
-                            if (blockstate2.is(Blocks.END_STONE)) {
+                        if (!iblockdata2.is(this.plant)) {
+                            if (iblockdata2.is(Blocks.END_STONE)) {
                                 flag1 = true;
                             }
                             break;
@@ -99,18 +96,22 @@
                         ++j;
                     }
 
-                    if (j < 2 || j <= randomsource.nextInt(flag1 ? 5 : 4)) {
+                    if (j < 2 || j <= random.nextInt(flag1 ? 5 : 4)) {
                         flag = true;
                     }
-                } else if (blockstate1.isAir()) {
+                } else if (iblockdata1.isAir()) {
                     flag = true;
                 }
 
-                if (flag && allNeighborsEmpty(serverlevel, blockpos1, (Direction) null) && serverlevel.isEmptyBlock(blockpos.above(2))) {
-                    serverlevel.setBlock(blockpos, ChorusPlantBlock.getStateWithConnections(serverlevel, blockpos, this.plant.defaultBlockState()), 2);
-                    this.placeGrownFlower(serverlevel, blockpos1, i);
+                if (flag && allNeighborsEmpty(level, blockposition1, (Direction) null) && level.isEmptyBlock(pos.above(2))) {
+                    // CraftBukkit start - add event
+                    if (CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition1, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(i)), 2)) {
+                        level.setBlock(pos, ChorusPlantBlock.getStateWithConnections(level, pos, this.plant.defaultBlockState()), 2);
+                        this.placeGrownFlower(level, blockposition1, i);
+                    }
+                    // CraftBukkit end
                 } else if (i < 4) {
-                    j = randomsource.nextInt(4);
+                    j = random.nextInt(4);
                     if (flag1) {
                         ++j;
                     }
@@ -118,87 +119,97 @@
                     boolean flag2 = false;
 
                     for (int l = 0; l < j; ++l) {
-                        Direction direction = Direction.Plane.HORIZONTAL.getRandomDirection(randomsource);
-                        BlockPos blockpos2 = blockpos.relative(direction);
+                        Direction enumdirection = Direction.Plane.HORIZONTAL.getRandomDirection(random);
+                        BlockPos blockposition2 = pos.relative(enumdirection);
 
-                        if (serverlevel.isEmptyBlock(blockpos2) && serverlevel.isEmptyBlock(blockpos2.below()) && allNeighborsEmpty(serverlevel, blockpos2, direction.getOpposite())) {
-                            this.placeGrownFlower(serverlevel, blockpos2, i + 1);
-                            flag2 = true;
+                        if (level.isEmptyBlock(blockposition2) && level.isEmptyBlock(blockposition2.below()) && allNeighborsEmpty(level, blockposition2, enumdirection.getOpposite())) {
+                            // CraftBukkit start - add event
+                            if (CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition2, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(i + 1)), 2)) {
+                                this.placeGrownFlower(level, blockposition2, i + 1);
+                                flag2 = true;
+                            }
+                            // CraftBukkit end
                         }
                     }
 
                     if (flag2) {
-                        serverlevel.setBlock(blockpos, ChorusPlantBlock.getStateWithConnections(serverlevel, blockpos, this.plant.defaultBlockState()), 2);
+                        level.setBlock(pos, ChorusPlantBlock.getStateWithConnections(level, pos, this.plant.defaultBlockState()), 2);
                     } else {
-                        this.placeDeadFlower(serverlevel, blockpos);
+                        // CraftBukkit start - add event
+                        if (CraftEventFactory.handleBlockGrowEvent(level, pos, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(5)), 2)) {
+                            this.placeDeadFlower(level, pos);
+                        }
+                        // CraftBukkit end
                     }
                 } else {
-                    this.placeDeadFlower(serverlevel, blockpos);
+                    // CraftBukkit start - add event
+                    if (CraftEventFactory.handleBlockGrowEvent(level, pos, this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, Integer.valueOf(5)), 2)) {
+                        this.placeDeadFlower(level, pos);
+                    }
+                    // CraftBukkit end
                 }
 
             }
         }
     }
 
-    private void placeGrownFlower(Level level, BlockPos blockpos, int i) {
-        level.setBlock(blockpos, (BlockState) this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, i), 2);
-        level.levelEvent(1033, blockpos, 0);
+    private void placeGrownFlower(Level level, BlockPos pos, int age) {
+        level.setBlock(pos, (IBlockData) this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, age), 2);
+        level.levelEvent(1033, pos, 0);
     }
 
-    private void placeDeadFlower(Level level, BlockPos blockpos) {
-        level.setBlock(blockpos, (BlockState) this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, 5), 2);
-        level.levelEvent(1034, blockpos, 0);
+    private void placeDeadFlower(Level level, BlockPos pos) {
+        level.setBlock(pos, (IBlockData) this.defaultBlockState().setValue(ChorusFlowerBlock.AGE, 5), 2);
+        level.levelEvent(1034, pos, 0);
     }
 
-    private static boolean allNeighborsEmpty(LevelReader levelreader, BlockPos blockpos, @Nullable Direction direction) {
+    private static boolean allNeighborsEmpty(LevelReader level, BlockPos pos, @Nullable Direction excludingSide) {
         Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
-        Direction direction1;
+        Direction enumdirection1;
 
         do {
             if (!iterator.hasNext()) {
                 return true;
             }
 
-            direction1 = (Direction) iterator.next();
-        } while (direction1 == direction || levelreader.isEmptyBlock(blockpos.relative(direction1)));
+            enumdirection1 = (Direction) iterator.next();
+        } while (enumdirection1 == excludingSide || level.isEmptyBlock(pos.relative(enumdirection1)));
 
         return false;
     }
 
     @Override
-    @Override
-    public BlockState updateShape(BlockState blockstate, Direction direction, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, BlockPos blockpos1) {
-        if (direction != Direction.UP && !blockstate.canSurvive(levelaccessor, blockpos)) {
-            levelaccessor.scheduleTick(blockpos, (Block) this, 1);
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        if (facing != Direction.UP && !state.canSurvive(level, currentPos)) {
+            level.scheduleTick(currentPos, (Block) this, 1);
         }
 
-        return super.updateShape(blockstate, direction, blockstate1, levelaccessor, blockpos, blockpos1);
+        return super.updateShape(state, facing, facingState, level, currentPos, facingPos);
     }
 
     @Override
-    @Override
-    public boolean canSurvive(BlockState blockstate, LevelReader levelreader, BlockPos blockpos) {
-        BlockState blockstate1 = levelreader.getBlockState(blockpos.below());
+    public boolean canSurvive(IBlockData state, LevelReader level, BlockPos pos) {
+        IBlockData iblockdata1 = level.getBlockState(pos.below());
 
-        if (!blockstate1.is(this.plant) && !blockstate1.is(Blocks.END_STONE)) {
-            if (!blockstate1.isAir()) {
+        if (!iblockdata1.is(this.plant) && !iblockdata1.is(Blocks.END_STONE)) {
+            if (!iblockdata1.isAir()) {
                 return false;
             } else {
                 boolean flag = false;
                 Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
                 while (iterator.hasNext()) {
-                    Direction direction = (Direction) iterator.next();
-                    BlockState blockstate2 = levelreader.getBlockState(blockpos.relative(direction));
+                    Direction enumdirection = (Direction) iterator.next();
+                    IBlockData iblockdata2 = level.getBlockState(pos.relative(enumdirection));
 
-                    if (blockstate2.is(this.plant)) {
+                    if (iblockdata2.is(this.plant)) {
                         if (flag) {
                             return false;
                         }
 
                         flag = true;
-                    } else if (!blockstate2.isAir()) {
+                    } else if (!iblockdata2.isAir()) {
                         return false;
                     }
                 }
@@ -211,70 +222,73 @@
     }
 
     @Override
-    @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> statedefinition_builder) {
-        statedefinition_builder.add(ChorusFlowerBlock.AGE);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(ChorusFlowerBlock.AGE);
     }
 
-    public static void generatePlant(LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource, int i) {
-        levelaccessor.setBlock(blockpos, ChorusPlantBlock.getStateWithConnections(levelaccessor, blockpos, Blocks.CHORUS_PLANT.defaultBlockState()), 2);
-        growTreeRecursive(levelaccessor, blockpos, randomsource, blockpos, i, 0);
+    public static void generatePlant(LevelAccessor level, BlockPos pos, RandomSource random, int maxHorizontalDistance) {
+        level.setBlock(pos, ChorusPlantBlock.getStateWithConnections(level, pos, Blocks.CHORUS_PLANT.defaultBlockState()), 2);
+        growTreeRecursive(level, pos, random, pos, maxHorizontalDistance, 0);
     }
 
-    private static void growTreeRecursive(LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource, BlockPos blockpos1, int i, int j) {
+    private static void growTreeRecursive(LevelAccessor level, BlockPos branchPos, RandomSource random, BlockPos originalBranchPos, int maxHorizontalDistance, int iterations) {
         Block block = Blocks.CHORUS_PLANT;
-        int k = randomsource.nextInt(4) + 1;
+        int k = random.nextInt(4) + 1;
 
-        if (j == 0) {
+        if (iterations == 0) {
             ++k;
         }
 
         for (int l = 0; l < k; ++l) {
-            BlockPos blockpos2 = blockpos.above(l + 1);
+            BlockPos blockposition2 = branchPos.above(l + 1);
 
-            if (!allNeighborsEmpty(levelaccessor, blockpos2, (Direction) null)) {
+            if (!allNeighborsEmpty(level, blockposition2, (Direction) null)) {
                 return;
             }
 
-            levelaccessor.setBlock(blockpos2, ChorusPlantBlock.getStateWithConnections(levelaccessor, blockpos2, block.defaultBlockState()), 2);
-            levelaccessor.setBlock(blockpos2.below(), ChorusPlantBlock.getStateWithConnections(levelaccessor, blockpos2.below(), block.defaultBlockState()), 2);
+            level.setBlock(blockposition2, ChorusPlantBlock.getStateWithConnections(level, blockposition2, block.defaultBlockState()), 2);
+            level.setBlock(blockposition2.below(), ChorusPlantBlock.getStateWithConnections(level, blockposition2.below(), block.defaultBlockState()), 2);
         }
 
         boolean flag = false;
 
-        if (j < 4) {
-            int i1 = randomsource.nextInt(4);
+        if (iterations < 4) {
+            int i1 = random.nextInt(4);
 
-            if (j == 0) {
+            if (iterations == 0) {
                 ++i1;
             }
 
             for (int j1 = 0; j1 < i1; ++j1) {
-                Direction direction = Direction.Plane.HORIZONTAL.getRandomDirection(randomsource);
-                BlockPos blockpos3 = blockpos.above(k).relative(direction);
+                Direction enumdirection = Direction.Plane.HORIZONTAL.getRandomDirection(random);
+                BlockPos blockposition3 = branchPos.above(k).relative(enumdirection);
 
-                if (Math.abs(blockpos3.getX() - blockpos1.getX()) < i && Math.abs(blockpos3.getZ() - blockpos1.getZ()) < i && levelaccessor.isEmptyBlock(blockpos3) && levelaccessor.isEmptyBlock(blockpos3.below()) && allNeighborsEmpty(levelaccessor, blockpos3, direction.getOpposite())) {
+                if (Math.abs(blockposition3.getX() - originalBranchPos.getX()) < maxHorizontalDistance && Math.abs(blockposition3.getZ() - originalBranchPos.getZ()) < maxHorizontalDistance && level.isEmptyBlock(blockposition3) && level.isEmptyBlock(blockposition3.below()) && allNeighborsEmpty(level, blockposition3, enumdirection.getOpposite())) {
                     flag = true;
-                    levelaccessor.setBlock(blockpos3, ChorusPlantBlock.getStateWithConnections(levelaccessor, blockpos3, block.defaultBlockState()), 2);
-                    levelaccessor.setBlock(blockpos3.relative(direction.getOpposite()), ChorusPlantBlock.getStateWithConnections(levelaccessor, blockpos3.relative(direction.getOpposite()), block.defaultBlockState()), 2);
-                    growTreeRecursive(levelaccessor, blockpos3, randomsource, blockpos1, i, j + 1);
+                    level.setBlock(blockposition3, ChorusPlantBlock.getStateWithConnections(level, blockposition3, block.defaultBlockState()), 2);
+                    level.setBlock(blockposition3.relative(enumdirection.getOpposite()), ChorusPlantBlock.getStateWithConnections(level, blockposition3.relative(enumdirection.getOpposite()), block.defaultBlockState()), 2);
+                    growTreeRecursive(level, blockposition3, random, originalBranchPos, maxHorizontalDistance, iterations + 1);
                 }
             }
         }
 
         if (!flag) {
-            levelaccessor.setBlock(blockpos.above(k), (BlockState) Blocks.CHORUS_FLOWER.defaultBlockState().setValue(ChorusFlowerBlock.AGE, 5), 2);
+            level.setBlock(branchPos.above(k), (IBlockData) Blocks.CHORUS_FLOWER.defaultBlockState().setValue(ChorusFlowerBlock.AGE, 5), 2);
         }
 
     }
 
     @Override
-    @Override
-    public void onProjectileHit(Level level, BlockState blockstate, BlockHitResult blockhitresult, Projectile projectile) {
-        BlockPos blockpos = blockhitresult.getBlockPos();
+    public void onProjectileHit(Level level, IBlockData state, BlockHitResult hit, Projectile projectile) {
+        BlockPos blockposition = hit.getBlockPos();
 
-        if (!level.isClientSide && projectile.mayInteract(level, blockpos) && projectile.mayBreak(level)) {
-            level.destroyBlock(blockpos, true, projectile);
+        if (!level.isClientSide && projectile.mayInteract(level, blockposition) && projectile.mayBreak(level)) {
+            // CraftBukkit
+            if (!CraftEventFactory.callEntityChangeBlockEvent(projectile, blockposition, Blocks.AIR.defaultBlockState())) {
+                return;
+            }
+            // CraftBukkit end
+            level.destroyBlock(blockposition, true, projectile);
         }
 
     }
