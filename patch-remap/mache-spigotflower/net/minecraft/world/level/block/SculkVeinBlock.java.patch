--- a/net/minecraft/world/level/block/SculkVeinBlock.java
+++ b/net/minecraft/world/level/block/SculkVeinBlock.java
@@ -17,7 +17,7 @@
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
@@ -33,20 +33,18 @@
     private final MultifaceSpreader sameSpaceSpreader;
 
     @Override
-    @Override
     public MapCodec<SculkVeinBlock> codec() {
         return SculkVeinBlock.CODEC;
     }
 
-    public SculkVeinBlock(BlockBehaviour.Properties blockbehaviour_properties) {
-        super(blockbehaviour_properties);
+    public SculkVeinBlock(BlockBehaviour.Properties properties) {
+        super(properties);
         this.veinSpreader = new MultifaceSpreader(new SculkVeinBlock.SculkVeinSpreaderConfig(MultifaceSpreader.DEFAULT_SPREAD_ORDER));
         this.sameSpaceSpreader = new MultifaceSpreader(new SculkVeinBlock.SculkVeinSpreaderConfig(new MultifaceSpreader.SpreadType[]{MultifaceSpreader.SpreadType.SAME_POSITION}));
-        this.registerDefaultState((BlockState) this.defaultBlockState().setValue(SculkVeinBlock.WATERLOGGED, false));
+        this.registerDefaultState((IBlockData) this.defaultBlockState().setValue(SculkVeinBlock.WATERLOGGED, false));
     }
 
     @Override
-    @Override
     public MultifaceSpreader getSpreader() {
         return this.veinSpreader;
     }
@@ -55,17 +53,17 @@
         return this.sameSpaceSpreader;
     }
 
-    public static boolean regrow(LevelAccessor levelaccessor, BlockPos blockpos, BlockState blockstate, Collection<Direction> collection) {
+    public static boolean regrow(LevelAccessor level, BlockPos pos, IBlockData state, Collection<Direction> directions) {
         boolean flag = false;
-        BlockState blockstate1 = Blocks.SCULK_VEIN.defaultBlockState();
-        Iterator iterator = collection.iterator();
+        IBlockData iblockdata1 = Blocks.SCULK_VEIN.defaultBlockState();
+        Iterator iterator = directions.iterator();
 
         while (iterator.hasNext()) {
-            Direction direction = (Direction) iterator.next();
-            BlockPos blockpos1 = blockpos.relative(direction);
+            Direction enumdirection = (Direction) iterator.next();
+            BlockPos blockposition1 = pos.relative(enumdirection);
 
-            if (canAttachTo(levelaccessor, direction, blockpos1, levelaccessor.getBlockState(blockpos1))) {
-                blockstate1 = (BlockState) blockstate1.setValue(getFaceProperty(direction), true);
+            if (canAttachTo(level, enumdirection, blockposition1, level.getBlockState(blockposition1))) {
+                iblockdata1 = (IBlockData) iblockdata1.setValue(getFaceProperty(enumdirection), true);
                 flag = true;
             }
         }
@@ -73,80 +71,83 @@
         if (!flag) {
             return false;
         } else {
-            if (!blockstate.getFluidState().isEmpty()) {
-                blockstate1 = (BlockState) blockstate1.setValue(SculkVeinBlock.WATERLOGGED, true);
+            if (!state.getFluidState().isEmpty()) {
+                iblockdata1 = (IBlockData) iblockdata1.setValue(SculkVeinBlock.WATERLOGGED, true);
             }
 
-            levelaccessor.setBlock(blockpos, blockstate1, 3);
+            level.setBlock(pos, iblockdata1, 3);
             return true;
         }
     }
 
     @Override
-    @Override
-    public void onDischarged(LevelAccessor levelaccessor, BlockState blockstate, BlockPos blockpos, RandomSource randomsource) {
-        if (blockstate.is((Block) this)) {
-            Direction[] adirection = SculkVeinBlock.DIRECTIONS;
-            int i = adirection.length;
+    public void onDischarged(LevelAccessor level, IBlockData state, BlockPos pos, RandomSource random) {
+        if (state.is((Block) this)) {
+            Direction[] aenumdirection = SculkVeinBlock.DIRECTIONS;
+            int i = aenumdirection.length;
 
             for (int j = 0; j < i; ++j) {
-                Direction direction = adirection[j];
-                BooleanProperty booleanproperty = getFaceProperty(direction);
+                Direction enumdirection = aenumdirection[j];
+                BooleanProperty blockstateboolean = getFaceProperty(enumdirection);
 
-                if ((Boolean) blockstate.getValue(booleanproperty) && levelaccessor.getBlockState(blockpos.relative(direction)).is(Blocks.SCULK)) {
-                    blockstate = (BlockState) blockstate.setValue(booleanproperty, false);
+                if ((Boolean) state.getValue(blockstateboolean) && level.getBlockState(pos.relative(enumdirection)).is(Blocks.SCULK)) {
+                    state = (IBlockData) state.setValue(blockstateboolean, false);
                 }
             }
 
-            if (!hasAnyFace(blockstate)) {
-                FluidState fluidstate = levelaccessor.getFluidState(blockpos);
+            if (!hasAnyFace(state)) {
+                FluidState fluid = level.getFluidState(pos);
 
-                blockstate = (fluidstate.isEmpty() ? Blocks.AIR : Blocks.WATER).defaultBlockState();
+                state = (fluid.isEmpty() ? Blocks.AIR : Blocks.WATER).defaultBlockState();
             }
 
-            levelaccessor.setBlock(blockpos, blockstate, 3);
-            SculkBehaviour.super.onDischarged(levelaccessor, blockstate, blockpos, randomsource);
+            level.setBlock(pos, state, 3);
+            SculkBehaviour.super.onDischarged(level, state, pos, random);
         }
     }
 
     @Override
-    @Override
-    public int attemptUseCharge(SculkSpreader.ChargeCursor sculkspreader_chargecursor, LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource, SculkSpreader sculkspreader, boolean flag) {
-        return flag && this.attemptPlaceSculk(sculkspreader, levelaccessor, sculkspreader_chargecursor.getPos(), randomsource) ? sculkspreader_chargecursor.getCharge() - 1 : (randomsource.nextInt(sculkspreader.chargeDecayRate()) == 0 ? Mth.floor((float) sculkspreader_chargecursor.getCharge() * 0.5F) : sculkspreader_chargecursor.getCharge());
+    public int attemptUseCharge(SculkSpreader.ChargeCursor cursor, LevelAccessor level, BlockPos pos, RandomSource random, SculkSpreader spreader, boolean shouldConvertBlocks) {
+        // CraftBukkit - add source block
+        return shouldConvertBlocks && this.attemptPlaceSculk(spreader, level, cursor.getPos(), random, pos) ? cursor.getCharge() - 1 : (random.nextInt(spreader.chargeDecayRate()) == 0 ? Mth.floor((float) cursor.getCharge() * 0.5F) : cursor.getCharge());
     }
 
-    private boolean attemptPlaceSculk(SculkSpreader sculkspreader, LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource) {
-        BlockState blockstate = levelaccessor.getBlockState(blockpos);
+    private boolean attemptPlaceSculk(SculkSpreader sculkspreader, LevelAccessor generatoraccess, BlockPos blockposition, RandomSource randomsource, BlockPos sourceBlock) { // CraftBukkit
+        IBlockData iblockdata = generatoraccess.getBlockState(blockposition);
         TagKey<Block> tagkey = sculkspreader.replaceableBlocks();
         Iterator iterator = Direction.allShuffled(randomsource).iterator();
 
         while (iterator.hasNext()) {
-            Direction direction = (Direction) iterator.next();
+            Direction enumdirection = (Direction) iterator.next();
 
-            if (hasFace(blockstate, direction)) {
-                BlockPos blockpos1 = blockpos.relative(direction);
-                BlockState blockstate1 = levelaccessor.getBlockState(blockpos1);
+            if (hasFace(iblockdata, enumdirection)) {
+                BlockPos blockposition1 = blockposition.relative(enumdirection);
+                IBlockData iblockdata1 = generatoraccess.getBlockState(blockposition1);
 
-                if (blockstate1.is(tagkey)) {
-                    BlockState blockstate2 = Blocks.SCULK.defaultBlockState();
+                if (iblockdata1.is(tagkey)) {
+                    IBlockData iblockdata2 = Blocks.SCULK.defaultBlockState();
 
-                    levelaccessor.setBlock(blockpos1, blockstate2, 3);
-                    Block.pushEntitiesUp(blockstate1, blockstate2, levelaccessor, blockpos1);
-                    levelaccessor.playSound((Player) null, blockpos1, SoundEvents.SCULK_BLOCK_SPREAD, SoundSource.BLOCKS, 1.0F, 1.0F);
-                    this.veinSpreader.spreadAll(blockstate2, levelaccessor, blockpos1, sculkspreader.isWorldGeneration());
-                    Direction direction1 = direction.getOpposite();
-                    Direction[] adirection = SculkVeinBlock.DIRECTIONS;
-                    int i = adirection.length;
+                    // CraftBukkit start - Call BlockSpreadEvent
+                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockSpreadEvent(generatoraccess, sourceBlock, blockposition1, iblockdata2, 3)) {
+                        return false;
+                    }
+                    // CraftBukkit end
+                    Block.pushEntitiesUp(iblockdata1, iblockdata2, generatoraccess, blockposition1);
+                    generatoraccess.playSound((Player) null, blockposition1, SoundEvents.SCULK_BLOCK_SPREAD, SoundSource.BLOCKS, 1.0F, 1.0F);
+                    this.veinSpreader.spreadAll(iblockdata2, generatoraccess, blockposition1, sculkspreader.isWorldGeneration());
+                    Direction enumdirection1 = enumdirection.getOpposite();
+                    Direction[] aenumdirection = SculkVeinBlock.DIRECTIONS;
+                    int i = aenumdirection.length;
 
                     for (int j = 0; j < i; ++j) {
-                        Direction direction2 = adirection[j];
+                        Direction enumdirection2 = aenumdirection[j];
 
-                        if (direction2 != direction1) {
-                            BlockPos blockpos2 = blockpos1.relative(direction2);
-                            BlockState blockstate3 = levelaccessor.getBlockState(blockpos2);
+                        if (enumdirection2 != enumdirection1) {
+                            BlockPos blockposition2 = blockposition1.relative(enumdirection2);
+                            IBlockData iblockdata3 = generatoraccess.getBlockState(blockposition2);
 
-                            if (blockstate3.is((Block) this)) {
-                                this.onDischarged(levelaccessor, blockstate3, blockpos2, randomsource);
+                            if (iblockdata3.is((Block) this)) {
+                                this.onDischarged(generatoraccess, iblockdata3, blockposition2, randomsource);
                             }
                         }
                     }
@@ -159,17 +160,17 @@
         return false;
     }
 
-    public static boolean hasSubstrateAccess(LevelAccessor levelaccessor, BlockState blockstate, BlockPos blockpos) {
-        if (!blockstate.is(Blocks.SCULK_VEIN)) {
+    public static boolean hasSubstrateAccess(LevelAccessor level, IBlockData state, BlockPos pos) {
+        if (!state.is(Blocks.SCULK_VEIN)) {
             return false;
         } else {
-            Direction[] adirection = SculkVeinBlock.DIRECTIONS;
-            int i = adirection.length;
+            Direction[] aenumdirection = SculkVeinBlock.DIRECTIONS;
+            int i = aenumdirection.length;
 
             for (int j = 0; j < i; ++j) {
-                Direction direction = adirection[j];
+                Direction enumdirection = aenumdirection[j];
 
-                if (hasFace(blockstate, direction) && levelaccessor.getBlockState(blockpos.relative(direction)).is(BlockTags.SCULK_REPLACEABLE)) {
+                if (hasFace(state, enumdirection) && level.getBlockState(pos.relative(enumdirection)).is(BlockTags.SCULK_REPLACEABLE)) {
                     return true;
                 }
             }
@@ -179,75 +180,68 @@
     }
 
     @Override
-    @Override
-    public BlockState updateShape(BlockState blockstate, Direction direction, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, BlockPos blockpos1) {
-        if ((Boolean) blockstate.getValue(SculkVeinBlock.WATERLOGGED)) {
-            levelaccessor.scheduleTick(blockpos, (Fluid) Fluids.WATER, Fluids.WATER.getTickDelay(levelaccessor));
+    public IBlockData updateShape(IBlockData state, Direction direction, IBlockData neighborState, LevelAccessor level, BlockPos pos, BlockPos neighborPos) {
+        if ((Boolean) state.getValue(SculkVeinBlock.WATERLOGGED)) {
+            level.scheduleTick(pos, (Fluid) Fluids.WATER, Fluids.WATER.getTickDelay(level));
         }
 
-        return super.updateShape(blockstate, direction, blockstate1, levelaccessor, blockpos, blockpos1);
+        return super.updateShape(state, direction, neighborState, level, pos, neighborPos);
     }
 
     @Override
-    @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> statedefinition_builder) {
-        super.createBlockStateDefinition(statedefinition_builder);
-        statedefinition_builder.add(SculkVeinBlock.WATERLOGGED);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        super.createBlockStateDefinition(builder);
+        builder.add(SculkVeinBlock.WATERLOGGED);
     }
 
     @Override
-    @Override
-    public boolean canBeReplaced(BlockState blockstate, BlockPlaceContext blockplacecontext) {
-        return !blockplacecontext.getItemInHand().is(Items.SCULK_VEIN) || super.canBeReplaced(blockstate, blockplacecontext);
+    public boolean canBeReplaced(IBlockData state, BlockPlaceContext useContext) {
+        return !useContext.getItemInHand().is(Items.SCULK_VEIN) || super.canBeReplaced(state, useContext);
     }
 
     @Override
-    @Override
-    public FluidState getFluidState(BlockState blockstate) {
-        return (Boolean) blockstate.getValue(SculkVeinBlock.WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(blockstate);
+    public FluidState getFluidState(IBlockData state) {
+        return (Boolean) state.getValue(SculkVeinBlock.WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);
     }
 
     private class SculkVeinSpreaderConfig extends MultifaceSpreader.DefaultSpreaderConfig {
 
         private final MultifaceSpreader.SpreadType[] spreadTypes;
 
-        public SculkVeinSpreaderConfig(MultifaceSpreader.SpreadType... amultifacespreader_spreadtype) {
+        public SculkVeinSpreaderConfig(MultifaceSpreader.SpreadType... amultifacespreader_e) {
             super(SculkVeinBlock.this);
-            this.spreadTypes = amultifacespreader_spreadtype;
+            this.spreadTypes = amultifacespreader_e;
         }
 
         @Override
-        @Override
-        public boolean stateCanBeReplaced(BlockGetter blockgetter, BlockPos blockpos, BlockPos blockpos1, Direction direction, BlockState blockstate) {
-            BlockState blockstate1 = blockgetter.getBlockState(blockpos1.relative(direction));
+        public boolean stateCanBeReplaced(BlockGetter level, BlockPos pos, BlockPos spreadPos, Direction direction, IBlockData state) {
+            IBlockData iblockdata1 = level.getBlockState(spreadPos.relative(direction));
 
-            if (!blockstate1.is(Blocks.SCULK) && !blockstate1.is(Blocks.SCULK_CATALYST) && !blockstate1.is(Blocks.MOVING_PISTON)) {
-                if (blockpos.distManhattan(blockpos1) == 2) {
-                    BlockPos blockpos2 = blockpos.relative(direction.getOpposite());
+            if (!iblockdata1.is(Blocks.SCULK) && !iblockdata1.is(Blocks.SCULK_CATALYST) && !iblockdata1.is(Blocks.MOVING_PISTON)) {
+                if (pos.distManhattan(spreadPos) == 2) {
+                    BlockPos blockposition2 = pos.relative(direction.getOpposite());
 
-                    if (blockgetter.getBlockState(blockpos2).isFaceSturdy(blockgetter, blockpos2, direction)) {
+                    if (level.getBlockState(blockposition2).isFaceSturdy(level, blockposition2, direction)) {
                         return false;
                     }
                 }
 
-                FluidState fluidstate = blockstate.getFluidState();
+                FluidState fluid = state.getFluidState();
 
-                return !fluidstate.isEmpty() && !fluidstate.is((Fluid) Fluids.WATER) ? false : (blockstate.is(BlockTags.FIRE) ? false : blockstate.canBeReplaced() || super.stateCanBeReplaced(blockgetter, blockpos, blockpos1, direction, blockstate));
+                return !fluid.isEmpty() && !fluid.is((Fluid) Fluids.WATER) ? false : (state.is(BlockTags.FIRE) ? false : state.canBeReplaced() || super.stateCanBeReplaced(level, pos, spreadPos, direction, state));
             } else {
                 return false;
             }
         }
 
         @Override
-        @Override
         public MultifaceSpreader.SpreadType[] getSpreadTypes() {
             return this.spreadTypes;
         }
 
         @Override
-        @Override
-        public boolean isOtherBlockValidAsSource(BlockState blockstate) {
-            return !blockstate.is(Blocks.SCULK_VEIN);
+        public boolean isOtherBlockValidAsSource(IBlockData otherBlock) {
+            return !otherBlock.is(Blocks.SCULK_VEIN);
         }
     }
 }
