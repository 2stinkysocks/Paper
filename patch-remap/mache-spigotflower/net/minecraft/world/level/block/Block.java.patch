--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -44,14 +44,14 @@
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.IMaterial;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.gameevent.GameEvent;
@@ -63,14 +63,13 @@
 import net.minecraft.world.phys.shapes.VoxelShape;
 import org.slf4j.Logger;
 
-public class Block extends BlockBehaviour implements ItemLike {
+public class Block extends BlockBehaviour implements IMaterial {
 
     public static final MapCodec<Block> CODEC = simpleCodec(Block::new);
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder;
-    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    public static final IdMapper<IBlockData> BLOCK_STATE_REGISTRY = new IdMapper<>();
     private static final LoadingCache<VoxelShape, Boolean> SHAPE_FULL_BLOCK_CACHE = CacheBuilder.newBuilder().maximumSize(512L).weakKeys().build(new CacheLoader<VoxelShape, Boolean>() {
-        @Override
         public Boolean load(VoxelShape voxelshape) {
             return !Shapes.joinIsNotEmpty(Shapes.block(), voxelshape, BooleanOp.NOT_SAME);
         }
@@ -88,8 +87,8 @@
     public static final float INDESTRUCTIBLE = -1.0F;
     public static final float INSTANT = 0.0F;
     public static final int UPDATE_LIMIT = 512;
-    protected final StateDefinition<Block, BlockState> stateDefinition;
-    private BlockState defaultBlockState;
+    protected final StateDefinition<Block, IBlockData> stateDefinition;
+    private IBlockData defaultBlockState;
     @Nullable
     private String descriptionId;
     @Nullable
@@ -97,7 +96,6 @@
     private static final int CACHE_SIZE = 2048;
     private static final ThreadLocal<Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey>> OCCLUSION_CACHE = ThreadLocal.withInitial(() -> {
         Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = new Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey>(2048, 0.25F) {
-            @Override
             protected void rehash(int i) {}
         };
 
@@ -106,38 +104,37 @@
     });
 
     @Override
-    @Override
     protected MapCodec<? extends Block> codec() {
         return Block.CODEC;
     }
 
-    public static int getId(@Nullable BlockState blockstate) {
-        if (blockstate == null) {
+    public static int getId(@Nullable IBlockData state) {
+        if (state == null) {
             return 0;
         } else {
-            int i = Block.BLOCK_STATE_REGISTRY.getId(blockstate);
+            int i = Block.BLOCK_STATE_REGISTRY.getId(state);
 
             return i == -1 ? 0 : i;
         }
     }
 
-    public static BlockState stateById(int i) {
-        BlockState blockstate = (BlockState) Block.BLOCK_STATE_REGISTRY.byId(i);
+    public static IBlockData stateById(int id) {
+        IBlockData iblockdata = (IBlockData) Block.BLOCK_STATE_REGISTRY.byId(id);
 
-        return blockstate == null ? Blocks.AIR.defaultBlockState() : blockstate;
+        return iblockdata == null ? Blocks.AIR.defaultBlockState() : iblockdata;
     }
 
     public static Block byItem(@Nullable Item item) {
         return item instanceof BlockItem ? ((BlockItem) item).getBlock() : Blocks.AIR;
     }
 
-    public static BlockState pushEntitiesUp(BlockState blockstate, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos) {
-        VoxelShape voxelshape = Shapes.joinUnoptimized(blockstate.getCollisionShape(levelaccessor, blockpos), blockstate1.getCollisionShape(levelaccessor, blockpos), BooleanOp.ONLY_SECOND).move((double) blockpos.getX(), (double) blockpos.getY(), (double) blockpos.getZ());
+    public static IBlockData pushEntitiesUp(IBlockData oldState, IBlockData newState, LevelAccessor level, BlockPos pos) {
+        VoxelShape voxelshape = Shapes.joinUnoptimized(oldState.getCollisionShape(level, pos), newState.getCollisionShape(level, pos), BooleanOp.ONLY_SECOND).move((double) pos.getX(), (double) pos.getY(), (double) pos.getZ());
 
         if (voxelshape.isEmpty()) {
-            return blockstate1;
+            return newState;
         } else {
-            List<Entity> list = levelaccessor.getEntities((Entity) null, voxelshape.bounds());
+            List<Entity> list = level.getEntities((Entity) null, voxelshape.bounds());
             Iterator iterator = list.iterator();
 
             while (iterator.hasNext()) {
@@ -147,55 +144,55 @@
                 entity.teleportRelative(0.0D, 1.0D + d0, 0.0D);
             }
 
-            return blockstate1;
+            return newState;
         }
     }
 
-    public static VoxelShape box(double d0, double d1, double d2, double d3, double d4, double d5) {
-        return Shapes.box(d0 / 16.0D, d1 / 16.0D, d2 / 16.0D, d3 / 16.0D, d4 / 16.0D, d5 / 16.0D);
+    public static VoxelShape box(double x1, double d1, double y1, double d3, double z1, double d5) {
+        return Shapes.box(x1 / 16.0D, d1 / 16.0D, y1 / 16.0D, d3 / 16.0D, z1 / 16.0D, d5 / 16.0D);
     }
 
-    public static BlockState updateFromNeighbourShapes(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos) {
-        BlockState blockstate1 = blockstate;
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
-        Direction[] adirection = Block.UPDATE_SHAPE_ORDER;
-        int i = adirection.length;
+    public static IBlockData updateFromNeighbourShapes(IBlockData currentState, LevelAccessor level, BlockPos pos) {
+        IBlockData iblockdata1 = currentState;
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+        Direction[] aenumdirection = Block.UPDATE_SHAPE_ORDER;
+        int i = aenumdirection.length;
 
         for (int j = 0; j < i; ++j) {
-            Direction direction = adirection[j];
+            Direction enumdirection = aenumdirection[j];
 
-            blockpos_mutableblockpos.setWithOffset(blockpos, direction);
-            blockstate1 = blockstate1.updateShape(direction, levelaccessor.getBlockState(blockpos_mutableblockpos), levelaccessor, blockpos, blockpos_mutableblockpos);
+            blockposition_mutableblockposition.setWithOffset(pos, enumdirection);
+            iblockdata1 = iblockdata1.updateShape(enumdirection, level.getBlockState(blockposition_mutableblockposition), level, pos, blockposition_mutableblockposition);
         }
 
-        return blockstate1;
+        return iblockdata1;
     }
 
-    public static void updateOrDestroy(BlockState blockstate, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, int i) {
-        updateOrDestroy(blockstate, blockstate1, levelaccessor, blockpos, i, 512);
+    public static void updateOrDestroy(IBlockData oldState, IBlockData newState, LevelAccessor level, BlockPos pos, int flags) {
+        updateOrDestroy(oldState, newState, level, pos, flags, 512);
     }
 
-    public static void updateOrDestroy(BlockState blockstate, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, int i, int j) {
-        if (blockstate1 != blockstate) {
-            if (blockstate1.isAir()) {
-                if (!levelaccessor.isClientSide()) {
-                    levelaccessor.destroyBlock(blockpos, (i & 32) == 0, (Entity) null, j);
+    public static void updateOrDestroy(IBlockData oldState, IBlockData newState, LevelAccessor level, BlockPos pos, int flags, int recursionLeft) {
+        if (newState != oldState) {
+            if (newState.isAir()) {
+                if (!level.isClientSide()) {
+                    level.destroyBlock(pos, (flags & 32) == 0, (Entity) null, recursionLeft);
                 }
             } else {
-                levelaccessor.setBlock(blockpos, blockstate1, i & -33, j);
+                level.setBlock(pos, newState, flags & -33, recursionLeft);
             }
         }
 
     }
 
-    public Block(BlockBehaviour.Properties blockbehaviour_properties) {
-        super(blockbehaviour_properties);
+    public Block(BlockBehaviour.Properties properties) {
+        super(properties);
         this.builtInRegistryHolder = BuiltInRegistries.BLOCK.createIntrusiveHolder(this);
-        StateDefinition.Builder<Block, BlockState> statedefinition_builder = new StateDefinition.Builder<>(this);
+        StateDefinition.Builder<Block, IBlockData> blockstatelist_a = new StateDefinition.Builder<>(this);
 
-        this.createBlockStateDefinition(statedefinition_builder);
-        this.stateDefinition = statedefinition_builder.create(Block::defaultBlockState, BlockState::new);
-        this.registerDefaultState((BlockState) this.stateDefinition.any());
+        this.createBlockStateDefinition(blockstatelist_a);
+        this.stateDefinition = blockstatelist_a.create(Block::defaultBlockState, IBlockData::new);
+        this.registerDefaultState((IBlockData) this.stateDefinition.any());
         if (SharedConstants.IS_RUNNING_IN_IDE) {
             String s = this.getClass().getSimpleName();
 
@@ -206,40 +203,40 @@
 
     }
 
-    public static boolean isExceptionForConnection(BlockState blockstate) {
-        return blockstate.getBlock() instanceof LeavesBlock || blockstate.is(Blocks.BARRIER) || blockstate.is(Blocks.CARVED_PUMPKIN) || blockstate.is(Blocks.JACK_O_LANTERN) || blockstate.is(Blocks.MELON) || blockstate.is(Blocks.PUMPKIN) || blockstate.is(BlockTags.SHULKER_BOXES);
+    public static boolean isExceptionForConnection(IBlockData state) {
+        return state.getBlock() instanceof LeavesBlock || state.is(Blocks.BARRIER) || state.is(Blocks.CARVED_PUMPKIN) || state.is(Blocks.JACK_O_LANTERN) || state.is(Blocks.MELON) || state.is(Blocks.PUMPKIN) || state.is(BlockTags.SHULKER_BOXES);
     }
 
-    public boolean isRandomlyTicking(BlockState blockstate) {
+    public boolean isRandomlyTicking(IBlockData state) {
         return this.isRandomlyTicking;
     }
 
-    public static boolean shouldRenderFace(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, Direction direction, BlockPos blockpos1) {
-        BlockState blockstate1 = blockgetter.getBlockState(blockpos1);
+    public static boolean shouldRenderFace(IBlockData state, BlockGetter level, BlockPos offset, Direction face, BlockPos pos) {
+        IBlockData iblockdata1 = level.getBlockState(pos);
 
-        if (blockstate.skipRendering(blockstate1, direction)) {
+        if (state.skipRendering(iblockdata1, face)) {
             return false;
-        } else if (blockstate1.canOcclude()) {
-            Block.BlockStatePairKey block_blockstatepairkey = new Block.BlockStatePairKey(blockstate, blockstate1, direction);
+        } else if (iblockdata1.canOcclude()) {
+            Block.BlockStatePairKey block_a = new Block.BlockStatePairKey(state, iblockdata1, face);
             Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = (Object2ByteLinkedOpenHashMap) Block.OCCLUSION_CACHE.get();
-            byte b0 = object2bytelinkedopenhashmap.getAndMoveToFirst(block_blockstatepairkey);
+            byte b0 = object2bytelinkedopenhashmap.getAndMoveToFirst(block_a);
 
             if (b0 != 127) {
                 return b0 != 0;
             } else {
-                VoxelShape voxelshape = blockstate.getFaceOcclusionShape(blockgetter, blockpos, direction);
+                VoxelShape voxelshape = state.getFaceOcclusionShape(level, offset, face);
 
                 if (voxelshape.isEmpty()) {
                     return true;
                 } else {
-                    VoxelShape voxelshape1 = blockstate1.getFaceOcclusionShape(blockgetter, blockpos1, direction.getOpposite());
+                    VoxelShape voxelshape1 = iblockdata1.getFaceOcclusionShape(level, pos, face.getOpposite());
                     boolean flag = Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.ONLY_FIRST);
 
                     if (object2bytelinkedopenhashmap.size() == 2048) {
                         object2bytelinkedopenhashmap.removeLastByte();
                     }
 
-                    object2bytelinkedopenhashmap.putAndMoveToFirst(block_blockstatepairkey, (byte) (flag ? 1 : 0));
+                    object2bytelinkedopenhashmap.putAndMoveToFirst(block_a, (byte) (flag ? 1 : 0));
                     return flag;
                 }
             }
@@ -248,117 +245,123 @@
         }
     }
 
-    public static boolean canSupportRigidBlock(BlockGetter blockgetter, BlockPos blockpos) {
-        return blockgetter.getBlockState(blockpos).isFaceSturdy(blockgetter, blockpos, Direction.UP, SupportType.RIGID);
+    public static boolean canSupportRigidBlock(BlockGetter level, BlockPos pos) {
+        return level.getBlockState(pos).isFaceSturdy(level, pos, Direction.UP, SupportType.RIGID);
     }
 
-    public static boolean canSupportCenter(LevelReader levelreader, BlockPos blockpos, Direction direction) {
-        BlockState blockstate = levelreader.getBlockState(blockpos);
+    public static boolean canSupportCenter(LevelReader level, BlockPos pos, Direction direction) {
+        IBlockData iblockdata = level.getBlockState(pos);
 
-        return direction == Direction.DOWN && blockstate.is(BlockTags.UNSTABLE_BOTTOM_CENTER) ? false : blockstate.isFaceSturdy(levelreader, blockpos, direction, SupportType.CENTER);
+        return direction == Direction.DOWN && iblockdata.is(BlockTags.UNSTABLE_BOTTOM_CENTER) ? false : iblockdata.isFaceSturdy(level, pos, direction, SupportType.CENTER);
     }
 
-    public static boolean isFaceFull(VoxelShape voxelshape, Direction direction) {
-        VoxelShape voxelshape1 = voxelshape.getFaceShape(direction);
+    public static boolean isFaceFull(VoxelShape shape, Direction face) {
+        VoxelShape voxelshape1 = shape.getFaceShape(face);
 
         return isShapeFullBlock(voxelshape1);
     }
 
-    public static boolean isShapeFullBlock(VoxelShape voxelshape) {
-        return (Boolean) Block.SHAPE_FULL_BLOCK_CACHE.getUnchecked(voxelshape);
+    public static boolean isShapeFullBlock(VoxelShape shape) {
+        return (Boolean) Block.SHAPE_FULL_BLOCK_CACHE.getUnchecked(shape);
     }
 
-    public boolean propagatesSkylightDown(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos) {
-        return !isShapeFullBlock(blockstate.getShape(blockgetter, blockpos)) && blockstate.getFluidState().isEmpty();
+    public boolean propagatesSkylightDown(IBlockData state, BlockGetter level, BlockPos pos) {
+        return !isShapeFullBlock(state.getShape(level, pos)) && state.getFluidState().isEmpty();
     }
 
-    public void animateTick(BlockState blockstate, Level level, BlockPos blockpos, RandomSource randomsource) {}
+    public void animateTick(IBlockData state, Level level, BlockPos pos, RandomSource random) {}
 
-    public void destroy(LevelAccessor levelaccessor, BlockPos blockpos, BlockState blockstate) {}
+    public void destroy(LevelAccessor level, BlockPos pos, IBlockData state) {}
 
-    public static List<ItemStack> getDrops(BlockState blockstate, ServerLevel serverlevel, BlockPos blockpos, @Nullable BlockEntity blockentity) {
-        LootParams.Builder lootparams_builder = (new LootParams.Builder(serverlevel)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(blockpos)).withParameter(LootContextParams.TOOL, ItemStack.EMPTY).withOptionalParameter(LootContextParams.BLOCK_ENTITY, blockentity);
+    public static List<ItemStack> getDrops(IBlockData state, ServerLevel level, BlockPos pos, @Nullable BlockEntity blockEntity) {
+        LootParams.Builder lootparams_a = (new LootParams.Builder(level)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(pos)).withParameter(LootContextParams.TOOL, ItemStack.EMPTY).withOptionalParameter(LootContextParams.BLOCK_ENTITY, blockEntity);
 
-        return blockstate.getDrops(lootparams_builder);
+        return state.getDrops(lootparams_a);
     }
 
-    public static List<ItemStack> getDrops(BlockState blockstate, ServerLevel serverlevel, BlockPos blockpos, @Nullable BlockEntity blockentity, @Nullable Entity entity, ItemStack itemstack) {
-        LootParams.Builder lootparams_builder = (new LootParams.Builder(serverlevel)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(blockpos)).withParameter(LootContextParams.TOOL, itemstack).withOptionalParameter(LootContextParams.THIS_ENTITY, entity).withOptionalParameter(LootContextParams.BLOCK_ENTITY, blockentity);
+    public static List<ItemStack> getDrops(IBlockData state, ServerLevel level, BlockPos pos, @Nullable BlockEntity blockEntity, @Nullable Entity entity, ItemStack tool) {
+        LootParams.Builder lootparams_a = (new LootParams.Builder(level)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(pos)).withParameter(LootContextParams.TOOL, tool).withOptionalParameter(LootContextParams.THIS_ENTITY, entity).withOptionalParameter(LootContextParams.BLOCK_ENTITY, blockEntity);
 
-        return blockstate.getDrops(lootparams_builder);
+        return state.getDrops(lootparams_a);
     }
 
-    public static void dropResources(BlockState blockstate, Level level, BlockPos blockpos) {
+    public static void dropResources(IBlockData state, Level level, BlockPos pos) {
         if (level instanceof ServerLevel) {
-            getDrops(blockstate, (ServerLevel) level, blockpos, (BlockEntity) null).forEach((itemstack) -> {
-                popResource(level, blockpos, itemstack);
+            getDrops(state, (ServerLevel) level, pos, (BlockEntity) null).forEach((itemstack) -> {
+                popResource(level, pos, itemstack);
             });
-            blockstate.spawnAfterBreak((ServerLevel) level, blockpos, ItemStack.EMPTY, true);
+            state.spawnAfterBreak((ServerLevel) level, pos, ItemStack.EMPTY, true);
         }
 
     }
 
-    public static void dropResources(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos, @Nullable BlockEntity blockentity) {
-        if (levelaccessor instanceof ServerLevel) {
-            getDrops(blockstate, (ServerLevel) levelaccessor, blockpos, blockentity).forEach((itemstack) -> {
-                popResource((ServerLevel) levelaccessor, blockpos, itemstack);
+    public static void dropResources(IBlockData state, LevelAccessor level, BlockPos pos, @Nullable BlockEntity blockEntity) {
+        if (level instanceof ServerLevel) {
+            getDrops(state, (ServerLevel) level, pos, blockEntity).forEach((itemstack) -> {
+                popResource((ServerLevel) level, pos, itemstack);
             });
-            blockstate.spawnAfterBreak((ServerLevel) levelaccessor, blockpos, ItemStack.EMPTY, true);
+            state.spawnAfterBreak((ServerLevel) level, pos, ItemStack.EMPTY, true);
         }
 
     }
 
-    public static void dropResources(BlockState blockstate, Level level, BlockPos blockpos, @Nullable BlockEntity blockentity, @Nullable Entity entity, ItemStack itemstack) {
+    public static void dropResources(IBlockData state, Level level, BlockPos pos, @Nullable BlockEntity blockEntity, @Nullable Entity entity, ItemStack tool) {
         if (level instanceof ServerLevel) {
-            getDrops(blockstate, (ServerLevel) level, blockpos, blockentity, entity, itemstack).forEach((itemstack1) -> {
-                popResource(level, blockpos, itemstack1);
+            getDrops(state, (ServerLevel) level, pos, blockEntity, entity, tool).forEach((itemstack1) -> {
+                popResource(level, pos, itemstack1);
             });
-            blockstate.spawnAfterBreak((ServerLevel) level, blockpos, itemstack, true);
+            state.spawnAfterBreak((ServerLevel) level, pos, tool, true);
         }
 
     }
 
-    public static void popResource(Level level, BlockPos blockpos, ItemStack itemstack) {
+    public static void popResource(Level level, BlockPos pos, ItemStack stack) {
         double d0 = (double) EntityType.ITEM.getHeight() / 2.0D;
-        double d1 = (double) blockpos.getX() + 0.5D + Mth.nextDouble(level.random, -0.25D, 0.25D);
-        double d2 = (double) blockpos.getY() + 0.5D + Mth.nextDouble(level.random, -0.25D, 0.25D) - d0;
-        double d3 = (double) blockpos.getZ() + 0.5D + Mth.nextDouble(level.random, -0.25D, 0.25D);
+        double d1 = (double) pos.getX() + 0.5D + Mth.nextDouble(level.random, -0.25D, 0.25D);
+        double d2 = (double) pos.getY() + 0.5D + Mth.nextDouble(level.random, -0.25D, 0.25D) - d0;
+        double d3 = (double) pos.getZ() + 0.5D + Mth.nextDouble(level.random, -0.25D, 0.25D);
 
         popResource(level, () -> {
-            return new ItemEntity(level, d1, d2, d3, itemstack);
-        }, itemstack);
+            return new ItemEntity(level, d1, d2, d3, stack);
+        }, stack);
     }
 
-    public static void popResourceFromFace(Level level, BlockPos blockpos, Direction direction, ItemStack itemstack) {
+    public static void popResourceFromFace(Level level, BlockPos pos, Direction direction, ItemStack stack) {
         int i = direction.getStepX();
         int j = direction.getStepY();
         int k = direction.getStepZ();
         double d0 = (double) EntityType.ITEM.getWidth() / 2.0D;
         double d1 = (double) EntityType.ITEM.getHeight() / 2.0D;
-        double d2 = (double) blockpos.getX() + 0.5D + (i == 0 ? Mth.nextDouble(level.random, -0.25D, 0.25D) : (double) i * (0.5D + d0));
-        double d3 = (double) blockpos.getY() + 0.5D + (j == 0 ? Mth.nextDouble(level.random, -0.25D, 0.25D) : (double) j * (0.5D + d1)) - d1;
-        double d4 = (double) blockpos.getZ() + 0.5D + (k == 0 ? Mth.nextDouble(level.random, -0.25D, 0.25D) : (double) k * (0.5D + d0));
+        double d2 = (double) pos.getX() + 0.5D + (i == 0 ? Mth.nextDouble(level.random, -0.25D, 0.25D) : (double) i * (0.5D + d0));
+        double d3 = (double) pos.getY() + 0.5D + (j == 0 ? Mth.nextDouble(level.random, -0.25D, 0.25D) : (double) j * (0.5D + d1)) - d1;
+        double d4 = (double) pos.getZ() + 0.5D + (k == 0 ? Mth.nextDouble(level.random, -0.25D, 0.25D) : (double) k * (0.5D + d0));
         double d5 = i == 0 ? Mth.nextDouble(level.random, -0.1D, 0.1D) : (double) i * 0.1D;
         double d6 = j == 0 ? Mth.nextDouble(level.random, 0.0D, 0.1D) : (double) j * 0.1D + 0.1D;
         double d7 = k == 0 ? Mth.nextDouble(level.random, -0.1D, 0.1D) : (double) k * 0.1D;
 
         popResource(level, () -> {
-            return new ItemEntity(level, d2, d3, d4, itemstack, d5, d6, d7);
-        }, itemstack);
+            return new ItemEntity(level, d2, d3, d4, stack, d5, d6, d7);
+        }, stack);
     }
 
-    private static void popResource(Level level, Supplier<ItemEntity> supplier, ItemStack itemstack) {
-        if (!level.isClientSide && !itemstack.isEmpty() && level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
-            ItemEntity itementity = (ItemEntity) supplier.get();
+    private static void popResource(Level level, Supplier<ItemEntity> itemEntitySupplier, ItemStack stack) {
+        if (!level.isClientSide && !stack.isEmpty() && level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+            ItemEntity entityitem = (ItemEntity) itemEntitySupplier.get();
 
-            itementity.setDefaultPickUpDelay();
-            level.addFreshEntity(itementity);
+            entityitem.setDefaultPickUpDelay();
+            // CraftBukkit start
+            if (level.captureDrops != null) {
+                level.captureDrops.add(entityitem);
+            } else {
+                level.addFreshEntity(entityitem);
+            }
+            // CraftBukkit end
         }
     }
 
-    protected void popExperience(ServerLevel serverlevel, BlockPos blockpos, int i) {
-        if (serverlevel.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
-            ExperienceOrb.award(serverlevel, Vec3.atCenterOf(blockpos), i);
+    public void popExperience(ServerLevel level, BlockPos pos, int amount) {
+        if (level.getGameRules().getBoolean(GameRules.RULE_DOBLOCKDROPS)) {
+            ExperienceOrb.award(level, Vec3.atCenterOf(pos), amount);
         }
 
     }
@@ -367,25 +370,25 @@
         return this.explosionResistance;
     }
 
-    public void wasExploded(Level level, BlockPos blockpos, Explosion explosion) {}
+    public void wasExploded(Level level, BlockPos pos, Explosion explosion) {}
 
-    public void stepOn(Level level, BlockPos blockpos, BlockState blockstate, Entity entity) {}
+    public void stepOn(Level level, BlockPos pos, IBlockData state, Entity entity) {}
 
     @Nullable
-    public BlockState getStateForPlacement(BlockPlaceContext blockplacecontext) {
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
         return this.defaultBlockState();
     }
 
-    public void playerDestroy(Level level, Player player, BlockPos blockpos, BlockState blockstate, @Nullable BlockEntity blockentity, ItemStack itemstack) {
+    public void playerDestroy(Level level, Player player, BlockPos pos, IBlockData state, @Nullable BlockEntity blockEntity, ItemStack tool) {
         player.awardStat(Stats.BLOCK_MINED.get(this));
-        player.causeFoodExhaustion(0.005F);
-        dropResources(blockstate, level, blockpos, blockentity, player, itemstack);
+        player.causeFoodExhaustion(0.005F, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.BLOCK_MINED); // CraftBukkit - EntityExhaustionEvent
+        dropResources(state, level, pos, blockEntity, player, tool);
     }
 
-    public void setPlacedBy(Level level, BlockPos blockpos, BlockState blockstate, @Nullable LivingEntity livingentity, ItemStack itemstack) {}
+    public void setPlacedBy(Level level, BlockPos pos, IBlockData state, @Nullable LivingEntity placer, ItemStack stack) {}
 
-    public boolean isPossibleToRespawnInThis(BlockState blockstate) {
-        return !blockstate.isSolid() && !blockstate.liquid();
+    public boolean isPossibleToRespawnInThis(IBlockData state) {
+        return !state.isSolid() && !state.liquid();
     }
 
     public MutableComponent getName() {
@@ -400,15 +403,15 @@
         return this.descriptionId;
     }
 
-    public void fallOn(Level level, BlockState blockstate, BlockPos blockpos, Entity entity, float f) {
-        entity.causeFallDamage(f, 1.0F, entity.damageSources().fall());
+    public void fallOn(Level level, IBlockData state, BlockPos pos, Entity entity, float fallDistance) {
+        entity.causeFallDamage(fallDistance, 1.0F, entity.damageSources().fall());
     }
 
-    public void updateEntityAfterFallOn(BlockGetter blockgetter, Entity entity) {
+    public void updateEntityAfterFallOn(BlockGetter level, Entity entity) {
         entity.setDeltaMovement(entity.getDeltaMovement().multiply(1.0D, 0.0D, 1.0D));
     }
 
-    public ItemStack getCloneItemStack(LevelReader levelreader, BlockPos blockpos, BlockState blockstate) {
+    public ItemStack getCloneItemStack(LevelReader iworldreader, BlockPos blockposition, IBlockData iblockdata) {
         return new ItemStack(this);
     }
 
@@ -424,65 +427,64 @@
         return this.jumpFactor;
     }
 
-    protected void spawnDestroyParticles(Level level, Player player, BlockPos blockpos, BlockState blockstate) {
-        level.levelEvent(player, 2001, blockpos, getId(blockstate));
+    protected void spawnDestroyParticles(Level level, Player player, BlockPos pos, IBlockData state) {
+        level.levelEvent(player, 2001, pos, getId(state));
     }
 
-    public BlockState playerWillDestroy(Level level, BlockPos blockpos, BlockState blockstate, Player player) {
-        this.spawnDestroyParticles(level, player, blockpos, blockstate);
-        if (blockstate.is(BlockTags.GUARDED_BY_PIGLINS)) {
-            PiglinAi.angerNearbyPiglins(player, false);
+    public IBlockData playerWillDestroy(Level world, BlockPos blockposition, IBlockData iblockdata, Player entityhuman) {
+        this.spawnDestroyParticles(world, entityhuman, blockposition, iblockdata);
+        if (iblockdata.is(BlockTags.GUARDED_BY_PIGLINS)) {
+            PiglinAi.angerNearbyPiglins(entityhuman, false);
         }
 
-        level.gameEvent(GameEvent.BLOCK_DESTROY, blockpos, GameEvent.Context.of(player, blockstate));
-        return blockstate;
+        world.gameEvent(GameEvent.BLOCK_DESTROY, blockposition, GameEvent.Context.of(entityhuman, iblockdata));
+        return iblockdata;
     }
 
-    public void handlePrecipitation(BlockState blockstate, Level level, BlockPos blockpos, Biome.Precipitation biome_precipitation) {}
+    public void handlePrecipitation(IBlockData state, Level level, BlockPos pos, Biome.Precipitation precipitation) {}
 
     public boolean dropFromExplosion(Explosion explosion) {
         return true;
     }
 
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> statedefinition_builder) {}
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {}
 
-    public StateDefinition<Block, BlockState> getStateDefinition() {
+    public StateDefinition<Block, IBlockData> getStateDefinition() {
         return this.stateDefinition;
     }
 
-    protected final void registerDefaultState(BlockState blockstate) {
-        this.defaultBlockState = blockstate;
+    protected final void registerDefaultState(IBlockData state) {
+        this.defaultBlockState = state;
     }
 
-    public final BlockState defaultBlockState() {
+    public final IBlockData defaultBlockState() {
         return this.defaultBlockState;
     }
 
-    public final BlockState withPropertiesOf(BlockState blockstate) {
-        BlockState blockstate1 = this.defaultBlockState();
-        Iterator iterator = blockstate.getBlock().getStateDefinition().getProperties().iterator();
+    public final IBlockData withPropertiesOf(IBlockData state) {
+        IBlockData iblockdata1 = this.defaultBlockState();
+        Iterator iterator = state.getBlock().getStateDefinition().getProperties().iterator();
 
         while (iterator.hasNext()) {
-            Property<?> property = (Property) iterator.next();
+            Property<?> iblockstate = (Property) iterator.next();
 
-            if (blockstate1.hasProperty(property)) {
-                blockstate1 = copyProperty(blockstate, blockstate1, property);
+            if (iblockdata1.hasProperty(iblockstate)) {
+                iblockdata1 = copyProperty(state, iblockdata1, iblockstate);
             }
         }
 
-        return blockstate1;
+        return iblockdata1;
     }
 
-    private static <T extends Comparable<T>> BlockState copyProperty(BlockState blockstate, BlockState blockstate1, Property<T> property) {
-        return (BlockState) blockstate1.setValue(property, blockstate.getValue(property));
+    private static <T extends Comparable<T>> IBlockData copyProperty(IBlockData sourceState, IBlockData targetState, Property<T> property) {
+        return (IBlockData) targetState.setValue(property, sourceState.getValue(property));
     }
 
-    public SoundType getSoundType(BlockState blockstate) {
+    public SoundType getSoundType(IBlockData state) {
         return this.soundType;
     }
 
     @Override
-    @Override
     public Item asItem() {
         if (this.item == null) {
             this.item = Item.byBlock(this);
@@ -495,21 +497,19 @@
         return this.dynamicShape;
     }
 
-    @Override
     public String toString() {
         return "Block{" + BuiltInRegistries.BLOCK.getKey(this) + "}";
     }
 
-    public void appendHoverText(ItemStack itemstack, @Nullable BlockGetter blockgetter, List<Component> list, TooltipFlag tooltipflag) {}
+    public void appendHoverText(ItemStack stack, @Nullable BlockGetter level, List<Component> tooltip, TooltipFlag flag) {}
 
     @Override
-    @Override
     protected Block asBlock() {
         return this;
     }
 
-    protected ImmutableMap<BlockState, VoxelShape> getShapeForEachState(Function<BlockState, VoxelShape> function) {
-        return (ImmutableMap) this.stateDefinition.getPossibleStates().stream().collect(ImmutableMap.toImmutableMap(Function.identity(), function));
+    protected ImmutableMap<IBlockData, VoxelShape> getShapeForEachState(Function<IBlockData, VoxelShape> shapeGetter) {
+        return (ImmutableMap) this.stateDefinition.getPossibleStates().stream().collect(ImmutableMap.toImmutableMap(Function.identity(), shapeGetter));
     }
 
     /** @deprecated */
@@ -518,43 +518,49 @@
         return this.builtInRegistryHolder;
     }
 
-    protected void tryDropExperience(ServerLevel serverlevel, BlockPos blockpos, ItemStack itemstack, IntProvider intprovider) {
+    // CraftBukkit start
+    protected int tryDropExperience(ServerLevel worldserver, BlockPos blockposition, ItemStack itemstack, IntProvider intprovider) {
         if (EnchantmentHelper.getItemEnchantmentLevel(Enchantments.SILK_TOUCH, itemstack) == 0) {
-            int i = intprovider.sample(serverlevel.random);
+            int i = intprovider.sample(worldserver.random);
 
             if (i > 0) {
-                this.popExperience(serverlevel, blockpos, i);
+                // this.popExperience(worldserver, blockposition, i);
+                return i;
             }
         }
 
+        return 0;
     }
 
+    public int getExpDrop(IBlockData iblockdata, ServerLevel worldserver, BlockPos blockposition, ItemStack itemstack, boolean flag) {
+        return 0;
+    }
+    // CraftBukkit end
+
     public static final class BlockStatePairKey {
 
-        private final BlockState first;
-        private final BlockState second;
+        private final IBlockData first;
+        private final IBlockData second;
         private final Direction direction;
 
-        public BlockStatePairKey(BlockState blockstate, BlockState blockstate1, Direction direction) {
-            this.first = blockstate;
-            this.second = blockstate1;
+        public BlockStatePairKey(IBlockData first, IBlockData second, Direction direction) {
+            this.first = first;
+            this.second = second;
             this.direction = direction;
         }
 
-        @Override
         public boolean equals(Object object) {
             if (this == object) {
                 return true;
             } else if (!(object instanceof Block.BlockStatePairKey)) {
                 return false;
             } else {
-                Block.BlockStatePairKey block_blockstatepairkey = (Block.BlockStatePairKey) object;
+                Block.BlockStatePairKey block_a = (Block.BlockStatePairKey) object;
 
-                return this.first == block_blockstatepairkey.first && this.second == block_blockstatepairkey.second && this.direction == block_blockstatepairkey.direction;
+                return this.first == block_a.first && this.second == block_a.second && this.direction == block_a.direction;
             }
         }
 
-        @Override
         public int hashCode() {
             int i = this.first.hashCode();
 
