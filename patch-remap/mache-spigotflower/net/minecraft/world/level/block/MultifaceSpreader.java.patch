--- a/net/minecraft/world/level/block/MultifaceSpreader.java
+++ b/net/minecraft/world/level/block/MultifaceSpreader.java
@@ -9,83 +9,83 @@
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.LevelAccessor;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 
 public class MultifaceSpreader {
 
     public static final MultifaceSpreader.SpreadType[] DEFAULT_SPREAD_ORDER = new MultifaceSpreader.SpreadType[]{MultifaceSpreader.SpreadType.SAME_POSITION, MultifaceSpreader.SpreadType.SAME_PLANE, MultifaceSpreader.SpreadType.WRAP_AROUND};
     private final MultifaceSpreader.SpreadConfig config;
 
-    public MultifaceSpreader(MultifaceBlock multifaceblock) {
-        this((MultifaceSpreader.SpreadConfig) (new MultifaceSpreader.DefaultSpreaderConfig(multifaceblock)));
+    public MultifaceSpreader(MultifaceBlock block) {
+        this((MultifaceSpreader.SpreadConfig) (new MultifaceSpreader.DefaultSpreaderConfig(block)));
     }
 
-    public MultifaceSpreader(MultifaceSpreader.SpreadConfig multifacespreader_spreadconfig) {
-        this.config = multifacespreader_spreadconfig;
+    public MultifaceSpreader(MultifaceSpreader.SpreadConfig config) {
+        this.config = config;
     }
 
-    public boolean canSpreadInAnyDirection(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, Direction direction) {
-        return Direction.stream().anyMatch((direction1) -> {
-            MultifaceSpreader.SpreadConfig multifacespreader_spreadconfig = this.config;
+    public boolean canSpreadInAnyDirection(IBlockData state, BlockGetter level, BlockPos pos, Direction spreadDirection) {
+        return Direction.stream().anyMatch((enumdirection1) -> {
+            MultifaceSpreader.SpreadConfig multifacespreader_b = this.config;
 
             Objects.requireNonNull(this.config);
-            return this.getSpreadFromFaceTowardDirection(blockstate, blockgetter, blockpos, direction, direction1, multifacespreader_spreadconfig::canSpreadInto).isPresent();
+            return this.getSpreadFromFaceTowardDirection(state, level, pos, spreadDirection, enumdirection1, multifacespreader_b::canSpreadInto).isPresent();
         });
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> spreadFromRandomFaceTowardRandomDirection(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource) {
-        return (Optional) Direction.allShuffled(randomsource).stream().filter((direction) -> {
-            return this.config.canSpreadFrom(blockstate, direction);
-        }).map((direction) -> {
-            return this.spreadFromFaceTowardRandomDirection(blockstate, levelaccessor, blockpos, direction, randomsource, false);
+    public Optional<MultifaceSpreader.c> spreadFromRandomFaceTowardRandomDirection(IBlockData state, LevelAccessor level, BlockPos pos, RandomSource random) {
+        return (Optional) Direction.allShuffled(random).stream().filter((enumdirection) -> {
+            return this.config.canSpreadFrom(state, enumdirection);
+        }).map((enumdirection) -> {
+            return this.spreadFromFaceTowardRandomDirection(state, level, pos, enumdirection, random, false);
         }).filter(Optional::isPresent).findFirst().orElse(Optional.empty());
     }
 
-    public long spreadAll(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos, boolean flag) {
-        return (Long) Direction.stream().filter((direction) -> {
-            return this.config.canSpreadFrom(blockstate, direction);
-        }).map((direction) -> {
-            return this.spreadFromFaceTowardAllDirections(blockstate, levelaccessor, blockpos, direction, flag);
+    public long spreadAll(IBlockData state, LevelAccessor level, BlockPos pos, boolean markForPostprocessing) {
+        return (Long) Direction.stream().filter((enumdirection) -> {
+            return this.config.canSpreadFrom(state, enumdirection);
+        }).map((enumdirection) -> {
+            return this.spreadFromFaceTowardAllDirections(state, level, pos, enumdirection, markForPostprocessing);
         }).reduce(0L, Long::sum);
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> spreadFromFaceTowardRandomDirection(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos, Direction direction, RandomSource randomsource, boolean flag) {
-        return (Optional) Direction.allShuffled(randomsource).stream().map((direction1) -> {
-            return this.spreadFromFaceTowardDirection(blockstate, levelaccessor, blockpos, direction, direction1, flag);
+    public Optional<MultifaceSpreader.c> spreadFromFaceTowardRandomDirection(IBlockData state, LevelAccessor level, BlockPos pos, Direction spreadDirection, RandomSource random, boolean markForPostprocessing) {
+        return (Optional) Direction.allShuffled(random).stream().map((enumdirection1) -> {
+            return this.spreadFromFaceTowardDirection(state, level, pos, spreadDirection, enumdirection1, markForPostprocessing);
         }).filter(Optional::isPresent).findFirst().orElse(Optional.empty());
     }
 
-    private long spreadFromFaceTowardAllDirections(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos, Direction direction, boolean flag) {
-        return Direction.stream().map((direction1) -> {
-            return this.spreadFromFaceTowardDirection(blockstate, levelaccessor, blockpos, direction, direction1, flag);
+    private long spreadFromFaceTowardAllDirections(IBlockData state, LevelAccessor level, BlockPos pos, Direction spreadDirection, boolean markForPostprocessing) {
+        return Direction.stream().map((enumdirection1) -> {
+            return this.spreadFromFaceTowardDirection(state, level, pos, spreadDirection, enumdirection1, markForPostprocessing);
         }).filter(Optional::isPresent).count();
     }
 
     @VisibleForTesting
-    public Optional<MultifaceSpreader.SpreadPos> spreadFromFaceTowardDirection(BlockState blockstate, LevelAccessor levelaccessor, BlockPos blockpos, Direction direction, Direction direction1, boolean flag) {
-        MultifaceSpreader.SpreadConfig multifacespreader_spreadconfig = this.config;
+    public Optional<MultifaceSpreader.c> spreadFromFaceTowardDirection(IBlockData state, LevelAccessor level, BlockPos pos, Direction spreadDirection, Direction face, boolean markForPostprocessing) {
+        MultifaceSpreader.SpreadConfig multifacespreader_b = this.config;
 
         Objects.requireNonNull(this.config);
-        return this.getSpreadFromFaceTowardDirection(blockstate, levelaccessor, blockpos, direction, direction1, multifacespreader_spreadconfig::canSpreadInto).flatMap((multifacespreader_spreadpos) -> {
-            return this.spreadToFace(levelaccessor, multifacespreader_spreadpos, flag);
+        return this.getSpreadFromFaceTowardDirection(state, level, pos, spreadDirection, face, multifacespreader_b::canSpreadInto).flatMap((multifacespreader_c) -> {
+            return this.spreadToFace(level, multifacespreader_c, markForPostprocessing);
         });
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> getSpreadFromFaceTowardDirection(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, Direction direction, Direction direction1, MultifaceSpreader.SpreadPredicate multifacespreader_spreadpredicate) {
-        if (direction1.getAxis() == direction.getAxis()) {
+    public Optional<MultifaceSpreader.c> getSpreadFromFaceTowardDirection(IBlockData state, BlockGetter level, BlockPos pos, Direction spreadDirection, Direction face, MultifaceSpreader.SpreadPredicate predicate) {
+        if (face.getAxis() == spreadDirection.getAxis()) {
             return Optional.empty();
-        } else if (!this.config.isOtherBlockValidAsSource(blockstate) && (!this.config.hasFace(blockstate, direction) || this.config.hasFace(blockstate, direction1))) {
+        } else if (!this.config.isOtherBlockValidAsSource(state) && (!this.config.hasFace(state, spreadDirection) || this.config.hasFace(state, face))) {
             return Optional.empty();
         } else {
-            MultifaceSpreader.SpreadType[] amultifacespreader_spreadtype = this.config.getSpreadTypes();
-            int i = amultifacespreader_spreadtype.length;
+            MultifaceSpreader.SpreadType[] amultifacespreader_e = this.config.getSpreadTypes();
+            int i = amultifacespreader_e.length;
 
             for (int j = 0; j < i; ++j) {
-                MultifaceSpreader.SpreadType multifacespreader_spreadtype = amultifacespreader_spreadtype[j];
-                MultifaceSpreader.SpreadPos multifacespreader_spreadpos = multifacespreader_spreadtype.getSpreadPos(blockpos, direction1, direction);
+                MultifaceSpreader.SpreadType multifacespreader_e = amultifacespreader_e[j];
+                MultifaceSpreader.c multifacespreader_c = multifacespreader_e.getSpreadPos(pos, face, spreadDirection);
 
-                if (multifacespreader_spreadpredicate.test(blockgetter, blockpos, multifacespreader_spreadpos)) {
-                    return Optional.of(multifacespreader_spreadpos);
+                if (predicate.test(level, pos, multifacespreader_c)) {
+                    return Optional.of(multifacespreader_c);
                 }
             }
 
@@ -93,72 +93,70 @@
         }
     }
 
-    public Optional<MultifaceSpreader.SpreadPos> spreadToFace(LevelAccessor levelaccessor, MultifaceSpreader.SpreadPos multifacespreader_spreadpos, boolean flag) {
-        BlockState blockstate = levelaccessor.getBlockState(multifacespreader_spreadpos.pos());
+    public Optional<MultifaceSpreader.c> spreadToFace(LevelAccessor level, MultifaceSpreader.c pos, boolean markForPostprocessing) {
+        IBlockData iblockdata = level.getBlockState(pos.pos());
 
-        return this.config.placeBlock(levelaccessor, multifacespreader_spreadpos, blockstate, flag) ? Optional.of(multifacespreader_spreadpos) : Optional.empty();
+        return this.config.placeBlock(level, pos, iblockdata, markForPostprocessing) ? Optional.of(pos) : Optional.empty();
     }
 
     public static class DefaultSpreaderConfig implements MultifaceSpreader.SpreadConfig {
 
         protected MultifaceBlock block;
 
-        public DefaultSpreaderConfig(MultifaceBlock multifaceblock) {
-            this.block = multifaceblock;
+        public DefaultSpreaderConfig(MultifaceBlock block) {
+            this.block = block;
         }
 
         @Nullable
         @Override
-        @Override
-        public BlockState getStateForPlacement(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, Direction direction) {
-            return this.block.getStateForPlacement(blockstate, blockgetter, blockpos, direction);
+        public IBlockData getStateForPlacement(IBlockData currentState, BlockGetter level, BlockPos pos, Direction lookingDirection) {
+            return this.block.getStateForPlacement(currentState, level, pos, lookingDirection);
         }
 
-        protected boolean stateCanBeReplaced(BlockGetter blockgetter, BlockPos blockpos, BlockPos blockpos1, Direction direction, BlockState blockstate) {
-            return blockstate.isAir() || blockstate.is((Block) this.block) || blockstate.is(Blocks.WATER) && blockstate.getFluidState().isSource();
+        protected boolean stateCanBeReplaced(BlockGetter level, BlockPos pos, BlockPos spreadPos, Direction direction, IBlockData state) {
+            return state.isAir() || state.is((Block) this.block) || state.is(Blocks.WATER) && state.getFluidState().isSource();
         }
 
         @Override
-        @Override
-        public boolean canSpreadInto(BlockGetter blockgetter, BlockPos blockpos, MultifaceSpreader.SpreadPos multifacespreader_spreadpos) {
-            BlockState blockstate = blockgetter.getBlockState(multifacespreader_spreadpos.pos());
+        public boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.c spreadPos) {
+            IBlockData iblockdata = level.getBlockState(spreadPos.pos());
 
-            return this.stateCanBeReplaced(blockgetter, blockpos, multifacespreader_spreadpos.pos(), multifacespreader_spreadpos.face(), blockstate) && this.block.isValidStateForPlacement(blockgetter, blockstate, multifacespreader_spreadpos.pos(), multifacespreader_spreadpos.face());
+            return this.stateCanBeReplaced(level, pos, spreadPos.pos(), spreadPos.face(), iblockdata) && this.block.isValidStateForPlacement(level, iblockdata, spreadPos.pos(), spreadPos.face());
         }
     }
 
     public interface SpreadConfig {
 
         @Nullable
-        BlockState getStateForPlacement(BlockState currentState, BlockGetter level, BlockPos pos, Direction lookingDirection);
+        IBlockData getStateForPlacement(IBlockData currentState, BlockGetter level, BlockPos pos, Direction lookingDirection);
 
-        boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.SpreadPos spreadPos);
+        boolean canSpreadInto(BlockGetter level, BlockPos pos, MultifaceSpreader.c spreadPos);
 
         default MultifaceSpreader.SpreadType[] getSpreadTypes() {
             return MultifaceSpreader.DEFAULT_SPREAD_ORDER;
         }
 
-        default boolean hasFace(BlockState blockstate, Direction direction) {
-            return MultifaceBlock.hasFace(blockstate, direction);
+        default boolean hasFace(IBlockData state, Direction direction) {
+            return MultifaceBlock.hasFace(state, direction);
         }
 
-        default boolean isOtherBlockValidAsSource(BlockState blockstate) {
+        default boolean isOtherBlockValidAsSource(IBlockData otherBlock) {
             return false;
         }
 
-        default boolean canSpreadFrom(BlockState blockstate, Direction direction) {
-            return this.isOtherBlockValidAsSource(blockstate) || this.hasFace(blockstate, direction);
+        default boolean canSpreadFrom(IBlockData state, Direction direction) {
+            return this.isOtherBlockValidAsSource(state) || this.hasFace(state, direction);
         }
 
-        default boolean placeBlock(LevelAccessor levelaccessor, MultifaceSpreader.SpreadPos multifacespreader_spreadpos, BlockState blockstate, boolean flag) {
-            BlockState blockstate1 = this.getStateForPlacement(blockstate, levelaccessor, multifacespreader_spreadpos.pos(), multifacespreader_spreadpos.face());
+        default boolean placeBlock(LevelAccessor level, MultifaceSpreader.c pos, IBlockData state, boolean markForPostprocessing) {
+            IBlockData iblockdata1 = this.getStateForPlacement(state, level, pos.pos(), pos.face());
 
-            if (blockstate1 != null) {
-                if (flag) {
-                    levelaccessor.getChunk(multifacespreader_spreadpos.pos()).markPosForPostprocessing(multifacespreader_spreadpos.pos());
+            if (iblockdata1 != null) {
+                if (markForPostprocessing) {
+                    level.getChunk(pos.pos()).markPosForPostprocessing(pos.pos());
                 }
 
-                return levelaccessor.setBlock(multifacespreader_spreadpos.pos(), blockstate1, 2);
+                return org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockSpreadEvent(level, pos.source(), pos.pos(), iblockdata1, 2); // CraftBukkit
             } else {
                 return false;
             }
@@ -168,39 +166,36 @@
     @FunctionalInterface
     public interface SpreadPredicate {
 
-        boolean test(BlockGetter level, BlockPos pos, MultifaceSpreader.SpreadPos spreadPos);
+        boolean test(BlockGetter level, BlockPos pos, MultifaceSpreader.c spreadPos);
     }
 
     public static enum SpreadType {
 
         SAME_POSITION {
             @Override
-            @Override
-            public MultifaceSpreader.SpreadPos getSpreadPos(BlockPos blockpos, Direction direction, Direction direction1) {
-                return new MultifaceSpreader.SpreadPos(blockpos, direction);
+            public MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
+                return new MultifaceSpreader.c(pos, face, pos); // CraftBukkit
             }
         },
         SAME_PLANE {
             @Override
-            @Override
-            public MultifaceSpreader.SpreadPos getSpreadPos(BlockPos blockpos, Direction direction, Direction direction1) {
-                return new MultifaceSpreader.SpreadPos(blockpos.relative(direction), direction1);
+            public MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
+                return new MultifaceSpreader.c(pos.relative(face), spreadDirection, pos); // CraftBukkit
             }
         },
         WRAP_AROUND {
             @Override
-            @Override
-            public MultifaceSpreader.SpreadPos getSpreadPos(BlockPos blockpos, Direction direction, Direction direction1) {
-                return new MultifaceSpreader.SpreadPos(blockpos.relative(direction).relative(direction1), direction.getOpposite());
+            public MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection) {
+                return new MultifaceSpreader.c(pos.relative(face).relative(spreadDirection), face.getOpposite(), pos); // CraftBukkit
             }
         };
 
         SpreadType() {}
 
-        public abstract MultifaceSpreader.SpreadPos getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection);
+        public abstract MultifaceSpreader.c getSpreadPos(BlockPos pos, Direction face, Direction spreadDirection);
     }
 
-    public static record SpreadPos(BlockPos pos, Direction face) {
+    public static record c(BlockPos pos, Direction face, BlockPos source) { // CraftBukkit
 
     }
 }
