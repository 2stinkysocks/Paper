--- a/net/minecraft/world/level/block/CeilingHangingSignBlock.java
+++ b/net/minecraft/world/level/block/CeilingHangingSignBlock.java
@@ -10,7 +10,7 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.tags.BlockTags;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.HangingSignItem;
@@ -26,7 +26,7 @@
 import net.minecraft.world.level.block.entity.HangingSignBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
@@ -51,129 +51,116 @@
     private static final Map<Integer, VoxelShape> AABBS = Maps.newHashMap(ImmutableMap.of(0, Block.box(1.0D, 0.0D, 7.0D, 15.0D, 10.0D, 9.0D), 4, Block.box(7.0D, 0.0D, 1.0D, 9.0D, 10.0D, 15.0D), 8, Block.box(1.0D, 0.0D, 7.0D, 15.0D, 10.0D, 9.0D), 12, Block.box(7.0D, 0.0D, 1.0D, 9.0D, 10.0D, 15.0D)));
 
     @Override
-    @Override
     public MapCodec<CeilingHangingSignBlock> codec() {
         return CeilingHangingSignBlock.CODEC;
     }
 
-    public CeilingHangingSignBlock(WoodType woodtype, BlockBehaviour.Properties blockbehaviour_properties) {
-        super(woodtype, blockbehaviour_properties.sound(woodtype.hangingSignSoundType()));
-        this.registerDefaultState((BlockState) ((BlockState) ((BlockState) ((BlockState) this.stateDefinition.any()).setValue(CeilingHangingSignBlock.ROTATION, 0)).setValue(CeilingHangingSignBlock.ATTACHED, false)).setValue(CeilingHangingSignBlock.WATERLOGGED, false));
+    public CeilingHangingSignBlock(WoodType blockpropertywood, BlockBehaviour.Properties blockbase_info) {
+        super(blockpropertywood, blockbase_info.sound(blockpropertywood.hangingSignSoundType()));
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(CeilingHangingSignBlock.ROTATION, 0)).setValue(CeilingHangingSignBlock.ATTACHED, false)).setValue(CeilingHangingSignBlock.WATERLOGGED, false));
     }
 
     @Override
-    @Override
-    public InteractionResult use(BlockState blockstate, Level level, BlockPos blockpos, Player player, InteractionHand interactionhand, BlockHitResult blockhitresult) {
-        BlockEntity blockentity = level.getBlockEntity(blockpos);
+    public InteractionResult use(IBlockData state, Level level, BlockPos pos, Player player, EnumHand hand, BlockHitResult hit) {
+        BlockEntity tileentity = level.getBlockEntity(pos);
 
-        if (blockentity instanceof SignBlockEntity) {
-            SignBlockEntity signblockentity = (SignBlockEntity) blockentity;
-            ItemStack itemstack = player.getItemInHand(interactionhand);
+        if (tileentity instanceof SignBlockEntity) {
+            SignBlockEntity tileentitysign = (SignBlockEntity) tileentity;
+            ItemStack itemstack = player.getItemInHand(hand);
 
-            if (this.shouldTryToChainAnotherHangingSign(player, blockhitresult, signblockentity, itemstack)) {
+            if (this.shouldTryToChainAnotherHangingSign(player, hit, tileentitysign, itemstack)) {
                 return InteractionResult.PASS;
             }
         }
 
-        return super.use(blockstate, level, blockpos, player, interactionhand, blockhitresult);
+        return super.use(state, level, pos, player, hand, hit);
     }
 
-    private boolean shouldTryToChainAnotherHangingSign(Player player, BlockHitResult blockhitresult, SignBlockEntity signblockentity, ItemStack itemstack) {
-        return !signblockentity.canExecuteClickCommands(signblockentity.isFacingFrontText(player), player) && itemstack.getItem() instanceof HangingSignItem && blockhitresult.getDirection().equals(Direction.DOWN);
+    private boolean shouldTryToChainAnotherHangingSign(Player player, BlockHitResult hitResult, SignBlockEntity sign, ItemStack stack) {
+        return !sign.canExecuteClickCommands(sign.isFacingFrontText(player), player) && stack.getItem() instanceof HangingSignItem && hitResult.getDirection().equals(Direction.DOWN);
     }
 
     @Override
-    @Override
-    public boolean canSurvive(BlockState blockstate, LevelReader levelreader, BlockPos blockpos) {
-        return levelreader.getBlockState(blockpos.above()).isFaceSturdy(levelreader, blockpos.above(), Direction.DOWN, SupportType.CENTER);
+    public boolean canSurvive(IBlockData state, LevelReader level, BlockPos pos) {
+        return level.getBlockState(pos.above()).isFaceSturdy(level, pos.above(), Direction.DOWN, SupportType.CENTER);
     }
 
     @Override
-    @Override
-    public BlockState getStateForPlacement(BlockPlaceContext blockplacecontext) {
-        Level level = blockplacecontext.getLevel();
-        FluidState fluidstate = level.getFluidState(blockplacecontext.getClickedPos());
-        BlockPos blockpos = blockplacecontext.getClickedPos().above();
-        BlockState blockstate = level.getBlockState(blockpos);
-        boolean flag = blockstate.is(BlockTags.ALL_HANGING_SIGNS);
-        Direction direction = Direction.fromYRot((double) blockplacecontext.getRotation());
-        boolean flag1 = !Block.isFaceFull(blockstate.getCollisionShape(level, blockpos), Direction.DOWN) || blockplacecontext.isSecondaryUseActive();
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        Level world = context.getLevel();
+        FluidState fluid = world.getFluidState(context.getClickedPos());
+        BlockPos blockposition = context.getClickedPos().above();
+        IBlockData iblockdata = world.getBlockState(blockposition);
+        boolean flag = iblockdata.is(BlockTags.ALL_HANGING_SIGNS);
+        Direction enumdirection = Direction.fromYRot((double) context.getRotation());
+        boolean flag1 = !Block.isFaceFull(iblockdata.getCollisionShape(world, blockposition), Direction.DOWN) || context.isSecondaryUseActive();
 
-        if (flag && !blockplacecontext.isSecondaryUseActive()) {
-            if (blockstate.hasProperty(WallHangingSignBlock.FACING)) {
-                Direction direction1 = (Direction) blockstate.getValue(WallHangingSignBlock.FACING);
+        if (flag && !context.isSecondaryUseActive()) {
+            if (iblockdata.hasProperty(WallHangingSignBlock.FACING)) {
+                Direction enumdirection1 = (Direction) iblockdata.getValue(WallHangingSignBlock.FACING);
 
-                if (direction1.getAxis().test(direction)) {
+                if (enumdirection1.getAxis().test(enumdirection)) {
                     flag1 = false;
                 }
-            } else if (blockstate.hasProperty(CeilingHangingSignBlock.ROTATION)) {
-                Optional<Direction> optional = RotationSegment.convertToDirection((Integer) blockstate.getValue(CeilingHangingSignBlock.ROTATION));
+            } else if (iblockdata.hasProperty(CeilingHangingSignBlock.ROTATION)) {
+                Optional<Direction> optional = RotationSegment.convertToDirection((Integer) iblockdata.getValue(CeilingHangingSignBlock.ROTATION));
 
-                if (optional.isPresent() && ((Direction) optional.get()).getAxis().test(direction)) {
+                if (optional.isPresent() && ((Direction) optional.get()).getAxis().test(enumdirection)) {
                     flag1 = false;
                 }
             }
         }
 
-        int i = !flag1 ? RotationSegment.convertToSegment(direction.getOpposite()) : RotationSegment.convertToSegment(blockplacecontext.getRotation() + 180.0F);
+        int i = !flag1 ? RotationSegment.convertToSegment(enumdirection.getOpposite()) : RotationSegment.convertToSegment(context.getRotation() + 180.0F);
 
-        return (BlockState) ((BlockState) ((BlockState) this.defaultBlockState().setValue(CeilingHangingSignBlock.ATTACHED, flag1)).setValue(CeilingHangingSignBlock.ROTATION, i)).setValue(CeilingHangingSignBlock.WATERLOGGED, fluidstate.getType() == Fluids.WATER);
+        return (IBlockData) ((IBlockData) ((IBlockData) this.defaultBlockState().setValue(CeilingHangingSignBlock.ATTACHED, flag1)).setValue(CeilingHangingSignBlock.ROTATION, i)).setValue(CeilingHangingSignBlock.WATERLOGGED, fluid.getType() == Fluids.WATER);
     }
 
     @Override
-    @Override
-    public VoxelShape getShape(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, CollisionContext collisioncontext) {
-        VoxelShape voxelshape = (VoxelShape) CeilingHangingSignBlock.AABBS.get(blockstate.getValue(CeilingHangingSignBlock.ROTATION));
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        VoxelShape voxelshape = (VoxelShape) CeilingHangingSignBlock.AABBS.get(state.getValue(CeilingHangingSignBlock.ROTATION));
 
         return voxelshape == null ? CeilingHangingSignBlock.SHAPE : voxelshape;
     }
 
     @Override
-    @Override
-    public VoxelShape getBlockSupportShape(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos) {
-        return this.getShape(blockstate, blockgetter, blockpos, CollisionContext.empty());
+    public VoxelShape getBlockSupportShape(IBlockData state, BlockGetter level, BlockPos pos) {
+        return this.getShape(state, level, pos, CollisionContext.empty());
     }
 
     @Override
-    @Override
-    public BlockState updateShape(BlockState blockstate, Direction direction, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, BlockPos blockpos1) {
-        return direction == Direction.UP && !this.canSurvive(blockstate, levelaccessor, blockpos) ? Blocks.AIR.defaultBlockState() : super.updateShape(blockstate, direction, blockstate1, levelaccessor, blockpos, blockpos1);
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        return facing == Direction.UP && !this.canSurvive(state, level, currentPos) ? Blocks.AIR.defaultBlockState() : super.updateShape(state, facing, facingState, level, currentPos, facingPos);
     }
 
     @Override
-    @Override
-    public float getYRotationDegrees(BlockState blockstate) {
-        return RotationSegment.convertToDegrees((Integer) blockstate.getValue(CeilingHangingSignBlock.ROTATION));
+    public float getYRotationDegrees(IBlockData state) {
+        return RotationSegment.convertToDegrees((Integer) state.getValue(CeilingHangingSignBlock.ROTATION));
     }
 
     @Override
-    @Override
-    public BlockState rotate(BlockState blockstate, Rotation rotation) {
-        return (BlockState) blockstate.setValue(CeilingHangingSignBlock.ROTATION, rotation.rotate((Integer) blockstate.getValue(CeilingHangingSignBlock.ROTATION), 16));
+    public IBlockData rotate(IBlockData state, Rotation rotation) {
+        return (IBlockData) state.setValue(CeilingHangingSignBlock.ROTATION, rotation.rotate((Integer) state.getValue(CeilingHangingSignBlock.ROTATION), 16));
     }
 
     @Override
-    @Override
-    public BlockState mirror(BlockState blockstate, Mirror mirror) {
-        return (BlockState) blockstate.setValue(CeilingHangingSignBlock.ROTATION, mirror.mirror((Integer) blockstate.getValue(CeilingHangingSignBlock.ROTATION), 16));
+    public IBlockData mirror(IBlockData state, Mirror mirror) {
+        return (IBlockData) state.setValue(CeilingHangingSignBlock.ROTATION, mirror.mirror((Integer) state.getValue(CeilingHangingSignBlock.ROTATION), 16));
     }
 
     @Override
-    @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> statedefinition_builder) {
-        statedefinition_builder.add(CeilingHangingSignBlock.ROTATION, CeilingHangingSignBlock.ATTACHED, CeilingHangingSignBlock.WATERLOGGED);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(CeilingHangingSignBlock.ROTATION, CeilingHangingSignBlock.ATTACHED, CeilingHangingSignBlock.WATERLOGGED);
     }
 
     @Override
-    @Override
-    public BlockEntity newBlockEntity(BlockPos blockpos, BlockState blockstate) {
-        return new HangingSignBlockEntity(blockpos, blockstate);
+    public BlockEntity newBlockEntity(BlockPos pos, IBlockData state) {
+        return new HangingSignBlockEntity(pos, state);
     }
 
     @Nullable
     @Override
-    @Override
-    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState blockstate, BlockEntityType<T> blockentitytype) {
-        return createTickerHelper(blockentitytype, BlockEntityType.HANGING_SIGN, SignBlockEntity::tick);
+    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, IBlockData state, BlockEntityType<T> blockEntityType) {
+        return null; // Craftbukkit - remove unnecessary sign ticking
     }
 }
