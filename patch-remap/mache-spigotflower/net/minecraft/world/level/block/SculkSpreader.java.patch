--- a/net/minecraft/world/level/block/SculkSpreader.java
+++ b/net/minecraft/world/level/block/SculkSpreader.java
@@ -30,6 +30,7 @@
 import net.minecraft.core.Vec3i;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
+import net.minecraft.nbt.Tag;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
@@ -37,9 +38,14 @@
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import org.slf4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.event.block.SculkBloomEvent;
+// CraftBukkit end
 
 public class SculkSpreader {
 
@@ -56,14 +62,15 @@
     private final int additionalDecayRate;
     private List<SculkSpreader.ChargeCursor> cursors = new ArrayList();
     private static final Logger LOGGER = LogUtils.getLogger();
+    public Level level; // CraftBukkit
 
-    public SculkSpreader(boolean flag, TagKey<Block> tagkey, int i, int j, int k, int l) {
-        this.isWorldGeneration = flag;
-        this.replaceableBlocks = tagkey;
-        this.growthSpawnCost = i;
-        this.noGrowthRadius = j;
-        this.chargeDecayRate = k;
-        this.additionalDecayRate = l;
+    public SculkSpreader(boolean isWorldGeneration, TagKey<Block> replaceableBlocks, int growthSpawnCoat, int noGrowthRadius, int chargeDecayRate, int additionalDecayRate) {
+        this.isWorldGeneration = isWorldGeneration;
+        this.replaceableBlocks = replaceableBlocks;
+        this.growthSpawnCost = growthSpawnCoat;
+        this.noGrowthRadius = noGrowthRadius;
+        this.chargeDecayRate = chargeDecayRate;
+        this.additionalDecayRate = additionalDecayRate;
     }
 
     public static SculkSpreader createLevelSpreader() {
@@ -107,10 +114,10 @@
         this.cursors.clear();
     }
 
-    public void load(CompoundTag compoundtag) {
-        if (compoundtag.contains("cursors", 9)) {
+    public void load(CompoundTag tag) {
+        if (tag.contains("cursors", 9)) {
             this.cursors.clear();
-            DataResult dataresult = SculkSpreader.ChargeCursor.CODEC.listOf().parse(new Dynamic(NbtOps.INSTANCE, compoundtag.getList("cursors", 10)));
+            DataResult<List<SculkSpreader.ChargeCursor>> dataresult = SculkSpreader.ChargeCursor.CODEC.listOf().parse(new Dynamic<>(NbtOps.INSTANCE, tag.getList("cursors", 10))); // CraftBukkit - decompile error
             Logger logger = SculkSpreader.LOGGER;
 
             Objects.requireNonNull(logger);
@@ -124,63 +131,76 @@
 
     }
 
-    public void save(CompoundTag compoundtag) {
-        DataResult dataresult = SculkSpreader.ChargeCursor.CODEC.listOf().encodeStart(NbtOps.INSTANCE, this.cursors);
+    public void save(CompoundTag tag) {
+        DataResult<Tag> dataresult = SculkSpreader.ChargeCursor.CODEC.listOf().encodeStart(NbtOps.INSTANCE, this.cursors); // CraftBukkit - decompile error
         Logger logger = SculkSpreader.LOGGER;
 
         Objects.requireNonNull(logger);
-        dataresult.resultOrPartial(logger::error).ifPresent((tag) -> {
-            compoundtag.put("cursors", tag);
+        dataresult.resultOrPartial(logger::error).ifPresent((nbtbase) -> {
+            tag.put("cursors", nbtbase);
         });
     }
 
-    public void addCursors(BlockPos blockpos, int i) {
-        while (i > 0) {
-            int j = Math.min(i, 1000);
+    public void addCursors(BlockPos pos, int charge) {
+        while (charge > 0) {
+            int j = Math.min(charge, 1000);
 
-            this.addCursor(new SculkSpreader.ChargeCursor(blockpos, j));
-            i -= j;
+            this.addCursor(new SculkSpreader.ChargeCursor(pos, j));
+            charge -= j;
         }
 
     }
 
-    private void addCursor(SculkSpreader.ChargeCursor sculkspreader_chargecursor) {
+    private void addCursor(SculkSpreader.ChargeCursor cursor) {
         if (this.cursors.size() < 32) {
-            this.cursors.add(sculkspreader_chargecursor);
+            // CraftBukkit start
+            if (!isWorldGeneration()) { // CraftBukkit - SPIGOT-7475: Don't call event during world generation
+                CraftBlock bukkitBlock = CraftBlock.at(level, cursor.pos);
+                SculkBloomEvent event = new SculkBloomEvent(bukkitBlock, cursor.getCharge());
+                Bukkit.getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return;
+                }
+
+                cursor.charge = event.getCharge();
+            }
+            // CraftBukkit end
+
+            this.cursors.add(cursor);
         }
     }
 
-    public void updateCursors(LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource, boolean flag) {
+    public void updateCursors(LevelAccessor level, BlockPos pos, RandomSource random, boolean shouldConvertBlocks) {
         if (!this.cursors.isEmpty()) {
             List<SculkSpreader.ChargeCursor> list = new ArrayList();
             Map<BlockPos, SculkSpreader.ChargeCursor> map = new HashMap();
             Object2IntMap<BlockPos> object2intmap = new Object2IntOpenHashMap();
             Iterator iterator = this.cursors.iterator();
 
-            BlockPos blockpos1;
+            BlockPos blockposition1;
 
             while (iterator.hasNext()) {
-                SculkSpreader.ChargeCursor sculkspreader_chargecursor = (SculkSpreader.ChargeCursor) iterator.next();
+                SculkSpreader.ChargeCursor sculkspreader_a = (SculkSpreader.ChargeCursor) iterator.next();
 
-                sculkspreader_chargecursor.update(levelaccessor, blockpos, randomsource, this, flag);
-                if (sculkspreader_chargecursor.charge <= 0) {
-                    levelaccessor.levelEvent(3006, sculkspreader_chargecursor.getPos(), 0);
+                sculkspreader_a.update(level, pos, random, this, shouldConvertBlocks);
+                if (sculkspreader_a.charge <= 0) {
+                    level.levelEvent(3006, sculkspreader_a.getPos(), 0);
                 } else {
-                    blockpos1 = sculkspreader_chargecursor.getPos();
-                    object2intmap.computeInt(blockpos1, (blockpos2, integer) -> {
-                        return (integer == null ? 0 : integer) + sculkspreader_chargecursor.charge;
+                    blockposition1 = sculkspreader_a.getPos();
+                    object2intmap.computeInt(blockposition1, (blockposition2, integer) -> {
+                        return (integer == null ? 0 : integer) + sculkspreader_a.charge;
                     });
-                    SculkSpreader.ChargeCursor sculkspreader_chargecursor1 = (SculkSpreader.ChargeCursor) map.get(blockpos1);
+                    SculkSpreader.ChargeCursor sculkspreader_a1 = (SculkSpreader.ChargeCursor) map.get(blockposition1);
 
-                    if (sculkspreader_chargecursor1 == null) {
-                        map.put(blockpos1, sculkspreader_chargecursor);
-                        list.add(sculkspreader_chargecursor);
-                    } else if (!this.isWorldGeneration() && sculkspreader_chargecursor.charge + sculkspreader_chargecursor1.charge <= 1000) {
-                        sculkspreader_chargecursor1.mergeWith(sculkspreader_chargecursor);
+                    if (sculkspreader_a1 == null) {
+                        map.put(blockposition1, sculkspreader_a);
+                        list.add(sculkspreader_a);
+                    } else if (!this.isWorldGeneration() && sculkspreader_a.charge + sculkspreader_a1.charge <= 1000) {
+                        sculkspreader_a1.mergeWith(sculkspreader_a);
                     } else {
-                        list.add(sculkspreader_chargecursor);
-                        if (sculkspreader_chargecursor.charge < sculkspreader_chargecursor1.charge) {
-                            map.put(blockpos1, sculkspreader_chargecursor);
+                        list.add(sculkspreader_a);
+                        if (sculkspreader_a.charge < sculkspreader_a1.charge) {
+                            map.put(blockposition1, sculkspreader_a);
                         }
                     }
                 }
@@ -191,16 +211,16 @@
             while (objectiterator.hasNext()) {
                 Entry<BlockPos> entry = (Entry) objectiterator.next();
 
-                blockpos1 = (BlockPos) entry.getKey();
+                blockposition1 = (BlockPos) entry.getKey();
                 int i = entry.getIntValue();
-                SculkSpreader.ChargeCursor sculkspreader_chargecursor2 = (SculkSpreader.ChargeCursor) map.get(blockpos1);
-                Collection<Direction> collection = sculkspreader_chargecursor2 == null ? null : sculkspreader_chargecursor2.getFacingData();
+                SculkSpreader.ChargeCursor sculkspreader_a2 = (SculkSpreader.ChargeCursor) map.get(blockposition1);
+                Collection<Direction> collection = sculkspreader_a2 == null ? null : sculkspreader_a2.getFacingData();
 
                 if (i > 0 && collection != null) {
                     int j = (int) (Math.log1p((double) i) / 2.299999952316284D) + 1;
                     int k = (j << 6) + MultifaceBlock.pack(collection);
 
-                    levelaccessor.levelEvent(3006, blockpos1, k);
+                    level.levelEvent(3006, blockposition1, k);
                 }
             }
 
@@ -211,8 +231,8 @@
     public static class ChargeCursor {
 
         private static final ObjectArrayList<Vec3i> NON_CORNER_NEIGHBOURS = (ObjectArrayList) Util.make(new ObjectArrayList(18), (objectarraylist) -> {
-            Stream stream = BlockPos.betweenClosedStream(new BlockPos(-1, -1, -1), new BlockPos(1, 1, 1)).filter((blockpos) -> {
-                return (blockpos.getX() == 0 || blockpos.getY() == 0 || blockpos.getZ() == 0) && !blockpos.equals(BlockPos.ZERO);
+            Stream stream = BlockPos.betweenClosedStream(new BlockPos(-1, -1, -1), new BlockPos(1, 1, 1)).filter((blockposition) -> {
+                return (blockposition.getX() == 0 || blockposition.getY() == 0 || blockposition.getZ() == 0) && !blockposition.equals(BlockPos.ZERO);
             }).map(BlockPos::immutable);
 
             Objects.requireNonNull(objectarraylist);
@@ -229,23 +249,23 @@
             return Sets.newEnumSet(list, Direction.class);
         }, Lists::newArrayList);
         public static final Codec<SculkSpreader.ChargeCursor> CODEC = RecordCodecBuilder.create((instance) -> {
-            return instance.group(BlockPos.CODEC.fieldOf("pos").forGetter(SculkSpreader.ChargeCursor::getPos), Codec.intRange(0, 1000).fieldOf("charge").orElse(0).forGetter(SculkSpreader.ChargeCursor::getCharge), Codec.intRange(0, 1).fieldOf("decay_delay").orElse(1).forGetter(SculkSpreader.ChargeCursor::getDecayDelay), Codec.intRange(0, Integer.MAX_VALUE).fieldOf("update_delay").orElse(0).forGetter((sculkspreader_chargecursor) -> {
-                return sculkspreader_chargecursor.updateDelay;
-            }), SculkSpreader.ChargeCursor.DIRECTION_SET.optionalFieldOf("facings").forGetter((sculkspreader_chargecursor) -> {
-                return Optional.ofNullable(sculkspreader_chargecursor.getFacingData());
+            return instance.group(BlockPos.CODEC.fieldOf("pos").forGetter(SculkSpreader.ChargeCursor::getPos), Codec.intRange(0, 1000).fieldOf("charge").orElse(0).forGetter(SculkSpreader.ChargeCursor::getCharge), Codec.intRange(0, 1).fieldOf("decay_delay").orElse(1).forGetter(SculkSpreader.ChargeCursor::getDecayDelay), Codec.intRange(0, Integer.MAX_VALUE).fieldOf("update_delay").orElse(0).forGetter((sculkspreader_a) -> {
+                return sculkspreader_a.updateDelay;
+            }), SculkSpreader.ChargeCursor.DIRECTION_SET.optionalFieldOf("facings").forGetter((sculkspreader_a) -> {
+                return Optional.ofNullable(sculkspreader_a.getFacingData());
             })).apply(instance, SculkSpreader.ChargeCursor::new);
         });
 
-        private ChargeCursor(BlockPos blockpos, int i, int j, int k, Optional<Set<Direction>> optional) {
-            this.pos = blockpos;
-            this.charge = i;
-            this.decayDelay = j;
-            this.updateDelay = k;
-            this.facings = (Set) optional.orElse((Object) null);
+        private ChargeCursor(BlockPos pos, int charge, int decayDelay, int updateDelay, Optional<Set<Direction>> facings) {
+            this.pos = pos;
+            this.charge = charge;
+            this.decayDelay = decayDelay;
+            this.updateDelay = updateDelay;
+            this.facings = (Set) facings.orElse(null); // CraftBukkit - decompile error
         }
 
-        public ChargeCursor(BlockPos blockpos, int i) {
-            this(blockpos, i, 1, 0, Optional.empty());
+        public ChargeCursor(BlockPos pos, int charge) {
+            this(pos, charge, 1, 0, Optional.empty());
         }
 
         public BlockPos getPos() {
@@ -265,56 +285,56 @@
             return this.facings;
         }
 
-        private boolean shouldUpdate(LevelAccessor levelaccessor, BlockPos blockpos, boolean flag) {
+        private boolean shouldUpdate(LevelAccessor level, BlockPos pos, boolean isWorldGeneration) {
             if (this.charge <= 0) {
                 return false;
-            } else if (flag) {
+            } else if (isWorldGeneration) {
                 return true;
-            } else if (levelaccessor instanceof ServerLevel) {
-                ServerLevel serverlevel = (ServerLevel) levelaccessor;
+            } else if (level instanceof ServerLevel) {
+                ServerLevel worldserver = (ServerLevel) level;
 
-                return serverlevel.shouldTickBlocksAt(blockpos);
+                return worldserver.shouldTickBlocksAt(pos);
             } else {
                 return false;
             }
         }
 
-        public void update(LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource, SculkSpreader sculkspreader, boolean flag) {
-            if (this.shouldUpdate(levelaccessor, blockpos, sculkspreader.isWorldGeneration)) {
+        public void update(LevelAccessor level, BlockPos pos, RandomSource random, SculkSpreader spreader, boolean shouldConvertBlocks) {
+            if (this.shouldUpdate(level, pos, spreader.isWorldGeneration)) {
                 if (this.updateDelay > 0) {
                     --this.updateDelay;
                 } else {
-                    BlockState blockstate = levelaccessor.getBlockState(this.pos);
-                    SculkBehaviour sculkbehaviour = getBlockBehaviour(blockstate);
+                    IBlockData iblockdata = level.getBlockState(this.pos);
+                    SculkBehaviour sculkbehaviour = getBlockBehaviour(iblockdata);
 
-                    if (flag && sculkbehaviour.attemptSpreadVein(levelaccessor, this.pos, blockstate, this.facings, sculkspreader.isWorldGeneration())) {
+                    if (shouldConvertBlocks && sculkbehaviour.attemptSpreadVein(level, this.pos, iblockdata, this.facings, spreader.isWorldGeneration())) {
                         if (sculkbehaviour.canChangeBlockStateOnSpread()) {
-                            blockstate = levelaccessor.getBlockState(this.pos);
-                            sculkbehaviour = getBlockBehaviour(blockstate);
+                            iblockdata = level.getBlockState(this.pos);
+                            sculkbehaviour = getBlockBehaviour(iblockdata);
                         }
 
-                        levelaccessor.playSound((Player) null, this.pos, SoundEvents.SCULK_BLOCK_SPREAD, SoundSource.BLOCKS, 1.0F, 1.0F);
+                        level.playSound((Player) null, this.pos, SoundEvents.SCULK_BLOCK_SPREAD, SoundSource.BLOCKS, 1.0F, 1.0F);
                     }
 
-                    this.charge = sculkbehaviour.attemptUseCharge(this, levelaccessor, blockpos, randomsource, sculkspreader, flag);
+                    this.charge = sculkbehaviour.attemptUseCharge(this, level, pos, random, spreader, shouldConvertBlocks);
                     if (this.charge <= 0) {
-                        sculkbehaviour.onDischarged(levelaccessor, blockstate, this.pos, randomsource);
+                        sculkbehaviour.onDischarged(level, iblockdata, this.pos, random);
                     } else {
-                        BlockPos blockpos1 = getValidMovementPos(levelaccessor, this.pos, randomsource);
+                        BlockPos blockposition1 = getValidMovementPos(level, this.pos, random);
 
-                        if (blockpos1 != null) {
-                            sculkbehaviour.onDischarged(levelaccessor, blockstate, this.pos, randomsource);
-                            this.pos = blockpos1.immutable();
-                            if (sculkspreader.isWorldGeneration() && !this.pos.closerThan(new Vec3i(blockpos.getX(), this.pos.getY(), blockpos.getZ()), 15.0D)) {
+                        if (blockposition1 != null) {
+                            sculkbehaviour.onDischarged(level, iblockdata, this.pos, random);
+                            this.pos = blockposition1.immutable();
+                            if (spreader.isWorldGeneration() && !this.pos.closerThan(new Vec3i(pos.getX(), this.pos.getY(), pos.getZ()), 15.0D)) {
                                 this.charge = 0;
                                 return;
                             }
 
-                            blockstate = levelaccessor.getBlockState(blockpos1);
+                            iblockdata = level.getBlockState(blockposition1);
                         }
 
-                        if (blockstate.getBlock() instanceof SculkBehaviour) {
-                            this.facings = MultifaceBlock.availableFaces(blockstate);
+                        if (iblockdata.getBlock() instanceof SculkBehaviour) {
+                            this.facings = MultifaceBlock.availableFaces(iblockdata);
                         }
 
                         this.decayDelay = sculkbehaviour.updateDecayDelay(this.decayDelay);
@@ -324,14 +344,14 @@
             }
         }
 
-        void mergeWith(SculkSpreader.ChargeCursor sculkspreader_chargecursor) {
-            this.charge += sculkspreader_chargecursor.charge;
-            sculkspreader_chargecursor.charge = 0;
-            this.updateDelay = Math.min(this.updateDelay, sculkspreader_chargecursor.updateDelay);
+        void mergeWith(SculkSpreader.ChargeCursor cursor) {
+            this.charge += cursor.charge;
+            cursor.charge = 0;
+            this.updateDelay = Math.min(this.updateDelay, cursor.updateDelay);
         }
 
-        private static SculkBehaviour getBlockBehaviour(BlockState blockstate) {
-            Block block = blockstate.getBlock();
+        private static SculkBehaviour getBlockBehaviour(IBlockData state) {
+            Block block = state.getBlock();
             SculkBehaviour sculkbehaviour;
 
             if (block instanceof SculkBehaviour) {
@@ -345,50 +365,50 @@
             return sculkbehaviour;
         }
 
-        private static List<Vec3i> getRandomizedNonCornerNeighbourOffsets(RandomSource randomsource) {
-            return Util.shuffledCopy(SculkSpreader.ChargeCursor.NON_CORNER_NEIGHBOURS, randomsource);
+        private static List<Vec3i> getRandomizedNonCornerNeighbourOffsets(RandomSource random) {
+            return Util.shuffledCopy(SculkSpreader.ChargeCursor.NON_CORNER_NEIGHBOURS, random);
         }
 
         @Nullable
-        private static BlockPos getValidMovementPos(LevelAccessor levelaccessor, BlockPos blockpos, RandomSource randomsource) {
-            BlockPos.MutableBlockPos blockpos_mutableblockpos = blockpos.mutable();
-            BlockPos.MutableBlockPos blockpos_mutableblockpos1 = blockpos.mutable();
-            Iterator iterator = getRandomizedNonCornerNeighbourOffsets(randomsource).iterator();
+        private static BlockPos getValidMovementPos(LevelAccessor level, BlockPos pos, RandomSource random) {
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = pos.mutable();
+            BlockPos.MutableBlockPos blockposition_mutableblockposition1 = pos.mutable();
+            Iterator iterator = getRandomizedNonCornerNeighbourOffsets(random).iterator();
 
             while (iterator.hasNext()) {
-                Vec3i vec3i = (Vec3i) iterator.next();
+                Vec3i baseblockposition = (Vec3i) iterator.next();
 
-                blockpos_mutableblockpos1.setWithOffset(blockpos, vec3i);
-                BlockState blockstate = levelaccessor.getBlockState(blockpos_mutableblockpos1);
+                blockposition_mutableblockposition1.setWithOffset(pos, baseblockposition);
+                IBlockData iblockdata = level.getBlockState(blockposition_mutableblockposition1);
 
-                if (blockstate.getBlock() instanceof SculkBehaviour && isMovementUnobstructed(levelaccessor, blockpos, blockpos_mutableblockpos1)) {
-                    blockpos_mutableblockpos.set(blockpos_mutableblockpos1);
-                    if (SculkVeinBlock.hasSubstrateAccess(levelaccessor, blockstate, blockpos_mutableblockpos1)) {
+                if (iblockdata.getBlock() instanceof SculkBehaviour && isMovementUnobstructed(level, pos, blockposition_mutableblockposition1)) {
+                    blockposition_mutableblockposition.set(blockposition_mutableblockposition1);
+                    if (SculkVeinBlock.hasSubstrateAccess(level, iblockdata, blockposition_mutableblockposition1)) {
                         break;
                     }
                 }
             }
 
-            return blockpos_mutableblockpos.equals(blockpos) ? null : blockpos_mutableblockpos;
+            return blockposition_mutableblockposition.equals(pos) ? null : blockposition_mutableblockposition;
         }
 
-        private static boolean isMovementUnobstructed(LevelAccessor levelaccessor, BlockPos blockpos, BlockPos blockpos1) {
-            if (blockpos.distManhattan(blockpos1) == 1) {
+        private static boolean isMovementUnobstructed(LevelAccessor level, BlockPos fromPos, BlockPos toPos) {
+            if (fromPos.distManhattan(toPos) == 1) {
                 return true;
             } else {
-                BlockPos blockpos2 = blockpos1.subtract(blockpos);
-                Direction direction = Direction.fromAxisAndDirection(Direction.Axis.X, blockpos2.getX() < 0 ? Direction.AxisDirection.NEGATIVE : Direction.AxisDirection.POSITIVE);
-                Direction direction1 = Direction.fromAxisAndDirection(Direction.Axis.Y, blockpos2.getY() < 0 ? Direction.AxisDirection.NEGATIVE : Direction.AxisDirection.POSITIVE);
-                Direction direction2 = Direction.fromAxisAndDirection(Direction.Axis.Z, blockpos2.getZ() < 0 ? Direction.AxisDirection.NEGATIVE : Direction.AxisDirection.POSITIVE);
+                BlockPos blockposition2 = toPos.subtract(fromPos);
+                Direction enumdirection = Direction.fromAxisAndDirection(Direction.Axis.X, blockposition2.getX() < 0 ? Direction.AxisDirection.NEGATIVE : Direction.AxisDirection.POSITIVE);
+                Direction enumdirection1 = Direction.fromAxisAndDirection(Direction.Axis.Y, blockposition2.getY() < 0 ? Direction.AxisDirection.NEGATIVE : Direction.AxisDirection.POSITIVE);
+                Direction enumdirection2 = Direction.fromAxisAndDirection(Direction.Axis.Z, blockposition2.getZ() < 0 ? Direction.AxisDirection.NEGATIVE : Direction.AxisDirection.POSITIVE);
 
-                return blockpos2.getX() == 0 ? isUnobstructed(levelaccessor, blockpos, direction1) || isUnobstructed(levelaccessor, blockpos, direction2) : (blockpos2.getY() == 0 ? isUnobstructed(levelaccessor, blockpos, direction) || isUnobstructed(levelaccessor, blockpos, direction2) : isUnobstructed(levelaccessor, blockpos, direction) || isUnobstructed(levelaccessor, blockpos, direction1));
+                return blockposition2.getX() == 0 ? isUnobstructed(level, fromPos, enumdirection1) || isUnobstructed(level, fromPos, enumdirection2) : (blockposition2.getY() == 0 ? isUnobstructed(level, fromPos, enumdirection) || isUnobstructed(level, fromPos, enumdirection2) : isUnobstructed(level, fromPos, enumdirection) || isUnobstructed(level, fromPos, enumdirection1));
             }
         }
 
-        private static boolean isUnobstructed(LevelAccessor levelaccessor, BlockPos blockpos, Direction direction) {
-            BlockPos blockpos1 = blockpos.relative(direction);
+        private static boolean isUnobstructed(LevelAccessor level, BlockPos pos, Direction direction) {
+            BlockPos blockposition1 = pos.relative(direction);
 
-            return !levelaccessor.getBlockState(blockpos1).isFaceSturdy(levelaccessor, blockpos1, direction.getOpposite());
+            return !level.getBlockState(blockposition1).isFaceSturdy(level, blockposition1, direction.getOpposite());
         }
     }
 }
