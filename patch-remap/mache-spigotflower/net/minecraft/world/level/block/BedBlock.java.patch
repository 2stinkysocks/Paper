--- a/net/minecraft/world/level/block/BedBlock.java
+++ b/net/minecraft/world/level/block/BedBlock.java
@@ -9,7 +9,7 @@
 import net.minecraft.core.Direction;
 import net.minecraft.network.chat.Component;
 import net.minecraft.util.Mth;
-import net.minecraft.world.InteractionHand;
+import net.minecraft.world.EnumHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
@@ -28,13 +28,13 @@
 import net.minecraft.world.level.block.entity.BedBlockEntity;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BedPart;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.level.block.state.properties.EnumProperty;
-import net.minecraft.world.level.pathfinder.PathComputationType;
+import net.minecraft.world.level.pathfinder.PathMode;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
@@ -64,60 +64,68 @@
     private final DyeColor color;
 
     @Override
-    @Override
     public MapCodec<BedBlock> codec() {
         return BedBlock.CODEC;
     }
 
-    public BedBlock(DyeColor dyecolor, BlockBehaviour.Properties blockbehaviour_properties) {
-        super(blockbehaviour_properties);
-        this.color = dyecolor;
-        this.registerDefaultState((BlockState) ((BlockState) ((BlockState) this.stateDefinition.any()).setValue(BedBlock.PART, BedPart.FOOT)).setValue(BedBlock.OCCUPIED, false));
+    public BedBlock(DyeColor color, BlockBehaviour.Properties properties) {
+        super(properties);
+        this.color = color;
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(BedBlock.PART, BedPart.FOOT)).setValue(BedBlock.OCCUPIED, false));
     }
 
     @Nullable
-    public static Direction getBedOrientation(BlockGetter blockgetter, BlockPos blockpos) {
-        BlockState blockstate = blockgetter.getBlockState(blockpos);
+    public static Direction getBedOrientation(BlockGetter level, BlockPos pos) {
+        IBlockData iblockdata = level.getBlockState(pos);
 
-        return blockstate.getBlock() instanceof BedBlock ? (Direction) blockstate.getValue(BedBlock.FACING) : null;
+        return iblockdata.getBlock() instanceof BedBlock ? (Direction) iblockdata.getValue(BedBlock.FACING) : null;
     }
 
     @Override
-    @Override
-    public InteractionResult use(BlockState blockstate, Level level, BlockPos blockpos, Player player, InteractionHand interactionhand, BlockHitResult blockhitresult) {
+    public InteractionResult use(IBlockData state, Level level, BlockPos pos, Player player, EnumHand hand, BlockHitResult hit) {
         if (level.isClientSide) {
             return InteractionResult.CONSUME;
         } else {
-            if (blockstate.getValue(BedBlock.PART) != BedPart.HEAD) {
-                blockpos = blockpos.relative((Direction) blockstate.getValue(BedBlock.FACING));
-                blockstate = level.getBlockState(blockpos);
-                if (!blockstate.is((Block) this)) {
+            if (state.getValue(BedBlock.PART) != BedPart.HEAD) {
+                pos = pos.relative((Direction) state.getValue(BedBlock.FACING));
+                state = level.getBlockState(pos);
+                if (!state.is((Block) this)) {
                     return InteractionResult.CONSUME;
                 }
             }
 
-            if (!canSetSpawn(level)) {
-                level.removeBlock(blockpos, false);
-                BlockPos blockpos1 = blockpos.relative(((Direction) blockstate.getValue(BedBlock.FACING)).getOpposite());
+            // CraftBukkit - moved world and biome check into EntityHuman
+            if (false && !canSetSpawn(level)) {
+                level.removeBlock(pos, false);
+                BlockPos blockposition1 = pos.relative(((Direction) state.getValue(BedBlock.FACING)).getOpposite());
 
-                if (level.getBlockState(blockpos1).is((Block) this)) {
-                    level.removeBlock(blockpos1, false);
+                if (level.getBlockState(blockposition1).is((Block) this)) {
+                    level.removeBlock(blockposition1, false);
                 }
 
-                Vec3 vec3 = blockpos.getCenter();
+                Vec3 vec3d = pos.getCenter();
 
-                level.explode((Entity) null, level.damageSources().badRespawnPointExplosion(vec3), (ExplosionDamageCalculator) null, vec3, 5.0F, true, Level.ExplosionInteraction.BLOCK);
+                level.explode((Entity) null, level.damageSources().badRespawnPointExplosion(vec3d), (ExplosionDamageCalculator) null, vec3d, 5.0F, true, Level.a.BLOCK);
                 return InteractionResult.SUCCESS;
-            } else if ((Boolean) blockstate.getValue(BedBlock.OCCUPIED)) {
-                if (!this.kickVillagerOutOfBed(level, blockpos)) {
+            } else if ((Boolean) state.getValue(BedBlock.OCCUPIED)) {
+                if (!this.kickVillagerOutOfBed(level, pos)) {
                     player.displayClientMessage(Component.translatable("block.minecraft.bed.occupied"), true);
                 }
 
                 return InteractionResult.SUCCESS;
             } else {
-                player.startSleepInBed(blockpos).ifLeft((player_bedsleepingproblem) -> {
-                    if (player_bedsleepingproblem.getMessage() != null) {
-                        player.displayClientMessage(player_bedsleepingproblem.getMessage(), true);
+                // CraftBukkit start
+                IBlockData finaliblockdata = state;
+                BlockPos finalblockposition = pos;
+                // CraftBukkit end
+                player.startSleepInBed(pos).ifLeft((entityhuman_enumbedresult) -> {
+                    // CraftBukkit start - handling bed explosion from below here
+                    if (!level.dimensionType().bedWorks()) {
+                        this.explodeBed(finaliblockdata, level, finalblockposition);
+                    } else
+                    // CraftBukkit end
+                    if (entityhuman_enumbedresult.getMessage() != null) {
+                        player.displayClientMessage(entityhuman_enumbedresult.getMessage(), true);
                     }
 
                 });
@@ -126,12 +134,33 @@
         }
     }
 
+    // CraftBukkit start
+    private InteractionResult explodeBed(IBlockData iblockdata, Level world, BlockPos blockposition) {
+        {
+            {
+                world.removeBlock(blockposition, false);
+                BlockPos blockposition1 = blockposition.relative(((Direction) iblockdata.getValue(BedBlock.FACING)).getOpposite());
+
+                if (world.getBlockState(blockposition1).getBlock() == this) {
+                    world.removeBlock(blockposition1, false);
+                }
+
+                Vec3 vec3d = blockposition.getCenter();
+
+                world.explode((Entity) null, world.damageSources().badRespawnPointExplosion(vec3d), (ExplosionDamageCalculator) null, vec3d, 5.0F, true, Level.a.BLOCK);
+                return InteractionResult.SUCCESS;
+            }
+        }
+    }
+    // CraftBukkit end
+
     public static boolean canSetSpawn(Level level) {
-        return level.dimensionType().bedWorks();
+        // CraftBukkit - moved world and biome check into EntityHuman
+        return true || level.dimensionType().bedWorks();
     }
 
-    private boolean kickVillagerOutOfBed(Level level, BlockPos blockpos) {
-        List<Villager> list = level.getEntitiesOfClass(Villager.class, new AABB(blockpos), LivingEntity::isSleeping);
+    private boolean kickVillagerOutOfBed(Level level, BlockPos pos) {
+        List<Villager> list = level.getEntitiesOfClass(Villager.class, new AABB(pos), LivingEntity::isSleeping);
 
         if (list.isEmpty()) {
             return false;
@@ -142,16 +171,14 @@
     }
 
     @Override
-    @Override
-    public void fallOn(Level level, BlockState blockstate, BlockPos blockpos, Entity entity, float f) {
-        super.fallOn(level, blockstate, blockpos, entity, f * 0.5F);
+    public void fallOn(Level level, IBlockData state, BlockPos pos, Entity entity, float fallDistance) {
+        super.fallOn(level, state, pos, entity, fallDistance * 0.5F);
     }
 
     @Override
-    @Override
-    public void updateEntityAfterFallOn(BlockGetter blockgetter, Entity entity) {
+    public void updateEntityAfterFallOn(BlockGetter level, Entity entity) {
         if (entity.isSuppressingBounce()) {
-            super.updateEntityAfterFallOn(blockgetter, entity);
+            super.updateEntityAfterFallOn(level, entity);
         } else {
             this.bounceUp(entity);
         }
@@ -159,64 +186,60 @@
     }
 
     private void bounceUp(Entity entity) {
-        Vec3 vec3 = entity.getDeltaMovement();
+        Vec3 vec3d = entity.getDeltaMovement();
 
-        if (vec3.y < 0.0D) {
+        if (vec3d.y < 0.0D) {
             double d0 = entity instanceof LivingEntity ? 1.0D : 0.8D;
 
-            entity.setDeltaMovement(vec3.x, -vec3.y * 0.6600000262260437D * d0, vec3.z);
+            entity.setDeltaMovement(vec3d.x, -vec3d.y * 0.6600000262260437D * d0, vec3d.z);
         }
 
     }
 
     @Override
-    @Override
-    public BlockState updateShape(BlockState blockstate, Direction direction, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, BlockPos blockpos1) {
-        return direction == getNeighbourDirection((BedPart) blockstate.getValue(BedBlock.PART), (Direction) blockstate.getValue(BedBlock.FACING)) ? (blockstate1.is((Block) this) && blockstate1.getValue(BedBlock.PART) != blockstate.getValue(BedBlock.PART) ? (BlockState) blockstate.setValue(BedBlock.OCCUPIED, (Boolean) blockstate1.getValue(BedBlock.OCCUPIED)) : Blocks.AIR.defaultBlockState()) : super.updateShape(blockstate, direction, blockstate1, levelaccessor, blockpos, blockpos1);
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        return facing == getNeighbourDirection((BedPart) state.getValue(BedBlock.PART), (Direction) state.getValue(BedBlock.FACING)) ? (facingState.is((Block) this) && facingState.getValue(BedBlock.PART) != state.getValue(BedBlock.PART) ? (IBlockData) state.setValue(BedBlock.OCCUPIED, (Boolean) facingState.getValue(BedBlock.OCCUPIED)) : Blocks.AIR.defaultBlockState()) : super.updateShape(state, facing, facingState, level, currentPos, facingPos);
     }
 
-    private static Direction getNeighbourDirection(BedPart bedpart, Direction direction) {
-        return bedpart == BedPart.FOOT ? direction : direction.getOpposite();
+    private static Direction getNeighbourDirection(BedPart part, Direction direction) {
+        return part == BedPart.FOOT ? direction : direction.getOpposite();
     }
 
     @Override
-    @Override
-    public BlockState playerWillDestroy(Level level, BlockPos blockpos, BlockState blockstate, Player player) {
-        if (!level.isClientSide && player.isCreative()) {
-            BedPart bedpart = (BedPart) blockstate.getValue(BedBlock.PART);
+    public IBlockData playerWillDestroy(Level world, BlockPos blockposition, IBlockData iblockdata, Player entityhuman) {
+        if (!world.isClientSide && entityhuman.isCreative()) {
+            BedPart blockpropertybedpart = (BedPart) iblockdata.getValue(BedBlock.PART);
 
-            if (bedpart == BedPart.FOOT) {
-                BlockPos blockpos1 = blockpos.relative(getNeighbourDirection(bedpart, (Direction) blockstate.getValue(BedBlock.FACING)));
-                BlockState blockstate1 = level.getBlockState(blockpos1);
+            if (blockpropertybedpart == BedPart.FOOT) {
+                BlockPos blockposition1 = blockposition.relative(getNeighbourDirection(blockpropertybedpart, (Direction) iblockdata.getValue(BedBlock.FACING)));
+                IBlockData iblockdata1 = world.getBlockState(blockposition1);
 
-                if (blockstate1.is((Block) this) && blockstate1.getValue(BedBlock.PART) == BedPart.HEAD) {
-                    level.setBlock(blockpos1, Blocks.AIR.defaultBlockState(), 35);
-                    level.levelEvent(player, 2001, blockpos1, Block.getId(blockstate1));
+                if (iblockdata1.is((Block) this) && iblockdata1.getValue(BedBlock.PART) == BedPart.HEAD) {
+                    world.setBlock(blockposition1, Blocks.AIR.defaultBlockState(), 35);
+                    world.levelEvent(entityhuman, 2001, blockposition1, Block.getId(iblockdata1));
                 }
             }
         }
 
-        return super.playerWillDestroy(level, blockpos, blockstate, player);
+        return super.playerWillDestroy(world, blockposition, iblockdata, entityhuman);
     }
 
     @Nullable
     @Override
-    @Override
-    public BlockState getStateForPlacement(BlockPlaceContext blockplacecontext) {
-        Direction direction = blockplacecontext.getHorizontalDirection();
-        BlockPos blockpos = blockplacecontext.getClickedPos();
-        BlockPos blockpos1 = blockpos.relative(direction);
-        Level level = blockplacecontext.getLevel();
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        Direction enumdirection = context.getHorizontalDirection();
+        BlockPos blockposition = context.getClickedPos();
+        BlockPos blockposition1 = blockposition.relative(enumdirection);
+        Level world = context.getLevel();
 
-        return level.getBlockState(blockpos1).canBeReplaced(blockplacecontext) && level.getWorldBorder().isWithinBounds(blockpos1) ? (BlockState) this.defaultBlockState().setValue(BedBlock.FACING, direction) : null;
+        return world.getBlockState(blockposition1).canBeReplaced(context) && world.getWorldBorder().isWithinBounds(blockposition1) ? (IBlockData) this.defaultBlockState().setValue(BedBlock.FACING, enumdirection) : null;
     }
 
     @Override
-    @Override
-    public VoxelShape getShape(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, CollisionContext collisioncontext) {
-        Direction direction = getConnectedDirection(blockstate).getOpposite();
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        Direction enumdirection = getConnectedDirection(state).getOpposite();
 
-        switch (direction) {
+        switch (enumdirection) {
             case NORTH:
                 return BedBlock.NORTH_SHAPE;
             case SOUTH:
@@ -228,82 +251,82 @@
         }
     }
 
-    public static Direction getConnectedDirection(BlockState blockstate) {
-        Direction direction = (Direction) blockstate.getValue(BedBlock.FACING);
+    public static Direction getConnectedDirection(IBlockData state) {
+        Direction enumdirection = (Direction) state.getValue(BedBlock.FACING);
 
-        return blockstate.getValue(BedBlock.PART) == BedPart.HEAD ? direction.getOpposite() : direction;
+        return state.getValue(BedBlock.PART) == BedPart.HEAD ? enumdirection.getOpposite() : enumdirection;
     }
 
-    public static DoubleBlockCombiner.BlockType getBlockType(BlockState blockstate) {
-        BedPart bedpart = (BedPart) blockstate.getValue(BedBlock.PART);
+    public static DoubleBlockCombiner.BlockType getBlockType(IBlockData state) {
+        BedPart blockpropertybedpart = (BedPart) state.getValue(BedBlock.PART);
 
-        return bedpart == BedPart.HEAD ? DoubleBlockCombiner.BlockType.FIRST : DoubleBlockCombiner.BlockType.SECOND;
+        return blockpropertybedpart == BedPart.HEAD ? DoubleBlockCombiner.BlockType.FIRST : DoubleBlockCombiner.BlockType.SECOND;
     }
 
-    private static boolean isBunkBed(BlockGetter blockgetter, BlockPos blockpos) {
-        return blockgetter.getBlockState(blockpos.below()).getBlock() instanceof BedBlock;
+    private static boolean isBunkBed(BlockGetter level, BlockPos pos) {
+        return level.getBlockState(pos.below()).getBlock() instanceof BedBlock;
     }
 
-    public static Optional<Vec3> findStandUpPosition(EntityType<?> entitytype, CollisionGetter collisiongetter, BlockPos blockpos, Direction direction, float f) {
-        Direction direction1 = direction.getClockWise();
-        Direction direction2 = direction1.isFacingAngle(f) ? direction1.getOpposite() : direction1;
+    public static Optional<Vec3> findStandUpPosition(EntityType<?> entityType, CollisionGetter collisionGetter, BlockPos pos, Direction direction, float yRot) {
+        Direction enumdirection1 = direction.getClockWise();
+        Direction enumdirection2 = enumdirection1.isFacingAngle(yRot) ? enumdirection1.getOpposite() : enumdirection1;
 
-        if (isBunkBed(collisiongetter, blockpos)) {
-            return findBunkBedStandUpPosition(entitytype, collisiongetter, blockpos, direction, direction2);
+        if (isBunkBed(collisionGetter, pos)) {
+            return findBunkBedStandUpPosition(entityType, collisionGetter, pos, direction, enumdirection2);
         } else {
-            int[][] aint = bedStandUpOffsets(direction, direction2);
-            Optional<Vec3> optional = findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos, aint, true);
+            int[][] aint = bedStandUpOffsets(direction, enumdirection2);
+            Optional<Vec3> optional = findStandUpPositionAtOffset(entityType, collisionGetter, pos, aint, true);
 
-            return optional.isPresent() ? optional : findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos, aint, false);
+            return optional.isPresent() ? optional : findStandUpPositionAtOffset(entityType, collisionGetter, pos, aint, false);
         }
     }
 
-    private static Optional<Vec3> findBunkBedStandUpPosition(EntityType<?> entitytype, CollisionGetter collisiongetter, BlockPos blockpos, Direction direction, Direction direction1) {
-        int[][] aint = bedSurroundStandUpOffsets(direction, direction1);
-        Optional<Vec3> optional = findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos, aint, true);
+    private static Optional<Vec3> findBunkBedStandUpPosition(EntityType<?> entityType, CollisionGetter collisionGetter, BlockPos pos, Direction stateFacing, Direction entityFacing) {
+        int[][] aint = bedSurroundStandUpOffsets(stateFacing, entityFacing);
+        Optional<Vec3> optional = findStandUpPositionAtOffset(entityType, collisionGetter, pos, aint, true);
 
         if (optional.isPresent()) {
             return optional;
         } else {
-            BlockPos blockpos1 = blockpos.below();
-            Optional<Vec3> optional1 = findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos1, aint, true);
+            BlockPos blockposition1 = pos.below();
+            Optional<Vec3> optional1 = findStandUpPositionAtOffset(entityType, collisionGetter, blockposition1, aint, true);
 
             if (optional1.isPresent()) {
                 return optional1;
             } else {
-                int[][] aint1 = bedAboveStandUpOffsets(direction);
-                Optional<Vec3> optional2 = findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos, aint1, true);
+                int[][] aint1 = bedAboveStandUpOffsets(stateFacing);
+                Optional<Vec3> optional2 = findStandUpPositionAtOffset(entityType, collisionGetter, pos, aint1, true);
 
                 if (optional2.isPresent()) {
                     return optional2;
                 } else {
-                    Optional<Vec3> optional3 = findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos, aint, false);
+                    Optional<Vec3> optional3 = findStandUpPositionAtOffset(entityType, collisionGetter, pos, aint, false);
 
                     if (optional3.isPresent()) {
                         return optional3;
                     } else {
-                        Optional<Vec3> optional4 = findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos1, aint, false);
+                        Optional<Vec3> optional4 = findStandUpPositionAtOffset(entityType, collisionGetter, blockposition1, aint, false);
 
-                        return optional4.isPresent() ? optional4 : findStandUpPositionAtOffset(entitytype, collisiongetter, blockpos, aint1, false);
+                        return optional4.isPresent() ? optional4 : findStandUpPositionAtOffset(entityType, collisionGetter, pos, aint1, false);
                     }
                 }
             }
         }
     }
 
-    private static Optional<Vec3> findStandUpPositionAtOffset(EntityType<?> entitytype, CollisionGetter collisiongetter, BlockPos blockpos, int[][] aint, boolean flag) {
-        BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
-        int[][] aint1 = aint;
-        int i = aint.length;
+    private static Optional<Vec3> findStandUpPositionAtOffset(EntityType<?> entityType, CollisionGetter collisionGetter, BlockPos pos, int[][] offsets, boolean simulate) {
+        BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+        int[][] aint1 = offsets;
+        int i = offsets.length;
 
         for (int j = 0; j < i; ++j) {
             int[] aint2 = aint1[j];
 
-            blockpos_mutableblockpos.set(blockpos.getX() + aint2[0], blockpos.getY(), blockpos.getZ() + aint2[1]);
-            Vec3 vec3 = DismountHelper.findSafeDismountLocation(entitytype, collisiongetter, blockpos_mutableblockpos, flag);
+            blockposition_mutableblockposition.set(pos.getX() + aint2[0], pos.getY(), pos.getZ() + aint2[1]);
+            Vec3 vec3d = DismountHelper.findSafeDismountLocation(entityType, collisionGetter, blockposition_mutableblockposition, simulate);
 
-            if (vec3 != null) {
-                return Optional.of(vec3);
+            if (vec3d != null) {
+                return Optional.of(vec3d);
             }
         }
 
@@ -311,33 +334,34 @@
     }
 
     @Override
-    @Override
-    public RenderShape getRenderShape(BlockState blockstate) {
-        return RenderShape.ENTITYBLOCK_ANIMATED;
+    public EnumRenderType getRenderShape(IBlockData state) {
+        return EnumRenderType.ENTITYBLOCK_ANIMATED;
     }
 
     @Override
-    @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> statedefinition_builder) {
-        statedefinition_builder.add(BedBlock.FACING, BedBlock.PART, BedBlock.OCCUPIED);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(BedBlock.FACING, BedBlock.PART, BedBlock.OCCUPIED);
     }
 
     @Override
-    @Override
-    public BlockEntity newBlockEntity(BlockPos blockpos, BlockState blockstate) {
-        return new BedBlockEntity(blockpos, blockstate, this.color);
+    public BlockEntity newBlockEntity(BlockPos pos, IBlockData state) {
+        return new BedBlockEntity(pos, state, this.color);
     }
 
     @Override
-    @Override
-    public void setPlacedBy(Level level, BlockPos blockpos, BlockState blockstate, @Nullable LivingEntity livingentity, ItemStack itemstack) {
-        super.setPlacedBy(level, blockpos, blockstate, livingentity, itemstack);
+    public void setPlacedBy(Level level, BlockPos pos, IBlockData state, @Nullable LivingEntity placer, ItemStack stack) {
+        super.setPlacedBy(level, pos, state, placer, stack);
         if (!level.isClientSide) {
-            BlockPos blockpos1 = blockpos.relative((Direction) blockstate.getValue(BedBlock.FACING));
+            BlockPos blockposition1 = pos.relative((Direction) state.getValue(BedBlock.FACING));
 
-            level.setBlock(blockpos1, (BlockState) blockstate.setValue(BedBlock.PART, BedPart.HEAD), 3);
-            level.blockUpdated(blockpos, Blocks.AIR);
-            blockstate.updateNeighbourShapes(level, blockpos, 3);
+            level.setBlock(blockposition1, (IBlockData) state.setValue(BedBlock.PART, BedPart.HEAD), 3);
+            // CraftBukkit start - SPIGOT-7315: Don't updated if we capture block states
+            if (level.captureBlockStates) {
+                return;
+            }
+            // CraftBukkit end
+            level.blockUpdated(pos, Blocks.AIR);
+            state.updateNeighbourShapes(level, pos, 3);
         }
 
     }
@@ -347,28 +371,26 @@
     }
 
     @Override
-    @Override
-    public long getSeed(BlockState blockstate, BlockPos blockpos) {
-        BlockPos blockpos1 = blockpos.relative((Direction) blockstate.getValue(BedBlock.FACING), blockstate.getValue(BedBlock.PART) == BedPart.HEAD ? 0 : 1);
+    public long getSeed(IBlockData state, BlockPos pos) {
+        BlockPos blockposition1 = pos.relative((Direction) state.getValue(BedBlock.FACING), state.getValue(BedBlock.PART) == BedPart.HEAD ? 0 : 1);
 
-        return Mth.getSeed(blockpos1.getX(), blockpos.getY(), blockpos1.getZ());
+        return Mth.getSeed(blockposition1.getX(), pos.getY(), blockposition1.getZ());
     }
 
     @Override
-    @Override
-    public boolean isPathfindable(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, PathComputationType pathcomputationtype) {
+    public boolean isPathfindable(IBlockData state, BlockGetter level, BlockPos pos, PathMode type) {
         return false;
     }
 
-    private static int[][] bedStandUpOffsets(Direction direction, Direction direction1) {
-        return (int[][]) ArrayUtils.addAll(bedSurroundStandUpOffsets(direction, direction1), bedAboveStandUpOffsets(direction));
+    private static int[][] bedStandUpOffsets(Direction firstDir, Direction secondDir) {
+        return (int[][]) ArrayUtils.addAll(bedSurroundStandUpOffsets(firstDir, secondDir), bedAboveStandUpOffsets(firstDir));
     }
 
-    private static int[][] bedSurroundStandUpOffsets(Direction direction, Direction direction1) {
-        return new int[][]{{direction1.getStepX(), direction1.getStepZ()}, {direction1.getStepX() - direction.getStepX(), direction1.getStepZ() - direction.getStepZ()}, {direction1.getStepX() - direction.getStepX() * 2, direction1.getStepZ() - direction.getStepZ() * 2}, {-direction.getStepX() * 2, -direction.getStepZ() * 2}, {-direction1.getStepX() - direction.getStepX() * 2, -direction1.getStepZ() - direction.getStepZ() * 2}, {-direction1.getStepX() - direction.getStepX(), -direction1.getStepZ() - direction.getStepZ()}, {-direction1.getStepX(), -direction1.getStepZ()}, {-direction1.getStepX() + direction.getStepX(), -direction1.getStepZ() + direction.getStepZ()}, {direction.getStepX(), direction.getStepZ()}, {direction1.getStepX() + direction.getStepX(), direction1.getStepZ() + direction.getStepZ()}};
+    private static int[][] bedSurroundStandUpOffsets(Direction firstDir, Direction secondDir) {
+        return new int[][]{{secondDir.getStepX(), secondDir.getStepZ()}, {secondDir.getStepX() - firstDir.getStepX(), secondDir.getStepZ() - firstDir.getStepZ()}, {secondDir.getStepX() - firstDir.getStepX() * 2, secondDir.getStepZ() - firstDir.getStepZ() * 2}, {-firstDir.getStepX() * 2, -firstDir.getStepZ() * 2}, {-secondDir.getStepX() - firstDir.getStepX() * 2, -secondDir.getStepZ() - firstDir.getStepZ() * 2}, {-secondDir.getStepX() - firstDir.getStepX(), -secondDir.getStepZ() - firstDir.getStepZ()}, {-secondDir.getStepX(), -secondDir.getStepZ()}, {-secondDir.getStepX() + firstDir.getStepX(), -secondDir.getStepZ() + firstDir.getStepZ()}, {firstDir.getStepX(), firstDir.getStepZ()}, {secondDir.getStepX() + firstDir.getStepX(), secondDir.getStepZ() + firstDir.getStepZ()}};
     }
 
-    private static int[][] bedAboveStandUpOffsets(Direction direction) {
-        return new int[][]{{0, 0}, {-direction.getStepX(), -direction.getStepZ()}};
+    private static int[][] bedAboveStandUpOffsets(Direction dir) {
+        return new int[][]{{0, 0}, {-dir.getStepX(), -dir.getStepZ()}};
     }
 }
