--- a/net/minecraft/world/level/block/VineBlock.java
+++ b/net/minecraft/world/level/block/VineBlock.java
@@ -18,12 +18,13 @@
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
 import net.minecraft.world.level.block.state.BlockBehaviour;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.BooleanProperty;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class VineBlock extends Block {
 
@@ -42,40 +43,39 @@
     private static final VoxelShape EAST_AABB = Block.box(15.0D, 0.0D, 0.0D, 16.0D, 16.0D, 16.0D);
     private static final VoxelShape NORTH_AABB = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 16.0D, 1.0D);
     private static final VoxelShape SOUTH_AABB = Block.box(0.0D, 0.0D, 15.0D, 16.0D, 16.0D, 16.0D);
-    private final Map<BlockState, VoxelShape> shapesCache;
+    private final Map<IBlockData, VoxelShape> shapesCache;
 
     @Override
-    @Override
     public MapCodec<VineBlock> codec() {
         return VineBlock.CODEC;
     }
 
-    public VineBlock(BlockBehaviour.Properties blockbehaviour_properties) {
-        super(blockbehaviour_properties);
-        this.registerDefaultState((BlockState) ((BlockState) ((BlockState) ((BlockState) ((BlockState) ((BlockState) this.stateDefinition.any()).setValue(VineBlock.UP, false)).setValue(VineBlock.NORTH, false)).setValue(VineBlock.EAST, false)).setValue(VineBlock.SOUTH, false)).setValue(VineBlock.WEST, false));
+    public VineBlock(BlockBehaviour.Properties properties) {
+        super(properties);
+        this.registerDefaultState((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) this.stateDefinition.any()).setValue(VineBlock.UP, false)).setValue(VineBlock.NORTH, false)).setValue(VineBlock.EAST, false)).setValue(VineBlock.SOUTH, false)).setValue(VineBlock.WEST, false));
         this.shapesCache = ImmutableMap.copyOf((Map) this.stateDefinition.getPossibleStates().stream().collect(Collectors.toMap(Function.identity(), VineBlock::calculateShape)));
     }
 
-    private static VoxelShape calculateShape(BlockState blockstate) {
+    private static VoxelShape calculateShape(IBlockData state) {
         VoxelShape voxelshape = Shapes.empty();
 
-        if ((Boolean) blockstate.getValue(VineBlock.UP)) {
+        if ((Boolean) state.getValue(VineBlock.UP)) {
             voxelshape = VineBlock.UP_AABB;
         }
 
-        if ((Boolean) blockstate.getValue(VineBlock.NORTH)) {
+        if ((Boolean) state.getValue(VineBlock.NORTH)) {
             voxelshape = Shapes.or(voxelshape, VineBlock.NORTH_AABB);
         }
 
-        if ((Boolean) blockstate.getValue(VineBlock.SOUTH)) {
+        if ((Boolean) state.getValue(VineBlock.SOUTH)) {
             voxelshape = Shapes.or(voxelshape, VineBlock.SOUTH_AABB);
         }
 
-        if ((Boolean) blockstate.getValue(VineBlock.EAST)) {
+        if ((Boolean) state.getValue(VineBlock.EAST)) {
             voxelshape = Shapes.or(voxelshape, VineBlock.EAST_AABB);
         }
 
-        if ((Boolean) blockstate.getValue(VineBlock.WEST)) {
+        if ((Boolean) state.getValue(VineBlock.WEST)) {
             voxelshape = Shapes.or(voxelshape, VineBlock.WEST_AABB);
         }
 
@@ -83,35 +83,32 @@
     }
 
     @Override
-    @Override
-    public VoxelShape getShape(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos, CollisionContext collisioncontext) {
-        return (VoxelShape) this.shapesCache.get(blockstate);
+    public VoxelShape getShape(IBlockData state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        return (VoxelShape) this.shapesCache.get(state);
     }
 
     @Override
-    @Override
-    public boolean propagatesSkylightDown(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos) {
+    public boolean propagatesSkylightDown(IBlockData state, BlockGetter level, BlockPos pos) {
         return true;
     }
 
     @Override
-    @Override
-    public boolean canSurvive(BlockState blockstate, LevelReader levelreader, BlockPos blockpos) {
-        return this.hasFaces(this.getUpdatedState(blockstate, levelreader, blockpos));
+    public boolean canSurvive(IBlockData state, LevelReader level, BlockPos pos) {
+        return this.hasFaces(this.getUpdatedState(state, level, pos));
     }
 
-    private boolean hasFaces(BlockState blockstate) {
-        return this.countFaces(blockstate) > 0;
+    private boolean hasFaces(IBlockData state) {
+        return this.countFaces(state) > 0;
     }
 
-    private int countFaces(BlockState blockstate) {
+    private int countFaces(IBlockData state) {
         int i = 0;
         Iterator iterator = VineBlock.PROPERTY_BY_DIRECTION.values().iterator();
 
         while (iterator.hasNext()) {
-            BooleanProperty booleanproperty = (BooleanProperty) iterator.next();
+            BooleanProperty blockstateboolean = (BooleanProperty) iterator.next();
 
-            if ((Boolean) blockstate.getValue(booleanproperty)) {
+            if ((Boolean) state.getValue(blockstateboolean)) {
                 ++i;
             }
         }
@@ -119,155 +116,157 @@
         return i;
     }
 
-    private boolean canSupportAtFace(BlockGetter blockgetter, BlockPos blockpos, Direction direction) {
+    private boolean canSupportAtFace(BlockGetter level, BlockPos pos, Direction direction) {
         if (direction == Direction.DOWN) {
             return false;
         } else {
-            BlockPos blockpos1 = blockpos.relative(direction);
+            BlockPos blockposition1 = pos.relative(direction);
 
-            if (isAcceptableNeighbour(blockgetter, blockpos1, direction)) {
+            if (isAcceptableNeighbour(level, blockposition1, direction)) {
                 return true;
             } else if (direction.getAxis() == Direction.Axis.Y) {
                 return false;
             } else {
-                BooleanProperty booleanproperty = (BooleanProperty) VineBlock.PROPERTY_BY_DIRECTION.get(direction);
-                BlockState blockstate = blockgetter.getBlockState(blockpos.above());
+                BooleanProperty blockstateboolean = (BooleanProperty) VineBlock.PROPERTY_BY_DIRECTION.get(direction);
+                IBlockData iblockdata = level.getBlockState(pos.above());
 
-                return blockstate.is((Block) this) && (Boolean) blockstate.getValue(booleanproperty);
+                return iblockdata.is((Block) this) && (Boolean) iblockdata.getValue(blockstateboolean);
             }
         }
     }
 
-    public static boolean isAcceptableNeighbour(BlockGetter blockgetter, BlockPos blockpos, Direction direction) {
-        return MultifaceBlock.canAttachTo(blockgetter, direction, blockpos, blockgetter.getBlockState(blockpos));
+    public static boolean isAcceptableNeighbour(BlockGetter blockReader, BlockPos neighborPos, Direction attachedFace) {
+        return MultifaceBlock.canAttachTo(blockReader, attachedFace, neighborPos, blockReader.getBlockState(neighborPos));
     }
 
-    private BlockState getUpdatedState(BlockState blockstate, BlockGetter blockgetter, BlockPos blockpos) {
-        BlockPos blockpos1 = blockpos.above();
+    private IBlockData getUpdatedState(IBlockData state, BlockGetter level, BlockPos pos) {
+        BlockPos blockposition1 = pos.above();
 
-        if ((Boolean) blockstate.getValue(VineBlock.UP)) {
-            blockstate = (BlockState) blockstate.setValue(VineBlock.UP, isAcceptableNeighbour(blockgetter, blockpos1, Direction.DOWN));
+        if ((Boolean) state.getValue(VineBlock.UP)) {
+            state = (IBlockData) state.setValue(VineBlock.UP, isAcceptableNeighbour(level, blockposition1, Direction.DOWN));
         }
 
-        BlockState blockstate1 = null;
+        IBlockData iblockdata1 = null;
         Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
         while (iterator.hasNext()) {
-            Direction direction = (Direction) iterator.next();
-            BooleanProperty booleanproperty = getPropertyForFace(direction);
+            Direction enumdirection = (Direction) iterator.next();
+            BooleanProperty blockstateboolean = getPropertyForFace(enumdirection);
 
-            if ((Boolean) blockstate.getValue(booleanproperty)) {
-                boolean flag = this.canSupportAtFace(blockgetter, blockpos, direction);
+            if ((Boolean) state.getValue(blockstateboolean)) {
+                boolean flag = this.canSupportAtFace(level, pos, enumdirection);
 
                 if (!flag) {
-                    if (blockstate1 == null) {
-                        blockstate1 = blockgetter.getBlockState(blockpos1);
+                    if (iblockdata1 == null) {
+                        iblockdata1 = level.getBlockState(blockposition1);
                     }
 
-                    flag = blockstate1.is((Block) this) && (Boolean) blockstate1.getValue(booleanproperty);
+                    flag = iblockdata1.is((Block) this) && (Boolean) iblockdata1.getValue(blockstateboolean);
                 }
 
-                blockstate = (BlockState) blockstate.setValue(booleanproperty, flag);
+                state = (IBlockData) state.setValue(blockstateboolean, flag);
             }
         }
 
-        return blockstate;
+        return state;
     }
 
     @Override
-    @Override
-    public BlockState updateShape(BlockState blockstate, Direction direction, BlockState blockstate1, LevelAccessor levelaccessor, BlockPos blockpos, BlockPos blockpos1) {
-        if (direction == Direction.DOWN) {
-            return super.updateShape(blockstate, direction, blockstate1, levelaccessor, blockpos, blockpos1);
+    public IBlockData updateShape(IBlockData state, Direction facing, IBlockData facingState, LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
+        if (facing == Direction.DOWN) {
+            return super.updateShape(state, facing, facingState, level, currentPos, facingPos);
         } else {
-            BlockState blockstate2 = this.getUpdatedState(blockstate, levelaccessor, blockpos);
+            IBlockData iblockdata2 = this.getUpdatedState(state, level, currentPos);
 
-            return !this.hasFaces(blockstate2) ? Blocks.AIR.defaultBlockState() : blockstate2;
+            return !this.hasFaces(iblockdata2) ? Blocks.AIR.defaultBlockState() : iblockdata2;
         }
     }
 
     @Override
-    @Override
-    public void randomTick(BlockState blockstate, ServerLevel serverlevel, BlockPos blockpos, RandomSource randomsource) {
-        if (serverlevel.getGameRules().getBoolean(GameRules.RULE_DO_VINES_SPREAD)) {
-            if (randomsource.nextInt(4) == 0) {
-                Direction direction = Direction.getRandom(randomsource);
-                BlockPos blockpos1 = blockpos.above();
-                BlockPos blockpos2;
-                BlockState blockstate1;
-                Direction direction1;
+    public void randomTick(IBlockData state, ServerLevel level, BlockPos pos, RandomSource random) {
+        if (level.getGameRules().getBoolean(GameRules.RULE_DO_VINES_SPREAD)) {
+            if (random.nextInt(4) == 0) {
+                Direction enumdirection = Direction.getRandom(random);
+                BlockPos blockposition1 = pos.above();
+                BlockPos blockposition2;
+                IBlockData iblockdata1;
+                Direction enumdirection1;
 
-                if (direction.getAxis().isHorizontal() && !(Boolean) blockstate.getValue(getPropertyForFace(direction))) {
-                    if (this.canSpread(serverlevel, blockpos)) {
-                        blockpos2 = blockpos.relative(direction);
-                        blockstate1 = serverlevel.getBlockState(blockpos2);
-                        if (blockstate1.isAir()) {
-                            direction1 = direction.getClockWise();
-                            Direction direction2 = direction.getCounterClockWise();
-                            boolean flag = (Boolean) blockstate.getValue(getPropertyForFace(direction1));
-                            boolean flag1 = (Boolean) blockstate.getValue(getPropertyForFace(direction2));
-                            BlockPos blockpos3 = blockpos2.relative(direction1);
-                            BlockPos blockpos4 = blockpos2.relative(direction2);
+                if (enumdirection.getAxis().isHorizontal() && !(Boolean) state.getValue(getPropertyForFace(enumdirection))) {
+                    if (this.canSpread(level, pos)) {
+                        blockposition2 = pos.relative(enumdirection);
+                        iblockdata1 = level.getBlockState(blockposition2);
+                        if (iblockdata1.isAir()) {
+                            enumdirection1 = enumdirection.getClockWise();
+                            Direction enumdirection2 = enumdirection.getCounterClockWise();
+                            boolean flag = (Boolean) state.getValue(getPropertyForFace(enumdirection1));
+                            boolean flag1 = (Boolean) state.getValue(getPropertyForFace(enumdirection2));
+                            BlockPos blockposition3 = blockposition2.relative(enumdirection1);
+                            BlockPos blockposition4 = blockposition2.relative(enumdirection2);
 
-                            if (flag && isAcceptableNeighbour(serverlevel, blockpos3, direction1)) {
-                                serverlevel.setBlock(blockpos2, (BlockState) this.defaultBlockState().setValue(getPropertyForFace(direction1), true), 2);
-                            } else if (flag1 && isAcceptableNeighbour(serverlevel, blockpos4, direction2)) {
-                                serverlevel.setBlock(blockpos2, (BlockState) this.defaultBlockState().setValue(getPropertyForFace(direction2), true), 2);
+                            // CraftBukkit start - Call BlockSpreadEvent
+                            BlockPos source = pos;
+
+                            if (flag && isAcceptableNeighbour(level, blockposition3, enumdirection1)) {
+                                CraftEventFactory.handleBlockSpreadEvent(level, source, blockposition2, (IBlockData) this.defaultBlockState().setValue(getPropertyForFace(enumdirection1), true), 2);
+                            } else if (flag1 && isAcceptableNeighbour(level, blockposition4, enumdirection2)) {
+                                CraftEventFactory.handleBlockSpreadEvent(level, source, blockposition2, (IBlockData) this.defaultBlockState().setValue(getPropertyForFace(enumdirection2), true), 2);
                             } else {
-                                Direction direction3 = direction.getOpposite();
+                                Direction enumdirection3 = enumdirection.getOpposite();
 
-                                if (flag && serverlevel.isEmptyBlock(blockpos3) && isAcceptableNeighbour(serverlevel, blockpos.relative(direction1), direction3)) {
-                                    serverlevel.setBlock(blockpos3, (BlockState) this.defaultBlockState().setValue(getPropertyForFace(direction3), true), 2);
-                                } else if (flag1 && serverlevel.isEmptyBlock(blockpos4) && isAcceptableNeighbour(serverlevel, blockpos.relative(direction2), direction3)) {
-                                    serverlevel.setBlock(blockpos4, (BlockState) this.defaultBlockState().setValue(getPropertyForFace(direction3), true), 2);
-                                } else if ((double) randomsource.nextFloat() < 0.05D && isAcceptableNeighbour(serverlevel, blockpos2.above(), Direction.UP)) {
-                                    serverlevel.setBlock(blockpos2, (BlockState) this.defaultBlockState().setValue(VineBlock.UP, true), 2);
+                                if (flag && level.isEmptyBlock(blockposition3) && isAcceptableNeighbour(level, pos.relative(enumdirection1), enumdirection3)) {
+                                    CraftEventFactory.handleBlockSpreadEvent(level, source, blockposition3, (IBlockData) this.defaultBlockState().setValue(getPropertyForFace(enumdirection3), true), 2);
+                                } else if (flag1 && level.isEmptyBlock(blockposition4) && isAcceptableNeighbour(level, pos.relative(enumdirection2), enumdirection3)) {
+                                    CraftEventFactory.handleBlockSpreadEvent(level, source, blockposition4, (IBlockData) this.defaultBlockState().setValue(getPropertyForFace(enumdirection3), true), 2);
+                                } else if ((double) random.nextFloat() < 0.05D && isAcceptableNeighbour(level, blockposition2.above(), Direction.UP)) {
+                                    CraftEventFactory.handleBlockSpreadEvent(level, source, blockposition2, (IBlockData) this.defaultBlockState().setValue(VineBlock.UP, true), 2);
                                 }
+                                // CraftBukkit end
                             }
-                        } else if (isAcceptableNeighbour(serverlevel, blockpos2, direction)) {
-                            serverlevel.setBlock(blockpos, (BlockState) blockstate.setValue(getPropertyForFace(direction), true), 2);
+                        } else if (isAcceptableNeighbour(level, blockposition2, enumdirection)) {
+                            CraftEventFactory.handleBlockGrowEvent(level, pos, (IBlockData) state.setValue(getPropertyForFace(enumdirection), true), 2); // CraftBukkit
                         }
 
                     }
                 } else {
-                    if (direction == Direction.UP && blockpos.getY() < serverlevel.getMaxBuildHeight() - 1) {
-                        if (this.canSupportAtFace(serverlevel, blockpos, direction)) {
-                            serverlevel.setBlock(blockpos, (BlockState) blockstate.setValue(VineBlock.UP, true), 2);
+                    if (enumdirection == Direction.UP && pos.getY() < level.getMaxBuildHeight() - 1) {
+                        if (this.canSupportAtFace(level, pos, enumdirection)) {
+                            CraftEventFactory.handleBlockGrowEvent(level, pos, (IBlockData) state.setValue(VineBlock.UP, true), 2); // CraftBukkit
                             return;
                         }
 
-                        if (serverlevel.isEmptyBlock(blockpos1)) {
-                            if (!this.canSpread(serverlevel, blockpos)) {
+                        if (level.isEmptyBlock(blockposition1)) {
+                            if (!this.canSpread(level, pos)) {
                                 return;
                             }
 
-                            BlockState blockstate2 = blockstate;
+                            IBlockData iblockdata2 = state;
                             Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
                             while (iterator.hasNext()) {
-                                direction1 = (Direction) iterator.next();
-                                if (randomsource.nextBoolean() || !isAcceptableNeighbour(serverlevel, blockpos1.relative(direction1), direction1)) {
-                                    blockstate2 = (BlockState) blockstate2.setValue(getPropertyForFace(direction1), false);
+                                enumdirection1 = (Direction) iterator.next();
+                                if (random.nextBoolean() || !isAcceptableNeighbour(level, blockposition1.relative(enumdirection1), enumdirection1)) {
+                                    iblockdata2 = (IBlockData) iblockdata2.setValue(getPropertyForFace(enumdirection1), false);
                                 }
                             }
 
-                            if (this.hasHorizontalConnection(blockstate2)) {
-                                serverlevel.setBlock(blockpos1, blockstate2, 2);
+                            if (this.hasHorizontalConnection(iblockdata2)) {
+                                CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition1, iblockdata2, 2); // CraftBukkit
                             }
 
                             return;
                         }
                     }
 
-                    if (blockpos.getY() > serverlevel.getMinBuildHeight()) {
-                        blockpos2 = blockpos.below();
-                        blockstate1 = serverlevel.getBlockState(blockpos2);
-                        if (blockstate1.isAir() || blockstate1.is((Block) this)) {
-                            BlockState blockstate3 = blockstate1.isAir() ? this.defaultBlockState() : blockstate1;
-                            BlockState blockstate4 = this.copyRandomFaces(blockstate, blockstate3, randomsource);
+                    if (pos.getY() > level.getMinBuildHeight()) {
+                        blockposition2 = pos.below();
+                        iblockdata1 = level.getBlockState(blockposition2);
+                        if (iblockdata1.isAir() || iblockdata1.is((Block) this)) {
+                            IBlockData iblockdata3 = iblockdata1.isAir() ? this.defaultBlockState() : iblockdata1;
+                            IBlockData iblockdata4 = this.copyRandomFaces(state, iblockdata3, random);
 
-                            if (blockstate3 != blockstate4 && this.hasHorizontalConnection(blockstate4)) {
-                                serverlevel.setBlock(blockpos2, blockstate4, 2);
+                            if (iblockdata3 != iblockdata4 && this.hasHorizontalConnection(iblockdata4)) {
+                                CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition2, iblockdata4, 2); // CraftBukkit
                             }
                         }
                     }
@@ -277,38 +276,38 @@
         }
     }
 
-    private BlockState copyRandomFaces(BlockState blockstate, BlockState blockstate1, RandomSource randomsource) {
+    private IBlockData copyRandomFaces(IBlockData sourceState, IBlockData spreadState, RandomSource random) {
         Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
         while (iterator.hasNext()) {
-            Direction direction = (Direction) iterator.next();
+            Direction enumdirection = (Direction) iterator.next();
 
-            if (randomsource.nextBoolean()) {
-                BooleanProperty booleanproperty = getPropertyForFace(direction);
+            if (random.nextBoolean()) {
+                BooleanProperty blockstateboolean = getPropertyForFace(enumdirection);
 
-                if ((Boolean) blockstate.getValue(booleanproperty)) {
-                    blockstate1 = (BlockState) blockstate1.setValue(booleanproperty, true);
+                if ((Boolean) sourceState.getValue(blockstateboolean)) {
+                    spreadState = (IBlockData) spreadState.setValue(blockstateboolean, true);
                 }
             }
         }
 
-        return blockstate1;
+        return spreadState;
     }
 
-    private boolean hasHorizontalConnection(BlockState blockstate) {
-        return (Boolean) blockstate.getValue(VineBlock.NORTH) || (Boolean) blockstate.getValue(VineBlock.EAST) || (Boolean) blockstate.getValue(VineBlock.SOUTH) || (Boolean) blockstate.getValue(VineBlock.WEST);
+    private boolean hasHorizontalConnection(IBlockData state) {
+        return (Boolean) state.getValue(VineBlock.NORTH) || (Boolean) state.getValue(VineBlock.EAST) || (Boolean) state.getValue(VineBlock.SOUTH) || (Boolean) state.getValue(VineBlock.WEST);
     }
 
-    private boolean canSpread(BlockGetter blockgetter, BlockPos blockpos) {
+    private boolean canSpread(BlockGetter blockReader, BlockPos pos) {
         boolean flag = true;
-        Iterable<BlockPos> iterable = BlockPos.betweenClosed(blockpos.getX() - 4, blockpos.getY() - 1, blockpos.getZ() - 4, blockpos.getX() + 4, blockpos.getY() + 1, blockpos.getZ() + 4);
+        Iterable<BlockPos> iterable = BlockPos.betweenClosed(pos.getX() - 4, pos.getY() - 1, pos.getZ() - 4, pos.getX() + 4, pos.getY() + 1, pos.getZ() + 4);
         int i = 5;
         Iterator iterator = iterable.iterator();
 
         while (iterator.hasNext()) {
-            BlockPos blockpos1 = (BlockPos) iterator.next();
+            BlockPos blockposition1 = (BlockPos) iterator.next();
 
-            if (blockgetter.getBlockState(blockpos1).is((Block) this)) {
+            if (blockReader.getBlockState(blockposition1).is((Block) this)) {
                 --i;
                 if (i <= 0) {
                     return false;
@@ -320,74 +319,69 @@
     }
 
     @Override
-    @Override
-    public boolean canBeReplaced(BlockState blockstate, BlockPlaceContext blockplacecontext) {
-        BlockState blockstate1 = blockplacecontext.getLevel().getBlockState(blockplacecontext.getClickedPos());
+    public boolean canBeReplaced(IBlockData state, BlockPlaceContext useContext) {
+        IBlockData iblockdata1 = useContext.getLevel().getBlockState(useContext.getClickedPos());
 
-        return blockstate1.is((Block) this) ? this.countFaces(blockstate1) < VineBlock.PROPERTY_BY_DIRECTION.size() : super.canBeReplaced(blockstate, blockplacecontext);
+        return iblockdata1.is((Block) this) ? this.countFaces(iblockdata1) < VineBlock.PROPERTY_BY_DIRECTION.size() : super.canBeReplaced(state, useContext);
     }
 
     @Nullable
     @Override
-    @Override
-    public BlockState getStateForPlacement(BlockPlaceContext blockplacecontext) {
-        BlockState blockstate = blockplacecontext.getLevel().getBlockState(blockplacecontext.getClickedPos());
-        boolean flag = blockstate.is((Block) this);
-        BlockState blockstate1 = flag ? blockstate : this.defaultBlockState();
-        Direction[] adirection = blockplacecontext.getNearestLookingDirections();
-        int i = adirection.length;
+    public IBlockData getStateForPlacement(BlockPlaceContext context) {
+        IBlockData iblockdata = context.getLevel().getBlockState(context.getClickedPos());
+        boolean flag = iblockdata.is((Block) this);
+        IBlockData iblockdata1 = flag ? iblockdata : this.defaultBlockState();
+        Direction[] aenumdirection = context.getNearestLookingDirections();
+        int i = aenumdirection.length;
 
         for (int j = 0; j < i; ++j) {
-            Direction direction = adirection[j];
+            Direction enumdirection = aenumdirection[j];
 
-            if (direction != Direction.DOWN) {
-                BooleanProperty booleanproperty = getPropertyForFace(direction);
-                boolean flag1 = flag && (Boolean) blockstate.getValue(booleanproperty);
+            if (enumdirection != Direction.DOWN) {
+                BooleanProperty blockstateboolean = getPropertyForFace(enumdirection);
+                boolean flag1 = flag && (Boolean) iblockdata.getValue(blockstateboolean);
 
-                if (!flag1 && this.canSupportAtFace(blockplacecontext.getLevel(), blockplacecontext.getClickedPos(), direction)) {
-                    return (BlockState) blockstate1.setValue(booleanproperty, true);
+                if (!flag1 && this.canSupportAtFace(context.getLevel(), context.getClickedPos(), enumdirection)) {
+                    return (IBlockData) iblockdata1.setValue(blockstateboolean, true);
                 }
             }
         }
 
-        return flag ? blockstate1 : null;
+        return flag ? iblockdata1 : null;
     }
 
     @Override
-    @Override
-    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> statedefinition_builder) {
-        statedefinition_builder.add(VineBlock.UP, VineBlock.NORTH, VineBlock.EAST, VineBlock.SOUTH, VineBlock.WEST);
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, IBlockData> builder) {
+        builder.add(VineBlock.UP, VineBlock.NORTH, VineBlock.EAST, VineBlock.SOUTH, VineBlock.WEST);
     }
 
     @Override
-    @Override
-    public BlockState rotate(BlockState blockstate, Rotation rotation) {
-        switch (rotation) {
+    public IBlockData rotate(IBlockData state, Rotation rotate) {
+        switch (rotate) {
             case CLOCKWISE_180:
-                return (BlockState) ((BlockState) ((BlockState) ((BlockState) blockstate.setValue(VineBlock.NORTH, (Boolean) blockstate.getValue(VineBlock.SOUTH))).setValue(VineBlock.EAST, (Boolean) blockstate.getValue(VineBlock.WEST))).setValue(VineBlock.SOUTH, (Boolean) blockstate.getValue(VineBlock.NORTH))).setValue(VineBlock.WEST, (Boolean) blockstate.getValue(VineBlock.EAST));
+                return (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) state.setValue(VineBlock.NORTH, (Boolean) state.getValue(VineBlock.SOUTH))).setValue(VineBlock.EAST, (Boolean) state.getValue(VineBlock.WEST))).setValue(VineBlock.SOUTH, (Boolean) state.getValue(VineBlock.NORTH))).setValue(VineBlock.WEST, (Boolean) state.getValue(VineBlock.EAST));
             case COUNTERCLOCKWISE_90:
-                return (BlockState) ((BlockState) ((BlockState) ((BlockState) blockstate.setValue(VineBlock.NORTH, (Boolean) blockstate.getValue(VineBlock.EAST))).setValue(VineBlock.EAST, (Boolean) blockstate.getValue(VineBlock.SOUTH))).setValue(VineBlock.SOUTH, (Boolean) blockstate.getValue(VineBlock.WEST))).setValue(VineBlock.WEST, (Boolean) blockstate.getValue(VineBlock.NORTH));
+                return (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) state.setValue(VineBlock.NORTH, (Boolean) state.getValue(VineBlock.EAST))).setValue(VineBlock.EAST, (Boolean) state.getValue(VineBlock.SOUTH))).setValue(VineBlock.SOUTH, (Boolean) state.getValue(VineBlock.WEST))).setValue(VineBlock.WEST, (Boolean) state.getValue(VineBlock.NORTH));
             case CLOCKWISE_90:
-                return (BlockState) ((BlockState) ((BlockState) ((BlockState) blockstate.setValue(VineBlock.NORTH, (Boolean) blockstate.getValue(VineBlock.WEST))).setValue(VineBlock.EAST, (Boolean) blockstate.getValue(VineBlock.NORTH))).setValue(VineBlock.SOUTH, (Boolean) blockstate.getValue(VineBlock.EAST))).setValue(VineBlock.WEST, (Boolean) blockstate.getValue(VineBlock.SOUTH));
+                return (IBlockData) ((IBlockData) ((IBlockData) ((IBlockData) state.setValue(VineBlock.NORTH, (Boolean) state.getValue(VineBlock.WEST))).setValue(VineBlock.EAST, (Boolean) state.getValue(VineBlock.NORTH))).setValue(VineBlock.SOUTH, (Boolean) state.getValue(VineBlock.EAST))).setValue(VineBlock.WEST, (Boolean) state.getValue(VineBlock.SOUTH));
             default:
-                return blockstate;
+                return state;
         }
     }
 
     @Override
-    @Override
-    public BlockState mirror(BlockState blockstate, Mirror mirror) {
+    public IBlockData mirror(IBlockData state, Mirror mirror) {
         switch (mirror) {
             case LEFT_RIGHT:
-                return (BlockState) ((BlockState) blockstate.setValue(VineBlock.NORTH, (Boolean) blockstate.getValue(VineBlock.SOUTH))).setValue(VineBlock.SOUTH, (Boolean) blockstate.getValue(VineBlock.NORTH));
+                return (IBlockData) ((IBlockData) state.setValue(VineBlock.NORTH, (Boolean) state.getValue(VineBlock.SOUTH))).setValue(VineBlock.SOUTH, (Boolean) state.getValue(VineBlock.NORTH));
             case FRONT_BACK:
-                return (BlockState) ((BlockState) blockstate.setValue(VineBlock.EAST, (Boolean) blockstate.getValue(VineBlock.WEST))).setValue(VineBlock.WEST, (Boolean) blockstate.getValue(VineBlock.EAST));
+                return (IBlockData) ((IBlockData) state.setValue(VineBlock.EAST, (Boolean) state.getValue(VineBlock.WEST))).setValue(VineBlock.WEST, (Boolean) state.getValue(VineBlock.EAST));
             default:
-                return super.mirror(blockstate, mirror);
+                return super.mirror(state, mirror);
         }
     }
 
-    public static BooleanProperty getPropertyForFace(Direction direction) {
-        return (BooleanProperty) VineBlock.PROPERTY_BY_DIRECTION.get(direction);
+    public static BooleanProperty getPropertyForFace(Direction face) {
+        return (BooleanProperty) VineBlock.PROPERTY_BY_DIRECTION.get(face);
     }
 }
