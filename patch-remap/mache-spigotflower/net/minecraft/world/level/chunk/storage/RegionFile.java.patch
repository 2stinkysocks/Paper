--- a/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -1,3 +1,4 @@
+// mc-dev import
 package net.minecraft.world.level.chunk.storage;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -44,38 +45,38 @@
     @VisibleForTesting
     protected final RegionBitmap usedSectors;
 
-    public RegionFile(Path path, Path path1, boolean flag) throws IOException {
-        this(path, path1, RegionFileVersion.VERSION_DEFLATE, flag);
+    public RegionFile(Path regionFile, Path containingFolder, boolean sync) throws IOException {
+        this(regionFile, containingFolder, RegionFileVersion.VERSION_DEFLATE, sync);
     }
 
-    public RegionFile(Path path, Path path1, RegionFileVersion regionfileversion, boolean flag) throws IOException {
+    public RegionFile(Path regionFile, Path containingFolder, RegionFileVersion version, boolean sync) throws IOException {
         this.header = ByteBuffer.allocateDirect(8192);
         this.usedSectors = new RegionBitmap();
-        this.version = regionfileversion;
-        if (!Files.isDirectory(path1, new LinkOption[0])) {
-            throw new IllegalArgumentException("Expected directory, got " + path1.toAbsolutePath());
+        this.version = version;
+        if (!Files.isDirectory(containingFolder, new LinkOption[0])) {
+            throw new IllegalArgumentException("Expected directory, got " + containingFolder.toAbsolutePath());
         } else {
-            this.externalFileDir = path1;
+            this.externalFileDir = containingFolder;
             this.offsets = this.header.asIntBuffer();
-            this.offsets.limit(1024);
-            this.header.position(4096);
+            ((java.nio.Buffer) this.offsets).limit(1024); // CraftBukkit - decompile error
+            ((java.nio.Buffer) this.header).position(4096); // CraftBukkit - decompile error
             this.timestamps = this.header.asIntBuffer();
-            if (flag) {
-                this.file = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DSYNC);
+            if (sync) {
+                this.file = FileChannel.open(regionFile, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DSYNC);
             } else {
-                this.file = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);
+                this.file = FileChannel.open(regionFile, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);
             }
 
             this.usedSectors.force(0, 2);
-            this.header.position(0);
+            ((java.nio.Buffer) this.header).position(0); // CraftBukkit - decompile error
             int i = this.file.read(this.header, 0L);
 
             if (i != -1) {
                 if (i != 8192) {
-                    RegionFile.LOGGER.warn("Region file {} has truncated header: {}", path, i);
+                    RegionFile.LOGGER.warn("Region file {} has truncated header: {}", regionFile, i);
                 }
 
-                long j = Files.size(path);
+                long j = Files.size(regionFile);
 
                 for (int k = 0; k < 1024; ++k) {
                     int l = this.offsets.get(k);
@@ -85,13 +86,13 @@
                         int j1 = getNumSectors(l);
 
                         if (i1 < 2) {
-                            RegionFile.LOGGER.warn("Region file {} has invalid sector at index: {}; sector {} overlaps with header", new Object[]{path, k, i1});
+                            RegionFile.LOGGER.warn("Region file {} has invalid sector at index: {}; sector {} overlaps with header", new Object[]{regionFile, k, i1});
                             this.offsets.put(k, 0);
                         } else if (j1 == 0) {
-                            RegionFile.LOGGER.warn("Region file {} has an invalid sector at index: {}; size has to be > 0", path, k);
+                            RegionFile.LOGGER.warn("Region file {} has an invalid sector at index: {}; size has to be > 0", regionFile, k);
                             this.offsets.put(k, 0);
                         } else if ((long) i1 * 4096L > j) {
-                            RegionFile.LOGGER.warn("Region file {} has an invalid sector at index: {}; sector {} is out of bounds", new Object[]{path, k, i1});
+                            RegionFile.LOGGER.warn("Region file {} has an invalid sector at index: {}; sector {} is out of bounds", new Object[]{regionFile, k, i1});
                             this.offsets.put(k, 0);
                         } else {
                             this.usedSectors.force(i1, j1);
@@ -103,15 +104,15 @@
         }
     }
 
-    private Path getExternalChunkPath(ChunkPos chunkpos) {
-        String s = "c." + chunkpos.x + "." + chunkpos.z + ".mcc";
+    private Path getExternalChunkPath(ChunkPos chunkPos) {
+        String s = "c." + chunkPos.x + "." + chunkPos.z + ".mcc";
 
         return this.externalFileDir.resolve(s);
     }
 
     @Nullable
-    public synchronized DataInputStream getChunkDataInputStream(ChunkPos chunkpos) throws IOException {
-        int i = this.getOffset(chunkpos);
+    public synchronized DataInputStream getChunkDataInputStream(ChunkPos chunkPos) throws IOException {
+        int i = this.getOffset(chunkPos);
 
         if (i == 0) {
             return null;
@@ -122,16 +123,16 @@
             ByteBuffer bytebuffer = ByteBuffer.allocate(l);
 
             this.file.read(bytebuffer, (long) (j * 4096));
-            bytebuffer.flip();
+            ((java.nio.Buffer) bytebuffer).flip(); // CraftBukkit - decompile error
             if (bytebuffer.remaining() < 5) {
-                RegionFile.LOGGER.error("Chunk {} header is truncated: expected {} but read {}", new Object[]{chunkpos, l, bytebuffer.remaining()});
+                RegionFile.LOGGER.error("Chunk {} header is truncated: expected {} but read {}", new Object[]{chunkPos, l, bytebuffer.remaining()});
                 return null;
             } else {
                 int i1 = bytebuffer.getInt();
                 byte b0 = bytebuffer.get();
 
                 if (i1 == 0) {
-                    RegionFile.LOGGER.warn("Chunk {} is allocated, but stream is missing", chunkpos);
+                    RegionFile.LOGGER.warn("Chunk {} is allocated, but stream is missing", chunkPos);
                     return null;
                 } else {
                     int j1 = i1 - 1;
@@ -141,15 +142,15 @@
                             RegionFile.LOGGER.warn("Chunk has both internal and external streams");
                         }
 
-                        return this.createExternalChunkInputStream(chunkpos, getExternalChunkVersion(b0));
+                        return this.createExternalChunkInputStream(chunkPos, getExternalChunkVersion(b0));
                     } else if (j1 > bytebuffer.remaining()) {
-                        RegionFile.LOGGER.error("Chunk {} stream is truncated: expected {} but read {}", new Object[]{chunkpos, j1, bytebuffer.remaining()});
+                        RegionFile.LOGGER.error("Chunk {} stream is truncated: expected {} but read {}", new Object[]{chunkPos, j1, bytebuffer.remaining()});
                         return null;
                     } else if (j1 < 0) {
-                        RegionFile.LOGGER.error("Declared size {} of chunk {} is negative", i1, chunkpos);
+                        RegionFile.LOGGER.error("Declared size {} of chunk {} is negative", i1, chunkPos);
                         return null;
                     } else {
-                        return this.createChunkInputStream(chunkpos, b0, createStream(bytebuffer, j1));
+                        return this.createChunkInputStream(chunkPos, b0, createStream(bytebuffer, j1));
                     }
                 }
             }
@@ -160,60 +161,60 @@
         return (int) (Util.getEpochMillis() / 1000L);
     }
 
-    private static boolean isExternalStreamChunk(byte b0) {
-        return (b0 & 128) != 0;
+    private static boolean isExternalStreamChunk(byte versionByte) {
+        return (versionByte & 128) != 0;
     }
 
-    private static byte getExternalChunkVersion(byte b0) {
-        return (byte) (b0 & -129);
+    private static byte getExternalChunkVersion(byte versionByte) {
+        return (byte) (versionByte & -129);
     }
 
     @Nullable
-    private DataInputStream createChunkInputStream(ChunkPos chunkpos, byte b0, InputStream inputstream) throws IOException {
-        RegionFileVersion regionfileversion = RegionFileVersion.fromId(b0);
+    private DataInputStream createChunkInputStream(ChunkPos chunkPos, byte versionByte, InputStream inputStream) throws IOException {
+        RegionFileVersion regionfilecompression = RegionFileVersion.fromId(versionByte);
 
-        if (regionfileversion == null) {
-            RegionFile.LOGGER.error("Chunk {} has invalid chunk stream version {}", chunkpos, b0);
+        if (regionfilecompression == null) {
+            RegionFile.LOGGER.error("Chunk {} has invalid chunk stream version {}", chunkPos, versionByte);
             return null;
         } else {
-            return new DataInputStream(regionfileversion.wrap(inputstream));
+            return new DataInputStream(regionfilecompression.wrap(inputStream));
         }
     }
 
     @Nullable
-    private DataInputStream createExternalChunkInputStream(ChunkPos chunkpos, byte b0) throws IOException {
-        Path path = this.getExternalChunkPath(chunkpos);
+    private DataInputStream createExternalChunkInputStream(ChunkPos chunkPos, byte versionByte) throws IOException {
+        Path path = this.getExternalChunkPath(chunkPos);
 
         if (!Files.isRegularFile(path, new LinkOption[0])) {
             RegionFile.LOGGER.error("External chunk path {} is not file", path);
             return null;
         } else {
-            return this.createChunkInputStream(chunkpos, b0, Files.newInputStream(path));
+            return this.createChunkInputStream(chunkPos, versionByte, Files.newInputStream(path));
         }
     }
 
-    private static ByteArrayInputStream createStream(ByteBuffer bytebuffer, int i) {
-        return new ByteArrayInputStream(bytebuffer.array(), bytebuffer.position(), i);
+    private static ByteArrayInputStream createStream(ByteBuffer sourceBuffer, int length) {
+        return new ByteArrayInputStream(sourceBuffer.array(), sourceBuffer.position(), length);
     }
 
-    private int packSectorOffset(int i, int j) {
-        return i << 8 | j;
+    private int packSectorOffset(int sectorOffset, int sectorCount) {
+        return sectorOffset << 8 | sectorCount;
     }
 
-    private static int getNumSectors(int i) {
-        return i & 255;
+    private static int getNumSectors(int packedSectorOffset) {
+        return packedSectorOffset & 255;
     }
 
-    private static int getSectorNumber(int i) {
-        return i >> 8 & 16777215;
+    private static int getSectorNumber(int packedSectorOffset) {
+        return packedSectorOffset >> 8 & 16777215;
     }
 
-    private static int sizeToSectors(int i) {
-        return (i + 4096 - 1) / 4096;
+    private static int sizeToSectors(int size) {
+        return (size + 4096 - 1) / 4096;
     }
 
-    public boolean doesChunkExist(ChunkPos chunkpos) {
-        int i = this.getOffset(chunkpos);
+    public boolean doesChunkExist(ChunkPos chunkPos) {
+        int i = this.getOffset(chunkPos);
 
         if (i == 0) {
             return false;
@@ -224,7 +225,7 @@
 
             try {
                 this.file.read(bytebuffer, (long) (j * 4096));
-                bytebuffer.flip();
+                ((java.nio.Buffer) bytebuffer).flip(); // CraftBukkit - decompile error
                 if (bytebuffer.remaining() != 5) {
                     return false;
                 } else {
@@ -236,7 +237,7 @@
                             return false;
                         }
 
-                        if (!Files.isRegularFile(this.getExternalChunkPath(chunkpos), new LinkOption[0])) {
+                        if (!Files.isRegularFile(this.getExternalChunkPath(chunkPos), new LinkOption[0])) {
                             return false;
                         }
                     } else {
@@ -263,59 +264,59 @@
         }
     }
 
-    public DataOutputStream getChunkDataOutputStream(ChunkPos chunkpos) throws IOException {
-        return new DataOutputStream(this.version.wrap((OutputStream) (new RegionFile.ChunkBuffer(chunkpos))));
+    public DataOutputStream getChunkDataOutputStream(ChunkPos chunkPos) throws IOException {
+        return new DataOutputStream(this.version.wrap((OutputStream) (new RegionFile.ChunkBuffer(chunkPos))));
     }
 
     public void flush() throws IOException {
         this.file.force(true);
     }
 
-    public void clear(ChunkPos chunkpos) throws IOException {
-        int i = getOffsetIndex(chunkpos);
+    public void clear(ChunkPos chunkPos) throws IOException {
+        int i = getOffsetIndex(chunkPos);
         int j = this.offsets.get(i);
 
         if (j != 0) {
             this.offsets.put(i, 0);
             this.timestamps.put(i, getTimestamp());
             this.writeHeader();
-            Files.deleteIfExists(this.getExternalChunkPath(chunkpos));
+            Files.deleteIfExists(this.getExternalChunkPath(chunkPos));
             this.usedSectors.free(getSectorNumber(j), getNumSectors(j));
         }
     }
 
-    protected synchronized void write(ChunkPos chunkpos, ByteBuffer bytebuffer) throws IOException {
-        int i = getOffsetIndex(chunkpos);
+    protected synchronized void write(ChunkPos chunkPos, ByteBuffer chunkData) throws IOException {
+        int i = getOffsetIndex(chunkPos);
         int j = this.offsets.get(i);
         int k = getSectorNumber(j);
         int l = getNumSectors(j);
-        int i1 = bytebuffer.remaining();
+        int i1 = chunkData.remaining();
         int j1 = sizeToSectors(i1);
         int k1;
-        RegionFile.CommitOp regionfile_commitop;
+        RegionFile.b regionfile_b;
 
         if (j1 >= 256) {
-            Path path = this.getExternalChunkPath(chunkpos);
+            Path path = this.getExternalChunkPath(chunkPos);
 
-            RegionFile.LOGGER.warn("Saving oversized chunk {} ({} bytes} to external file {}", new Object[]{chunkpos, i1, path});
+            RegionFile.LOGGER.warn("Saving oversized chunk {} ({} bytes} to external file {}", new Object[]{chunkPos, i1, path});
             j1 = 1;
             k1 = this.usedSectors.allocate(j1);
-            regionfile_commitop = this.writeToExternalFile(path, bytebuffer);
+            regionfile_b = this.writeToExternalFile(path, chunkData);
             ByteBuffer bytebuffer1 = this.createExternalStub();
 
             this.file.write(bytebuffer1, (long) (k1 * 4096));
         } else {
             k1 = this.usedSectors.allocate(j1);
-            regionfile_commitop = () -> {
-                Files.deleteIfExists(this.getExternalChunkPath(chunkpos));
+            regionfile_b = () -> {
+                Files.deleteIfExists(this.getExternalChunkPath(chunkPos));
             };
-            this.file.write(bytebuffer, (long) (k1 * 4096));
+            this.file.write(chunkData, (long) (k1 * 4096));
         }
 
         this.offsets.put(i, this.packSectorOffset(k1, j1));
         this.timestamps.put(i, getTimestamp());
         this.writeHeader();
-        regionfile_commitop.run();
+        regionfile_b.run();
         if (k != 0) {
             this.usedSectors.free(k, l);
         }
@@ -327,17 +328,17 @@
 
         bytebuffer.putInt(1);
         bytebuffer.put((byte) (this.version.getId() | 128));
-        bytebuffer.flip();
+        ((java.nio.Buffer) bytebuffer).flip(); // CraftBukkit - decompile error
         return bytebuffer;
     }
 
-    private RegionFile.CommitOp writeToExternalFile(Path path, ByteBuffer bytebuffer) throws IOException {
+    private RegionFile.b writeToExternalFile(Path externalChunkFile, ByteBuffer chunkData) throws IOException {
         Path path1 = Files.createTempFile(this.externalFileDir, "tmp", (String) null);
         FileChannel filechannel = FileChannel.open(path1, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
 
         try {
-            bytebuffer.position(5);
-            filechannel.write(bytebuffer);
+            ((java.nio.Buffer) chunkData).position(5); // CraftBukkit - decompile error
+            filechannel.write(chunkData);
         } catch (Throwable throwable) {
             if (filechannel != null) {
                 try {
@@ -355,28 +356,27 @@
         }
 
         return () -> {
-            Files.move(path1, path, StandardCopyOption.REPLACE_EXISTING);
+            Files.move(path1, externalChunkFile, StandardCopyOption.REPLACE_EXISTING);
         };
     }
 
     private void writeHeader() throws IOException {
-        this.header.position(0);
+        ((java.nio.Buffer) this.header).position(0); // CraftBukkit - decompile error
         this.file.write(this.header, 0L);
     }
 
-    private int getOffset(ChunkPos chunkpos) {
-        return this.offsets.get(getOffsetIndex(chunkpos));
+    private int getOffset(ChunkPos chunkPos) {
+        return this.offsets.get(getOffsetIndex(chunkPos));
     }
 
-    public boolean hasChunk(ChunkPos chunkpos) {
-        return this.getOffset(chunkpos) != 0;
+    public boolean hasChunk(ChunkPos chunkPos) {
+        return this.getOffset(chunkPos) != 0;
     }
 
-    private static int getOffsetIndex(ChunkPos chunkpos) {
-        return chunkpos.getRegionLocalX() + chunkpos.getRegionLocalZ() * 32;
+    private static int getOffsetIndex(ChunkPos chunkPos) {
+        return chunkPos.getRegionLocalX() + chunkPos.getRegionLocalZ() * 32;
     }
 
-    @Override
     public void close() throws IOException {
         try {
             this.padToFullSector();
@@ -397,7 +397,7 @@
         if (i != j) {
             ByteBuffer bytebuffer = RegionFile.PADDING_BUFFER.duplicate();
 
-            bytebuffer.position(0);
+            ((java.nio.Buffer) bytebuffer).position(0); // CraftBukkit - decompile error
             this.file.write(bytebuffer, (long) (j - 1));
         }
 
@@ -407,17 +407,16 @@
 
         private final ChunkPos pos;
 
-        public ChunkBuffer(ChunkPos chunkpos) {
+        public ChunkBuffer(ChunkPos chunkcoordintpair) {
             super(8096);
             super.write(0);
             super.write(0);
             super.write(0);
             super.write(0);
             super.write(RegionFile.this.version.getId());
-            this.pos = chunkpos;
+            this.pos = chunkcoordintpair;
         }
 
-        @Override
         public void close() throws IOException {
             ByteBuffer bytebuffer = ByteBuffer.wrap(this.buf, 0, this.count);
 
@@ -426,7 +425,7 @@
         }
     }
 
-    private interface CommitOp {
+    private interface b {
 
         void run() throws IOException;
     }
