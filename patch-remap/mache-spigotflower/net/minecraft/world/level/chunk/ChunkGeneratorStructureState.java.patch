--- a/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
+++ b/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
@@ -1,3 +1,4 @@
+// mc-dev import
 package net.minecraft.world.level.chunk;
 
 import com.google.common.base.Stopwatch;
@@ -45,40 +46,40 @@
     private boolean hasGeneratedPositions;
     private final List<Holder<StructureSet>> possibleStructureSets;
 
-    public static ChunkGeneratorStructureState createForFlat(RandomState randomstate, long i, BiomeSource biomesource, Stream<Holder<StructureSet>> stream) {
-        List<Holder<StructureSet>> list = stream.filter((holder) -> {
-            return hasBiomesForStructureSet((StructureSet) holder.value(), biomesource);
+    public static ChunkGeneratorStructureState createForFlat(RandomState randomState, long levelSeed, BiomeSource worldchunkmanager, Stream<Holder<StructureSet>> biomeSource) {
+        List<Holder<StructureSet>> list = biomeSource.filter((holder) -> {
+            return hasBiomesForStructureSet((StructureSet) holder.value(), worldchunkmanager);
         }).toList();
 
-        return new ChunkGeneratorStructureState(randomstate, biomesource, i, 0L, list);
+        return new ChunkGeneratorStructureState(randomState, worldchunkmanager, levelSeed, 0L, list);
     }
 
-    public static ChunkGeneratorStructureState createForNormal(RandomState randomstate, long i, BiomeSource biomesource, HolderLookup<StructureSet> holderlookup) {
-        List<Holder<StructureSet>> list = (List) holderlookup.listElements().filter((holder_reference) -> {
-            return hasBiomesForStructureSet((StructureSet) holder_reference.value(), biomesource);
+    public static ChunkGeneratorStructureState createForNormal(RandomState randomState, long seed, BiomeSource worldchunkmanager, HolderLookup<StructureSet> biomeSource) {
+        List<Holder<StructureSet>> list = (List) biomeSource.listElements().filter((holder_c) -> {
+            return hasBiomesForStructureSet((StructureSet) holder_c.value(), worldchunkmanager);
         }).collect(Collectors.toUnmodifiableList());
 
-        return new ChunkGeneratorStructureState(randomstate, biomesource, i, i, list);
+        return new ChunkGeneratorStructureState(randomState, worldchunkmanager, seed, seed, list);
     }
 
-    private static boolean hasBiomesForStructureSet(StructureSet structureset, BiomeSource biomesource) {
-        Stream<Holder<Biome>> stream = structureset.structures().stream().flatMap((structureset_structureselectionentry) -> {
-            Structure structure = (Structure) structureset_structureselectionentry.structure().value();
+    private static boolean hasBiomesForStructureSet(StructureSet structureSet, BiomeSource biomeSource) {
+        Stream<Holder<Biome>> stream = structureSet.structures().stream().flatMap((structureset_a) -> {
+            Structure structure = (Structure) structureset_a.structure().value();
 
             return structure.biomes().stream();
         });
-        Set set = biomesource.possibleBiomes();
+        Set set = biomeSource.possibleBiomes();
 
         Objects.requireNonNull(set);
         return stream.anyMatch(set::contains);
     }
 
-    private ChunkGeneratorStructureState(RandomState randomstate, BiomeSource biomesource, long i, long j, List<Holder<StructureSet>> list) {
-        this.randomState = randomstate;
-        this.levelSeed = i;
-        this.biomeSource = biomesource;
+    private ChunkGeneratorStructureState(RandomState randomState, BiomeSource biomeSource, long levelSeed, long j, List<Holder<StructureSet>> cocentricRingsSeed) {
+        this.randomState = randomState;
+        this.levelSeed = levelSeed;
+        this.biomeSource = biomeSource;
         this.concentricRingsSeed = j;
-        this.possibleStructureSets = list;
+        this.possibleStructureSets = cocentricRingsSeed;
     }
 
     public List<Holder<StructureSet>> possibleStructureSets() {
@@ -94,8 +95,8 @@
             Iterator iterator = structureset.structures().iterator();
 
             while (iterator.hasNext()) {
-                StructureSet.StructureSelectionEntry structureset_structureselectionentry = (StructureSet.StructureSelectionEntry) iterator.next();
-                Structure structure = (Structure) structureset_structureselectionentry.structure().value();
+                StructureSet.a structureset_a = (StructureSet.a) iterator.next();
+                Structure structure = (Structure) structureset_a.structure().value();
                 Stream stream = structure.biomes().stream();
 
                 Objects.requireNonNull(set);
@@ -120,16 +121,16 @@
         });
     }
 
-    private CompletableFuture<List<ChunkPos>> generateRingPositions(Holder<StructureSet> holder, ConcentricRingsStructurePlacement concentricringsstructureplacement) {
-        if (concentricringsstructureplacement.count() == 0) {
+    private CompletableFuture<List<ChunkPos>> generateRingPositions(Holder<StructureSet> structureSet, ConcentricRingsStructurePlacement placement) {
+        if (placement.count() == 0) {
             return CompletableFuture.completedFuture(List.of());
         } else {
             Stopwatch stopwatch = Stopwatch.createStarted(Util.TICKER);
-            int i = concentricringsstructureplacement.distance();
-            int j = concentricringsstructureplacement.count();
+            int i = placement.distance();
+            int j = placement.count();
             List<CompletableFuture<ChunkPos>> list = new ArrayList(j);
-            int k = concentricringsstructureplacement.spread();
-            HolderSet<Biome> holderset = concentricringsstructureplacement.preferredBiomes();
+            int k = placement.spread();
+            HolderSet<Biome> holderset = placement.preferredBiomes();
             RandomSource randomsource = RandomSource.create();
 
             randomsource.setSeed(this.concentricRingsSeed);
@@ -144,17 +145,17 @@
                 RandomSource randomsource1 = randomsource.fork();
 
                 list.add(CompletableFuture.supplyAsync(() -> {
-                    BiomeSource biomesource = this.biomeSource;
+                    BiomeSource worldchunkmanager = this.biomeSource;
                     int i2 = SectionPos.sectionToBlockCoord(k1, 8);
                     int j2 = SectionPos.sectionToBlockCoord(l1, 8);
 
                     Objects.requireNonNull(holderset);
-                    Pair<BlockPos, Holder<Biome>> pair = biomesource.findBiomeHorizontal(i2, 0, j2, 112, holderset::contains, randomsource1, this.randomState.sampler());
+                    Pair<BlockPos, Holder<Biome>> pair = worldchunkmanager.findBiomeHorizontal(i2, 0, j2, 112, holderset::contains, randomsource1, this.randomState.sampler());
 
                     if (pair != null) {
-                        BlockPos blockpos = (BlockPos) pair.getFirst();
+                        BlockPos blockposition = (BlockPos) pair.getFirst();
 
-                        return new ChunkPos(SectionPos.blockToSectionCoord(blockpos.getX()), SectionPos.blockToSectionCoord(blockpos.getZ()));
+                        return new ChunkPos(SectionPos.blockToSectionCoord(blockposition.getX()), SectionPos.blockToSectionCoord(blockposition.getZ()));
                     } else {
                         return new ChunkPos(k1, l1);
                     }
@@ -173,7 +174,7 @@
             return Util.sequence(list).thenApply((list1) -> {
                 double d2 = (double) stopwatch.stop().elapsed(TimeUnit.MILLISECONDS) / 1000.0D;
 
-                ChunkGeneratorStructureState.LOGGER.debug("Calculation for {} took {}s", holder, d2);
+                ChunkGeneratorStructureState.LOGGER.debug("Calculation for {} took {}s", structureSet, d2);
                 return list1;
             });
         }
@@ -188,27 +189,27 @@
     }
 
     @Nullable
-    public List<ChunkPos> getRingPositionsFor(ConcentricRingsStructurePlacement concentricringsstructureplacement) {
+    public List<ChunkPos> getRingPositionsFor(ConcentricRingsStructurePlacement placement) {
         this.ensureStructuresGenerated();
-        CompletableFuture<List<ChunkPos>> completablefuture = (CompletableFuture) this.ringPositions.get(concentricringsstructureplacement);
+        CompletableFuture<List<ChunkPos>> completablefuture = (CompletableFuture) this.ringPositions.get(placement);
 
         return completablefuture != null ? (List) completablefuture.join() : null;
     }
 
-    public List<StructurePlacement> getPlacementsForStructure(Holder<Structure> holder) {
+    public List<StructurePlacement> getPlacementsForStructure(Holder<Structure> structure) {
         this.ensureStructuresGenerated();
-        return (List) this.placementsForStructure.getOrDefault(holder.value(), List.of());
+        return (List) this.placementsForStructure.getOrDefault(structure.value(), List.of());
     }
 
     public RandomState randomState() {
         return this.randomState;
     }
 
-    public boolean hasStructureChunkInRange(Holder<StructureSet> holder, int i, int j, int k) {
-        StructurePlacement structureplacement = ((StructureSet) holder.value()).placement();
+    public boolean hasStructureChunkInRange(Holder<StructureSet> structureSet, int x, int z, int range) {
+        StructurePlacement structureplacement = ((StructureSet) structureSet.value()).placement();
 
-        for (int l = i - k; l <= i + k; ++l) {
-            for (int i1 = j - k; i1 <= j + k; ++i1) {
+        for (int l = x - range; l <= x + range; ++l) {
+            for (int i1 = z - range; i1 <= z + range; ++i1) {
                 if (structureplacement.isStructureChunk(this, l, i1)) {
                     return true;
                 }
