--- a/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -33,40 +33,40 @@
     public static final int MAX_STRUCTURE_DISTANCE = 8;
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
-    private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (chunkstatus, serverlevel, structuretemplatemanager, threadedlevellightengine, function, chunkaccess) -> {
-        return CompletableFuture.completedFuture(Either.left(chunkaccess));
+    private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     };
-    public static final ChunkStatus EMPTY = registerSimple("empty", (ChunkStatus) null, -1, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, serverlevel, chunkgenerator, list, chunkaccess) -> {
+    public static final ChunkStatus EMPTY = registerSimple("empty", (ChunkStatus) null, -1, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
     });
-    public static final ChunkStatus STRUCTURE_STARTS = register("structure_starts", ChunkStatus.EMPTY, 0, false, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess) -> {
-        if (serverlevel.getServer().getWorldData().worldGenOptions().generateStructures()) {
-            chunkgenerator.createStructures(serverlevel.registryAccess(), serverlevel.getChunkSource().getGeneratorState(), serverlevel.structureManager(), chunkaccess, structuretemplatemanager);
+    public static final ChunkStatus STRUCTURE_STARTS = register("structure_starts", ChunkStatus.EMPTY, 0, false, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        if (worldserver.serverLevelData.worldGenOptions().generateStructures()) { // CraftBukkit
+            chunkgenerator.createStructures(worldserver.registryAccess(), worldserver.getChunkSource().getGeneratorState(), worldserver.structureManager(), ichunkaccess, structuretemplatemanager);
         }
 
-        serverlevel.onStructureStartsAvailable(chunkaccess);
-        return CompletableFuture.completedFuture(Either.left(chunkaccess));
-    }, (chunkstatus, serverlevel, structuretemplatemanager, threadedlevellightengine, function, chunkaccess) -> {
-        serverlevel.onStructureStartsAvailable(chunkaccess);
-        return CompletableFuture.completedFuture(Either.left(chunkaccess));
+        worldserver.onStructureStartsAvailable(ichunkaccess);
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        worldserver.onStructureStartsAvailable(ichunkaccess);
+        return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     });
-    public static final ChunkStatus STRUCTURE_REFERENCES = registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, serverlevel, chunkgenerator, list, chunkaccess) -> {
-        WorldGenRegion worldgenregion = new WorldGenRegion(serverlevel, list, chunkstatus, -1);
+    public static final ChunkStatus STRUCTURE_REFERENCES = registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
 
-        chunkgenerator.createReferences(worldgenregion, serverlevel.structureManager().forWorldGenRegion(worldgenregion), chunkaccess);
+        chunkgenerator.createReferences(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess);
     });
-    public static final ChunkStatus BIOMES = register("biomes", ChunkStatus.STRUCTURE_REFERENCES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess) -> {
-        WorldGenRegion worldgenregion = new WorldGenRegion(serverlevel, list, chunkstatus, -1);
+    public static final ChunkStatus BIOMES = register("biomes", ChunkStatus.STRUCTURE_REFERENCES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
 
-        return chunkgenerator.createBiomes(executor, serverlevel.getChunkSource().randomState(), Blender.of(worldgenregion), serverlevel.structureManager().forWorldGenRegion(worldgenregion), chunkaccess).thenApply((chunkaccess1) -> {
-            return Either.left(chunkaccess1);
+        return chunkgenerator.createBiomes(executor, worldserver.getChunkSource().randomState(), Blender.of(regionlimitedworldaccess), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess).thenApply((ichunkaccess1) -> {
+            return Either.left(ichunkaccess1);
         });
     });
-    public static final ChunkStatus NOISE = register("noise", ChunkStatus.BIOMES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess) -> {
-        WorldGenRegion worldgenregion = new WorldGenRegion(serverlevel, list, chunkstatus, 0);
+    public static final ChunkStatus NOISE = register("noise", ChunkStatus.BIOMES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
-        return chunkgenerator.fillFromNoise(executor, Blender.of(worldgenregion), serverlevel.getChunkSource().randomState(), serverlevel.structureManager().forWorldGenRegion(worldgenregion), chunkaccess).thenApply((chunkaccess1) -> {
-            if (chunkaccess1 instanceof ProtoChunk) {
-                ProtoChunk protochunk = (ProtoChunk) chunkaccess1;
+        return chunkgenerator.fillFromNoise(executor, Blender.of(regionlimitedworldaccess), worldserver.getChunkSource().randomState(), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess).thenApply((ichunkaccess1) -> {
+            if (ichunkaccess1 instanceof ProtoChunk) {
+                ProtoChunk protochunk = (ProtoChunk) ichunkaccess1;
                 BelowZeroRetrogen belowzeroretrogen = protochunk.getBelowZeroRetrogen();
 
                 if (belowzeroretrogen != null) {
@@ -77,52 +77,52 @@
                 }
             }
 
-            return Either.left(chunkaccess1);
+            return Either.left(ichunkaccess1);
         });
     });
-    public static final ChunkStatus SURFACE = registerSimple("surface", ChunkStatus.NOISE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, serverlevel, chunkgenerator, list, chunkaccess) -> {
-        WorldGenRegion worldgenregion = new WorldGenRegion(serverlevel, list, chunkstatus, 0);
+    public static final ChunkStatus SURFACE = registerSimple("surface", ChunkStatus.NOISE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
-        chunkgenerator.buildSurface(worldgenregion, serverlevel.structureManager().forWorldGenRegion(worldgenregion), serverlevel.getChunkSource().randomState(), chunkaccess);
+        chunkgenerator.buildSurface(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), worldserver.getChunkSource().randomState(), ichunkaccess);
     });
-    public static final ChunkStatus CARVERS = registerSimple("carvers", ChunkStatus.SURFACE, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, serverlevel, chunkgenerator, list, chunkaccess) -> {
-        WorldGenRegion worldgenregion = new WorldGenRegion(serverlevel, list, chunkstatus, 0);
+    public static final ChunkStatus CARVERS = registerSimple("carvers", ChunkStatus.SURFACE, 8, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
-        if (chunkaccess instanceof ProtoChunk) {
-            ProtoChunk protochunk = (ProtoChunk) chunkaccess;
+        if (ichunkaccess instanceof ProtoChunk) {
+            ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
 
-            Blender.addAroundOldChunksCarvingMaskFilter(worldgenregion, protochunk);
+            Blender.addAroundOldChunksCarvingMaskFilter(regionlimitedworldaccess, protochunk);
         }
 
-        chunkgenerator.applyCarvers(worldgenregion, serverlevel.getSeed(), serverlevel.getChunkSource().randomState(), serverlevel.getBiomeManager(), serverlevel.structureManager().forWorldGenRegion(worldgenregion), chunkaccess, GenerationStep.Carving.AIR);
+        chunkgenerator.applyCarvers(regionlimitedworldaccess, worldserver.getSeed(), worldserver.getChunkSource().randomState(), worldserver.getBiomeManager(), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess, GenerationStep.Carving.AIR);
     });
-    public static final ChunkStatus FEATURES = registerSimple("features", ChunkStatus.CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, serverlevel, chunkgenerator, list, chunkaccess) -> {
-        Heightmap.primeHeightmaps(chunkaccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
-        WorldGenRegion worldgenregion = new WorldGenRegion(serverlevel, list, chunkstatus, 1);
+    public static final ChunkStatus FEATURES = registerSimple("features", ChunkStatus.CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        Heightmap.primeHeightmaps(ichunkaccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
+        WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1);
 
-        chunkgenerator.applyBiomeDecoration(worldgenregion, chunkaccess, serverlevel.structureManager().forWorldGenRegion(worldgenregion));
-        Blender.generateBorderTicks(worldgenregion, chunkaccess);
+        chunkgenerator.applyBiomeDecoration(regionlimitedworldaccess, ichunkaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess));
+        Blender.generateBorderTicks(regionlimitedworldaccess, ichunkaccess);
     });
-    public static final ChunkStatus INITIALIZE_LIGHT = register("initialize_light", ChunkStatus.FEATURES, 0, false, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess) -> {
-        return initializeLight(threadedlevellightengine, chunkaccess);
-    }, (chunkstatus, serverlevel, structuretemplatemanager, threadedlevellightengine, function, chunkaccess) -> {
-        return initializeLight(threadedlevellightengine, chunkaccess);
+    public static final ChunkStatus INITIALIZE_LIGHT = register("initialize_light", ChunkStatus.FEATURES, 0, false, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return initializeLight(lightenginethreaded, ichunkaccess);
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return initializeLight(lightenginethreaded, ichunkaccess);
     });
-    public static final ChunkStatus LIGHT = register("light", ChunkStatus.INITIALIZE_LIGHT, 1, true, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess) -> {
-        return lightChunk(threadedlevellightengine, chunkaccess);
-    }, (chunkstatus, serverlevel, structuretemplatemanager, threadedlevellightengine, function, chunkaccess) -> {
-        return lightChunk(threadedlevellightengine, chunkaccess);
+    public static final ChunkStatus LIGHT = register("light", ChunkStatus.INITIALIZE_LIGHT, 1, true, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return lightChunk(lightenginethreaded, ichunkaccess);
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return lightChunk(lightenginethreaded, ichunkaccess);
     });
-    public static final ChunkStatus SPAWN = registerSimple("spawn", ChunkStatus.LIGHT, 0, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, serverlevel, chunkgenerator, list, chunkaccess) -> {
-        if (!chunkaccess.isUpgrading()) {
-            chunkgenerator.spawnOriginalMobs(new WorldGenRegion(serverlevel, list, chunkstatus, -1));
+    public static final ChunkStatus SPAWN = registerSimple("spawn", ChunkStatus.LIGHT, 0, ChunkStatus.POST_FEATURES, ChunkStatus.Type.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+        if (!ichunkaccess.isUpgrading()) {
+            chunkgenerator.spawnOriginalMobs(new WorldGenRegion(worldserver, list, chunkstatus, -1));
         }
 
     });
-    public static final ChunkStatus FULL = register("full", ChunkStatus.SPAWN, 0, false, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.LEVELCHUNK, (chunkstatus, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess) -> {
-        return (CompletableFuture) function.apply(chunkaccess);
-    }, (chunkstatus, serverlevel, structuretemplatemanager, threadedlevellightengine, function, chunkaccess) -> {
-        return (CompletableFuture) function.apply(chunkaccess);
+    public static final ChunkStatus FULL = register("full", ChunkStatus.SPAWN, 0, false, ChunkStatus.POST_FEATURES, ChunkStatus.Type.LEVELCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess) -> {
+        return (CompletableFuture) function.apply(ichunkaccess);
+    }, (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
+        return (CompletableFuture) function.apply(ichunkaccess);
     });
     private static final List<ChunkStatus> STATUS_BY_RANGE = ImmutableList.of(ChunkStatus.FULL, ChunkStatus.INITIALIZE_LIGHT, ChunkStatus.CARVERS, ChunkStatus.BIOMES, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, ChunkStatus.STRUCTURE_STARTS, new ChunkStatus[0]);
     private static final IntList RANGE_BY_STATUS = (IntList) Util.make(new IntArrayList(getStatusList().size()), (intarraylist) -> {
@@ -143,33 +143,33 @@
     private final ChunkStatus.LoadingTask loadingTask;
     private final int range;
     private final boolean hasLoadDependencies;
-    private final ChunkStatus.ChunkType chunkType;
+    private final ChunkStatus.Type chunkType;
     private final EnumSet<Heightmap.Types> heightmapsAfter;
 
-    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> initializeLight(ThreadedLevelLightEngine threadedlevellightengine, ChunkAccess chunkaccess) {
-        chunkaccess.initializeLightSources();
-        ((ProtoChunk) chunkaccess).setLightEngine(threadedlevellightengine);
-        boolean flag = isLighted(chunkaccess);
+    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> initializeLight(ThreadedLevelLightEngine lightEngine, ChunkAccess chunk) {
+        chunk.initializeLightSources();
+        ((ProtoChunk) chunk).setLightEngine(lightEngine);
+        boolean flag = isLighted(chunk);
 
-        return threadedlevellightengine.initializeLight(chunkaccess, flag).thenApply(Either::left);
+        return lightEngine.initializeLight(chunk, flag).thenApply(Either::left);
     }
 
-    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> lightChunk(ThreadedLevelLightEngine threadedlevellightengine, ChunkAccess chunkaccess) {
-        boolean flag = isLighted(chunkaccess);
+    private static CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> lightChunk(ThreadedLevelLightEngine lightEngine, ChunkAccess chunk) {
+        boolean flag = isLighted(chunk);
 
-        return threadedlevellightengine.lightChunk(chunkaccess, flag).thenApply(Either::left);
+        return lightEngine.lightChunk(chunk, flag).thenApply(Either::left);
     }
 
-    private static ChunkStatus registerSimple(String s, @Nullable ChunkStatus chunkstatus, int i, EnumSet<Heightmap.Types> enumset, ChunkStatus.ChunkType chunkstatus_chunktype, ChunkStatus.SimpleGenerationTask chunkstatus_simplegenerationtask) {
-        return register(s, chunkstatus, i, enumset, chunkstatus_chunktype, chunkstatus_simplegenerationtask);
+    private static ChunkStatus registerSimple(String key, @Nullable ChunkStatus parent, int taskRange, EnumSet<Heightmap.Types> heightmaps, ChunkStatus.Type type, ChunkStatus.SimpleGenerationTask generationTask) {
+        return register(key, parent, taskRange, heightmaps, type, generationTask);
     }
 
-    private static ChunkStatus register(String s, @Nullable ChunkStatus chunkstatus, int i, EnumSet<Heightmap.Types> enumset, ChunkStatus.ChunkType chunkstatus_chunktype, ChunkStatus.GenerationTask chunkstatus_generationtask) {
-        return register(s, chunkstatus, i, false, enumset, chunkstatus_chunktype, chunkstatus_generationtask, ChunkStatus.PASSTHROUGH_LOAD_TASK);
+    private static ChunkStatus register(String key, @Nullable ChunkStatus parent, int taskRange, EnumSet<Heightmap.Types> heightmaps, ChunkStatus.Type type, ChunkStatus.GenerationTask generationTask) {
+        return register(key, parent, taskRange, false, heightmaps, type, generationTask, ChunkStatus.PASSTHROUGH_LOAD_TASK);
     }
 
-    private static ChunkStatus register(String s, @Nullable ChunkStatus chunkstatus, int i, boolean flag, EnumSet<Heightmap.Types> enumset, ChunkStatus.ChunkType chunkstatus_chunktype, ChunkStatus.GenerationTask chunkstatus_generationtask, ChunkStatus.LoadingTask chunkstatus_loadingtask) {
-        return (ChunkStatus) Registry.register(BuiltInRegistries.CHUNK_STATUS, s, new ChunkStatus(chunkstatus, i, flag, enumset, chunkstatus_chunktype, chunkstatus_generationtask, chunkstatus_loadingtask));
+    private static ChunkStatus register(String key, @Nullable ChunkStatus parent, int taskRange, boolean hasLoadDependencies, EnumSet<Heightmap.Types> heightmaps, ChunkStatus.Type type, ChunkStatus.GenerationTask generationTask, ChunkStatus.LoadingTask loadingTask) {
+        return (ChunkStatus) Registry.register(BuiltInRegistries.CHUNK_STATUS, key, new ChunkStatus(parent, taskRange, hasLoadDependencies, heightmaps, type, generationTask, loadingTask));
     }
 
     public static List<ChunkStatus> getStatusList() {
@@ -186,31 +186,31 @@
         return list;
     }
 
-    private static boolean isLighted(ChunkAccess chunkaccess) {
-        return chunkaccess.getStatus().isOrAfter(ChunkStatus.LIGHT) && chunkaccess.isLightCorrect();
+    private static boolean isLighted(ChunkAccess chunk) {
+        return chunk.getStatus().isOrAfter(ChunkStatus.LIGHT) && chunk.isLightCorrect();
     }
 
-    public static ChunkStatus getStatusAroundFullChunk(int i) {
-        return i >= ChunkStatus.STATUS_BY_RANGE.size() ? ChunkStatus.EMPTY : (i < 0 ? ChunkStatus.FULL : (ChunkStatus) ChunkStatus.STATUS_BY_RANGE.get(i));
+    public static ChunkStatus getStatusAroundFullChunk(int radius) {
+        return radius >= ChunkStatus.STATUS_BY_RANGE.size() ? ChunkStatus.EMPTY : (radius < 0 ? ChunkStatus.FULL : (ChunkStatus) ChunkStatus.STATUS_BY_RANGE.get(radius));
     }
 
     public static int maxDistance() {
         return ChunkStatus.STATUS_BY_RANGE.size();
     }
 
-    public static int getDistance(ChunkStatus chunkstatus) {
-        return ChunkStatus.RANGE_BY_STATUS.getInt(chunkstatus.getIndex());
+    public static int getDistance(ChunkStatus status) {
+        return ChunkStatus.RANGE_BY_STATUS.getInt(status.getIndex());
     }
 
-    ChunkStatus(@Nullable ChunkStatus chunkstatus, int i, boolean flag, EnumSet<Heightmap.Types> enumset, ChunkStatus.ChunkType chunkstatus_chunktype, ChunkStatus.GenerationTask chunkstatus_generationtask, ChunkStatus.LoadingTask chunkstatus_loadingtask) {
-        this.parent = chunkstatus == null ? this : chunkstatus;
-        this.generationTask = chunkstatus_generationtask;
-        this.loadingTask = chunkstatus_loadingtask;
-        this.range = i;
-        this.hasLoadDependencies = flag;
-        this.chunkType = chunkstatus_chunktype;
-        this.heightmapsAfter = enumset;
-        this.index = chunkstatus == null ? 0 : chunkstatus.getIndex() + 1;
+    ChunkStatus(@Nullable ChunkStatus parent, int range, boolean hasLoadDependencies, EnumSet<Heightmap.Types> heightmapsAfter, ChunkStatus.Type chunkType, ChunkStatus.GenerationTask generationTask, ChunkStatus.LoadingTask loadingTask) {
+        this.parent = parent == null ? this : parent;
+        this.generationTask = generationTask;
+        this.loadingTask = loadingTask;
+        this.range = range;
+        this.hasLoadDependencies = hasLoadDependencies;
+        this.chunkType = chunkType;
+        this.heightmapsAfter = heightmapsAfter;
+        this.index = parent == null ? 0 : parent.getIndex() + 1;
     }
 
     public int getIndex() {
@@ -221,14 +221,14 @@
         return this.parent;
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> generate(Executor executor, ServerLevel serverlevel, ChunkGenerator chunkgenerator, StructureTemplateManager structuretemplatemanager, ThreadedLevelLightEngine threadedlevellightengine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list) {
-        ChunkAccess chunkaccess = (ChunkAccess) list.get(list.size() / 2);
-        ProfiledDuration profiledduration = JvmProfiler.INSTANCE.onChunkGenerate(chunkaccess.getPos(), serverlevel.dimension(), this.toString());
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> generate(Executor exectutor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, List<ChunkAccess> cache) {
+        ChunkAccess ichunkaccess = (ChunkAccess) cache.get(cache.size() / 2);
+        ProfiledDuration profiledduration = JvmProfiler.INSTANCE.onChunkGenerate(ichunkaccess.getPos(), level.dimension(), this.toString());
 
-        return this.generationTask.doWork(this, executor, serverlevel, chunkgenerator, structuretemplatemanager, threadedlevellightengine, function, list, chunkaccess).thenApply((either) -> {
-            either.ifLeft((chunkaccess1) -> {
-                if (chunkaccess1 instanceof ProtoChunk) {
-                    ProtoChunk protochunk = (ProtoChunk) chunkaccess1;
+        return this.generationTask.doWork(this, exectutor, level, chunkGenerator, structureTemplateManager, lightEngine, task, cache, ichunkaccess).thenApply((either) -> {
+            either.ifLeft((ichunkaccess1) -> {
+                if (ichunkaccess1 instanceof ProtoChunk) {
+                    ProtoChunk protochunk = (ProtoChunk) ichunkaccess1;
 
                     if (!protochunk.getStatus().isOrAfter(this)) {
                         protochunk.setStatus(this);
@@ -244,8 +244,8 @@
         });
     }
 
-    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> load(ServerLevel serverlevel, StructureTemplateManager structuretemplatemanager, ThreadedLevelLightEngine threadedlevellightengine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, ChunkAccess chunkaccess) {
-        return this.loadingTask.doWork(this, serverlevel, structuretemplatemanager, threadedlevellightengine, function, chunkaccess);
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> load(ServerLevel level, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, ChunkAccess loadingChunk) {
+        return this.loadingTask.doWork(this, level, structureTemplateManager, lightEngine, task, loadingChunk);
     }
 
     public int getRange() {
@@ -256,51 +256,49 @@
         return this.hasLoadDependencies;
     }
 
-    public ChunkStatus.ChunkType getChunkType() {
+    public ChunkStatus.Type getChunkType() {
         return this.chunkType;
     }
 
-    public static ChunkStatus byName(String s) {
-        return (ChunkStatus) BuiltInRegistries.CHUNK_STATUS.get(ResourceLocation.tryParse(s));
+    public static ChunkStatus byName(String key) {
+        return (ChunkStatus) BuiltInRegistries.CHUNK_STATUS.get(ResourceLocation.tryParse(key));
     }
 
     public EnumSet<Heightmap.Types> heightmapsAfter() {
         return this.heightmapsAfter;
     }
 
-    public boolean isOrAfter(ChunkStatus chunkstatus) {
-        return this.getIndex() >= chunkstatus.getIndex();
+    public boolean isOrAfter(ChunkStatus status) {
+        return this.getIndex() >= status.getIndex();
     }
 
-    @Override
     public String toString() {
         return BuiltInRegistries.CHUNK_STATUS.getKey(this).toString();
     }
 
-    public static enum ChunkType {
+    public static enum Type {
 
         PROTOCHUNK, LEVELCHUNK;
 
-        private ChunkType() {}
+        private Type() {}
     }
 
     private interface GenerationTask {
 
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus status, Executor executor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task, List<ChunkAccess> cache, ChunkAccess loadingChunk);
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> doWork(ChunkStatus status, Executor executor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, List<ChunkAccess> cache, ChunkAccess loadingChunk);
     }
 
     private interface LoadingTask {
 
-        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus status, ServerLevel level, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> task, ChunkAccess chunk);
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> doWork(ChunkStatus status, ServerLevel level, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, ChunkAccess chunk);
     }
 
     private interface SimpleGenerationTask extends ChunkStatus.GenerationTask {
 
         @Override
-        @Override
-        default CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> doWork(ChunkStatus chunkstatus, Executor executor, ServerLevel serverlevel, ChunkGenerator chunkgenerator, StructureTemplateManager structuretemplatemanager, ThreadedLevelLightEngine threadedlevellightengine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function, List<ChunkAccess> list, ChunkAccess chunkaccess) {
-            this.doWork(chunkstatus, serverlevel, chunkgenerator, list, chunkaccess);
-            return CompletableFuture.completedFuture(Either.left(chunkaccess));
+        default CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>> doWork(ChunkStatus status, Executor executor, ServerLevel level, ChunkGenerator chunkGenerator, StructureTemplateManager structureTemplateManager, ThreadedLevelLightEngine lightEngine, Function<ChunkAccess, CompletableFuture<Either<ChunkAccess, ChunkHolder.Failure>>> task, List<ChunkAccess> cache, ChunkAccess loadingChunk) {
+            this.doWork(status, level, chunkGenerator, cache, loadingChunk);
+            return CompletableFuture.completedFuture(Either.left(loadingChunk));
         }
 
         void doWork(ChunkStatus status, ServerLevel level, ChunkGenerator generator, List<ChunkAccess> cache, ChunkAccess loadingChunk);
