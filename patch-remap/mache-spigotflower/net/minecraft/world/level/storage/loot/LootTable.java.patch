--- a/net/minecraft/world/level/storage/loot/LootTable.java
+++ b/net/minecraft/world/level/storage/loot/LootTable.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.level.storage.loot;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
@@ -28,6 +29,13 @@
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
 import org.slf4j.Logger;
 
+// CraftBukkit start
+import org.bukkit.craftbukkit.CraftLootTable;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.world.LootGenerateEvent;
+// CraftBukkit end
+
 public class LootTable {
 
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -49,20 +57,21 @@
     private final List<LootPool> pools;
     private final List<LootItemFunction> functions;
     private final BiFunction<ItemStack, LootContext, ItemStack> compositeFunction;
+    public CraftLootTable craftLootTable; // CraftBukkit
 
-    LootTable(LootContextParamSet lootcontextparamset, Optional<ResourceLocation> optional, List<LootPool> list, List<LootItemFunction> list1) {
-        this.paramSet = lootcontextparamset;
+    LootTable(LootContextParamSet lootcontextparameterset, Optional<ResourceLocation> optional, List<LootPool> list, List<LootItemFunction> list1) {
+        this.paramSet = lootcontextparameterset;
         this.randomSequence = optional;
         this.pools = list;
         this.functions = list1;
         this.compositeFunction = LootItemFunctions.compose(list1);
     }
 
-    public static Consumer<ItemStack> createStackSplitter(ServerLevel serverlevel, Consumer<ItemStack> consumer) {
+    public static Consumer<ItemStack> createStackSplitter(ServerLevel level, Consumer<ItemStack> output) {
         return (itemstack) -> {
-            if (itemstack.isItemEnabled(serverlevel.enabledFeatures())) {
+            if (itemstack.isItemEnabled(level.enabledFeatures())) {
                 if (itemstack.getCount() < itemstack.getMaxStackSize()) {
-                    consumer.accept(itemstack);
+                    output.accept(itemstack);
                 } else {
                     int i = itemstack.getCount();
 
@@ -70,7 +79,7 @@
                         ItemStack itemstack1 = itemstack.copyWithCount(Math.min(itemstack.getMaxStackSize(), i));
 
                         i -= itemstack1.getCount();
-                        consumer.accept(itemstack1);
+                        output.accept(itemstack1);
                     }
                 }
 
@@ -78,55 +87,55 @@
         };
     }
 
-    public void getRandomItemsRaw(LootParams lootparams, Consumer<ItemStack> consumer) {
-        this.getRandomItemsRaw((new LootContext.Builder(lootparams)).create(this.randomSequence), consumer);
+    public void getRandomItemsRaw(LootParams params, Consumer<ItemStack> output) {
+        this.getRandomItemsRaw((new LootContext.Builder(params)).create(this.randomSequence), output);
     }
 
-    public void getRandomItemsRaw(LootContext lootcontext, Consumer<ItemStack> consumer) {
-        LootContext.VisitedEntry<?> lootcontext_visitedentry = LootContext.createVisitedEntry(this);
+    public void getRandomItemsRaw(LootContext context, Consumer<ItemStack> output) {
+        LootContext.c<?> loottableinfo_c = LootContext.createVisitedEntry(this);
 
-        if (lootcontext.pushVisitedElement(lootcontext_visitedentry)) {
-            Consumer<ItemStack> consumer1 = LootItemFunction.decorate(this.compositeFunction, consumer, lootcontext);
+        if (context.pushVisitedElement(loottableinfo_c)) {
+            Consumer<ItemStack> consumer1 = LootItemFunction.decorate(this.compositeFunction, output, context);
             Iterator iterator = this.pools.iterator();
 
             while (iterator.hasNext()) {
-                LootPool lootpool = (LootPool) iterator.next();
+                LootPool lootselector = (LootPool) iterator.next();
 
-                lootpool.addRandomItems(consumer1, lootcontext);
+                lootselector.addRandomItems(consumer1, context);
             }
 
-            lootcontext.popVisitedElement(lootcontext_visitedentry);
+            context.popVisitedElement(loottableinfo_c);
         } else {
             LootTable.LOGGER.warn("Detected infinite loop in loot tables");
         }
 
     }
 
-    public void getRandomItems(LootParams lootparams, long i, Consumer<ItemStack> consumer) {
-        this.getRandomItemsRaw((new LootContext.Builder(lootparams)).withOptionalRandomSeed(i).create(this.randomSequence), createStackSplitter(lootparams.getLevel(), consumer));
+    public void getRandomItems(LootParams params, long seed, Consumer<ItemStack> consumer) {
+        this.getRandomItemsRaw((new LootContext.Builder(params)).withOptionalRandomSeed(seed).create(this.randomSequence), createStackSplitter(params.getLevel(), consumer));
     }
 
-    public void getRandomItems(LootParams lootparams, Consumer<ItemStack> consumer) {
-        this.getRandomItemsRaw(lootparams, createStackSplitter(lootparams.getLevel(), consumer));
+    public void getRandomItems(LootParams params, Consumer<ItemStack> output) {
+        this.getRandomItemsRaw(params, createStackSplitter(params.getLevel(), output));
     }
 
-    public void getRandomItems(LootContext lootcontext, Consumer<ItemStack> consumer) {
-        this.getRandomItemsRaw(lootcontext, createStackSplitter(lootcontext.getLevel(), consumer));
+    public void getRandomItems(LootContext contextData, Consumer<ItemStack> output) {
+        this.getRandomItemsRaw(contextData, createStackSplitter(contextData.getLevel(), output));
     }
 
-    public ObjectArrayList<ItemStack> getRandomItems(LootParams lootparams, long i) {
-        return this.getRandomItems((new LootContext.Builder(lootparams)).withOptionalRandomSeed(i).create(this.randomSequence));
+    public ObjectArrayList<ItemStack> getRandomItems(LootParams params, long seed) {
+        return this.getRandomItems((new LootContext.Builder(params)).withOptionalRandomSeed(seed).create(this.randomSequence));
     }
 
-    public ObjectArrayList<ItemStack> getRandomItems(LootParams lootparams) {
-        return this.getRandomItems((new LootContext.Builder(lootparams)).create(this.randomSequence));
+    public ObjectArrayList<ItemStack> getRandomItems(LootParams params) {
+        return this.getRandomItems((new LootContext.Builder(params)).create(this.randomSequence));
     }
 
-    private ObjectArrayList<ItemStack> getRandomItems(LootContext lootcontext) {
+    private ObjectArrayList<ItemStack> getRandomItems(LootContext context) {
         ObjectArrayList<ItemStack> objectarraylist = new ObjectArrayList();
 
         Objects.requireNonNull(objectarraylist);
-        this.getRandomItems(lootcontext, objectarraylist::add);
+        this.getRandomItems(context, objectarraylist::add);
         return objectarraylist;
     }
 
@@ -134,25 +143,38 @@
         return this.paramSet;
     }
 
-    public void validate(ValidationContext validationcontext) {
+    public void validate(ValidationContext validator) {
         int i;
 
         for (i = 0; i < this.pools.size(); ++i) {
-            ((LootPool) this.pools.get(i)).validate(validationcontext.forChild(".pools[" + i + "]"));
+            ((LootPool) this.pools.get(i)).validate(validator.forChild(".pools[" + i + "]"));
         }
 
         for (i = 0; i < this.functions.size(); ++i) {
-            ((LootItemFunction) this.functions.get(i)).validate(validationcontext.forChild(".functions[" + i + "]"));
+            ((LootItemFunction) this.functions.get(i)).validate(validator.forChild(".functions[" + i + "]"));
         }
 
     }
 
-    public void fill(Container container, LootParams lootparams, long i) {
-        LootContext lootcontext = (new LootContext.Builder(lootparams)).withOptionalRandomSeed(i).create(this.randomSequence);
-        ObjectArrayList<ItemStack> objectarraylist = this.getRandomItems(lootcontext);
-        RandomSource randomsource = lootcontext.getRandom();
-        List<Integer> list = this.getAvailableSlots(container, randomsource);
+    public void fill(Container container, LootParams params, long seed) {
+        // CraftBukkit start
+        this.fillInventory(container, params, seed, false);
+    }
 
+    public void fillInventory(Container iinventory, LootParams lootparams, long i, boolean plugin) {
+        // CraftBukkit end
+        LootContext loottableinfo = (new LootContext.Builder(lootparams)).withOptionalRandomSeed(i).create(this.randomSequence);
+        ObjectArrayList<ItemStack> objectarraylist = this.getRandomItems(loottableinfo);
+        RandomSource randomsource = loottableinfo.getRandom();
+        // CraftBukkit start
+        LootGenerateEvent event = CraftEventFactory.callLootGenerateEvent(iinventory, this, loottableinfo, objectarraylist, plugin);
+        if (event.isCancelled()) {
+            return;
+        }
+        objectarraylist = event.getLoot().stream().map(CraftItemStack::asNMSCopy).collect(ObjectArrayList.toList());
+        // CraftBukkit end
+        List<Integer> list = this.getAvailableSlots(iinventory, randomsource);
+
         this.shuffleAndSplitItems(objectarraylist, list.size(), randomsource);
         ObjectListIterator objectlistiterator = objectarraylist.iterator();
 
@@ -165,17 +187,17 @@
             }
 
             if (itemstack.isEmpty()) {
-                container.setItem((Integer) list.remove(list.size() - 1), ItemStack.EMPTY);
+                iinventory.setItem((Integer) list.remove(list.size() - 1), ItemStack.EMPTY);
             } else {
-                container.setItem((Integer) list.remove(list.size() - 1), itemstack);
+                iinventory.setItem((Integer) list.remove(list.size() - 1), itemstack);
             }
         }
 
     }
 
-    private void shuffleAndSplitItems(ObjectArrayList<ItemStack> objectarraylist, int i, RandomSource randomsource) {
+    private void shuffleAndSplitItems(ObjectArrayList<ItemStack> stacks, int emptySlotsCount, RandomSource random) {
         List<ItemStack> list = Lists.newArrayList();
-        ObjectListIterator objectlistiterator = objectarraylist.iterator();
+        ObjectListIterator objectlistiterator = stacks.iterator();
 
         while (objectlistiterator.hasNext()) {
             ItemStack itemstack = (ItemStack) objectlistiterator.next();
@@ -188,38 +210,38 @@
             }
         }
 
-        while (i - objectarraylist.size() - list.size() > 0 && !list.isEmpty()) {
-            ItemStack itemstack1 = (ItemStack) list.remove(Mth.nextInt(randomsource, 0, list.size() - 1));
-            int j = Mth.nextInt(randomsource, 1, itemstack1.getCount() / 2);
+        while (emptySlotsCount - stacks.size() - list.size() > 0 && !list.isEmpty()) {
+            ItemStack itemstack1 = (ItemStack) list.remove(Mth.nextInt(random, 0, list.size() - 1));
+            int j = Mth.nextInt(random, 1, itemstack1.getCount() / 2);
             ItemStack itemstack2 = itemstack1.split(j);
 
-            if (itemstack1.getCount() > 1 && randomsource.nextBoolean()) {
+            if (itemstack1.getCount() > 1 && random.nextBoolean()) {
                 list.add(itemstack1);
             } else {
-                objectarraylist.add(itemstack1);
+                stacks.add(itemstack1);
             }
 
-            if (itemstack2.getCount() > 1 && randomsource.nextBoolean()) {
+            if (itemstack2.getCount() > 1 && random.nextBoolean()) {
                 list.add(itemstack2);
             } else {
-                objectarraylist.add(itemstack2);
+                stacks.add(itemstack2);
             }
         }
 
-        objectarraylist.addAll(list);
-        Util.shuffle(objectarraylist, randomsource);
+        stacks.addAll(list);
+        Util.shuffle(stacks, random);
     }
 
-    private List<Integer> getAvailableSlots(Container container, RandomSource randomsource) {
+    private List<Integer> getAvailableSlots(Container inventory, RandomSource random) {
         ObjectArrayList<Integer> objectarraylist = new ObjectArrayList();
 
-        for (int i = 0; i < container.getContainerSize(); ++i) {
-            if (container.getItem(i).isEmpty()) {
+        for (int i = 0; i < inventory.getContainerSize(); ++i) {
+            if (inventory.getItem(i).isEmpty()) {
                 objectarraylist.add(i);
             }
         }
 
-        Util.shuffle(objectarraylist, randomsource);
+        Util.shuffle(objectarraylist, random);
         return objectarraylist;
     }
 
@@ -229,8 +251,8 @@
 
     public static class Builder implements FunctionUserBuilder<LootTable.Builder> {
 
-        private final com.google.common.collect.ImmutableList.Builder<LootPool> pools = ImmutableList.builder();
-        private final com.google.common.collect.ImmutableList.Builder<LootItemFunction> functions = ImmutableList.builder();
+        private final Builder<LootPool> pools = ImmutableList.builder();
+        private final Builder<LootItemFunction> functions = ImmutableList.builder();
         private LootContextParamSet paramSet;
         private Optional<ResourceLocation> randomSequence;
 
@@ -239,30 +261,28 @@
             this.randomSequence = Optional.empty();
         }
 
-        public LootTable.Builder withPool(LootPool.Builder lootpool_builder) {
-            this.pools.add(lootpool_builder.build());
+        public LootTable.Builder withPool(LootPool.Builder lootPool) {
+            this.pools.add(lootPool.build());
             return this;
         }
 
-        public LootTable.Builder setParamSet(LootContextParamSet lootcontextparamset) {
-            this.paramSet = lootcontextparamset;
+        public LootTable.Builder setParamSet(LootContextParamSet parameterSet) {
+            this.paramSet = parameterSet;
             return this;
         }
 
-        public LootTable.Builder setRandomSequence(ResourceLocation resourcelocation) {
-            this.randomSequence = Optional.of(resourcelocation);
+        public LootTable.Builder setRandomSequence(ResourceLocation randomSequence) {
+            this.randomSequence = Optional.of(randomSequence);
             return this;
         }
 
         @Override
-        @Override
-        public LootTable.Builder apply(LootItemFunction.Builder lootitemfunction_builder) {
-            this.functions.add(lootitemfunction_builder.build());
+        public LootTable.Builder apply(LootItemFunction.a functionBuilder) {
+            this.functions.add(functionBuilder.build());
             return this;
         }
 
         @Override
-        @Override
         public LootTable.Builder unwrap() {
             return this;
         }
