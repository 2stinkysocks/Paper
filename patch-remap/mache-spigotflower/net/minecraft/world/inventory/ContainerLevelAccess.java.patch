--- a/net/minecraft/world/inventory/ContainerLevelAccess.java
+++ b/net/minecraft/world/inventory/ContainerLevelAccess.java
@@ -8,33 +8,57 @@
 
 public interface ContainerLevelAccess {
 
+    // CraftBukkit start
+    default Level getWorld() {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    default BlockPos getPosition() {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    default org.bukkit.Location getLocation() {
+        return new org.bukkit.Location(getWorld().getWorld(), getPosition().getX(), getPosition().getY(), getPosition().getZ());
+    }
+    // CraftBukkit end
+
     ContainerLevelAccess NULL = new ContainerLevelAccess() {
         @Override
-        @Override
-        public <T> Optional<T> evaluate(BiFunction<Level, BlockPos, T> bifunction) {
+        public <T> Optional<T> evaluate(BiFunction<Level, BlockPos, T> levelPosConsumer) {
             return Optional.empty();
         }
     };
 
-    static ContainerLevelAccess create(final Level level, final BlockPos blockpos) {
+    static ContainerLevelAccess create(final Level level, final BlockPos pos) {
         return new ContainerLevelAccess() {
+            // CraftBukkit start
             @Override
+            public Level getWorld() {
+                return level;
+            }
+
             @Override
-            public <T> Optional<T> evaluate(BiFunction<Level, BlockPos, T> bifunction) {
-                return Optional.of(bifunction.apply(level, blockpos));
+            public BlockPos getPosition() {
+                return pos;
             }
+            // CraftBukkit end
+
+            @Override
+            public <T> Optional<T> evaluate(BiFunction<Level, BlockPos, T> levelPosConsumer) {
+                return Optional.of(levelPosConsumer.apply(level, pos));
+            }
         };
     }
 
     <T> Optional<T> evaluate(BiFunction<Level, BlockPos, T> levelPosConsumer);
 
-    default <T> T evaluate(BiFunction<Level, BlockPos, T> bifunction, T t0) {
-        return this.evaluate(bifunction).orElse(t0);
+    default <T> T evaluate(BiFunction<Level, BlockPos, T> levelPosConsumer, T defaultValue) {
+        return this.evaluate(levelPosConsumer).orElse(defaultValue);
     }
 
-    default void execute(BiConsumer<Level, BlockPos> biconsumer) {
-        this.evaluate((level, blockpos) -> {
-            biconsumer.accept(level, blockpos);
+    default void execute(BiConsumer<Level, BlockPos> levelPosConsumer) {
+        this.evaluate((world, blockposition) -> {
+            levelPosConsumer.accept(world, blockposition);
             return Optional.empty();
         });
     }
