--- a/net/minecraft/world/item/enchantment/FrostWalkerEnchantment.java
+++ b/net/minecraft/world/item/enchantment/FrostWalkerEnchantment.java
@@ -8,59 +8,58 @@
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.FrostedIceBlock;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.phys.shapes.CollisionContext;
 
 public class FrostWalkerEnchantment extends Enchantment {
 
-    public FrostWalkerEnchantment(Enchantment.Rarity enchantment_rarity, EquipmentSlot... aequipmentslot) {
-        super(enchantment_rarity, EnchantmentCategory.ARMOR_FEET, aequipmentslot);
+    public FrostWalkerEnchantment(Enchantment.Rarity rarity, EquipmentSlot... applicableSlots) {
+        super(rarity, EnchantmentCategory.ARMOR_FEET, applicableSlots);
     }
 
     @Override
-    @Override
-    public int getMinCost(int i) {
-        return i * 10;
+    public int getMinCost(int enchantmentLevel) {
+        return enchantmentLevel * 10;
     }
 
     @Override
-    @Override
-    public int getMaxCost(int i) {
-        return this.getMinCost(i) + 15;
+    public int getMaxCost(int enchantmentLevel) {
+        return this.getMinCost(enchantmentLevel) + 15;
     }
 
     @Override
-    @Override
     public boolean isTreasureOnly() {
         return true;
     }
 
     @Override
-    @Override
     public int getMaxLevel() {
         return 2;
     }
 
-    public static void onEntityMoved(LivingEntity livingentity, Level level, BlockPos blockpos, int i) {
-        if (livingentity.onGround()) {
-            BlockState blockstate = Blocks.FROSTED_ICE.defaultBlockState();
-            int j = Math.min(16, 2 + i);
-            BlockPos.MutableBlockPos blockpos_mutableblockpos = new BlockPos.MutableBlockPos();
-            Iterator iterator = BlockPos.betweenClosed(blockpos.offset(-j, -1, -j), blockpos.offset(j, -1, j)).iterator();
+    public static void onEntityMoved(LivingEntity living, Level level, BlockPos pos, int levelConflicting) {
+        if (living.onGround()) {
+            IBlockData iblockdata = Blocks.FROSTED_ICE.defaultBlockState();
+            int j = Math.min(16, 2 + levelConflicting);
+            BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
+            Iterator iterator = BlockPos.betweenClosed(pos.offset(-j, -1, -j), pos.offset(j, -1, j)).iterator();
 
             while (iterator.hasNext()) {
-                BlockPos blockpos1 = (BlockPos) iterator.next();
+                BlockPos blockposition1 = (BlockPos) iterator.next();
 
-                if (blockpos1.closerToCenterThan(livingentity.position(), (double) j)) {
-                    blockpos_mutableblockpos.set(blockpos1.getX(), blockpos1.getY() + 1, blockpos1.getZ());
-                    BlockState blockstate1 = level.getBlockState(blockpos_mutableblockpos);
+                if (blockposition1.closerToCenterThan(living.position(), (double) j)) {
+                    blockposition_mutableblockposition.set(blockposition1.getX(), blockposition1.getY() + 1, blockposition1.getZ());
+                    IBlockData iblockdata1 = level.getBlockState(blockposition_mutableblockposition);
 
-                    if (blockstate1.isAir()) {
-                        BlockState blockstate2 = level.getBlockState(blockpos1);
+                    if (iblockdata1.isAir()) {
+                        IBlockData iblockdata2 = level.getBlockState(blockposition1);
 
-                        if (blockstate2 == FrostedIceBlock.meltsInto() && blockstate.canSurvive(level, blockpos1) && level.isUnobstructed(blockstate, blockpos1, CollisionContext.empty())) {
-                            level.setBlockAndUpdate(blockpos1, blockstate);
-                            level.scheduleTick(blockpos1, Blocks.FROSTED_ICE, Mth.nextInt(livingentity.getRandom(), 60, 120));
+                        if (iblockdata2 == FrostedIceBlock.meltsInto() && iblockdata.canSurvive(level, blockposition1) && level.isUnobstructed(iblockdata, blockposition1, CollisionContext.empty())) {
+                            // CraftBukkit Start - Call EntityBlockFormEvent for Frost Walker
+                            if (org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(level, blockposition1, iblockdata, living)) {
+                                level.scheduleTick(blockposition1, Blocks.FROSTED_ICE, Mth.nextInt(living.getRandom(), 60, 120));
+                            }
+                            // CraftBukkit End
                         }
                     }
                 }
@@ -70,8 +69,7 @@
     }
 
     @Override
-    @Override
-    public boolean checkCompatibility(Enchantment enchantment) {
-        return super.checkCompatibility(enchantment) && enchantment != Enchantments.DEPTH_STRIDER;
+    public boolean checkCompatibility(Enchantment ench) {
+        return super.checkCompatibility(ench) && ench != Enchantments.DEPTH_STRIDER;
     }
 }
