--- a/net/minecraft/commands/arguments/selector/EntitySelectorParser.java
+++ b/net/minecraft/commands/arguments/selector/EntitySelectorParser.java
@@ -53,17 +53,17 @@
     public static final DynamicCommandExceptionType ERROR_EXPECTED_OPTION_VALUE = new DynamicCommandExceptionType((object) -> {
         return Component.translatableEscape("argument.entity.options.valueless", object);
     });
-    public static final BiConsumer<Vec3, List<? extends Entity>> ORDER_NEAREST = (vec3, list) -> {
+    public static final BiConsumer<Vec3, List<? extends Entity>> ORDER_NEAREST = (vec3d, list) -> {
         list.sort((entity, entity1) -> {
-            return Doubles.compare(entity.distanceToSqr(vec3), entity1.distanceToSqr(vec3));
+            return Doubles.compare(entity.distanceToSqr(vec3d), entity1.distanceToSqr(vec3d));
         });
     };
-    public static final BiConsumer<Vec3, List<? extends Entity>> ORDER_FURTHEST = (vec3, list) -> {
+    public static final BiConsumer<Vec3, List<? extends Entity>> ORDER_FURTHEST = (vec3d, list) -> {
         list.sort((entity, entity1) -> {
-            return Doubles.compare(entity1.distanceToSqr(vec3), entity.distanceToSqr(vec3));
+            return Doubles.compare(entity1.distanceToSqr(vec3d), entity.distanceToSqr(vec3d));
         });
     };
-    public static final BiConsumer<Vec3, List<? extends Entity>> ORDER_RANDOM = (vec3, list) -> {
+    public static final BiConsumer<Vec3, List<? extends Entity>> ORDER_RANDOM = (vec3d, list) -> {
         Collections.shuffle(list);
     };
     public static final BiFunction<SuggestionsBuilder, Consumer<SuggestionsBuilder>, CompletableFuture<Suggestions>> SUGGEST_NOTHING = (suggestionsbuilder, consumer) -> {
@@ -114,11 +114,11 @@
     private boolean hasAdvancements;
     private boolean usesSelectors;
 
-    public EntitySelectorParser(StringReader stringreader) {
-        this(stringreader, true);
+    public EntitySelectorParser(StringReader reader) {
+        this(reader, true);
     }
 
-    public EntitySelectorParser(StringReader stringreader, boolean flag) {
+    public EntitySelectorParser(StringReader reader, boolean allowSelectors) {
         this.distance = MinMaxBounds.Doubles.ANY;
         this.level = MinMaxBounds.Ints.ANY;
         this.rotX = WrappedMinMaxBounds.ANY;
@@ -128,50 +128,50 @@
         };
         this.order = EntitySelector.ORDER_ARBITRARY;
         this.suggestions = EntitySelectorParser.SUGGEST_NOTHING;
-        this.reader = stringreader;
-        this.allowSelectors = flag;
+        this.reader = reader;
+        this.allowSelectors = allowSelectors;
     }
 
     public EntitySelector getSelector() {
-        AABB aabb;
+        AABB axisalignedbb;
 
         if (this.deltaX == null && this.deltaY == null && this.deltaZ == null) {
             if (this.distance.max().isPresent()) {
                 double d0 = (Double) this.distance.max().get();
 
-                aabb = new AABB(-d0, -d0, -d0, d0 + 1.0D, d0 + 1.0D, d0 + 1.0D);
+                axisalignedbb = new AABB(-d0, -d0, -d0, d0 + 1.0D, d0 + 1.0D, d0 + 1.0D);
             } else {
-                aabb = null;
+                axisalignedbb = null;
             }
         } else {
-            aabb = this.createAabb(this.deltaX == null ? 0.0D : this.deltaX, this.deltaY == null ? 0.0D : this.deltaY, this.deltaZ == null ? 0.0D : this.deltaZ);
+            axisalignedbb = this.createAabb(this.deltaX == null ? 0.0D : this.deltaX, this.deltaY == null ? 0.0D : this.deltaY, this.deltaZ == null ? 0.0D : this.deltaZ);
         }
 
-        Function function;
+        Function<Vec3, Vec3> function; // CraftBukkit - decompile error
 
         if (this.x == null && this.y == null && this.z == null) {
-            function = (vec3) -> {
-                return vec3;
+            function = (vec3d) -> {
+                return vec3d;
             };
         } else {
-            function = (vec3) -> {
-                return new Vec3(this.x == null ? vec3.x : this.x, this.y == null ? vec3.y : this.y, this.z == null ? vec3.z : this.z);
+            function = (vec3d) -> {
+                return new Vec3(this.x == null ? vec3d.x : this.x, this.y == null ? vec3d.y : this.y, this.z == null ? vec3d.z : this.z);
             };
         }
 
-        return new EntitySelector(this.maxResults, this.includesEntities, this.worldLimited, this.predicate, this.distance, function, aabb, this.order, this.currentEntity, this.playerName, this.entityUUID, this.type, this.usesSelectors);
+        return new EntitySelector(this.maxResults, this.includesEntities, this.worldLimited, this.predicate, this.distance, function, axisalignedbb, this.order, this.currentEntity, this.playerName, this.entityUUID, this.type, this.usesSelectors);
     }
 
-    private AABB createAabb(double d0, double d1, double d2) {
-        boolean flag = d0 < 0.0D;
+    private AABB createAabb(double sizeX, double d1, double sizeY) {
+        boolean flag = sizeX < 0.0D;
         boolean flag1 = d1 < 0.0D;
-        boolean flag2 = d2 < 0.0D;
-        double d3 = flag ? d0 : 0.0D;
+        boolean flag2 = sizeY < 0.0D;
+        double d3 = flag ? sizeX : 0.0D;
         double d4 = flag1 ? d1 : 0.0D;
-        double d5 = flag2 ? d2 : 0.0D;
-        double d6 = (flag ? 0.0D : d0) + 1.0D;
+        double d5 = flag2 ? sizeY : 0.0D;
+        double d6 = (flag ? 0.0D : sizeX) + 1.0D;
         double d7 = (flag1 ? 0.0D : d1) + 1.0D;
-        double d8 = (flag2 ? 0.0D : d2) + 1.0D;
+        double d8 = (flag2 ? 0.0D : sizeY) + 1.0D;
 
         return new AABB(d3, d4, d5, d6, d7, d8);
     }
@@ -193,19 +193,21 @@
 
     }
 
-    private Predicate<Entity> createRotationPredicate(WrappedMinMaxBounds wrappedminmaxbounds, ToDoubleFunction<Entity> todoublefunction) {
-        double d0 = (double) Mth.wrapDegrees(wrappedminmaxbounds.min() == null ? 0.0F : wrappedminmaxbounds.min());
-        double d1 = (double) Mth.wrapDegrees(wrappedminmaxbounds.max() == null ? 359.0F : wrappedminmaxbounds.max());
+    private Predicate<Entity> createRotationPredicate(WrappedMinMaxBounds angleBounds, ToDoubleFunction<Entity> angleFunction) {
+        double d0 = (double) Mth.wrapDegrees(angleBounds.min() == null ? 0.0F : angleBounds.min());
+        double d1 = (double) Mth.wrapDegrees(angleBounds.max() == null ? 359.0F : angleBounds.max());
 
         return (entity) -> {
-            double d2 = Mth.wrapDegrees(todoublefunction.applyAsDouble(entity));
+            double d2 = Mth.wrapDegrees(angleFunction.applyAsDouble(entity));
 
             return d0 > d1 ? d2 >= d0 || d2 <= d1 : d2 >= d0 && d2 <= d1;
         };
     }
 
-    protected void parseSelector() throws CommandSyntaxException {
-        this.usesSelectors = true;
+    // CraftBukkit start
+    protected void parseSelector(boolean overridePermissions) throws CommandSyntaxException {
+        this.usesSelectors = !overridePermissions;
+        // CraftBukkit end
         this.suggestions = this::suggestSelector;
         if (!this.reader.canRead()) {
             throw EntitySelectorParser.ERROR_MISSING_SELECTOR_TYPE.createWithContext(this.reader);
@@ -287,7 +289,7 @@
                 this.reader.skipWhitespace();
                 int i = this.reader.getCursor();
                 String s = this.reader.readString();
-                EntitySelectorOptions.Modifier entityselectoroptions_modifier = EntitySelectorOptions.get(this, s, i);
+                EntitySelectorOptions.Modifier playerselector_a = EntitySelectorOptions.get(this, s, i);
 
                 this.reader.skipWhitespace();
                 if (!this.reader.canRead() || this.reader.peek() != '=') {
@@ -298,7 +300,7 @@
                 this.reader.skip();
                 this.reader.skipWhitespace();
                 this.suggestions = EntitySelectorParser.SUGGEST_NOTHING;
-                entityselectoroptions_modifier.handle(this);
+                playerselector_a.handle(this);
                 this.reader.skipWhitespace();
                 this.suggestions = this::suggestOptionsNextOrClose;
                 if (!this.reader.canRead()) {
@@ -364,32 +366,32 @@
         return this.distance;
     }
 
-    public void setDistance(MinMaxBounds.Doubles minmaxbounds_doubles) {
-        this.distance = minmaxbounds_doubles;
+    public void setDistance(MinMaxBounds.Doubles distance) {
+        this.distance = distance;
     }
 
     public MinMaxBounds.Ints getLevel() {
         return this.level;
     }
 
-    public void setLevel(MinMaxBounds.Ints minmaxbounds_ints) {
-        this.level = minmaxbounds_ints;
+    public void setLevel(MinMaxBounds.Ints level) {
+        this.level = level;
     }
 
     public WrappedMinMaxBounds getRotX() {
         return this.rotX;
     }
 
-    public void setRotX(WrappedMinMaxBounds wrappedminmaxbounds) {
-        this.rotX = wrappedminmaxbounds;
+    public void setRotX(WrappedMinMaxBounds rotX) {
+        this.rotX = rotX;
     }
 
     public WrappedMinMaxBounds getRotY() {
         return this.rotY;
     }
 
-    public void setRotY(WrappedMinMaxBounds wrappedminmaxbounds) {
-        this.rotY = wrappedminmaxbounds;
+    public void setRotY(WrappedMinMaxBounds rotY) {
+        this.rotY = rotY;
     }
 
     @Nullable
@@ -407,28 +409,28 @@
         return this.z;
     }
 
-    public void setX(double d0) {
-        this.x = d0;
+    public void setX(double x) {
+        this.x = x;
     }
 
-    public void setY(double d0) {
-        this.y = d0;
+    public void setY(double y) {
+        this.y = y;
     }
 
-    public void setZ(double d0) {
-        this.z = d0;
+    public void setZ(double z) {
+        this.z = z;
     }
 
-    public void setDeltaX(double d0) {
-        this.deltaX = d0;
+    public void setDeltaX(double deltaX) {
+        this.deltaX = deltaX;
     }
 
-    public void setDeltaY(double d0) {
-        this.deltaY = d0;
+    public void setDeltaY(double deltaY) {
+        this.deltaY = deltaY;
     }
 
-    public void setDeltaZ(double d0) {
-        this.deltaZ = d0;
+    public void setDeltaZ(double deltaZ) {
+        this.deltaZ = deltaZ;
     }
 
     @Nullable
@@ -446,23 +448,29 @@
         return this.deltaZ;
     }
 
-    public void setMaxResults(int i) {
-        this.maxResults = i;
+    public void setMaxResults(int maxResults) {
+        this.maxResults = maxResults;
     }
 
-    public void setIncludesEntities(boolean flag) {
-        this.includesEntities = flag;
+    public void setIncludesEntities(boolean includesEntities) {
+        this.includesEntities = includesEntities;
     }
 
     public BiConsumer<Vec3, List<? extends Entity>> getOrder() {
         return this.order;
     }
 
-    public void setOrder(BiConsumer<Vec3, List<? extends Entity>> biconsumer) {
-        this.order = biconsumer;
+    public void setOrder(BiConsumer<Vec3, List<? extends Entity>> order) {
+        this.order = order;
     }
 
     public EntitySelector parse() throws CommandSyntaxException {
+        // CraftBukkit start
+        return parse(false);
+    }
+
+    public EntitySelector parse(boolean overridePermissions) throws CommandSyntaxException {
+        // CraftBukkit end
         this.startPosition = this.reader.getCursor();
         this.suggestions = this::suggestNameOrSelector;
         if (this.reader.canRead() && this.reader.peek() == '@') {
@@ -471,7 +479,7 @@
             }
 
             this.reader.skip();
-            this.parseSelector();
+            this.parseSelector(overridePermissions); // CraftBukkit
         } else {
             this.parseNameOrUUID();
         }
@@ -480,143 +488,143 @@
         return this.getSelector();
     }
 
-    private static void fillSelectorSuggestions(SuggestionsBuilder suggestionsbuilder) {
-        suggestionsbuilder.suggest("@p", Component.translatable("argument.entity.selector.nearestPlayer"));
-        suggestionsbuilder.suggest("@a", Component.translatable("argument.entity.selector.allPlayers"));
-        suggestionsbuilder.suggest("@r", Component.translatable("argument.entity.selector.randomPlayer"));
-        suggestionsbuilder.suggest("@s", Component.translatable("argument.entity.selector.self"));
-        suggestionsbuilder.suggest("@e", Component.translatable("argument.entity.selector.allEntities"));
+    private static void fillSelectorSuggestions(SuggestionsBuilder builder) {
+        builder.suggest("@p", Component.translatable("argument.entity.selector.nearestPlayer"));
+        builder.suggest("@a", Component.translatable("argument.entity.selector.allPlayers"));
+        builder.suggest("@r", Component.translatable("argument.entity.selector.randomPlayer"));
+        builder.suggest("@s", Component.translatable("argument.entity.selector.self"));
+        builder.suggest("@e", Component.translatable("argument.entity.selector.allEntities"));
     }
 
-    private CompletableFuture<Suggestions> suggestNameOrSelector(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        consumer.accept(suggestionsbuilder);
+    private CompletableFuture<Suggestions> suggestNameOrSelector(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        consumer.accept(builder);
         if (this.allowSelectors) {
-            fillSelectorSuggestions(suggestionsbuilder);
+            fillSelectorSuggestions(builder);
         }
 
-        return suggestionsbuilder.buildFuture();
+        return builder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestName(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        SuggestionsBuilder suggestionsbuilder1 = suggestionsbuilder.createOffset(this.startPosition);
+    private CompletableFuture<Suggestions> suggestName(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        SuggestionsBuilder suggestionsbuilder1 = builder.createOffset(this.startPosition);
 
         consumer.accept(suggestionsbuilder1);
-        return suggestionsbuilder.add(suggestionsbuilder1).buildFuture();
+        return builder.add(suggestionsbuilder1).buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestSelector(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        SuggestionsBuilder suggestionsbuilder1 = suggestionsbuilder.createOffset(suggestionsbuilder.getStart() - 1);
+    private CompletableFuture<Suggestions> suggestSelector(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        SuggestionsBuilder suggestionsbuilder1 = builder.createOffset(builder.getStart() - 1);
 
         fillSelectorSuggestions(suggestionsbuilder1);
-        suggestionsbuilder.add(suggestionsbuilder1);
-        return suggestionsbuilder.buildFuture();
+        builder.add(suggestionsbuilder1);
+        return builder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestOpenOptions(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        suggestionsbuilder.suggest(String.valueOf('['));
-        return suggestionsbuilder.buildFuture();
+    private CompletableFuture<Suggestions> suggestOpenOptions(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        builder.suggest(String.valueOf('['));
+        return builder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestOptionsKeyOrClose(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        suggestionsbuilder.suggest(String.valueOf(']'));
-        EntitySelectorOptions.suggestNames(this, suggestionsbuilder);
-        return suggestionsbuilder.buildFuture();
+    private CompletableFuture<Suggestions> suggestOptionsKeyOrClose(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        builder.suggest(String.valueOf(']'));
+        EntitySelectorOptions.suggestNames(this, builder);
+        return builder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestOptionsKey(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        EntitySelectorOptions.suggestNames(this, suggestionsbuilder);
-        return suggestionsbuilder.buildFuture();
+    private CompletableFuture<Suggestions> suggestOptionsKey(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        EntitySelectorOptions.suggestNames(this, builder);
+        return builder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestOptionsNextOrClose(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        suggestionsbuilder.suggest(String.valueOf(','));
-        suggestionsbuilder.suggest(String.valueOf(']'));
-        return suggestionsbuilder.buildFuture();
+    private CompletableFuture<Suggestions> suggestOptionsNextOrClose(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        builder.suggest(String.valueOf(','));
+        builder.suggest(String.valueOf(']'));
+        return builder.buildFuture();
     }
 
-    private CompletableFuture<Suggestions> suggestEquals(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        suggestionsbuilder.suggest(String.valueOf('='));
-        return suggestionsbuilder.buildFuture();
+    private CompletableFuture<Suggestions> suggestEquals(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        builder.suggest(String.valueOf('='));
+        return builder.buildFuture();
     }
 
     public boolean isCurrentEntity() {
         return this.currentEntity;
     }
 
-    public void setSuggestions(BiFunction<SuggestionsBuilder, Consumer<SuggestionsBuilder>, CompletableFuture<Suggestions>> bifunction) {
-        this.suggestions = bifunction;
+    public void setSuggestions(BiFunction<SuggestionsBuilder, Consumer<SuggestionsBuilder>, CompletableFuture<Suggestions>> suggestionHandler) {
+        this.suggestions = suggestionHandler;
     }
 
-    public CompletableFuture<Suggestions> fillSuggestions(SuggestionsBuilder suggestionsbuilder, Consumer<SuggestionsBuilder> consumer) {
-        return (CompletableFuture) this.suggestions.apply(suggestionsbuilder.createOffset(this.reader.getCursor()), consumer);
+    public CompletableFuture<Suggestions> fillSuggestions(SuggestionsBuilder builder, Consumer<SuggestionsBuilder> consumer) {
+        return (CompletableFuture) this.suggestions.apply(builder.createOffset(this.reader.getCursor()), consumer);
     }
 
     public boolean hasNameEquals() {
         return this.hasNameEquals;
     }
 
-    public void setHasNameEquals(boolean flag) {
-        this.hasNameEquals = flag;
+    public void setHasNameEquals(boolean hasNameEquals) {
+        this.hasNameEquals = hasNameEquals;
     }
 
     public boolean hasNameNotEquals() {
         return this.hasNameNotEquals;
     }
 
-    public void setHasNameNotEquals(boolean flag) {
-        this.hasNameNotEquals = flag;
+    public void setHasNameNotEquals(boolean hasNameNotEquals) {
+        this.hasNameNotEquals = hasNameNotEquals;
     }
 
     public boolean isLimited() {
         return this.isLimited;
     }
 
-    public void setLimited(boolean flag) {
-        this.isLimited = flag;
+    public void setLimited(boolean isLimited) {
+        this.isLimited = isLimited;
     }
 
     public boolean isSorted() {
         return this.isSorted;
     }
 
-    public void setSorted(boolean flag) {
-        this.isSorted = flag;
+    public void setSorted(boolean isSorted) {
+        this.isSorted = isSorted;
     }
 
     public boolean hasGamemodeEquals() {
         return this.hasGamemodeEquals;
     }
 
-    public void setHasGamemodeEquals(boolean flag) {
-        this.hasGamemodeEquals = flag;
+    public void setHasGamemodeEquals(boolean hasGamemodeEquals) {
+        this.hasGamemodeEquals = hasGamemodeEquals;
     }
 
     public boolean hasGamemodeNotEquals() {
         return this.hasGamemodeNotEquals;
     }
 
-    public void setHasGamemodeNotEquals(boolean flag) {
-        this.hasGamemodeNotEquals = flag;
+    public void setHasGamemodeNotEquals(boolean hasGamemodeNotEquals) {
+        this.hasGamemodeNotEquals = hasGamemodeNotEquals;
     }
 
     public boolean hasTeamEquals() {
         return this.hasTeamEquals;
     }
 
-    public void setHasTeamEquals(boolean flag) {
-        this.hasTeamEquals = flag;
+    public void setHasTeamEquals(boolean hasTeamEquals) {
+        this.hasTeamEquals = hasTeamEquals;
     }
 
     public boolean hasTeamNotEquals() {
         return this.hasTeamNotEquals;
     }
 
-    public void setHasTeamNotEquals(boolean flag) {
-        this.hasTeamNotEquals = flag;
+    public void setHasTeamNotEquals(boolean hasTeamNotEquals) {
+        this.hasTeamNotEquals = hasTeamNotEquals;
     }
 
-    public void limitToType(EntityType<?> entitytype) {
-        this.type = entitytype;
+    public void limitToType(EntityType<?> type) {
+        this.type = type;
     }
 
     public void setTypeLimitedInversely() {
@@ -635,15 +643,15 @@
         return this.hasScores;
     }
 
-    public void setHasScores(boolean flag) {
-        this.hasScores = flag;
+    public void setHasScores(boolean hasScores) {
+        this.hasScores = hasScores;
     }
 
     public boolean hasAdvancements() {
         return this.hasAdvancements;
     }
 
-    public void setHasAdvancements(boolean flag) {
-        this.hasAdvancements = flag;
+    public void setHasAdvancements(boolean hasAdvancements) {
+        this.hasAdvancements = hasAdvancements;
     }
 }
