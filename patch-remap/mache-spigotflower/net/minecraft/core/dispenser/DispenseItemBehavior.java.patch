--- a/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -8,7 +8,7 @@
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
-import net.minecraft.core.Position;
+import net.minecraft.core.IPosition;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
@@ -19,8 +19,8 @@
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EnumMobSpawn;
 import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.entity.Saddleable;
 import net.minecraft.world.entity.animal.horse.AbstractChestedHorse;
 import net.minecraft.world.entity.animal.horse.AbstractHorse;
@@ -40,6 +40,7 @@
 import net.minecraft.world.entity.vehicle.Boat;
 import net.minecraft.world.item.ArmorItem;
 import net.minecraft.world.item.BoneMealItem;
+import net.minecraft.world.item.BucketItem;
 import net.minecraft.world.item.DispensibleContainerItem;
 import net.minecraft.world.item.DyeColor;
 import net.minecraft.world.item.HoneycombItem;
@@ -60,7 +61,9 @@
 import net.minecraft.world.level.block.CandleCakeBlock;
 import net.minecraft.world.level.block.CarvedPumpkinBlock;
 import net.minecraft.world.level.block.DispenserBlock;
+import net.minecraft.world.level.block.LiquidBlockContainer;
 import net.minecraft.world.level.block.RespawnAnchorBlock;
+import net.minecraft.world.level.block.SaplingBlock;
 import net.minecraft.world.level.block.ShulkerBoxBlock;
 import net.minecraft.world.level.block.SkullBlock;
 import net.minecraft.world.level.block.TntBlock;
@@ -68,7 +71,7 @@
 import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.RotationSegment;
 import net.minecraft.world.level.gameevent.GameEvent;
@@ -76,330 +79,510 @@
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
+import org.bukkit.Location;
+import org.bukkit.TreeType;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.craftbukkit.util.DummyGeneratorAccess;
+import org.bukkit.event.block.BlockDispenseArmorEvent;
+import org.bukkit.event.block.BlockDispenseEvent;
+import org.bukkit.event.block.BlockFertilizeEvent;
+import org.bukkit.event.world.StructureGrowEvent;
+// CraftBukkit end
 
 public interface DispenseItemBehavior {
 
     Logger LOGGER = LogUtils.getLogger();
-    DispenseItemBehavior NOOP = (blocksource, itemstack) -> {
+    DispenseItemBehavior NOOP = (sourceblock, itemstack) -> {
         return itemstack;
     };
 
-    ItemStack dispense(BlockSource blockSource, ItemStack itemStack);
+    ItemStack dispense(SourceBlock sourceblock, ItemStack itemstack);
 
     static void bootStrap() {
         DispenserBlock.registerBehavior(Items.ARROW, new AbstractProjectileDispenseBehavior() {
             @Override
-            @Override
-            protected Projectile getProjectile(Level level, Position position, ItemStack itemstack) {
-                Arrow arrow = new Arrow(level, position.x(), position.y(), position.z(), itemstack.copyWithCount(1));
+            protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                Arrow entitytippedarrow = new Arrow(level, position.x(), position.y(), position.z(), stack.copyWithCount(1));
 
-                arrow.pickup = AbstractArrow.Pickup.ALLOWED;
-                return arrow;
+                entitytippedarrow.pickup = AbstractArrow.Pickup.ALLOWED;
+                return entitytippedarrow;
             }
         });
         DispenserBlock.registerBehavior(Items.TIPPED_ARROW, new AbstractProjectileDispenseBehavior() {
             @Override
-            @Override
-            protected Projectile getProjectile(Level level, Position position, ItemStack itemstack) {
-                Arrow arrow = new Arrow(level, position.x(), position.y(), position.z(), itemstack.copyWithCount(1));
+            protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                Arrow entitytippedarrow = new Arrow(level, position.x(), position.y(), position.z(), stack.copyWithCount(1));
 
-                arrow.setEffectsFromItem(itemstack);
-                arrow.pickup = AbstractArrow.Pickup.ALLOWED;
-                return arrow;
+                entitytippedarrow.setEffectsFromItem(stack);
+                entitytippedarrow.pickup = AbstractArrow.Pickup.ALLOWED;
+                return entitytippedarrow;
             }
         });
         DispenserBlock.registerBehavior(Items.SPECTRAL_ARROW, new AbstractProjectileDispenseBehavior() {
             @Override
-            @Override
-            protected Projectile getProjectile(Level level, Position position, ItemStack itemstack) {
-                SpectralArrow spectralarrow = new SpectralArrow(level, position.x(), position.y(), position.z(), itemstack.copyWithCount(1));
+            protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                SpectralArrow entityspectralarrow = new SpectralArrow(level, position.x(), position.y(), position.z(), stack.copyWithCount(1));
 
-                spectralarrow.pickup = AbstractArrow.Pickup.ALLOWED;
-                return spectralarrow;
+                entityspectralarrow.pickup = AbstractArrow.Pickup.ALLOWED;
+                return entityspectralarrow;
             }
         });
         DispenserBlock.registerBehavior(Items.EGG, new AbstractProjectileDispenseBehavior() {
             @Override
-            @Override
-            protected Projectile getProjectile(Level level, Position position, ItemStack itemstack) {
-                return (Projectile) Util.make(new ThrownEgg(level, position.x(), position.y(), position.z()), (thrownegg) -> {
-                    thrownegg.setItem(itemstack);
+            protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                return (Projectile) Util.make(new ThrownEgg(level, position.x(), position.y(), position.z()), (entityegg) -> {
+                    entityegg.setItem(stack);
                 });
             }
         });
         DispenserBlock.registerBehavior(Items.SNOWBALL, new AbstractProjectileDispenseBehavior() {
             @Override
-            @Override
-            protected Projectile getProjectile(Level level, Position position, ItemStack itemstack) {
-                return (Projectile) Util.make(new Snowball(level, position.x(), position.y(), position.z()), (snowball) -> {
-                    snowball.setItem(itemstack);
+            protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                return (Projectile) Util.make(new Snowball(level, position.x(), position.y(), position.z()), (entitysnowball) -> {
+                    entitysnowball.setItem(stack);
                 });
             }
         });
         DispenserBlock.registerBehavior(Items.EXPERIENCE_BOTTLE, new AbstractProjectileDispenseBehavior() {
             @Override
-            @Override
-            protected Projectile getProjectile(Level level, Position position, ItemStack itemstack) {
-                return (Projectile) Util.make(new ThrownExperienceBottle(level, position.x(), position.y(), position.z()), (thrownexperiencebottle) -> {
-                    thrownexperiencebottle.setItem(itemstack);
+            protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                return (Projectile) Util.make(new ThrownExperienceBottle(level, position.x(), position.y(), position.z()), (entitythrownexpbottle) -> {
+                    entitythrownexpbottle.setItem(stack);
                 });
             }
 
             @Override
-            @Override
             protected float getUncertainty() {
                 return super.getUncertainty() * 0.5F;
             }
 
             @Override
-            @Override
             protected float getPower() {
                 return super.getPower() * 1.25F;
             }
         });
         DispenserBlock.registerBehavior(Items.SPLASH_POTION, new DispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack dispense(BlockSource blocksource, ItemStack itemstack) {
+            public ItemStack dispense(SourceBlock sourceblock, ItemStack itemstack) {
                 return (new AbstractProjectileDispenseBehavior() {
                     @Override
-                    @Override
-                    protected Projectile getProjectile(Level level, Position position, ItemStack itemstack1) {
-                        return (Projectile) Util.make(new ThrownPotion(level, position.x(), position.y(), position.z()), (thrownpotion) -> {
-                            thrownpotion.setItem(itemstack1);
+                    protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                        return (Projectile) Util.make(new ThrownPotion(level, position.x(), position.y(), position.z()), (entitypotion) -> {
+                            entitypotion.setItem(stack);
                         });
                     }
 
                     @Override
-                    @Override
                     protected float getUncertainty() {
                         return super.getUncertainty() * 0.5F;
                     }
 
                     @Override
-                    @Override
                     protected float getPower() {
                         return super.getPower() * 1.25F;
                     }
-                }).dispense(blocksource, itemstack);
+                }).dispense(sourceblock, itemstack);
             }
         });
         DispenserBlock.registerBehavior(Items.LINGERING_POTION, new DispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack dispense(BlockSource blocksource, ItemStack itemstack) {
+            public ItemStack dispense(SourceBlock sourceblock, ItemStack itemstack) {
                 return (new AbstractProjectileDispenseBehavior() {
                     @Override
-                    @Override
-                    protected Projectile getProjectile(Level level, Position position, ItemStack itemstack1) {
-                        return (Projectile) Util.make(new ThrownPotion(level, position.x(), position.y(), position.z()), (thrownpotion) -> {
-                            thrownpotion.setItem(itemstack1);
+                    protected Projectile getProjectile(Level level, IPosition position, ItemStack stack) {
+                        return (Projectile) Util.make(new ThrownPotion(level, position.x(), position.y(), position.z()), (entitypotion) -> {
+                            entitypotion.setItem(stack);
                         });
                     }
 
                     @Override
-                    @Override
                     protected float getUncertainty() {
                         return super.getUncertainty() * 0.5F;
                     }
 
                     @Override
-                    @Override
                     protected float getPower() {
                         return super.getPower() * 1.25F;
                     }
-                }).dispense(blocksource, itemstack);
+                }).dispense(sourceblock, itemstack);
             }
         });
-        DefaultDispenseItemBehavior defaultdispenseitembehavior = new DefaultDispenseItemBehavior() {
+        DefaultDispenseItemBehavior dispensebehavioritem = new DefaultDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                EntityType entitytype = ((SpawnEggItem) itemstack.getItem()).getType(itemstack.getTag());
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                EntityType entitytypes = ((SpawnEggItem) itemstack.getItem()).getType(itemstack.getTag());
 
+                // CraftBukkit start
+                ServerLevel worldserver = sourceblock.level();
+                ItemStack itemstack1 = itemstack.split(1);
+                org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    itemstack.grow(1);
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    itemstack.grow(1);
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+
                 try {
-                    entitytype.spawn(blocksource.level(), itemstack, (Player) null, blocksource.pos().relative(direction), MobSpawnType.DISPENSER, direction != Direction.UP, false);
+                    entitytypes.spawn(sourceblock.level(), itemstack, (Player) null, sourceblock.pos().relative(enumdirection), EnumMobSpawn.DISPENSER, enumdirection != Direction.UP, false);
                 } catch (Exception exception) {
-                    null.LOGGER.error("Error while dispensing spawn egg from dispenser at {}", blocksource.pos(), exception);
+                    LOGGER.error("Error while dispensing spawn egg from dispenser at {}", sourceblock.pos(), exception); // CraftBukkit - decompile error
                     return ItemStack.EMPTY;
                 }
 
-                itemstack.shrink(1);
-                blocksource.level().gameEvent((Entity) null, GameEvent.ENTITY_PLACE, blocksource.pos());
+                // itemstack.shrink(1); // Handled during event processing
+                // CraftBukkit end
+                sourceblock.level().gameEvent((Entity) null, GameEvent.ENTITY_PLACE, sourceblock.pos());
                 return itemstack;
             }
         };
         Iterator iterator = SpawnEggItem.eggs().iterator();
 
         while (iterator.hasNext()) {
-            SpawnEggItem spawneggitem = (SpawnEggItem) iterator.next();
+            SpawnEggItem itemmonsteregg = (SpawnEggItem) iterator.next();
 
-            DispenserBlock.registerBehavior(spawneggitem, defaultdispenseitembehavior);
+            DispenserBlock.registerBehavior(itemmonsteregg, dispensebehavioritem);
         }
 
         DispenserBlock.registerBehavior(Items.ARMOR_STAND, new DefaultDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                BlockPos blockpos = blocksource.pos().relative(direction);
-                ServerLevel serverlevel = blocksource.level();
-                Consumer<ArmorStand> consumer = EntityType.appendDefaultStackConfig((armorstand) -> {
-                    armorstand.setYRot(direction.toYRot());
-                }, serverlevel, itemstack, (Player) null);
-                ArmorStand armorstand = (ArmorStand) EntityType.ARMOR_STAND.spawn(serverlevel, itemstack.getTag(), consumer, blockpos, MobSpawnType.DISPENSER, false, false);
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                BlockPos blockposition = sourceblock.pos().relative(enumdirection);
+                ServerLevel worldserver = sourceblock.level();
 
-                if (armorstand != null) {
-                    itemstack.shrink(1);
+                // CraftBukkit start
+                ItemStack itemstack1 = itemstack.split(1);
+                org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
                 }
 
+                if (event.isCancelled()) {
+                    itemstack.grow(1);
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    itemstack.grow(1);
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+                // CraftBukkit end
+
+                Consumer<ArmorStand> consumer = EntityType.appendDefaultStackConfig((entityarmorstand) -> {
+                    entityarmorstand.setYRot(enumdirection.toYRot());
+                }, worldserver, itemstack, (Player) null);
+                ArmorStand entityarmorstand = (ArmorStand) EntityType.ARMOR_STAND.spawn(worldserver, itemstack.getTag(), consumer, blockposition, EnumMobSpawn.DISPENSER, false, false);
+
+                if (entityarmorstand != null) {
+                    // itemstack.shrink(1); // CraftBukkit - Handled during event processing
+                }
+
                 return itemstack;
             }
         });
         DispenserBlock.registerBehavior(Items.SADDLE, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                List<LivingEntity> list = blocksource.level().getEntitiesOfClass(LivingEntity.class, new AABB(blockpos), (livingentity) -> {
-                    if (!(livingentity instanceof Saddleable)) {
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                List<LivingEntity> list = sourceblock.level().getEntitiesOfClass(LivingEntity.class, new AABB(blockposition), (entityliving) -> {
+                    if (!(entityliving instanceof Saddleable)) {
                         return false;
                     } else {
-                        Saddleable saddleable = (Saddleable) livingentity;
+                        Saddleable isaddleable = (Saddleable) entityliving;
 
-                        return !saddleable.isSaddled() && saddleable.isSaddleable();
+                        return !isaddleable.isSaddled() && isaddleable.isSaddleable();
                     }
                 });
 
                 if (!list.isEmpty()) {
+                    // CraftBukkit start
+                    ItemStack itemstack1 = itemstack.split(1);
+                    Level world = sourceblock.level();
+                    org.bukkit.block.Block block = CraftBlock.at(world, sourceblock.pos());
+                    CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+
+                    BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) list.get(0).getBukkitEntity());
+                    if (!DispenserBlock.eventFired) {
+                        world.getCraftServer().getPluginManager().callEvent(event);
+                    }
+
+                    if (event.isCancelled()) {
+                        itemstack.grow(1);
+                        return itemstack;
+                    }
+
+                    if (!event.getItem().equals(craftItem)) {
+                        itemstack.grow(1);
+                        // Chain to handler for new item
+                        ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                        DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                        if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != ArmorItem.DISPENSE_ITEM_BEHAVIOR) {
+                            idispensebehavior.dispense(sourceblock, eventStack);
+                            return itemstack;
+                        }
+                    }
+                    // CraftBukkit end
                     ((Saddleable) list.get(0)).equipSaddle(SoundSource.BLOCKS);
-                    itemstack.shrink(1);
+                    // itemstack.shrink(1); // CraftBukkit - handled above
                     this.setSuccess(true);
                     return itemstack;
                 } else {
-                    return super.execute(blocksource, itemstack);
+                    return super.execute(sourceblock, itemstack);
                 }
             }
         });
-        OptionalDispenseItemBehavior optionaldispenseitembehavior = new OptionalDispenseItemBehavior() {
+        OptionalDispenseItemBehavior dispensebehaviormaybe = new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                List<AbstractHorse> list = blocksource.level().getEntitiesOfClass(AbstractHorse.class, new AABB(blockpos), (abstracthorse) -> {
-                    return abstracthorse.isAlive() && abstracthorse.canWearArmor();
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                List<AbstractHorse> list = sourceblock.level().getEntitiesOfClass(AbstractHorse.class, new AABB(blockposition), (entityhorseabstract) -> {
+                    return entityhorseabstract.isAlive() && entityhorseabstract.canWearArmor();
                 });
                 Iterator iterator1 = list.iterator();
 
-                AbstractHorse abstracthorse;
+                AbstractHorse entityhorseabstract;
 
                 do {
                     if (!iterator1.hasNext()) {
-                        return super.execute(blocksource, itemstack);
+                        return super.execute(sourceblock, itemstack);
                     }
 
-                    abstracthorse = (AbstractHorse) iterator1.next();
-                } while (!abstracthorse.isArmor(itemstack) || abstracthorse.isWearingArmor() || !abstracthorse.isTamed());
+                    entityhorseabstract = (AbstractHorse) iterator1.next();
+                } while (!entityhorseabstract.isArmor(itemstack) || entityhorseabstract.isWearingArmor() || !entityhorseabstract.isTamed());
 
-                abstracthorse.getSlot(401).set(itemstack.split(1));
+                // CraftBukkit start
+                ItemStack itemstack1 = itemstack.split(1);
+                Level world = sourceblock.level();
+                org.bukkit.block.Block block = CraftBlock.at(world, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+
+                BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityhorseabstract.getBukkitEntity());
+                if (!DispenserBlock.eventFired) {
+                    world.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    itemstack.grow(1);
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    itemstack.grow(1);
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != ArmorItem.DISPENSE_ITEM_BEHAVIOR) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+
+                entityhorseabstract.getSlot(401).set(CraftItemStack.asNMSCopy(event.getItem()));
+                // CraftBukkit end
                 this.setSuccess(true);
                 return itemstack;
             }
         };
 
-        DispenserBlock.registerBehavior(Items.LEATHER_HORSE_ARMOR, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.IRON_HORSE_ARMOR, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.GOLDEN_HORSE_ARMOR, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.DIAMOND_HORSE_ARMOR, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.WHITE_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.ORANGE_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.CYAN_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.BLUE_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.BROWN_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.BLACK_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.GRAY_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.GREEN_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.LIGHT_BLUE_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.LIGHT_GRAY_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.LIME_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.MAGENTA_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.PINK_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.PURPLE_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.RED_CARPET, optionaldispenseitembehavior);
-        DispenserBlock.registerBehavior(Items.YELLOW_CARPET, optionaldispenseitembehavior);
+        DispenserBlock.registerBehavior(Items.LEATHER_HORSE_ARMOR, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.IRON_HORSE_ARMOR, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.GOLDEN_HORSE_ARMOR, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.DIAMOND_HORSE_ARMOR, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.WHITE_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.ORANGE_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.CYAN_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.BLUE_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.BROWN_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.BLACK_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.GRAY_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.GREEN_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.LIGHT_BLUE_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.LIGHT_GRAY_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.LIME_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.MAGENTA_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.PINK_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.PURPLE_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.RED_CARPET, dispensebehaviormaybe);
+        DispenserBlock.registerBehavior(Items.YELLOW_CARPET, dispensebehaviormaybe);
         DispenserBlock.registerBehavior(Items.CHEST, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                List<AbstractChestedHorse> list = blocksource.level().getEntitiesOfClass(AbstractChestedHorse.class, new AABB(blockpos), (abstractchestedhorse) -> {
-                    return abstractchestedhorse.isAlive() && !abstractchestedhorse.hasChest();
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                List<AbstractChestedHorse> list = sourceblock.level().getEntitiesOfClass(AbstractChestedHorse.class, new AABB(blockposition), (entityhorsechestedabstract) -> {
+                    return entityhorsechestedabstract.isAlive() && !entityhorsechestedabstract.hasChest();
                 });
                 Iterator iterator1 = list.iterator();
 
-                AbstractChestedHorse abstractchestedhorse;
+                AbstractChestedHorse entityhorsechestedabstract;
 
                 do {
                     if (!iterator1.hasNext()) {
-                        return super.execute(blocksource, itemstack);
+                        return super.execute(sourceblock, itemstack);
                     }
 
-                    abstractchestedhorse = (AbstractChestedHorse) iterator1.next();
-                } while (!abstractchestedhorse.isTamed() || !abstractchestedhorse.getSlot(499).set(itemstack));
+                    entityhorsechestedabstract = (AbstractChestedHorse) iterator1.next();
+                    // CraftBukkit start
+                } while (!entityhorsechestedabstract.isTamed());
+                ItemStack itemstack1 = itemstack.split(1);
+                Level world = sourceblock.level();
+                org.bukkit.block.Block block = CraftBlock.at(world, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
-                itemstack.shrink(1);
+                BlockDispenseArmorEvent event = new BlockDispenseArmorEvent(block, craftItem.clone(), (org.bukkit.craftbukkit.entity.CraftLivingEntity) entityhorsechestedabstract.getBukkitEntity());
+                if (!DispenserBlock.eventFired) {
+                    world.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != ArmorItem.DISPENSE_ITEM_BEHAVIOR) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+                entityhorsechestedabstract.getSlot(499).set(CraftItemStack.asNMSCopy(event.getItem()));
+                // CraftBukkit end
+
+                // itemstack.shrink(1); // CraftBukkit - handled above
                 this.setSuccess(true);
                 return itemstack;
             }
         });
         DispenserBlock.registerBehavior(Items.FIREWORK_ROCKET, new DefaultDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                Vec3 vec3 = DispenseItemBehavior.getEntityPokingOutOfBlockPos(blocksource, EntityType.FIREWORK_ROCKET, direction);
-                FireworkRocketEntity fireworkrocketentity = new FireworkRocketEntity(blocksource.level(), itemstack, vec3.x(), vec3.y(), vec3.z(), true);
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                // CraftBukkit start
+                ServerLevel worldserver = sourceblock.level();
+                ItemStack itemstack1 = itemstack.split(1);
+                org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
 
-                fireworkrocketentity.shoot((double) direction.getStepX(), (double) direction.getStepY(), (double) direction.getStepZ(), 0.5F, 1.0F);
-                blocksource.level().addFreshEntity(fireworkrocketentity);
-                itemstack.shrink(1);
+                BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(enumdirection.getStepX(), enumdirection.getStepY(), enumdirection.getStepZ()));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    itemstack.grow(1);
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    itemstack.grow(1);
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+
+                itemstack1 = CraftItemStack.asNMSCopy(event.getItem());
+                Vec3 vec3d = DispenseItemBehavior.getEntityPokingOutOfBlockPos(sourceblock, EntityType.FIREWORK_ROCKET, enumdirection);
+                FireworkRocketEntity entityfireworks = new FireworkRocketEntity(sourceblock.level(), itemstack, vec3d.x(), vec3d.y(), vec3d.z(), true);
+
+                entityfireworks.shoot((double) enumdirection.getStepX(), (double) enumdirection.getStepY(), (double) enumdirection.getStepZ(), 0.5F, 1.0F);
+                sourceblock.level().addFreshEntity(entityfireworks);
+                // itemstack.shrink(1); // Handled during event processing
+                // CraftBukkit end
                 return itemstack;
             }
 
             @Override
-            @Override
-            protected void playSound(BlockSource blocksource) {
-                blocksource.level().levelEvent(1004, blocksource.pos(), 0);
+            protected void playSound(SourceBlock sourceblock) {
+                sourceblock.level().levelEvent(1004, sourceblock.pos(), 0);
             }
         });
         DispenserBlock.registerBehavior(Items.FIRE_CHARGE, new DefaultDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                Position position = DispenserBlock.getDispensePosition(blocksource);
-                double d0 = position.x() + (double) ((float) direction.getStepX() * 0.3F);
-                double d1 = position.y() + (double) ((float) direction.getStepY() * 0.3F);
-                double d2 = position.z() + (double) ((float) direction.getStepZ() * 0.3F);
-                ServerLevel serverlevel = blocksource.level();
-                RandomSource randomsource = serverlevel.random;
-                double d3 = randomsource.triangle((double) direction.getStepX(), 0.11485000000000001D);
-                double d4 = randomsource.triangle((double) direction.getStepY(), 0.11485000000000001D);
-                double d5 = randomsource.triangle((double) direction.getStepZ(), 0.11485000000000001D);
-                SmallFireball smallfireball = new SmallFireball(serverlevel, d0, d1, d2, d3, d4, d5);
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                IPosition iposition = DispenserBlock.getDispensePosition(sourceblock);
+                double d0 = iposition.x() + (double) ((float) enumdirection.getStepX() * 0.3F);
+                double d1 = iposition.y() + (double) ((float) enumdirection.getStepY() * 0.3F);
+                double d2 = iposition.z() + (double) ((float) enumdirection.getStepZ() * 0.3F);
+                ServerLevel worldserver = sourceblock.level();
+                RandomSource randomsource = worldserver.random;
+                double d3 = randomsource.triangle((double) enumdirection.getStepX(), 0.11485000000000001D);
+                double d4 = randomsource.triangle((double) enumdirection.getStepY(), 0.11485000000000001D);
+                double d5 = randomsource.triangle((double) enumdirection.getStepZ(), 0.11485000000000001D);
 
-                serverlevel.addFreshEntity((Entity) Util.make(smallfireball, (smallfireball1) -> {
-                    smallfireball1.setItem(itemstack);
-                }));
-                itemstack.shrink(1);
+                // CraftBukkit start
+                ItemStack itemstack1 = itemstack.split(1);
+                org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(d3, d4, d5));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    itemstack.grow(1);
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    itemstack.grow(1);
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+
+                SmallFireball entitysmallfireball = new SmallFireball(worldserver, d0, d1, d2, event.getVelocity().getX(), event.getVelocity().getY(), event.getVelocity().getZ());
+                entitysmallfireball.setItem(itemstack1);
+                entitysmallfireball.projectileSource = new org.bukkit.craftbukkit.projectiles.CraftBlockProjectileSource(sourceblock.blockEntity());
+
+                worldserver.addFreshEntity(entitysmallfireball);
+                // itemstack.shrink(1); // Handled during event processing
+                // CraftBukkit end
                 return itemstack;
             }
 
             @Override
-            @Override
-            protected void playSound(BlockSource blocksource) {
-                blocksource.level().levelEvent(1018, blocksource.pos(), 0);
+            protected void playSound(SourceBlock sourceblock) {
+                sourceblock.level().levelEvent(1018, sourceblock.pos(), 0);
             }
         });
         DispenserBlock.registerBehavior(Items.OAK_BOAT, new BoatDispenseItemBehavior(Boat.Type.OAK));
@@ -420,98 +603,191 @@
         DispenserBlock.registerBehavior(Items.CHERRY_CHEST_BOAT, new BoatDispenseItemBehavior(Boat.Type.CHERRY, true));
         DispenserBlock.registerBehavior(Items.MANGROVE_CHEST_BOAT, new BoatDispenseItemBehavior(Boat.Type.MANGROVE, true));
         DispenserBlock.registerBehavior(Items.BAMBOO_CHEST_RAFT, new BoatDispenseItemBehavior(Boat.Type.BAMBOO, true));
-        DefaultDispenseItemBehavior defaultdispenseitembehavior1 = new DefaultDispenseItemBehavior() {
+        DefaultDispenseItemBehavior dispensebehavioritem1 = new DefaultDispenseItemBehavior() {
             private final DefaultDispenseItemBehavior defaultDispenseItemBehavior = new DefaultDispenseItemBehavior();
 
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
                 DispensibleContainerItem dispensiblecontaineritem = (DispensibleContainerItem) itemstack.getItem();
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                ServerLevel serverlevel = blocksource.level();
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                ServerLevel worldserver = sourceblock.level();
 
-                if (dispensiblecontaineritem.emptyContents((Player) null, serverlevel, blockpos, (BlockHitResult) null)) {
-                    dispensiblecontaineritem.checkExtraContent((Player) null, serverlevel, itemstack, blockpos);
-                    return new ItemStack(Items.BUCKET);
+                // CraftBukkit start
+                int x = blockposition.getX();
+                int y = blockposition.getY();
+                int z = blockposition.getZ();
+                IBlockData iblockdata = worldserver.getBlockState(blockposition);
+                if (iblockdata.isAir() || iblockdata.canBeReplaced() || (dispensiblecontaineritem instanceof BucketItem && iblockdata.getBlock() instanceof LiquidBlockContainer && ((LiquidBlockContainer) iblockdata.getBlock()).canPlaceLiquid((Player) null, worldserver, blockposition, iblockdata, ((BucketItem) dispensiblecontaineritem).content))) {
+                    org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                    CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
+
+                    BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(x, y, z));
+                    if (!DispenserBlock.eventFired) {
+                        worldserver.getCraftServer().getPluginManager().callEvent(event);
+                    }
+
+                    if (event.isCancelled()) {
+                        return itemstack;
+                    }
+
+                    if (!event.getItem().equals(craftItem)) {
+                        // Chain to handler for new item
+                        ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                        DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                        if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                            idispensebehavior.dispense(sourceblock, eventStack);
+                            return itemstack;
+                        }
+                    }
+
+                    dispensiblecontaineritem = (DispensibleContainerItem) CraftItemStack.asNMSCopy(event.getItem()).getItem();
+                }
+                // CraftBukkit end
+
+                if (dispensiblecontaineritem.emptyContents((Player) null, worldserver, blockposition, (BlockHitResult) null)) {
+                    dispensiblecontaineritem.checkExtraContent((Player) null, worldserver, itemstack, blockposition);
+                    // CraftBukkit start - Handle stacked buckets
+                    Item item = Items.BUCKET;
+                    itemstack.shrink(1);
+                    if (itemstack.isEmpty()) {
+                        itemstack.setItem(Items.BUCKET);
+                        itemstack.setCount(1);
+                    } else if (sourceblock.blockEntity().addItem(new ItemStack(item)) < 0) {
+                        this.defaultDispenseItemBehavior.dispense(sourceblock, new ItemStack(item));
+                    }
+                    return itemstack;
+                    // CraftBukkit end
                 } else {
-                    return this.defaultDispenseItemBehavior.dispense(blocksource, itemstack);
+                    return this.defaultDispenseItemBehavior.dispense(sourceblock, itemstack);
                 }
             }
         };
 
-        DispenserBlock.registerBehavior(Items.LAVA_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.WATER_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.POWDER_SNOW_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.SALMON_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.COD_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.PUFFERFISH_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.TROPICAL_FISH_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.AXOLOTL_BUCKET, defaultdispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.TADPOLE_BUCKET, defaultdispenseitembehavior1);
+        DispenserBlock.registerBehavior(Items.LAVA_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.WATER_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.POWDER_SNOW_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.SALMON_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.COD_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.PUFFERFISH_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.TROPICAL_FISH_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.AXOLOTL_BUCKET, dispensebehavioritem1);
+        DispenserBlock.registerBehavior(Items.TADPOLE_BUCKET, dispensebehavioritem1);
         DispenserBlock.registerBehavior(Items.BUCKET, new DefaultDispenseItemBehavior() {
             private final DefaultDispenseItemBehavior defaultDispenseItemBehavior = new DefaultDispenseItemBehavior();
 
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                ServerLevel serverlevel = blocksource.level();
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                BlockState blockstate = serverlevel.getBlockState(blockpos);
-                Block block = blockstate.getBlock();
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                ServerLevel worldserver = sourceblock.level();
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                IBlockData iblockdata = worldserver.getBlockState(blockposition);
+                Block block = iblockdata.getBlock();
 
                 if (block instanceof BucketPickup) {
-                    BucketPickup bucketpickup = (BucketPickup) block;
-                    ItemStack itemstack1 = bucketpickup.pickupBlock((Player) null, serverlevel, blockpos, blockstate);
+                    BucketPickup ifluidsource = (BucketPickup) block;
+                    ItemStack itemstack1 = ifluidsource.pickupBlock((Player) null, DummyGeneratorAccess.INSTANCE, blockposition, iblockdata); // CraftBukkit
 
                     if (itemstack1.isEmpty()) {
-                        return super.execute(blocksource, itemstack);
+                        return super.execute(sourceblock, itemstack);
                     } else {
-                        serverlevel.gameEvent((Entity) null, GameEvent.FLUID_PICKUP, blockpos);
+                        worldserver.gameEvent((Entity) null, GameEvent.FLUID_PICKUP, blockposition);
                         Item item = itemstack1.getItem();
 
+                        // CraftBukkit start
+                        org.bukkit.block.Block bukkitBlock = CraftBlock.at(worldserver, sourceblock.pos());
+                        CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
+
+                        BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
+                        if (!DispenserBlock.eventFired) {
+                            worldserver.getCraftServer().getPluginManager().callEvent(event);
+                        }
+
+                        if (event.isCancelled()) {
+                            return itemstack;
+                        }
+
+                        if (!event.getItem().equals(craftItem)) {
+                            // Chain to handler for new item
+                            ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                            DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                            if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                                idispensebehavior.dispense(sourceblock, eventStack);
+                                return itemstack;
+                            }
+                        }
+
+                        itemstack1 = ifluidsource.pickupBlock((Player) null, worldserver, blockposition, iblockdata); // From above
+                        // CraftBukkit end
+
                         itemstack.shrink(1);
                         if (itemstack.isEmpty()) {
                             return new ItemStack(item);
                         } else {
-                            if (blocksource.blockEntity().addItem(new ItemStack(item)) < 0) {
-                                this.defaultDispenseItemBehavior.dispense(blocksource, new ItemStack(item));
+                            if (sourceblock.blockEntity().addItem(new ItemStack(item)) < 0) {
+                                this.defaultDispenseItemBehavior.dispense(sourceblock, new ItemStack(item));
                             }
 
                             return itemstack;
                         }
                     }
                 } else {
-                    return super.execute(blocksource, itemstack);
+                    return super.execute(sourceblock, itemstack);
                 }
             }
         });
         DispenserBlock.registerBehavior(Items.FLINT_AND_STEEL, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                ServerLevel serverlevel = blocksource.level();
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                ServerLevel worldserver = sourceblock.level();
 
+                // CraftBukkit start
+                org.bukkit.block.Block bukkitBlock = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+                // CraftBukkit end
+
                 this.setSuccess(true);
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                BlockPos blockpos = blocksource.pos().relative(direction);
-                BlockState blockstate = serverlevel.getBlockState(blockpos);
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                BlockPos blockposition = sourceblock.pos().relative(enumdirection);
+                IBlockData iblockdata = worldserver.getBlockState(blockposition);
 
-                if (BaseFireBlock.canBePlacedAt(serverlevel, blockpos, direction)) {
-                    serverlevel.setBlockAndUpdate(blockpos, BaseFireBlock.getState(serverlevel, blockpos));
-                    serverlevel.gameEvent((Entity) null, GameEvent.BLOCK_PLACE, blockpos);
-                } else if (!CampfireBlock.canLight(blockstate) && !CandleBlock.canLight(blockstate) && !CandleCakeBlock.canLight(blockstate)) {
-                    if (blockstate.getBlock() instanceof TntBlock) {
-                        TntBlock.explode(serverlevel, blockpos);
-                        serverlevel.removeBlock(blockpos, false);
+                if (BaseFireBlock.canBePlacedAt(worldserver, blockposition, enumdirection)) {
+                    // CraftBukkit start - Ignition by dispensing flint and steel
+                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callBlockIgniteEvent(worldserver, blockposition, sourceblock.pos()).isCancelled()) {
+                        worldserver.setBlockAndUpdate(blockposition, BaseFireBlock.getState(worldserver, blockposition));
+                        worldserver.gameEvent((Entity) null, GameEvent.BLOCK_PLACE, blockposition);
+                    }
+                    // CraftBukkit end
+                } else if (!CampfireBlock.canLight(iblockdata) && !CandleBlock.canLight(iblockdata) && !CandleCakeBlock.canLight(iblockdata)) {
+                    if (iblockdata.getBlock() instanceof TntBlock && org.bukkit.craftbukkit.event.CraftEventFactory.callTNTPrimeEvent(worldserver, blockposition, org.bukkit.event.block.TNTPrimeEvent.PrimeCause.DISPENSER, null, sourceblock.pos())) { // CraftBukkit - TNTPrimeEvent
+                        TntBlock.explode(worldserver, blockposition);
+                        worldserver.removeBlock(blockposition, false);
                     } else {
                         this.setSuccess(false);
                     }
                 } else {
-                    serverlevel.setBlockAndUpdate(blockpos, (BlockState) blockstate.setValue(BlockStateProperties.LIT, true));
-                    serverlevel.gameEvent((Entity) null, GameEvent.BLOCK_CHANGE, blockpos);
+                    worldserver.setBlockAndUpdate(blockposition, (IBlockData) iblockdata.setValue(BlockStateProperties.LIT, true));
+                    worldserver.gameEvent((Entity) null, GameEvent.BLOCK_CHANGE, blockposition);
                 }
 
-                if (this.isSuccess() && itemstack.hurt(1, serverlevel.random, (ServerPlayer) null)) {
+                if (this.isSuccess() && itemstack.hurt(1, worldserver.random, (ServerPlayer) null)) {
                     itemstack.setCount(0);
                 }
 
@@ -520,72 +796,171 @@
         });
         DispenserBlock.registerBehavior(Items.BONE_MEAL, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
                 this.setSuccess(true);
-                ServerLevel serverlevel = blocksource.level();
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
+                ServerLevel worldserver = sourceblock.level();
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                // CraftBukkit start
+                org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
 
-                if (!BoneMealItem.growCrop(itemstack, serverlevel, blockpos) && !BoneMealItem.growWaterPlant(itemstack, serverlevel, blockpos, (Direction) null)) {
+                BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector(0, 0, 0));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+
+                worldserver.captureTreeGeneration = true;
+                // CraftBukkit end
+
+                if (!BoneMealItem.growCrop(itemstack, worldserver, blockposition) && !BoneMealItem.growWaterPlant(itemstack, worldserver, blockposition, (Direction) null)) {
                     this.setSuccess(false);
-                } else if (!serverlevel.isClientSide) {
-                    serverlevel.levelEvent(1505, blockpos, 0);
+                } else if (!worldserver.isClientSide) {
+                    worldserver.levelEvent(1505, blockposition, 0);
                 }
+                // CraftBukkit start
+                worldserver.captureTreeGeneration = false;
+                if (worldserver.capturedBlockStates.size() > 0) {
+                    TreeType treeType = SaplingBlock.treeType;
+                    SaplingBlock.treeType = null;
+                    Location location = CraftLocation.toBukkit(blockposition, worldserver.getWorld());
+                    List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(worldserver.capturedBlockStates.values());
+                    worldserver.capturedBlockStates.clear();
+                    StructureGrowEvent structureEvent = null;
+                    if (treeType != null) {
+                        structureEvent = new StructureGrowEvent(location, treeType, false, null, blocks);
+                        org.bukkit.Bukkit.getPluginManager().callEvent(structureEvent);
+                    }
 
+                    BlockFertilizeEvent fertilizeEvent = new BlockFertilizeEvent(location.getBlock(), null, blocks);
+                    fertilizeEvent.setCancelled(structureEvent != null && structureEvent.isCancelled());
+                    org.bukkit.Bukkit.getPluginManager().callEvent(fertilizeEvent);
+
+                    if (!fertilizeEvent.isCancelled()) {
+                        for (org.bukkit.block.BlockState blockstate : blocks) {
+                            blockstate.update(true);
+                        }
+                    }
+                }
+                // CraftBukkit end
+
                 return itemstack;
             }
         });
         DispenserBlock.registerBehavior(Blocks.TNT, new DefaultDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                ServerLevel serverlevel = blocksource.level();
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                PrimedTnt primedtnt = new PrimedTnt(serverlevel, (double) blockpos.getX() + 0.5D, (double) blockpos.getY(), (double) blockpos.getZ() + 0.5D, (LivingEntity) null);
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                ServerLevel worldserver = sourceblock.level();
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                // CraftBukkit start
+                // EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(worldserver, (double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, (EntityLiving) null);
 
-                serverlevel.addFreshEntity(primedtnt);
-                serverlevel.playSound((Player) null, primedtnt.getX(), primedtnt.getY(), primedtnt.getZ(), SoundEvents.TNT_PRIMED, SoundSource.BLOCKS, 1.0F, 1.0F);
-                serverlevel.gameEvent((Entity) null, GameEvent.ENTITY_PLACE, blockpos);
-                itemstack.shrink(1);
+                ItemStack itemstack1 = itemstack.split(1);
+                org.bukkit.block.Block block = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack1);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(block, craftItem.clone(), new org.bukkit.util.Vector((double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D));
+                if (!DispenserBlock.eventFired) {
+                   worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    itemstack.grow(1);
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    itemstack.grow(1);
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+
+                PrimedTnt entitytntprimed = new PrimedTnt(worldserver, event.getVelocity().getX(), event.getVelocity().getY(), event.getVelocity().getZ(), (LivingEntity) null);
+                // CraftBukkit end
+
+                worldserver.addFreshEntity(entitytntprimed);
+                worldserver.playSound((Player) null, entitytntprimed.getX(), entitytntprimed.getY(), entitytntprimed.getZ(), SoundEvents.TNT_PRIMED, SoundSource.BLOCKS, 1.0F, 1.0F);
+                worldserver.gameEvent((Entity) null, GameEvent.ENTITY_PLACE, blockposition);
+                // itemstack.shrink(1); // CraftBukkit - handled above
                 return itemstack;
             }
         });
-        OptionalDispenseItemBehavior optionaldispenseitembehavior1 = new OptionalDispenseItemBehavior() {
+        OptionalDispenseItemBehavior dispensebehaviormaybe1 = new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                this.setSuccess(ArmorItem.dispenseArmor(blocksource, itemstack));
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                this.setSuccess(ArmorItem.dispenseArmor(sourceblock, itemstack));
                 return itemstack;
             }
         };
 
-        DispenserBlock.registerBehavior(Items.CREEPER_HEAD, optionaldispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.ZOMBIE_HEAD, optionaldispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.DRAGON_HEAD, optionaldispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.SKELETON_SKULL, optionaldispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.PIGLIN_HEAD, optionaldispenseitembehavior1);
-        DispenserBlock.registerBehavior(Items.PLAYER_HEAD, optionaldispenseitembehavior1);
+        DispenserBlock.registerBehavior(Items.CREEPER_HEAD, dispensebehaviormaybe1);
+        DispenserBlock.registerBehavior(Items.ZOMBIE_HEAD, dispensebehaviormaybe1);
+        DispenserBlock.registerBehavior(Items.DRAGON_HEAD, dispensebehaviormaybe1);
+        DispenserBlock.registerBehavior(Items.SKELETON_SKULL, dispensebehaviormaybe1);
+        DispenserBlock.registerBehavior(Items.PIGLIN_HEAD, dispensebehaviormaybe1);
+        DispenserBlock.registerBehavior(Items.PLAYER_HEAD, dispensebehaviormaybe1);
         DispenserBlock.registerBehavior(Items.WITHER_SKELETON_SKULL, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                ServerLevel serverlevel = blocksource.level();
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                BlockPos blockpos = blocksource.pos().relative(direction);
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                ServerLevel worldserver = sourceblock.level();
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                BlockPos blockposition = sourceblock.pos().relative(enumdirection);
 
-                if (serverlevel.isEmptyBlock(blockpos) && WitherSkullBlock.canSpawnMob(serverlevel, blockpos, itemstack)) {
-                    serverlevel.setBlock(blockpos, (BlockState) Blocks.WITHER_SKELETON_SKULL.defaultBlockState().setValue(SkullBlock.ROTATION, RotationSegment.convertToSegment(direction)), 3);
-                    serverlevel.gameEvent((Entity) null, GameEvent.BLOCK_PLACE, blockpos);
-                    BlockEntity blockentity = serverlevel.getBlockEntity(blockpos);
+                // CraftBukkit start
+                org.bukkit.block.Block bukkitBlock = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
 
-                    if (blockentity instanceof SkullBlockEntity) {
-                        WitherSkullBlock.checkSpawn(serverlevel, blockpos, (SkullBlockEntity) blockentity);
+                BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
                     }
+                }
+                // CraftBukkit end
 
+                if (worldserver.isEmptyBlock(blockposition) && WitherSkullBlock.canSpawnMob(worldserver, blockposition, itemstack)) {
+                    worldserver.setBlock(blockposition, (IBlockData) Blocks.WITHER_SKELETON_SKULL.defaultBlockState().setValue(SkullBlock.ROTATION, RotationSegment.convertToSegment(enumdirection)), 3);
+                    worldserver.gameEvent((Entity) null, GameEvent.BLOCK_PLACE, blockposition);
+                    BlockEntity tileentity = worldserver.getBlockEntity(blockposition);
+
+                    if (tileentity instanceof SkullBlockEntity) {
+                        WitherSkullBlock.checkSpawn(worldserver, blockposition, (SkullBlockEntity) tileentity);
+                    }
+
                     itemstack.shrink(1);
                     this.setSuccess(true);
                 } else {
-                    this.setSuccess(ArmorItem.dispenseArmor(blocksource, itemstack));
+                    this.setSuccess(ArmorItem.dispenseArmor(sourceblock, itemstack));
                 }
 
                 return itemstack;
@@ -593,48 +968,71 @@
         });
         DispenserBlock.registerBehavior(Blocks.CARVED_PUMPKIN, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            protected ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                ServerLevel serverlevel = blocksource.level();
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                CarvedPumpkinBlock carvedpumpkinblock = (CarvedPumpkinBlock) Blocks.CARVED_PUMPKIN;
+            protected ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                ServerLevel worldserver = sourceblock.level();
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                CarvedPumpkinBlock blockpumpkincarved = (CarvedPumpkinBlock) Blocks.CARVED_PUMPKIN;
 
-                if (serverlevel.isEmptyBlock(blockpos) && carvedpumpkinblock.canSpawnGolem(serverlevel, blockpos)) {
-                    if (!serverlevel.isClientSide) {
-                        serverlevel.setBlock(blockpos, carvedpumpkinblock.defaultBlockState(), 3);
-                        serverlevel.gameEvent((Entity) null, GameEvent.BLOCK_PLACE, blockpos);
+                // CraftBukkit start
+                org.bukkit.block.Block bukkitBlock = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
                     }
+                }
+                // CraftBukkit end
 
+                if (worldserver.isEmptyBlock(blockposition) && blockpumpkincarved.canSpawnGolem(worldserver, blockposition)) {
+                    if (!worldserver.isClientSide) {
+                        worldserver.setBlock(blockposition, blockpumpkincarved.defaultBlockState(), 3);
+                        worldserver.gameEvent((Entity) null, GameEvent.BLOCK_PLACE, blockposition);
+                    }
+
                     itemstack.shrink(1);
                     this.setSuccess(true);
                 } else {
-                    this.setSuccess(ArmorItem.dispenseArmor(blocksource, itemstack));
+                    this.setSuccess(ArmorItem.dispenseArmor(sourceblock, itemstack));
                 }
 
                 return itemstack;
             }
         });
         DispenserBlock.registerBehavior(Blocks.SHULKER_BOX.asItem(), new ShulkerBoxDispenseBehavior());
-        DyeColor[] adyecolor = DyeColor.values();
-        int i = adyecolor.length;
+        DyeColor[] aenumcolor = DyeColor.values();
+        int i = aenumcolor.length;
 
         for (int j = 0; j < i; ++j) {
-            DyeColor dyecolor = adyecolor[j];
+            DyeColor enumcolor = aenumcolor[j];
 
-            DispenserBlock.registerBehavior(ShulkerBoxBlock.getBlockByColor(dyecolor).asItem(), new ShulkerBoxDispenseBehavior());
+            DispenserBlock.registerBehavior(ShulkerBoxBlock.getBlockByColor(enumcolor).asItem(), new ShulkerBoxDispenseBehavior());
         }
 
         DispenserBlock.registerBehavior(Items.GLASS_BOTTLE.asItem(), new OptionalDispenseItemBehavior() {
             private final DefaultDispenseItemBehavior defaultDispenseItemBehavior = new DefaultDispenseItemBehavior();
 
-            private ItemStack takeLiquid(BlockSource blocksource, ItemStack itemstack, ItemStack itemstack1) {
+            private ItemStack takeLiquid(SourceBlock sourceblock, ItemStack itemstack, ItemStack itemstack1) {
                 itemstack.shrink(1);
                 if (itemstack.isEmpty()) {
-                    blocksource.level().gameEvent((Entity) null, GameEvent.FLUID_PICKUP, blocksource.pos());
+                    sourceblock.level().gameEvent((Entity) null, GameEvent.FLUID_PICKUP, sourceblock.pos());
                     return itemstack1.copy();
                 } else {
-                    if (blocksource.blockEntity().addItem(itemstack1.copy()) < 0) {
-                        this.defaultDispenseItemBehavior.dispense(blocksource, itemstack1.copy());
+                    if (sourceblock.blockEntity().addItem(itemstack1.copy()) < 0) {
+                        this.defaultDispenseItemBehavior.dispense(sourceblock, itemstack1.copy());
                     }
 
                     return itemstack;
@@ -642,40 +1040,62 @@
             }
 
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
                 this.setSuccess(false);
-                ServerLevel serverlevel = blocksource.level();
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                BlockState blockstate = serverlevel.getBlockState(blockpos);
+                ServerLevel worldserver = sourceblock.level();
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                IBlockData iblockdata = worldserver.getBlockState(blockposition);
 
-                if (blockstate.is(BlockTags.BEEHIVES, (blockbehaviour_blockstatebase) -> {
-                    return blockbehaviour_blockstatebase.hasProperty(BeehiveBlock.HONEY_LEVEL) && blockbehaviour_blockstatebase.getBlock() instanceof BeehiveBlock;
-                }) && (Integer) blockstate.getValue(BeehiveBlock.HONEY_LEVEL) >= 5) {
-                    ((BeehiveBlock) blockstate.getBlock()).releaseBeesAndResetHoneyLevel(serverlevel, blockstate, blockpos, (Player) null, BeehiveBlockEntity.BeeReleaseStatus.BEE_RELEASED);
+                // CraftBukkit start
+                org.bukkit.block.Block bukkitBlock = CraftBlock.at(worldserver, sourceblock.pos());
+                CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemstack);
+
+                BlockDispenseEvent event = new BlockDispenseEvent(bukkitBlock, craftItem.clone(), new org.bukkit.util.Vector(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
+                if (!DispenserBlock.eventFired) {
+                    worldserver.getCraftServer().getPluginManager().callEvent(event);
+                }
+
+                if (event.isCancelled()) {
+                    return itemstack;
+                }
+
+                if (!event.getItem().equals(craftItem)) {
+                    // Chain to handler for new item
+                    ItemStack eventStack = CraftItemStack.asNMSCopy(event.getItem());
+                    DispenseItemBehavior idispensebehavior = (DispenseItemBehavior) DispenserBlock.DISPENSER_REGISTRY.get(eventStack.getItem());
+                    if (idispensebehavior != DispenseItemBehavior.NOOP && idispensebehavior != this) {
+                        idispensebehavior.dispense(sourceblock, eventStack);
+                        return itemstack;
+                    }
+                }
+                // CraftBukkit end
+
+                if (iblockdata.is(BlockTags.BEEHIVES, (blockbase_blockdata) -> {
+                    return blockbase_blockdata.hasProperty(BeehiveBlock.HONEY_LEVEL) && blockbase_blockdata.getBlock() instanceof BeehiveBlock;
+                }) && (Integer) iblockdata.getValue(BeehiveBlock.HONEY_LEVEL) >= 5) {
+                    ((BeehiveBlock) iblockdata.getBlock()).releaseBeesAndResetHoneyLevel(worldserver, iblockdata, blockposition, (Player) null, BeehiveBlockEntity.ReleaseStatus.BEE_RELEASED);
                     this.setSuccess(true);
-                    return this.takeLiquid(blocksource, itemstack, new ItemStack(Items.HONEY_BOTTLE));
-                } else if (serverlevel.getFluidState(blockpos).is(FluidTags.WATER)) {
+                    return this.takeLiquid(sourceblock, itemstack, new ItemStack(Items.HONEY_BOTTLE));
+                } else if (worldserver.getFluidState(blockposition).is(FluidTags.WATER)) {
                     this.setSuccess(true);
-                    return this.takeLiquid(blocksource, itemstack, PotionUtils.setPotion(new ItemStack(Items.POTION), Potions.WATER));
+                    return this.takeLiquid(sourceblock, itemstack, PotionUtils.setPotion(new ItemStack(Items.POTION), Potions.WATER));
                 } else {
-                    return super.execute(blocksource, itemstack);
+                    return super.execute(sourceblock, itemstack);
                 }
             }
         });
         DispenserBlock.registerBehavior(Items.GLOWSTONE, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                Direction direction = (Direction) blocksource.state().getValue(DispenserBlock.FACING);
-                BlockPos blockpos = blocksource.pos().relative(direction);
-                ServerLevel serverlevel = blocksource.level();
-                BlockState blockstate = serverlevel.getBlockState(blockpos);
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                Direction enumdirection = (Direction) sourceblock.state().getValue(DispenserBlock.FACING);
+                BlockPos blockposition = sourceblock.pos().relative(enumdirection);
+                ServerLevel worldserver = sourceblock.level();
+                IBlockData iblockdata = worldserver.getBlockState(blockposition);
 
                 this.setSuccess(true);
-                if (blockstate.is(Blocks.RESPAWN_ANCHOR)) {
-                    if ((Integer) blockstate.getValue(RespawnAnchorBlock.CHARGE) != 4) {
-                        RespawnAnchorBlock.charge((Entity) null, serverlevel, blockpos, blockstate);
+                if (iblockdata.is(Blocks.RESPAWN_ANCHOR)) {
+                    if ((Integer) iblockdata.getValue(RespawnAnchorBlock.CHARGE) != 4) {
+                        RespawnAnchorBlock.charge((Entity) null, worldserver, blockposition, iblockdata);
                         itemstack.shrink(1);
                     } else {
                         this.setSuccess(false);
@@ -683,28 +1103,27 @@
 
                     return itemstack;
                 } else {
-                    return super.execute(blocksource, itemstack);
+                    return super.execute(sourceblock, itemstack);
                 }
             }
         });
         DispenserBlock.registerBehavior(Items.SHEARS.asItem(), new ShearsDispenseItemBehavior());
         DispenserBlock.registerBehavior(Items.HONEYCOMB, new OptionalDispenseItemBehavior() {
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
-                BlockPos blockpos = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
-                ServerLevel serverlevel = blocksource.level();
-                BlockState blockstate = serverlevel.getBlockState(blockpos);
-                Optional<BlockState> optional = HoneycombItem.getWaxed(blockstate);
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
+                BlockPos blockposition = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
+                ServerLevel worldserver = sourceblock.level();
+                IBlockData iblockdata = worldserver.getBlockState(blockposition);
+                Optional<IBlockData> optional = HoneycombItem.getWaxed(iblockdata);
 
                 if (optional.isPresent()) {
-                    serverlevel.setBlockAndUpdate(blockpos, (BlockState) optional.get());
-                    serverlevel.levelEvent(3003, blockpos, 0);
+                    worldserver.setBlockAndUpdate(blockposition, (IBlockData) optional.get());
+                    worldserver.levelEvent(3003, blockposition, 0);
                     itemstack.shrink(1);
                     this.setSuccess(true);
                     return itemstack;
                 } else {
-                    return super.execute(blocksource, itemstack);
+                    return super.execute(sourceblock, itemstack);
                 }
             }
         });
@@ -712,27 +1131,26 @@
             private final DefaultDispenseItemBehavior defaultDispenseItemBehavior = new DefaultDispenseItemBehavior();
 
             @Override
-            @Override
-            public ItemStack execute(BlockSource blocksource, ItemStack itemstack) {
+            public ItemStack execute(SourceBlock sourceblock, ItemStack itemstack) {
                 if (PotionUtils.getPotion(itemstack) != Potions.WATER) {
-                    return this.defaultDispenseItemBehavior.dispense(blocksource, itemstack);
+                    return this.defaultDispenseItemBehavior.dispense(sourceblock, itemstack);
                 } else {
-                    ServerLevel serverlevel = blocksource.level();
-                    BlockPos blockpos = blocksource.pos();
-                    BlockPos blockpos1 = blocksource.pos().relative((Direction) blocksource.state().getValue(DispenserBlock.FACING));
+                    ServerLevel worldserver = sourceblock.level();
+                    BlockPos blockposition = sourceblock.pos();
+                    BlockPos blockposition1 = sourceblock.pos().relative((Direction) sourceblock.state().getValue(DispenserBlock.FACING));
 
-                    if (!serverlevel.getBlockState(blockpos1).is(BlockTags.CONVERTABLE_TO_MUD)) {
-                        return this.defaultDispenseItemBehavior.dispense(blocksource, itemstack);
+                    if (!worldserver.getBlockState(blockposition1).is(BlockTags.CONVERTABLE_TO_MUD)) {
+                        return this.defaultDispenseItemBehavior.dispense(sourceblock, itemstack);
                     } else {
-                        if (!serverlevel.isClientSide) {
+                        if (!worldserver.isClientSide) {
                             for (int k = 0; k < 5; ++k) {
-                                serverlevel.sendParticles(ParticleTypes.SPLASH, (double) blockpos.getX() + serverlevel.random.nextDouble(), (double) (blockpos.getY() + 1), (double) blockpos.getZ() + serverlevel.random.nextDouble(), 1, 0.0D, 0.0D, 0.0D, 1.0D);
+                                worldserver.sendParticles(ParticleTypes.SPLASH, (double) blockposition.getX() + worldserver.random.nextDouble(), (double) (blockposition.getY() + 1), (double) blockposition.getZ() + worldserver.random.nextDouble(), 1, 0.0D, 0.0D, 0.0D, 1.0D);
                             }
                         }
 
-                        serverlevel.playSound((Player) null, blockpos, SoundEvents.BOTTLE_EMPTY, SoundSource.BLOCKS, 1.0F, 1.0F);
-                        serverlevel.gameEvent((Entity) null, GameEvent.FLUID_PLACE, blockpos);
-                        serverlevel.setBlockAndUpdate(blockpos1, Blocks.MUD.defaultBlockState());
+                        worldserver.playSound((Player) null, blockposition, SoundEvents.BOTTLE_EMPTY, SoundSource.BLOCKS, 1.0F, 1.0F);
+                        worldserver.gameEvent((Entity) null, GameEvent.FLUID_PLACE, blockposition);
+                        worldserver.setBlockAndUpdate(blockposition1, Blocks.MUD.defaultBlockState());
                         return new ItemStack(Items.GLASS_BOTTLE);
                     }
                 }
@@ -740,7 +1158,7 @@
         });
     }
 
-    static Vec3 getEntityPokingOutOfBlockPos(BlockSource blocksource, EntityType<?> entitytype, Direction direction) {
-        return blocksource.center().add((double) direction.getStepX() * (0.5000099999997474D - (double) entitytype.getWidth() / 2.0D), (double) direction.getStepY() * (0.5000099999997474D - (double) entitytype.getHeight() / 2.0D) - (double) entitytype.getHeight() / 2.0D, (double) direction.getStepZ() * (0.5000099999997474D - (double) entitytype.getWidth() / 2.0D));
+    static Vec3 getEntityPokingOutOfBlockPos(SourceBlock sourceblock, EntityType<?> entitytypes, Direction enumdirection) {
+        return sourceblock.center().add((double) enumdirection.getStepX() * (0.5000099999997474D - (double) entitytypes.getWidth() / 2.0D), (double) enumdirection.getStepY() * (0.5000099999997474D - (double) entitytypes.getHeight() / 2.0D) - (double) entitytypes.getHeight() / 2.0D, (double) enumdirection.getStepZ() * (0.5000099999997474D - (double) entitytypes.getWidth() / 2.0D));
     }
 }
