--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -24,6 +30,17 @@
 import net.minecraft.util.VisibleForDebug;
 import org.slf4j.Logger;
 
+// CraftBukkit start
+import io.netty.buffer.ByteBuf;
+import java.util.concurrent.ExecutionException;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.player.PlayerResourcePackStatusEvent;
+// CraftBukkit end
+
 public abstract class ServerCommonPacketListenerImpl implements ServerCommonPacketListener {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final int LATENCY_CHECK_INTERVAL = 15000;
@@ -36,13 +54,21 @@
     private int latency;
     private volatile boolean suspendFlushingOnServerThread = false;
 
-    public ServerCommonPacketListenerImpl(MinecraftServer minecraftServer, Connection connection, CommonListenerCookie commonListenerCookie) {
-        this.server = minecraftServer;
-        this.connection = connection;
+    public ServerCommonPacketListenerImpl(MinecraftServer minecraftserver, Connection networkmanager, CommonListenerCookie commonlistenercookie, ServerPlayer player) { // CraftBukkit
+        this.server = minecraftserver;
+        this.connection = networkmanager;
         this.keepAliveTime = Util.getMillis();
-        this.latency = commonListenerCookie.latency();
+        this.latency = commonlistenercookie.latency();
+        // CraftBukkit start - add fields and methods
+        this.player = player;
+        this.cserver = minecraftserver.server;
     }
 
+    public CraftPlayer getCraftPlayer() {
+        return (this.player == null) ? null : (CraftPlayer) this.player.getBukkitEntity();
+        // CraftBukkit end
+    }
+
     @Override
     public void onDisconnect(Component reason) {
         if (this.isSingleplayerOwner()) {
@@ -52,9 +82,11 @@
     }
 
     @Override
-    public void handleKeepAlive(ServerboundKeepAlivePacket serverboundKeepAlivePacket) {
-        if (this.keepAlivePending && serverboundKeepAlivePacket.getId() == this.keepAliveChallenge) {
-            int i = (int)(Util.getMillis() - this.keepAliveTime);
+    public void handleKeepAlive(ServerboundKeepAlivePacket serverboundkeepalivepacket) {
+        PacketUtils.ensureRunningOnSameThread(serverboundkeepalivepacket, this, this.player.serverLevel()); // CraftBukkit
+        if (this.keepAlivePending && serverboundkeepalivepacket.getId() == this.keepAliveChallenge) {
+            int i = (int) (Util.getMillis() - this.keepAliveTime);
+
             this.latency = (this.latency * 3 + i) / 4;
             this.keepAlivePending = false;
         } else if (!this.isSingleplayerOwner()) {
@@ -66,10 +98,19 @@
     public void handlePong(ServerboundPongPacket serverboundPongPacket) {
     }
 
+    // CraftBukkit start
+    private static final ResourceLocation CUSTOM_REGISTER = new ResourceLocation("register");
+    private static final ResourceLocation CUSTOM_UNREGISTER = new ResourceLocation("unregister");
+
     @Override
     public void handleCustomPayload(ServerboundCustomPayloadPacket serverboundCustomPayloadPacket) {
     }
 
+    public final boolean isDisconnected() {
+        return !this.player.joining && !this.connection.isConnected();
+    }
+    // CraftBukkit end
+
     @Override
     public void handleResourcePackResponse(ServerboundResourcePackPacket serverboundResourcePackPacket) {
         PacketUtils.ensureRunningOnSameThread(serverboundResourcePackPacket, this, this.server);
@@ -77,12 +156,15 @@
             LOGGER.info("Disconnecting {} due to resource pack {} rejection", this.playerProfile().getName(), serverboundResourcePackPacket.id());
             this.disconnect(Component.translatable("multiplayer.requiredTexturePrompt.disconnect"));
         }
+        this.cserver.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(getCraftPlayer(), serverboundresourcepackpacket.id(), PlayerResourcePackStatusEvent.Status.values()[serverboundresourcepackpacket.action().ordinal()])); // CraftBukkit
+
     }
 
     protected void keepConnectionAlive() {
         this.server.getProfiler().push("keepAlive");
-        long millis = Util.getMillis();
-        if (millis - this.keepAliveTime >= 15000L) {
+        long i = Util.getMillis();
+
+        if (i - this.keepAliveTime >= 25000L) { // CraftBukkit
             if (this.keepAlivePending) {
                 this.disconnect(TIMEOUT_DISCONNECTION_MESSAGE);
             } else {
@@ -109,7 +191,15 @@
         this.send(packet, null);
     }
 
-    public void send(Packet<?> packet, @Nullable PacketSendListener packetSendListener) {
+    public void send(Packet<?> packet, @Nullable PacketSendListener packetsendlistener) {
+        // CraftBukkit start
+        if (packet == null) {
+            return;
+        } else if (packet instanceof ClientboundSetDefaultSpawnPositionPacket) {
+            ClientboundSetDefaultSpawnPositionPacket packet6 = (ClientboundSetDefaultSpawnPositionPacket) packet;
+            this.player.compassTarget = CraftLocation.toBukkit(packet6.pos, this.getCraftPlayer().getWorld());
+        }
+        // CraftBukkit end
         boolean flag = !this.suspendFlushingOnServerThread || !this.server.isSameThread();
 
         try {
@@ -122,10 +215,67 @@
         }
     }
 
-    public void disconnect(Component component) {
-        this.connection.send(new ClientboundDisconnectPacket(component), PacketSendListener.thenRun(() -> this.connection.disconnect(component)));
+    // CraftBukkit start
+    @Deprecated
+    public void disconnect(Component ichatbasecomponent) {
+        disconnect(CraftChatMessage.fromComponent(ichatbasecomponent));
+    }
+    // CraftBukkit end
+
+    public void disconnect(String s) {
+        // CraftBukkit start - fire PlayerKickEvent
+        if (this.processedDisconnect) {
+            return;
+        }
+        if (!this.cserver.isPrimaryThread()) {
+            Waitable waitable = new Waitable() {
+                @Override
+                protected Object evaluate() {
+                    ServerCommonPacketListenerImpl.this.disconnect(s);
+                    return null;
+                }
+            };
+
+            this.server.processQueue.add(waitable);
+
+            try {
+                waitable.get();
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            } catch (ExecutionException e) {
+                throw new RuntimeException(e);
+            }
+            return;
+        }
+
+        String leaveMessage = ChatFormatting.YELLOW + this.player.getScoreboardName() + " left the game.";
+
+        PlayerKickEvent event = new PlayerKickEvent(this.player.getBukkitEntity(), s, leaveMessage);
+
+        if (this.cserver.getServer().isRunning()) {
+            this.cserver.getPluginManager().callEvent(event);
+        }
+
+        if (event.isCancelled()) {
+            // Do not kick the player
+            return;
+        }
+        this.player.kickLeaveMessage = event.getLeaveMessage(); // CraftBukkit - SPIGOT-3034: Forward leave message to PlayerQuitEvent
+        // Send the possibly modified leave message
+        final Component ichatbasecomponent = CraftChatMessage.fromString(event.getReason(), true)[0];
+        // CraftBukkit end
+
+        this.connection.send(new ClientboundDisconnectPacket(ichatbasecomponent), PacketSendListener.thenRun(() -> {
+            this.connection.disconnect(ichatbasecomponent);
+        }));
+        this.onDisconnect(ichatbasecomponent); // CraftBukkit - fire quit instantly
         this.connection.setReadOnly();
-        this.server.executeBlocking(this.connection::handleDisconnection);
+        MinecraftServer minecraftserver = this.server;
+        Connection networkmanager = this.connection;
+
+        Objects.requireNonNull(this.connection);
+        // CraftBukkit - Don't wait
+        minecraftserver.wrapRunnable(networkmanager::handleDisconnection);
     }
 
     protected boolean isSingleplayerOwner() {
