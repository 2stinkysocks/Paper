--- a/net/minecraft/server/network/ServerConnectionListener.java
+++ b/net/minecraft/server/network/ServerConnectionListener.java
@@ -78,45 +84,40 @@
                 LOGGER.info("Using default channel type");
             }
 
-            this.channels
-                .add(
-                    new ServerBootstrap()
-                        .channel(clazz)
-                        .childHandler(
-                            new ChannelInitializer<Channel>() {
-                                @Override
-                                protected void initChannel(Channel channel) {
-                                    Connection.setInitialProtocolAttributes(channel);
-                
-                                    try {
-                                        channel.config().setOption(ChannelOption.TCP_NODELAY, true);
-                                    } catch (ChannelException var5) {
-                                    }
-                
-                                    ChannelPipeline channelPipeline = channel.pipeline()
-                                        .addLast("timeout", new ReadTimeoutHandler(30))
-                                        .addLast("legacy_query", new LegacyQueryHandler(ServerConnectionListener.this.getServer()));
-                                    Connection.configureSerialization(channelPipeline, PacketFlow.SERVERBOUND, null);
-                                    int rateLimitPacketsPerSecond = ServerConnectionListener.this.server.getRateLimitPacketsPerSecond();
-                                    Connection connection = (Connection)(rateLimitPacketsPerSecond > 0
-                                        ? new RateKickingConnection(rateLimitPacketsPerSecond)
-                                        : new Connection(PacketFlow.SERVERBOUND));
-                                    ServerConnectionListener.this.connections.add(connection);
-                                    connection.configurePacketHandler(channelPipeline);
-                                    connection.setListenerForServerboundHandshake(
-                                        new ServerHandshakePacketListenerImpl(ServerConnectionListener.this.server, connection)
-                                    );
-                                }
-                            }
-                        )
-                        .group(eventLoopGroup)
-                        .localAddress(address, port)
-                        .bind()
-                        .syncUninterruptibly()
-                );
+            this.channels.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(oclass)).childHandler(new ChannelInitializer<Channel>() {
+                protected void initChannel(Channel channel) {
+                    Connection.setInitialProtocolAttributes(channel);
+
+                    try {
+                        channel.config().setOption(ChannelOption.TCP_NODELAY, true);
+                    } catch (ChannelException channelexception) {
+                        ;
+                    }
+
+                    ChannelPipeline channelpipeline = channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyQueryHandler(ServerConnectionListener.this.getServer()));
+
+                    Connection.configureSerialization(channelpipeline, PacketFlow.SERVERBOUND, (BandwidthDebugMonitor) null);
+                    int j = ServerConnectionListener.this.server.getRateLimitPacketsPerSecond();
+                    Connection object = j > 0 ? new RateKickingConnection(j) : new Connection(PacketFlow.SERVERBOUND); // CraftBukkit - decompile error
+
+                    ServerConnectionListener.this.connections.add(object);
+                    ((Connection) object).configurePacketHandler(channelpipeline);
+                    ((Connection) object).setListenerForServerboundHandshake(new ServerHandshakePacketListenerImpl(ServerConnectionListener.this.server, (Connection) object));
+                }
+            }).group(eventloopgroup).localAddress(address, port)).option(ChannelOption.AUTO_READ, false).bind().syncUninterruptibly()); // CraftBukkit
         }
     }
 
+    // CraftBukkit start
+    public void acceptConnections() {
+        synchronized (this.channels) {
+            for (ChannelFuture future : this.channels) {
+                future.channel().config().setAutoRead(true);
+            }
+        }
+    }
+    // CraftBukkit end
+
     public SocketAddress startMemoryChannel() {
         ChannelFuture channelFuture;
         synchronized (this.channels) {
