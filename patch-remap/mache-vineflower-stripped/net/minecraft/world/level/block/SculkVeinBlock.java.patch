--- a/net/minecraft/world/level/block/SculkVeinBlock.java
+++ b/net/minecraft/world/level/block/SculkVeinBlock.java
@@ -94,19 +107,15 @@
     }
 
     @Override
-    public int attemptUseCharge(
-        SculkSpreader.ChargeCursor cursor, LevelAccessor level, BlockPos pos, RandomSource random, SculkSpreader spreader, boolean shouldConvertBlocks
-    ) {
-        if (shouldConvertBlocks && this.attemptPlaceSculk(spreader, level, cursor.getPos(), random)) {
-            return cursor.getCharge() - 1;
-        } else {
-            return random.nextInt(spreader.chargeDecayRate()) == 0 ? Mth.floor((float)cursor.getCharge() * 0.5F) : cursor.getCharge();
-        }
+    public int attemptUseCharge(SculkSpreader.ChargeCursor cursor, LevelAccessor level, BlockPos pos, RandomSource random, SculkSpreader spreader, boolean shouldConvertBlocks) {
+        // CraftBukkit - add source block
+        return shouldConvertBlocks && this.attemptPlaceSculk(spreader, level, cursor.getPos(), random, pos) ? cursor.getCharge() - 1 : (random.nextInt(spreader.chargeDecayRate()) == 0 ? Mth.floor((float) cursor.getCharge() * 0.5F) : cursor.getCharge());
     }
 
-    private boolean attemptPlaceSculk(SculkSpreader spreader, LevelAccessor level, BlockPos pos, RandomSource random) {
-        BlockState blockState = level.getBlockState(pos);
-        TagKey<Block> tagKey = spreader.replaceableBlocks();
+    private boolean attemptPlaceSculk(SculkSpreader sculkspreader, LevelAccessor generatoraccess, BlockPos blockposition, RandomSource randomsource, BlockPos sourceBlock) { // CraftBukkit
+        IBlockData iblockdata = generatoraccess.getBlockState(blockposition);
+        TagKey<Block> tagkey = sculkspreader.replaceableBlocks();
+        Iterator iterator = Direction.allShuffled(randomsource).iterator();
 
         for (Direction direction : Direction.allShuffled(random)) {
             if (hasFace(blockState, direction)) {
@@ -120,12 +120,34 @@
                     this.veinSpreader.spreadAll(blockState2, level, blockPos, spreader.isWorldGeneration());
                     Direction opposite = direction.getOpposite();
 
-                    for (Direction direction1 : DIRECTIONS) {
-                        if (direction1 != opposite) {
-                            BlockPos blockPos1 = blockPos.relative(direction1);
-                            BlockState blockState3 = level.getBlockState(blockPos1);
-                            if (blockState3.is(this)) {
-                                this.onDischarged(level, blockState3, blockPos1, random);
+            if (hasFace(iblockdata, enumdirection)) {
+                BlockPos blockposition1 = blockposition.relative(enumdirection);
+                IBlockData iblockdata1 = generatoraccess.getBlockState(blockposition1);
+
+                if (iblockdata1.is(tagkey)) {
+                    IBlockData iblockdata2 = Blocks.SCULK.defaultBlockState();
+
+                    // CraftBukkit start - Call BlockSpreadEvent
+                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockSpreadEvent(generatoraccess, sourceBlock, blockposition1, iblockdata2, 3)) {
+                        return false;
+                    }
+                    // CraftBukkit end
+                    Block.pushEntitiesUp(iblockdata1, iblockdata2, generatoraccess, blockposition1);
+                    generatoraccess.playSound((Player) null, blockposition1, SoundEvents.SCULK_BLOCK_SPREAD, SoundSource.BLOCKS, 1.0F, 1.0F);
+                    this.veinSpreader.spreadAll(iblockdata2, generatoraccess, blockposition1, sculkspreader.isWorldGeneration());
+                    Direction enumdirection1 = enumdirection.getOpposite();
+                    Direction[] aenumdirection = SculkVeinBlock.DIRECTIONS;
+                    int i = aenumdirection.length;
+
+                    for (int j = 0; j < i; ++j) {
+                        Direction enumdirection2 = aenumdirection[j];
+
+                        if (enumdirection2 != enumdirection1) {
+                            BlockPos blockposition2 = blockposition1.relative(enumdirection2);
+                            IBlockData iblockdata3 = generatoraccess.getBlockState(blockposition2);
+
+                            if (iblockdata3.is((Block) this)) {
+                                this.onDischarged(generatoraccess, iblockdata3, blockposition2, randomsource);
                             }
                         }
                     }
