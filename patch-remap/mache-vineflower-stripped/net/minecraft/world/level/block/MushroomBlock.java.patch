--- a/net/minecraft/world/level/block/MushroomBlock.java
+++ b/net/minecraft/world/level/block/MushroomBlock.java
@@ -19,6 +19,9 @@
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
+// CraftBukkit start
+import org.bukkit.TreeType;
+// CraftBukkit end
 
 public class MushroomBlock extends BushBlock implements BonemealableBlock {
     public static final MapCodec<MushroomBlock> CODEC = RecordCodecBuilder.mapCodec(
@@ -70,8 +77,8 @@
                 blockPos1 = pos.offset(random.nextInt(3) - 1, random.nextInt(2) - random.nextInt(2), random.nextInt(3) - 1);
             }
 
-            if (level.isEmptyBlock(blockPos1) && state.canSurvive(level, blockPos1)) {
-                level.setBlock(blockPos1, state, 2);
+            if (level.isEmptyBlock(blockposition2) && state.canSurvive(level, blockposition2)) {
+                org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockSpreadEvent(level, pos, blockposition2, state, 2); // CraftBukkit
             }
         }
     }
@@ -96,7 +104,8 @@
             return false;
         } else {
             level.removeBlock(pos, false);
-            if (holder.get().value().place(level, level.getChunkSource().getGenerator(), random, pos)) {
+            SaplingBlock.treeType = (this == Blocks.BROWN_MUSHROOM) ? TreeType.BROWN_MUSHROOM : TreeType.BROWN_MUSHROOM; // CraftBukkit
+            if (((ConfiguredFeature) ((Holder) optional.get()).value()).place(level, level.getChunkSource().getGenerator(), random, pos)) {
                 return true;
             } else {
                 level.setBlock(pos, state, 3);
