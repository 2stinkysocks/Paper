--- a/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
+++ b/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
@@ -28,6 +30,11 @@
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
 import org.slf4j.Logger;
+import net.minecraft.world.level.ChunkPos;
+// CraftBukkit start
+import net.minecraft.world.level.chunk.storage.EntityStorage;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+// CraftBukkit end
 
 public class PersistentEntitySectionManager<T extends EntityAccess> implements AutoCloseable {
     static final Logger LOGGER = LogUtils.getLogger();
@@ -52,8 +59,18 @@
         this.entityGetter = new LevelEntityGetterAdapter<>(this.visibleEntityStorage, this.sectionStorage);
     }
 
-    void removeSectionIfEmpty(long sectionKey, EntitySection<T> section) {
-        if (section.isEmpty()) {
+    // CraftBukkit start - add method to get all entities in chunk
+    public List<Entity> getEntities(ChunkPos chunkCoordIntPair) {
+        return sectionStorage.getExistingSectionsInChunk(chunkCoordIntPair.toLong()).flatMap(EntitySection::getEntities).map(entity -> (Entity) entity).collect(Collectors.toList());
+    }
+
+    public boolean isPending(long pair) {
+        return chunkLoadStatuses.get(pair) == b.PENDING;
+    }
+    // CraftBukkit end
+
+    void removeSectionIfEmpty(long sectionKey, EntitySection<T> entitysection) {
+        if (entitysection.isEmpty()) {
             this.sectionStorage.remove(sectionKey);
         }
     }
@@ -171,9 +209,16 @@
         }
     }
 
-    private boolean storeChunkSections(long chunkPosValue, Consumer<T> entityAction) {
-        PersistentEntitySectionManager.ChunkLoadStatus chunkLoadStatus = this.chunkLoadStatuses.get(chunkPosValue);
-        if (chunkLoadStatus == PersistentEntitySectionManager.ChunkLoadStatus.PENDING) {
+    private boolean storeChunkSections(long chunkPosValue, Consumer<T> consumer) {
+        // CraftBukkit start - add boolean for event call
+        return storeChunkSections(chunkPosValue, consumer, false);
+    }
+
+    private boolean storeChunkSections(long i, Consumer<T> consumer, boolean callEvent) {
+        // CraftBukkit end
+        PersistentEntitySectionManager.b persistententitysectionmanager_b = (PersistentEntitySectionManager.b) this.chunkLoadStatuses.get(i);
+
+        if (persistententitysectionmanager_b == PersistentEntitySectionManager.b.PENDING) {
             return false;
         } else {
             List<T> list = this.sectionStorage
@@ -181,8 +226,9 @@
                 .flatMap(entitySection -> entitySection.getEntities().filter(EntityAccess::shouldBeSaved))
                 .collect(Collectors.toList());
             if (list.isEmpty()) {
-                if (chunkLoadStatus == PersistentEntitySectionManager.ChunkLoadStatus.LOADED) {
-                    this.permanentStorage.storeEntities(new ChunkEntities<>(new ChunkPos(chunkPosValue), ImmutableList.of()));
+                if (persistententitysectionmanager_b == PersistentEntitySectionManager.b.LOADED) {
+                    if (callEvent) CraftEventFactory.callEntitiesUnloadEvent(((EntityStorage) permanentStorage).level, new ChunkPos(i), ImmutableList.of()); // CraftBukkit
+                    this.permanentStorage.storeEntities(new ChunkEntities<>(new ChunkPos(i), ImmutableList.of()));
                 }
 
                 return true;
@@ -190,8 +236,9 @@
                 this.requestChunkLoad(chunkPosValue);
                 return false;
             } else {
-                this.permanentStorage.storeEntities(new ChunkEntities<>(new ChunkPos(chunkPosValue), list));
-                list.forEach(entityAction);
+                if (callEvent) CraftEventFactory.callEntitiesUnloadEvent(((EntityStorage) permanentStorage).level, new ChunkPos(i), list.stream().map(entity -> (Entity) entity).collect(Collectors.toList())); // CraftBukkit
+                this.permanentStorage.storeEntities(new ChunkEntities<>(new ChunkPos(i), list));
+                list.forEach(consumer);
                 return true;
             }
         }
@@ -207,7 +258,10 @@
     }
 
     private boolean processChunkUnload(long chunkPosValue) {
-        boolean flag = this.storeChunkSections(chunkPosValue, entity -> entity.getPassengersAndSelf().forEach(this::unloadEntity));
+        boolean flag = this.storeChunkSections(chunkPosValue, (entityaccess) -> {
+            entityaccess.getPassengersAndSelf().forEach(this::unloadEntity);
+        }, true); // CraftBukkit - add boolean for event call
+
         if (!flag) {
             return false;
         } else {
@@ -227,10 +282,17 @@
     }
 
     private void processPendingLoads() {
-        ChunkEntities<T> chunkEntities;
-        while ((chunkEntities = this.loadingInbox.poll()) != null) {
-            chunkEntities.getEntities().forEach(entity -> this.addEntity((T)entity, true));
-            this.chunkLoadStatuses.put(chunkEntities.getPos().toLong(), PersistentEntitySectionManager.ChunkLoadStatus.LOADED);
+        ChunkEntities<T> chunkentities; // CraftBukkit - decompile error
+
+        while ((chunkentities = (ChunkEntities) this.loadingInbox.poll()) != null) {
+            chunkentities.getEntities().forEach((entityaccess) -> {
+                this.addEntity(entityaccess, true);
+            });
+            this.chunkLoadStatuses.put(chunkentities.getPos().toLong(), PersistentEntitySectionManager.b.LOADED);
+            // CraftBukkit start - call entity load event
+            List<Entity> entities = getEntities(chunkentities.getPos());
+            CraftEventFactory.callEntitiesLoadEvent(((EntityStorage) permanentStorage).level, chunkentities.getPos(), entities);
+            // CraftBukkit end
         }
     }
 
@@ -281,7 +349,15 @@
 
     @Override
     public void close() throws IOException {
-        this.saveAll();
+        // CraftBukkit start - add save boolean
+        close(true);
+    }
+
+    public void close(boolean save) throws IOException {
+        if (save) {
+            this.saveAll();
+        }
+        // CraftBukkit end
         this.permanentStorage.close();
     }
 
