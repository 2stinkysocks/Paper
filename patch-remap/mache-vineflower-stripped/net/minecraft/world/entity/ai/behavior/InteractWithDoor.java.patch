--- a/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
+++ b/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
@@ -31,62 +33,78 @@
     private static final double MAX_DISTANCE_TO_HOLD_DOOR_OPEN_FOR_OTHER_MOBS = 2.0;
 
     public static BehaviorControl<LivingEntity> create() {
-        MutableObject<Node> mutableObject = new MutableObject<>(null);
-        MutableInt mutableInt = new MutableInt(0);
-        return BehaviorBuilder.create(
-            instance -> instance.group(
-                        instance.present(MemoryModuleType.PATH),
-                        instance.registered(MemoryModuleType.DOORS_TO_CLOSE),
-                        instance.registered(MemoryModuleType.NEAREST_LIVING_ENTITIES)
-                    )
-                    .apply(
-                        instance,
-                        (navigationPath, doorsToClose, nearestLivingEntities) -> (level, entity, gameTime) -> {
-                                Path path = instance.get(navigationPath);
-                                Optional<Set<GlobalPos>> optional = instance.tryGet(doorsToClose);
-                                if (!path.notStarted() && !path.isDone()) {
-                                    if (Objects.equals(mutableObject.getValue(), path.getNextNode())) {
-                                        mutableInt.setValue(20);
-                                    } else if (mutableInt.decrementAndGet() > 0) {
-                                        return false;
-                                    }
-            
-                                    mutableObject.setValue(path.getNextNode());
-                                    Node previousNode = path.getPreviousNode();
-                                    Node nextNode = path.getNextNode();
-                                    BlockPos blockPos = previousNode.asBlockPos();
-                                    BlockState blockState = level.getBlockState(blockPos);
-                                    if (blockState.is(BlockTags.WOODEN_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
-                                        DoorBlock doorBlock = (DoorBlock)blockState.getBlock();
-                                        if (!doorBlock.isOpen(blockState)) {
-                                            doorBlock.setOpen(entity, level, blockState, blockPos, true);
-                                        }
-            
-                                        optional = rememberDoorToClose(doorsToClose, optional, level, blockPos);
-                                    }
-            
-                                    BlockPos blockPos1 = nextNode.asBlockPos();
-                                    BlockState blockState1 = level.getBlockState(blockPos1);
-                                    if (blockState1.is(BlockTags.WOODEN_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
-                                        DoorBlock doorBlock1 = (DoorBlock)blockState1.getBlock();
-                                        if (!doorBlock1.isOpen(blockState1)) {
-                                            doorBlock1.setOpen(entity, level, blockState1, blockPos1, true);
-                                            optional = rememberDoorToClose(doorsToClose, optional, level, blockPos1);
-                                        }
-                                    }
-            
-                                    optional.ifPresent(
-                                        doorPositions -> closeDoorsThatIHaveOpenedOrPassedThrough(
-                                                level, entity, previousNode, nextNode, (Set<GlobalPos>)doorPositions, instance.tryGet(nearestLivingEntities)
-                                            )
-                                    );
-                                    return true;
-                                } else {
+        MutableObject<Node> mutableobject = new MutableObject((Object) null);
+        MutableInt mutableint = new MutableInt(0);
+
+        return BehaviorBuilder.create((behaviorbuilder_b) -> {
+            return behaviorbuilder_b.group(behaviorbuilder_b.present(MemoryModuleType.PATH), behaviorbuilder_b.registered(MemoryModuleType.DOORS_TO_CLOSE), behaviorbuilder_b.registered(MemoryModuleType.NEAREST_LIVING_ENTITIES)).apply(behaviorbuilder_b, (memoryaccessor, memoryaccessor1, memoryaccessor2) -> {
+                return (worldserver, entityliving, i) -> {
+                    Path pathentity = (Path) behaviorbuilder_b.get(memoryaccessor);
+                    Optional<Set<GlobalPos>> optional = behaviorbuilder_b.tryGet(memoryaccessor1);
+
+                    if (!pathentity.notStarted() && !pathentity.isDone()) {
+                        if (Objects.equals(mutableobject.getValue(), pathentity.getNextNode())) {
+                            mutableint.setValue(20);
+                        } else if (mutableint.decrementAndGet() > 0) {
+                            return false;
+                        }
+
+                        mutableobject.setValue(pathentity.getNextNode());
+                        Node pathpoint = pathentity.getPreviousNode();
+                        Node pathpoint1 = pathentity.getNextNode();
+                        BlockPos blockposition = pathpoint.asBlockPos();
+                        IBlockData iblockdata = worldserver.getBlockState(blockposition);
+
+                        if (iblockdata.is(BlockTags.WOODEN_DOORS, (blockbase_blockdata) -> {
+                            return blockbase_blockdata.getBlock() instanceof DoorBlock;
+                        })) {
+                            DoorBlock blockdoor = (DoorBlock) iblockdata.getBlock();
+
+                            if (!blockdoor.isOpen(iblockdata)) {
+                                // CraftBukkit start - entities opening doors
+                                org.bukkit.event.entity.EntityInteractEvent event = new org.bukkit.event.entity.EntityInteractEvent(entityliving.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(entityliving.level(), blockposition));
+                                entityliving.level().getCraftServer().getPluginManager().callEvent(event);
+                                if (event.isCancelled()) {
                                     return false;
                                 }
+                                // CraftBukkit end
+                                blockdoor.setOpen(entityliving, worldserver, iblockdata, blockposition, true);
                             }
-                    )
-        );
+
+                            optional = rememberDoorToClose(memoryaccessor1, optional, worldserver, blockposition);
+                        }
+
+                        BlockPos blockposition1 = pathpoint1.asBlockPos();
+                        IBlockData iblockdata1 = worldserver.getBlockState(blockposition1);
+
+                        if (iblockdata1.is(BlockTags.WOODEN_DOORS, (blockbase_blockdata) -> {
+                            return blockbase_blockdata.getBlock() instanceof DoorBlock;
+                        })) {
+                            DoorBlock blockdoor1 = (DoorBlock) iblockdata1.getBlock();
+
+                            if (!blockdoor1.isOpen(iblockdata1)) {
+                                // CraftBukkit start - entities opening doors
+                                org.bukkit.event.entity.EntityInteractEvent event = new org.bukkit.event.entity.EntityInteractEvent(entityliving.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(entityliving.level(), blockposition1));
+                                entityliving.level().getCraftServer().getPluginManager().callEvent(event);
+                                if (event.isCancelled()) {
+                                    return false;
+                                }
+                                // CraftBukkit end
+                                blockdoor1.setOpen(entityliving, worldserver, iblockdata1, blockposition1, true);
+                                optional = rememberDoorToClose(memoryaccessor1, optional, worldserver, blockposition1);
+                            }
+                        }
+
+                        optional.ifPresent((set) -> {
+                            closeDoorsThatIHaveOpenedOrPassedThrough(worldserver, entityliving, pathpoint, pathpoint1, set, behaviorbuilder_b.tryGet(memoryaccessor2));
+                        });
+                        return true;
+                    } else {
+                        return false;
+                    }
+                };
+            });
+        });
     }
 
     public static void closeDoorsThatIHaveOpenedOrPassedThrough(
