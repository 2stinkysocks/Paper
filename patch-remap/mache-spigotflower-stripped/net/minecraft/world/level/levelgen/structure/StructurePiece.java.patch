--- a/net/minecraft/world/level/levelgen/structure/StructurePiece.java
+++ b/net/minecraft/world/level/levelgen/structure/StructurePiece.java
@@ -67,7 +61,8 @@
         this(structurepiecetype, i, (BoundingBox) dataresult.resultOrPartial(logger::error).orElseThrow(() -> {
             return new IllegalArgumentException("Invalid boundingbox");
         }));
-        int j = compoundtag.getInt("O");
+        // CraftBukkit end
+        int j = tag.getInt("O");
 
         this.setOrientation(j == -1 ? null : Direction.from2DDataValue(j));
     }
@@ -91,7 +83,8 @@
         dataresult.resultOrPartial(logger::error).ifPresent((tag) -> {
             compoundtag.put("BB", tag);
         });
-        Direction direction = this.getOrientation();
+        // CraftBukkit end
+        Direction enumdirection = this.getOrientation();
 
         compoundtag.putInt("O", direction == null ? -1 : direction.get2DDataValue());
         compoundtag.putInt("GD", this.genDepth);
@@ -189,8 +182,13 @@
                     blockstate = blockstate.rotate(this.rotation);
                 }
 
-                worldgenlevel.setBlock(blockpos_mutableblockpos, blockstate, 2);
-                FluidState fluidstate = worldgenlevel.getFluidState(blockpos_mutableblockpos);
+                level.setBlock(blockposition_mutableblockposition, blockstate, 2);
+                // CraftBukkit start - fluid handling is already done if we have a transformer generator access
+                if (level instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess) {
+                    return;
+                }
+                // CraftBukkit end
+                FluidState fluid = level.getFluidState(blockposition_mutableblockposition);
 
                 if (!fluidstate.isEmpty()) {
                     worldgenlevel.scheduleTick(blockpos_mutableblockpos, fluidstate.getType(), 0);
@@ -204,7 +202,39 @@
         }
     }
 
-    protected boolean canBeReplaced(LevelReader levelreader, int i, int j, int k, BoundingBox boundingbox) {
+    // CraftBukkit start
+    protected boolean placeCraftBlockEntity(ServerLevelAccessor worldAccess, BlockPos position, org.bukkit.craftbukkit.block.CraftBlockEntityState<?> craftBlockEntityState, int i) {
+        if (worldAccess instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess transformerAccess) {
+            return transformerAccess.setCraftBlock(position, craftBlockEntityState, i);
+        }
+        boolean result = worldAccess.setBlock(position, craftBlockEntityState.getHandle(), i);
+        BlockEntity tileEntity = worldAccess.getBlockEntity(position);
+        if (tileEntity != null) {
+            tileEntity.load(craftBlockEntityState.getSnapshotNBT());
+        }
+        return result;
+    }
+
+    protected void placeCraftSpawner(ServerLevelAccessor worldAccess, BlockPos position, org.bukkit.entity.EntityType entityType, int i) {
+        // This method is used in structures that are generated by code and place spawners as they set the entity after the block was placed making it impossible for plugins to access that information
+        org.bukkit.craftbukkit.block.CraftCreatureSpawner spawner = (org.bukkit.craftbukkit.block.CraftCreatureSpawner) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(position, Blocks.SPAWNER.defaultBlockState(), null);
+        spawner.setSpawnedType(entityType);
+        placeCraftBlockEntity(worldAccess, position, spawner, i);
+    }
+
+    protected void setCraftLootTable(ServerLevelAccessor worldAccess, BlockPos position, RandomSource randomSource, net.minecraft.resources.ResourceLocation loottableKey) {
+        // This method is used in structures that use data markers to a loot table to loot containers as otherwise plugins won't have access to that information.
+        net.minecraft.world.level.block.entity.BlockEntity tileEntity = worldAccess.getBlockEntity(position);
+        if (tileEntity instanceof net.minecraft.world.level.block.entity.RandomizableContainerBlockEntity tileEntityLootable) {
+            tileEntityLootable.setLootTable(loottableKey, randomSource.nextLong());
+            if (worldAccess instanceof org.bukkit.craftbukkit.util.TransformerGeneratorAccess transformerAccess) {
+                transformerAccess.setCraftBlock(position, (org.bukkit.craftbukkit.block.CraftBlockState) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(position, tileEntity.getBlockState(), tileEntityLootable.saveWithFullMetadata()), 3);
+            }
+        }
+    }
+    // CraftBukkit end
+
+    protected boolean canBeReplaced(LevelReader level, int x, int y, int z, BoundingBox box) {
         return true;
     }
 
@@ -397,12 +427,20 @@
                 blockstate = reorient(serverlevelaccessor, blockpos, Blocks.CHEST.defaultBlockState());
             }
 
-            serverlevelaccessor.setBlock(blockpos, blockstate, 2);
-            BlockEntity blockentity = serverlevelaccessor.getBlockEntity(blockpos);
+            // CraftBukkit start
+            /*
+            worldaccess.setBlock(blockposition, iblockdata, 2);
+            TileEntity tileentity = worldaccess.getBlockEntity(blockposition);
 
             if (blockentity instanceof ChestBlockEntity) {
                 ((ChestBlockEntity) blockentity).setLootTable(resourcelocation, randomsource.nextLong());
             }
+            */
+            org.bukkit.craftbukkit.block.CraftChest chestState = (org.bukkit.craftbukkit.block.CraftChest) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(pos, state, null);
+            chestState.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(lootTable)));
+            chestState.setSeed(random.nextLong());
+            placeCraftBlockEntity(level, pos, chestState, 2);
+            // CraftBukkit end
 
             return true;
         } else {
@@ -413,14 +451,22 @@
     protected boolean createDispenser(WorldGenLevel worldgenlevel, BoundingBox boundingbox, RandomSource randomsource, int i, int j, int k, Direction direction, ResourceLocation resourcelocation) {
         BlockPos.MutableBlockPos blockpos_mutableblockpos = this.getWorldPos(i, j, k);
 
-        if (boundingbox.isInside(blockpos_mutableblockpos) && !worldgenlevel.getBlockState(blockpos_mutableblockpos).is(Blocks.DISPENSER)) {
-            this.placeBlock(worldgenlevel, (BlockState) Blocks.DISPENSER.defaultBlockState().setValue(DispenserBlock.FACING, direction), i, j, k, boundingbox);
-            BlockEntity blockentity = worldgenlevel.getBlockEntity(blockpos_mutableblockpos);
+        if (box.isInside(blockposition_mutableblockposition) && !level.getBlockState(blockposition_mutableblockposition).is(Blocks.DISPENSER)) {
+            // CraftBukkit start
+            /*
+            this.placeBlock(generatoraccessseed, (IBlockData) Blocks.DISPENSER.defaultBlockState().setValue(BlockDispenser.FACING, enumdirection), i, j, k, structureboundingbox);
+            TileEntity tileentity = generatoraccessseed.getBlockEntity(blockposition_mutableblockposition);
 
             if (blockentity instanceof DispenserBlockEntity) {
                 ((DispenserBlockEntity) blockentity).setLootTable(resourcelocation, randomsource.nextLong());
             }
 
+            org.bukkit.craftbukkit.block.CraftDispenser dispenserState = (org.bukkit.craftbukkit.block.CraftDispenser) org.bukkit.craftbukkit.block.CraftBlockStates.getBlockState(blockposition_mutableblockposition, iblockdata, null);
+            dispenserState.setLootTable(org.bukkit.Bukkit.getLootTable(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(lootTable)));
+            dispenserState.setSeed(random.nextLong());
+            placeCraftBlockEntity(level, blockposition_mutableblockposition, dispenserState, 2);
+            // CraftBukkit end
+
             return true;
         } else {
             return false;
