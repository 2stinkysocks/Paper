--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -78,8 +74,8 @@
         }
     };
     private final Map<BlockPos, LevelChunk.RebindableTickingBlockEntityWrapper> tickersInLevel;
-    private boolean loaded;
-    final Level level;
+    public boolean loaded;
+    public final ServerLevel level; // CraftBukkit - type
     @Nullable
     private Supplier<FullChunkStatus> fullStatus;
     @Nullable
@@ -95,7 +91,7 @@
     public LevelChunk(Level level, ChunkPos chunkpos, UpgradeData upgradedata, LevelChunkTicks<Block> levelchunkticks, LevelChunkTicks<Fluid> levelchunkticks1, long i, @Nullable LevelChunkSection[] alevelchunksection, @Nullable LevelChunk.PostLoadProcessor levelchunk_postloadprocessor, @Nullable BlendingData blendingdata) {
         super(chunkpos, upgradedata, level, level.registryAccess().registryOrThrow(Registries.BIOME), i, alevelchunksection, blendingdata);
         this.tickersInLevel = Maps.newHashMap();
-        this.level = level;
+        this.level = (ServerLevel) level; // CraftBukkit - type
         this.gameEventListenerRegistrySections = new Int2ObjectOpenHashMap();
         Heightmap.Types[] aheightmap_types = Heightmap.Types.values();
         int j = aheightmap_types.length;
@@ -113,9 +109,10 @@
         this.fluidTicks = levelchunkticks1;
     }
 
-    public LevelChunk(ServerLevel serverlevel, ProtoChunk protochunk, @Nullable LevelChunk.PostLoadProcessor levelchunk_postloadprocessor) {
-        this(serverlevel, protochunk.getPos(), protochunk.getUpgradeData(), protochunk.unpackBlockTicks(), protochunk.unpackFluidTicks(), protochunk.getInhabitedTime(), protochunk.getSections(), levelchunk_postloadprocessor, protochunk.getBlendingData());
-        Iterator iterator = protochunk.getBlockEntities().values().iterator();
+    // CraftBukkit start
+    public boolean mustNotSave;
+    public boolean needsDecoration;
+    // CraftBukkit end
 
         while (iterator.hasNext()) {
             BlockEntity blockentity = (BlockEntity) iterator.next();
@@ -144,6 +145,10 @@
         this.skyLightSources = protochunk.skyLightSources;
         this.setLightCorrect(protochunk.isLightCorrect());
         this.unsaved = true;
+        this.needsDecoration = true; // CraftBukkit
+        // CraftBukkit start
+        this.persistentDataContainer = chunk.persistentDataContainer; // SPIGOT-6814: copy PDC to account for 1.17 to 1.18 chunk upgrading.
+        // CraftBukkit end
     }
 
     @Override
@@ -254,6 +253,7 @@
         }
     }
 
+    // CraftBukkit start
     @Nullable
     @Override
     @Override
@@ -262,7 +260,14 @@
         LevelChunkSection levelchunksection = this.getSection(this.getSectionIndex(i));
         boolean flag1 = levelchunksection.hasOnlyAir();
 
-        if (flag1 && blockstate.isAir()) {
+    @Nullable
+    public IBlockData setBlockState(BlockPos blockposition, IBlockData iblockdata, boolean flag, boolean doPlace) {
+        // CraftBukkit end
+        int i = blockposition.getY();
+        LevelChunkSection chunksection = this.getSection(this.getSectionIndex(i));
+        boolean flag1 = chunksection.hasOnlyAir();
+
+        if (flag1 && iblockdata.isAir()) {
             return null;
         } else {
             int j = blockpos.getX() & 15;
@@ -306,8 +311,9 @@
                 if (!levelchunksection.getBlockState(j, k, l).is(block)) {
                     return null;
                 } else {
-                    if (!this.level.isClientSide) {
-                        blockstate.onPlace(this.level, blockpos, blockstate1, flag);
+                    // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                    if (!this.level.isClientSide && doPlace && (!this.level.captureBlockStates || block instanceof net.minecraft.world.level.block.BaseEntityBlock)) {
+                        iblockdata.onPlace(this.level, blockposition, iblockdata1, flag);
                     }
 
                     if (blockstate.hasBlockEntity()) {
@@ -352,8 +356,13 @@
     }
 
     @Nullable
-    public BlockEntity getBlockEntity(BlockPos blockpos, LevelChunk.EntityCreationType levelchunk_entitycreationtype) {
-        BlockEntity blockentity = (BlockEntity) this.blockEntities.get(blockpos);
+    public BlockEntity getBlockEntity(BlockPos pos, LevelChunk.EnumTileEntityState creationType) {
+        // CraftBukkit start
+        BlockEntity tileentity = level.capturedTileEntities.get(pos);
+        if (tileentity == null) {
+            tileentity = (BlockEntity) this.blockEntities.get(pos);
+        }
+        // CraftBukkit end
 
         if (blockentity == null) {
             CompoundTag compoundtag = (CompoundTag) this.pendingBlockEntities.remove(blockpos);
@@ -432,6 +440,13 @@
                 blockentity1.setRemoved();
             }
 
+            // CraftBukkit start
+        } else {
+            System.out.println("Attempted to place a tile entity (" + blockEntity + ") at " + blockEntity.getBlockPos().getX() + "," + blockEntity.getBlockPos().getY() + "," + blockEntity.getBlockPos().getZ()
+                + " (" + getBlockState(blockposition) + ") where there was no entity tile!");
+            System.out.println("Chunk coordinates: " + (this.chunkPos.x * 16) + "," + (this.chunkPos.z * 16));
+            new Exception().printStackTrace();
+            // CraftBukkit end
         }
     }
 
@@ -463,8 +476,11 @@
         if (this.isInLevel()) {
             BlockEntity blockentity = (BlockEntity) this.blockEntities.remove(blockpos);
 
-            if (blockentity != null) {
-                Level level = this.level;
+            // CraftBukkit start - SPIGOT-5561: Also remove from pending map
+            if (!pendingBlockEntities.isEmpty()) {
+                pendingBlockEntities.remove(pos);
+            }
+            // CraftBukkit end
 
                 if (level instanceof ServerLevel) {
                     ServerLevel serverlevel = (ServerLevel) level;
@@ -516,6 +535,57 @@
 
     }
 
+    // CraftBukkit start
+    public void loadCallback() {
+        org.bukkit.Server server = this.level.getCraftServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            org.bukkit.Chunk bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(bukkitChunk, this.needsDecoration));
+
+            if (this.needsDecoration) {
+                this.needsDecoration = false;
+                java.util.Random random = new java.util.Random();
+                random.setSeed(level.getSeed());
+                long xRand = random.nextLong() / 2L * 2L + 1L;
+                long zRand = random.nextLong() / 2L * 2L + 1L;
+                random.setSeed((long) this.chunkPos.x * xRand + (long) this.chunkPos.z * zRand ^ level.getSeed());
+
+                org.bukkit.World world = this.level.getWorld();
+                if (world != null) {
+                    this.level.populating = true;
+                    try {
+                        for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                            populator.populate(world, random, bukkitChunk);
+                        }
+                    } finally {
+                        this.level.populating = false;
+                    }
+                }
+                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+            }
+        }
+    }
+
+    public void unloadCallback() {
+        org.bukkit.Server server = this.level.getCraftServer();
+        org.bukkit.Chunk bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
+        org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(bukkitChunk, this.isUnsaved());
+        server.getPluginManager().callEvent(unloadEvent);
+        // note: saving can be prevented, but not forced if no saving is actually required
+        this.mustNotSave = !unloadEvent.isSaveChunk();
+    }
+
+    @Override
+    public boolean isUnsaved() {
+        return super.isUnsaved() && !this.mustNotSave;
+    }
+    // CraftBukkit end
+
     public boolean isEmpty() {
         return false;
     }
