From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Wed, 20 Dec 2023 02:03:05 -0800
Subject: [PATCH] Remove Keyed from Registry generic qualifier

Keyed is no longer viable for future/current registry types.

diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
index 9bd330f3a3afcb8f693920517a5ad29c3c18098b..bde91e90f0b55a9de5d3557f72e4ba55276d4aeb 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
@@ -3,6 +3,7 @@ package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
 import com.google.common.collect.Iterators;
 import io.papermc.paper.plugin.configuration.PluginMeta;
 import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions.API_1_20_4;
 import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -15,6 +16,7 @@ import org.objectweb.asm.Opcodes;
 public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
 
     private static final Map<String, List<ModifierFactory>> MODIFIERS = Util.make(new LinkedHashMap<>(), map -> {
+        map.put("1.20.4", List.of(API_1_20_4::new));
     });
 
     private final Map<String, List<VersionedClassloaderBytecodeModifier>> constructedModifiers = MODIFIERS.entrySet().stream()
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_4.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_4.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f6dbc616c9920309f8a78ee5ac44a6836556873
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_4.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions;
+
+import com.google.common.base.Suppliers;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.VersionedClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import java.lang.constant.ClassDesc;
+import java.lang.reflect.Method;
+import java.util.function.Supplier;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.MethodVisitor;
+
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule.chain;
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule.forOwner;
+
+public class API_1_20_4 extends VersionedClassloaderBytecodeModifier {
+
+    public API_1_20_4(final int api) {
+        super(api);
+    }
+    private static final Method REGISTRY_KEYED_HANDLER;
+    static {
+        try {
+            REGISTRY_KEYED_HANDLER = API_1_20_4.class.getDeclaredMethod("tryCastKeyed", Object.class);
+        } catch (final ReflectiveOperationException exception) {
+            throw new RuntimeException(exception);
+        }
+    }
+
+    private static final Supplier<Class<?>> API_1_20_4_DELEGATES = Suppliers.memoize(() -> defineGeneratedDelegates(API_1_20_4.class, API_1_20_4.FINAL_RULE));
+
+    private static final ClassDesc KEYED = Keyed.class.describeConstable().orElseThrow();
+    private static final ClassDesc NAMESPACED_KEY = NamespacedKey.class.describeConstable().orElseThrow();
+    private static final RewriteRule FINAL_RULE = chain(
+        forOwner(Registry.class, f -> {
+            f.changeReturnTypeFuzzy(API_1_20_4_DELEGATES, Object.class, REGISTRY_KEYED_HANDLER, b -> b.names("get").hasReturn(KEYED).desc(d -> d.parameterType(0).equals(NAMESPACED_KEY)));
+        })
+    );
+
+    @Override
+    protected RewriteRule rootRule() {
+        return FINAL_RULE;
+    }
+
+    public static @Nullable Keyed tryCastKeyed(final @Nullable Object maybeKeyed) {
+        if (maybeKeyed == null) return null;
+        if (maybeKeyed instanceof final Keyed keyed) {
+            return keyed;
+        }
+        throw new IllegalStateException(maybeKeyed + " is not Keyed");
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
index 9131fc3a56819ae3e2d754fbe5d8815c71ab9ab3..5d81bceaee99cc9a9f1d6ebcd6d35f48769264e5 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
@@ -30,7 +30,7 @@ import org.bukkit.inventory.meta.trim.TrimPattern;
 import org.bukkit.potion.PotionEffectType;
 import org.jetbrains.annotations.NotNull;
 
-public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
+public class CraftRegistry<B, M> implements Registry<B> { // Paper - improve Registry
 
     private static RegistryAccess registry;
 
diff --git a/src/test/java/org/bukkit/PerRegistryTest.java b/src/test/java/org/bukkit/PerRegistryTest.java
index 6e3062da8840fc7118b59ddb0d6871c9a3178584..8c4d6434a9ae2b28f5adabb24b422dd8c4f52b79 100644
--- a/src/test/java/org/bukkit/PerRegistryTest.java
+++ b/src/test/java/org/bukkit/PerRegistryTest.java
@@ -46,7 +46,7 @@ public class PerRegistryTest extends AbstractTestingBase {
 
     @ParameterizedTest
     @MethodSource("data")
-    public <T extends Keyed> void testGet(Registry<T> registry) { // Paper - improve Registry
+    public <T> void testGet(Registry<T> registry) { // Paper - improve Registry
         registry.forEach(element -> {
             NamespacedKey key = registry.getKey(element); // Paper - improve Registry
             assertNotNull(key); // Paper - improve Registry
@@ -58,7 +58,7 @@ public class PerRegistryTest extends AbstractTestingBase {
 
     @ParameterizedTest
     @MethodSource("data")
-    public <T extends Keyed> void testMatch(Registry<T> registry) { // Paper - improve Registry
+    public <T> void testMatch(Registry<T> registry) { // Paper - improve Registry
         registry.forEach(element -> {
             NamespacedKey key = registry.getKey(element); // Paper - improve Registry
             assertNotNull(key); // Paper - improve Registry
@@ -72,7 +72,7 @@ public class PerRegistryTest extends AbstractTestingBase {
         });
     }
 
-    private <T extends Keyed> void assertSameMatchWithKeyMessage(Registry<T> registry, T element, String key) { // Paper - improve Registry
+    private <T> void assertSameMatchWithKeyMessage(Registry<T> registry, T element, String key) { // Paper - improve Registry
         assertSame(element, registry.match(key), key);
     }
 
